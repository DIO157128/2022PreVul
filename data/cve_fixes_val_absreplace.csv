,source,target,original_source,original_target
0,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 ) { struct STRUCT_OR_UNION_1 * VAR_2 = METHOD_1 ( VAR_3 ) ; struct STRUCT_OR_UNION_2 STRUCT_OR_UNION_3 ; struct STRUCT_OR_UNION_4 * VAR_4 ; struct STRUCT_OR_UNION_5 * VAR_5 ; TYPE_2 VAR_6 ; METHOD_2 ( VAR_7 ) ; METHOD_3 ( VAR_8 ) ; METHOD_4 ( VAR_9 ) ; VAR_10 -> VAR_11 = VAR_12 ; STRUCT_OR_UNION_6 = VAR_13 -> STRUCT_OR_UNION_7 ; VAR_14 -> STRUCT_OR_UNION_8 . VAR_15 = VAR_16 ; VAR_17 -> STRUCT_OR_UNION_9 . VAR_18 = VAR_19 ; VAR_20 = VAR_21 -> VAR_22 ; VAR_23 -> VAR_24 = VAR_25 ; METHOD_5 ( VAR_26 ) ; METHOD_6 ( & VAR_27 -> VAR_28 ) ; VAR_29 = METHOD_7 ( VAR_30 ) ; if ( VAR_31 != VAR_32 ) { if ( VAR_33 -> VAR_34 == VAR_35 || VAR_36 -> VAR_37 == VAR_38 ) { METHOD_8 ( VAR_39 ) ; VAR_40 -> VAR_41 = VAR_42 ; if ( ! METHOD_9 ( & VAR_43 -> VAR_44 ) || VAR_45 ) VAR_46 -> VAR_47 = VAR_48 ; METHOD_10 ( VAR_49 ) ; VAR_50 -> METHOD_11 ( VAR_51 ) ; METHOD_12 ( VAR_52 , VAR_53 , VAR_54 ) ; } <S2SV_StartBug> METHOD_13 ( VAR_55 ) ; <S2SV_EndBug> METHOD_14 ( VAR_56 ) = VAR_57 ; } while ( ( VAR_58 = METHOD_15 ( & VAR_59 -> VAR_60 ) ) != VAR_61 ) { if ( VAR_62 == VAR_63 ) METHOD_16 ( VAR_64 -> VAR_65 , 1 ) ; METHOD_17 ( VAR_66 ) . VAR_67 = VAR_68 -> VAR_69 ; METHOD_18 ( VAR_70 ) ; } if ( STRUCT_OR_UNION_10 . VAR_71 ) METHOD_19 ( & STRUCT_OR_UNION_11 ) ; METHOD_20 ( VAR_72 ) ; if ( VAR_73 ) METHOD_21 ( ) ; }","<S2SV_ModStart> ) ; } METHOD_22 ( VAR_72 , VAR_55 ) ;","CWE-000 static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; } <S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }","<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;"
1,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , <S2SV_StartBug> TYPE_4 * VAR_3 , <S2SV_EndBug> TYPE_5 * VAR_4 , TYPE_6 VAR_5 [ VAR_6 ] , <S2SV_StartBug> TYPE_7 VAR_7 [ VAR_8 ] , <S2SV_EndBug> <S2SV_StartBug> TYPE_8 VAR_9 [ VAR_10 ] ) { <S2SV_EndBug> TYPE_9 * const VAR_11 = & VAR_12 -> VAR_13 ; VAR_14 -> VAR_15 = VAR_16 -> VAR_17 ; <S2SV_StartBug> VAR_18 -> VAR_19 = VAR_20 ; <S2SV_EndBug> VAR_21 -> VAR_22 = * VAR_23 -> VAR_24 [ 0 ] ; <S2SV_StartBug> VAR_25 -> VAR_26 [ 0 ] . VAR_27 = VAR_28 -> VAR_29 ; <S2SV_EndBug> VAR_30 -> VAR_31 [ 1 ] . VAR_32 = VAR_33 -> VAR_34 ; VAR_35 -> VAR_36 = ( TYPE_10 ) VAR_37 [ VAR_38 ] ; VAR_39 -> VAR_40 = ( TYPE_11 ) VAR_41 [ VAR_42 ] ; VAR_43 -> VAR_44 = ( TYPE_12 ) VAR_45 [ VAR_46 ] ; <S2SV_StartBug> METHOD_1 ( VAR_47 -> VAR_48 , VAR_49 , sizeof ( VAR_50 -> VAR_51 ) ) ; <S2SV_EndBug> METHOD_2 ( VAR_52 -> VAR_53 , VAR_54 , sizeof ( * VAR_55 ) * VAR_56 ) ; }","<S2SV_ModStart> TYPE_12 VAR_20 , <S2SV_ModEnd> TYPE_8 VAR_45 [ <S2SV_ModStart> ] , TYPE_8 <S2SV_ModEnd> VAR_55 [ VAR_56 <S2SV_ModStart> [ VAR_56 ] , TYPE_12 VAR_57 <S2SV_ModStart> ; VAR_52 -> VAR_57 = VAR_57 ; VAR_52 -> <S2SV_ModStart> ; VAR_52 -> VAR_58 = * VAR_16 -> VAR_58 <S2SV_ModEnd> ; VAR_52 -> <S2SV_ModStart> VAR_46 ] ; METHOD_3 <S2SV_ModEnd> ( VAR_52 ->","CWE-119 static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , <S2SV_StartBug> int_mv * ref_mv , <S2SV_EndBug> int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] , <S2SV_StartBug> int64_t tx_size_diff [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) { <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; ctx -> skip = x -> skip ; <S2SV_StartBug> ctx -> best_mode_index = mode_index ; <S2SV_EndBug> ctx -> mic = * xd -> mi [ 0 ] ; <S2SV_StartBug> ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ; <S2SV_EndBug> ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ; ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ; ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ; ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ; <S2SV_StartBug> vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ; <S2SV_EndBug> vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ; }","<S2SV_ModStart> int mode_index , <S2SV_ModEnd> int64_t comp_pred_diff [ <S2SV_ModStart> ] , int64_t <S2SV_ModEnd> best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS <S2SV_ModStart> [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable <S2SV_ModStart> ; ctx -> skippable = skippable ; ctx -> <S2SV_ModStart> ; ctx -> mbmi_ext = * x -> mbmi_ext <S2SV_ModEnd> ; ctx -> <S2SV_ModStart> REFERENCE_MODE_SELECT ] ; memcpy <S2SV_ModEnd> ( ctx ->"
2,"CWE-125 static const TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const struct STRUCT_OR_UNION_0 * VAR_2 , TYPE_3 TYPE_4 VAR_3 , const TYPE_5 * VAR_4 , TYPE_6 TYPE_7 VAR_5 , TYPE_8 TYPE_9 VAR_6 , TYPE_10 TYPE_11 VAR_7 , TYPE_12 TYPE_13 VAR_8 ) { struct STRUCT_OR_UNION_1 VAR_9 ; const TYPE_14 * VAR_10 [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const TYPE_15 * VAR_11 = ( const TYPE_16 * ) VAR_12 + sizeof ( VAR_13 ) ; unsigned TYPE_17 VAR_14 ; <S2SV_StartBug> METHOD_1 ( * VAR_15 ) ; <S2SV_EndBug> METHOD_2 ( & VAR_16 , VAR_17 , sizeof ( VAR_18 ) ) ; METHOD_3 ( VAR_19 , METHOD_4 ( VAR_20 ) , VAR_21 . VAR_22 . VAR_23 ) ; VAR_24 = METHOD_5 ( VAR_25 . VAR_26 . VAR_27 ) ; METHOD_6 ( ( VAR_28 , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , VAR_29 - 4 , METHOD_7 ( VAR_30 . VAR_31 , VAR_32 ) ) ) ; if ( VAR_33 > 4 ) { if ( VAR_34 -> VAR_35 > 1 ) { METHOD_8 ( ( VAR_36 , ""<S2SV_blank>authdata=("" ) ) ; if ( ! METHOD_9 ( VAR_37 , ( const TYPE_18 * ) VAR_38 , VAR_39 - sizeof ( VAR_40 ) ) ) goto VAR_41 ; METHOD_10 ( ( VAR_42 , "")<S2SV_blank>"" ) ) ; } else if ( VAR_43 -> VAR_44 ) { if ( ! METHOD_11 ( VAR_45 , VAR_46 , VAR_47 ) ) goto VAR_48 ; } } return ( const TYPE_19 * ) VAR_49 + VAR_50 ; VAR_51 : METHOD_12 ( ( VAR_52 , ""<S2SV_blank>[|%s]"" , METHOD_13 ( VAR_53 ) ) ) ; return VAR_54 ; }","<S2SV_ModStart> TYPE_17 VAR_50 ; METHOD_14 ( * VAR_49 , sizeof ( VAR_40 ) <S2SV_ModEnd> ) ; METHOD_2","CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }","<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY"
3,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 * VAR_6 ) { struct STRUCT_OR_UNION_3 * VAR_7 = VAR_8 ; struct STRUCT_OR_UNION_4 VAR_9 ; TYPE_5 VAR_10 = - VAR_11 ; TYPE_6 VAR_12 ; if ( VAR_13 & ~ ( VAR_14 | VAR_15 | VAR_16 | VAR_17 | VAR_18 ) ) <S2SV_StartBug> goto VAR_19 ; <S2SV_EndBug> if ( VAR_20 ) * VAR_21 = sizeof ( VAR_22 ) ; VAR_23 = METHOD_1 ( VAR_24 , VAR_25 , VAR_26 , & VAR_27 ) ; if ( VAR_28 == VAR_29 ) goto VAR_30 ; METHOD_2 ( VAR_31 , & VAR_32 ) ; VAR_33 = VAR_34 -> VAR_35 ; if ( VAR_36 < VAR_37 ) { VAR_38 -> VAR_39 |= VAR_40 ; VAR_41 = VAR_42 ; } VAR_43 = METHOD_3 ( VAR_44 , 0 , VAR_45 -> VAR_46 , VAR_47 ) ; if ( VAR_48 ) { VAR_49 = - VAR_50 ; goto VAR_51 ; } VAR_52 = ( VAR_53 & VAR_54 ) ? VAR_55 -> VAR_56 : VAR_57 ; <S2SV_StartBug> if ( VAR_58 -> VAR_59 != VAR_60 ) <S2SV_EndBug> <S2SV_StartBug> METHOD_4 ( VAR_61 -> VAR_62 , & VAR_63 , sizeof ( struct STRUCT_OR_UNION_5 ) ) ; <S2SV_EndBug> VAR_64 : METHOD_5 ( VAR_65 , VAR_66 ) ; VAR_67 : return VAR_68 ; }","<S2SV_ModStart> ) goto VAR_67 <S2SV_ModEnd> ; VAR_66 = <S2SV_ModStart> != VAR_60 ) { <S2SV_ModStart> , sizeof ( VAR_63 ) ) ; * VAR_21 = sizeof ( VAR_63 ) ; } <S2SV_ModEnd> VAR_64 : METHOD_5","CWE-200 static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) <S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }","<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram"
4,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , const TYPE_2 * VAR_2 , TYPE_3 * * VAR_3 , TYPE_4 * VAR_4 ) { TYPE_5 VAR_5 ; TYPE_6 * VAR_6 ; TYPE_7 VAR_7 ; TYPE_8 VAR_8 ; TYPE_9 VAR_9 ; * VAR_10 = 0 ; * VAR_11 = VAR_12 ; VAR_13 = METHOD_1 ( VAR_14 ) ; VAR_15 = METHOD_2 ( VAR_16 ) ; <S2SV_StartBug> if ( ( VAR_17 > VAR_18 / 2 ) || ( VAR_19 > ( VAR_20 / 2 - 2 ) ) ) <S2SV_EndBug> return VAR_21 ; VAR_22 = 2 * VAR_23 + VAR_24 + 2 ; VAR_25 = METHOD_3 ( VAR_26 ) ; if ( ! VAR_27 ) return VAR_28 ; METHOD_4 ( VAR_29 , VAR_30 , VAR_31 ) ; VAR_32 [ VAR_33 ] = '\\0' ; METHOD_5 ( VAR_34 + VAR_35 + 1 , VAR_36 , VAR_37 ) ; VAR_38 [ 2 * VAR_39 + 1 ] = '\\0' ; METHOD_6 ( VAR_40 + 2 * VAR_41 + 2 , VAR_42 , VAR_43 ) ; VAR_44 = METHOD_7 ( VAR_45 , VAR_46 , VAR_47 , VAR_48 , VAR_49 ) ; METHOD_8 ( VAR_50 ) ; return VAR_51 ; }",<S2SV_ModStart> > VAR_20 / 4 <S2SV_ModEnd> ) || (,"CWE-119 CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ; <S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }",<S2SV_ModStart> > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || (
5,"CWE-59 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 ( * VAR_1 ) ( TYPE_3 * ) , const TYPE_4 * VAR_2 ) { TYPE_5 VAR_3 ; TYPE_6 VAR_4 ; if ( VAR_5 -> VAR_6 ) { VAR_7 = 0 ; if ( ! ( VAR_8 = METHOD_1 ( VAR_9 -> VAR_10 , VAR_11 | VAR_12 | VAR_13 | VAR_14 ) ) ) VAR_15 -> VAR_16 = VAR_17 ; else { VAR_18 = VAR_19 ; if ( VAR_20 != VAR_21 ) METHOD_2 ( VAR_22 , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , VAR_23 , VAR_24 -> VAR_25 ) ; } if ( ! VAR_26 || VAR_27 == VAR_28 ) { if ( VAR_29 -> VAR_30 ) METHOD_3 ( VAR_31 , VAR_32 , VAR_33 , VAR_34 -> VAR_35 ) ; <S2SV_StartBug> if ( ( VAR_36 -> VAR_37 = METHOD_4 ( VAR_38 -> VAR_39 , VAR_40 | VAR_41 | VAR_42 ) ) == - 1 ) { <S2SV_EndBug> METHOD_5 ( VAR_43 , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , VAR_44 , VAR_45 -> VAR_46 , VAR_47 ) ; if ( VAR_48 -> VAR_49 ) { METHOD_6 ( VAR_50 -> VAR_51 ) ; VAR_52 -> VAR_53 = VAR_54 ; } } } if ( VAR_55 -> VAR_56 == - 1 ) { METHOD_7 ( VAR_57 -> VAR_58 ) ; VAR_59 -> VAR_60 = VAR_61 ; } } }",<S2SV_ModStart> VAR_41 | VAR_42 | VAR_62,"CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }",<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
6,"CWE-284 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) { TYPE_2 VAR_1 = - 1 ; TYPE_3 VAR_2 = 1 ; TYPE_4 TYPE_5 TYPE_6 VAR_3 ; if ( ! VAR_4 ) { if ( METHOD_1 ( METHOD_2 ( 2 , 2 ) , & VAR_5 ) != VAR_6 ) { METHOD_3 ( VAR_7 , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; METHOD_4 ( - 1 ) ; } VAR_8 = 1 ; } struct STRUCT_OR_UNION_0 VAR_9 ; if ( 0 > ( VAR_10 = METHOD_5 ( VAR_11 , VAR_12 , VAR_13 ) ) ) { METHOD_6 ( ""socket()"" ) ; return - 1 ; } if ( METHOD_7 ( VAR_14 , VAR_15 , VAR_16 , ( TYPE_7 * ) & VAR_17 , sizeof ( TYPE_8 ) ) == - 1 ) { METHOD_8 ( ""setsockopt()"" ) ; METHOD_9 ( VAR_18 ) ; return - 1 ; } TYPE_9 TYPE_10 if ( METHOD_10 ( VAR_19 , VAR_20 , TYPE_11 , ( TYPE_12 * ) & VAR_21 , sizeof ( TYPE_13 ) ) == - 1 ) { METHOD_11 ( ""setsockopt()"" ) ; METHOD_12 ( VAR_22 ) ; return - 1 ; } METHOD_13 ( ( TYPE_14 * ) & VAR_23 , 0 , sizeof ( VAR_24 ) ) ; VAR_25 . VAR_26 = VAR_27 ; <S2SV_StartBug> VAR_28 . VAR_29 . VAR_30 = METHOD_14 ( VAR_31 ) ; <S2SV_EndBug> VAR_32 . VAR_33 = METHOD_15 ( VAR_34 ) ; if ( 0 > METHOD_16 ( VAR_35 , ( struct STRUCT_OR_UNION_1 * ) & VAR_36 , sizeof ( VAR_37 ) ) ) { METHOD_17 ( ""bind()"" ) ; METHOD_18 ( VAR_38 ) ; return - 1 ; } if ( METHOD_19 ( VAR_39 , 1 ) == - 1 ) { METHOD_20 ( ""listen()"" ) ; METHOD_21 ( VAR_40 ) ; return - 1 ; } return VAR_41 ; }",<S2SV_ModStart> = METHOD_14 ( VAR_42 <S2SV_ModEnd> ) ; VAR_37,"CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ;  ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; }   struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; }  ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; }   memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }",<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
7,"CWE-59 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { <S2SV_StartBug> TYPE_6 * VAR_5 = METHOD_1 ( VAR_6 , ""w"" ) ; <S2SV_EndBug> if ( ! VAR_7 ) return VAR_8 ; unsigned VAR_9 = 0 ; while ( VAR_10 <= 99999 ) { METHOD_2 ( VAR_11 + VAR_12 , ""fd/%u"" , VAR_13 ) ; TYPE_7 * VAR_14 = METHOD_3 ( VAR_15 ) ; if ( ! VAR_16 ) break ; METHOD_4 ( VAR_17 , ""%u:%s\\n"" , VAR_18 , VAR_19 ) ; METHOD_5 ( VAR_20 ) ; METHOD_6 ( VAR_21 + VAR_22 , ""fdinfo/%u"" , VAR_23 ) ; VAR_24 ++ ; TYPE_8 * VAR_25 = METHOD_7 ( VAR_26 , ""r"" ) ; if ( ! VAR_27 ) continue ; TYPE_9 VAR_28 [ 128 ] ; while ( METHOD_8 ( VAR_29 , sizeof ( VAR_30 ) - 1 , VAR_31 ) ) { TYPE_10 * VAR_32 = METHOD_9 ( VAR_33 , '\\n' ) ; VAR_34 [ 0 ] = '\\n' ; VAR_35 [ 1 ] = '\\0' ; METHOD_10 ( VAR_36 , VAR_37 ) ; } METHOD_11 ( VAR_38 ) ; } const TYPE_11 VAR_39 = METHOD_12 ( VAR_40 ) ; if ( METHOD_13 ( VAR_41 , VAR_42 , VAR_43 ) < 0 ) { METHOD_14 ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , VAR_44 , ( TYPE_12 ) VAR_45 , ( TYPE_13 ) VAR_46 ) ; METHOD_15 ( VAR_47 ) ; METHOD_16 ( VAR_48 ) ; return VAR_49 ; } METHOD_17 ( VAR_50 ) ; return VAR_51 ; }","<S2SV_ModStart> ( VAR_48 , ""wx"" <S2SV_ModEnd> ) ; if","CWE-59 static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { <S2SV_StartBug> FILE * fp = fopen ( dest_filename , ""w"" ) ; <S2SV_EndBug> if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , ""fd/%u"" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , ""%u:%s\\n"" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , ""fdinfo/%u"" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , ""r"" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } fclose ( fp ) ; return true ; }","<S2SV_ModStart> ( dest_filename , ""wx"" <S2SV_ModEnd> ) ; if"
8,"CWE-476 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * * VAR_5 , TYPE_7 * * VAR_6 , TYPE_8 * * VAR_7 ) { TYPE_9 * VAR_8 , * VAR_9 = ( TYPE_10 * ) VAR_10 ; TYPE_11 TYPE_12 VAR_11 ( VAR_12 , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( TYPE_13 ) VAR_13 , ( TYPE_14 ) VAR_14 , ( TYPE_15 ) VAR_15 , ( TYPE_16 ) VAR_16 ) ; VAR_17 = VAR_18 ; if ( VAR_19 -> VAR_20 > 0 ) { if ( METHOD_1 ( VAR_21 -> VAR_22 ) ) { VAR_23 += VAR_24 -> VAR_25 ; } else { TYPE_17 * VAR_26 = VAR_27 + VAR_28 -> VAR_29 ; if ( VAR_30 >= VAR_31 ) return 0 ; while ( VAR_32 < VAR_33 ) VAR_34 += METHOD_2 ( VAR_35 -> VAR_36 , VAR_37 ) ; } } VAR_38 : switch ( VAR_39 -> VAR_40 ) { case VAR_41 : VAR_42 = METHOD_3 ( VAR_43 -> VAR_44 , VAR_45 -> VAR_46 , VAR_47 -> VAR_48 , VAR_49 , VAR_50 , VAR_51 ) ; break ; case VAR_52 : VAR_53 = METHOD_4 ( VAR_54 -> VAR_55 , VAR_56 -> VAR_57 , VAR_58 -> VAR_59 , VAR_60 -> VAR_61 , VAR_62 , VAR_63 , VAR_64 ) ; break ; case VAR_65 : VAR_66 = METHOD_5 ( VAR_67 , VAR_68 -> VAR_69 , VAR_70 -> VAR_71 , VAR_72 , VAR_73 , VAR_74 ) ; break ; case VAR_75 : VAR_76 = METHOD_6 ( VAR_77 , VAR_78 -> VAR_79 , VAR_80 -> VAR_81 , VAR_82 , VAR_83 , VAR_84 ) ; break ; case VAR_85 : VAR_86 = METHOD_7 ( VAR_87 -> VAR_88 , VAR_89 -> VAR_90 , VAR_91 , VAR_92 ) ; break ; } if ( VAR_93 && VAR_94 < VAR_95 ) { if ( VAR_96 - VAR_97 -> VAR_98 < VAR_99 ) { VAR_100 : VAR_101 = VAR_102 ; VAR_103 += METHOD_8 ( VAR_104 -> VAR_105 , VAR_106 ) ; goto VAR_107 ; } if ( VAR_108 -> VAR_109 ) { TYPE_18 * VAR_110 ; switch ( VAR_111 -> VAR_112 ) { case VAR_113 : if ( ! METHOD_9 ( VAR_114 ) ) { VAR_115 = METHOD_10 ( VAR_116 -> VAR_117 , ( VAR_118 ? VAR_119 : VAR_120 ) , VAR_121 ) ; if ( ! METHOD_11 ( VAR_122 -> VAR_123 , VAR_124 , VAR_125 ) ) goto VAR_126 ; } break ; case VAR_127 : if ( METHOD_12 ( VAR_128 ) ) { TYPE_19 TYPE_20 VAR_129 = ( TYPE_21 * ) METHOD_13 ( VAR_130 -> VAR_131 , ( VAR_132 ? VAR_133 : VAR_134 ) , VAR_135 ) ; if ( VAR_136 && METHOD_14 ( VAR_137 -> VAR_138 , VAR_139 , VAR_140 ) ) goto VAR_141 ; } else if ( ! METHOD_15 ( VAR_142 -> VAR_143 , VAR_144 , VAR_145 ) TYPE_22 TYPE_23 && ! METHOD_16 ( VAR_146 -> VAR_147 , VAR_148 , VAR_149 ) ) goto VAR_150 ; break ; } } if ( VAR_151 -> VAR_152 == 0 ) { * VAR_153 = VAR_154 ; if ( VAR_155 ) { if ( * VAR_156 > VAR_157 ) * VAR_158 = METHOD_17 ( VAR_159 -> VAR_160 , VAR_161 , VAR_162 ) ; else * VAR_163 = METHOD_18 ( VAR_164 -> VAR_165 , ( VAR_166 ? VAR_167 : VAR_168 ) , VAR_169 ) ; } } else { if ( VAR_170 -> VAR_171 != VAR_172 ) { <S2SV_StartBug> * VAR_173 = VAR_174 - VAR_175 -> VAR_176 ; <S2SV_EndBug> if ( * VAR_177 > VAR_178 ) { * VAR_179 = METHOD_19 ( VAR_180 -> VAR_181 , VAR_182 , * VAR_183 , ( const TYPE_24 * * ) VAR_184 ) ; if ( VAR_185 && METHOD_20 ( * VAR_186 ) ) * VAR_187 = METHOD_21 ( VAR_188 -> VAR_189 , ( VAR_190 ? VAR_191 : VAR_192 ) , * VAR_193 ) ; } else { if ( VAR_194 ) * VAR_195 = METHOD_22 ( VAR_196 -> VAR_197 , <S2SV_StartBug> ( VAR_198 ? VAR_199 : VAR_200 ) , * VAR_201 ) ; <S2SV_EndBug> } } } * VAR_202 = VAR_203 - VAR_204 -> VAR_205 ; TYPE_25 TYPE_26 VAR_206 ( VAR_207 , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( TYPE_27 ) ( * VAR_208 - VAR_209 ) , ( TYPE_28 ) ( * VAR_210 - VAR_211 ) , VAR_212 -> VAR_213 , VAR_214 -> VAR_215 ) ; return 1 ; } return 0 ; }","<S2SV_ModStart> VAR_172 ) { if ( VAR_203 - VAR_211 < VAR_214 -> VAR_215 ) { * VAR_208 = ( TYPE_24 * ) VAR_211 ; if ( VAR_195 ) * VAR_195 = METHOD_22 ( VAR_214 -> VAR_197 , VAR_211 , * VAR_208 ) ; } else { <S2SV_ModStart> VAR_208 ) ; }","CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ;  ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ;   p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) {  ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ;   } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end )  ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end )   ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { <S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> } } } * high = p - reg -> dmin ;  ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ;   return 1 ; } return 0 ; }","<S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> low ) ; }"
9,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 -> VAR_4 . VAR_5 ; struct STRUCT_OR_UNION_2 * VAR_6 ; if ( ! METHOD_1 ( VAR_7 ) || ! VAR_8 ) return ; VAR_9 = & VAR_10 -> VAR_11 . VAR_12 ; <S2SV_StartBug> if ( METHOD_2 ( VAR_13 ) ) <S2SV_EndBug> METHOD_3 ( VAR_14 , VAR_15 ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> . VAR_14 ; METHOD_4 ( & VAR_10 -> VAR_11 . VAR_16 ) ; <S2SV_ModStart> VAR_15 ) ; METHOD_5 ( & VAR_10 -> VAR_11 . VAR_16 ) ;,"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
10,"CWE-119 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { unsigned TYPE_3 VAR_2 ; <S2SV_StartBug> TYPE_4 VAR_3 = { 0 } ; <S2SV_EndBug> VAR_4 . VAR_5 = ( VAR_6 -> VAR_7 + 15 ) / 16 ; VAR_8 . VAR_9 = ( VAR_10 -> VAR_11 + 15 ) / 16 ; VAR_12 . VAR_13 [ 0 ] = 0 ; VAR_14 . VAR_15 [ 1 ] = - 2 ; VAR_16 . VAR_17 [ 2 ] = - 4 ; VAR_18 . VAR_19 [ 3 ] = - 6 ; VAR_20 . VAR_21 [ 0 ] = 0 ; VAR_22 . VAR_23 [ 1 ] = 1 ; VAR_24 . VAR_25 [ 2 ] = 2 ; VAR_26 . VAR_27 [ 3 ] = 3 ; VAR_28 . VAR_29 [ 0 ] = 1500 ; VAR_30 . VAR_31 [ 1 ] = 1000 ; VAR_32 . VAR_33 [ 2 ] = 500 ; VAR_34 . VAR_35 [ 3 ] = 0 ; VAR_36 . VAR_37 = ( TYPE_5 * ) METHOD_1 ( VAR_38 . VAR_39 * VAR_40 . VAR_41 ) ; for ( VAR_42 = 0 ; VAR_43 < VAR_44 . VAR_45 * VAR_46 . VAR_47 ; ++ VAR_48 ) VAR_49 . VAR_50 [ VAR_51 ] = VAR_52 % 4 ; if ( METHOD_2 ( VAR_53 , VAR_54 , & VAR_55 ) ) METHOD_3 ( VAR_56 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map"" ) ; METHOD_4 ( VAR_57 . VAR_58 ) ; }","<S2SV_ModStart> ; TYPE_4 VAR_57 ; METHOD_5 ( & VAR_57 , 0 , sizeof ( VAR_57 ) ) <S2SV_ModEnd> ; VAR_57 .","CWE-119 static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map"" ) ; free ( roi . roi_map ) ; }","<S2SV_ModStart> ; vpx_roi_map_t roi ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> ; roi ."
11,"CWE-119 <S2SV_StartBug> static const TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 ) <S2SV_EndBug> { TYPE_3 * VAR_2 ; if ( * VAR_3 != '{' ) { <S2SV_StartBug> VAR_4 = VAR_5 ; <S2SV_EndBug> return 0 ; } VAR_6 -> VAR_7 = VAR_8 ; VAR_9 = METHOD_1 ( VAR_10 + 1 ) ; if ( * VAR_11 == '}' ) <S2SV_StartBug> return VAR_12 + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( VAR_13 -> VAR_14 = VAR_15 = METHOD_2 ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( VAR_16 = METHOD_3 ( METHOD_4 ( VAR_17 , METHOD_5 ( VAR_18 ) ) ) ) ) <S2SV_EndBug> return 0 ; VAR_19 -> VAR_20 = VAR_21 -> VAR_22 ; VAR_23 -> VAR_24 = 0 ; if ( * VAR_25 != ':' ) { <S2SV_StartBug> VAR_26 = VAR_27 ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( VAR_28 = METHOD_6 ( METHOD_7 ( VAR_29 , METHOD_8 ( VAR_30 + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * VAR_31 == ',' ) { TYPE_4 * VAR_32 ; if ( ! ( VAR_33 = METHOD_9 ( ) ) ) return 0 ; VAR_34 -> VAR_35 = VAR_36 ; VAR_37 -> VAR_38 = VAR_39 ; <S2SV_StartBug> VAR_40 = VAR_41 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( VAR_42 = METHOD_10 ( METHOD_11 ( VAR_43 , METHOD_12 ( VAR_44 + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; VAR_45 -> VAR_46 = VAR_47 -> VAR_48 ; VAR_49 -> VAR_50 = 0 ; if ( * VAR_51 != ':' ) { <S2SV_StartBug> VAR_52 = VAR_53 ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( VAR_54 = METHOD_13 ( METHOD_14 ( VAR_55 , METHOD_15 ( VAR_56 + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * VAR_57 == '}' ) <S2SV_StartBug> return VAR_58 + 1 ; <S2SV_EndBug> VAR_59 = VAR_60 ; return 0 ; }","<S2SV_ModStart> TYPE_2 * VAR_60 , const TYPE_2 * * VAR_59 <S2SV_ModStart> '{' ) { * VAR_59 = VAR_60 ; return 0 ; <S2SV_ModEnd> } VAR_13 -> <S2SV_ModStart> == '}' ) return VAR_60 + 1 ; <S2SV_ModEnd> VAR_13 -> VAR_55 <S2SV_ModStart> METHOD_9 ( ) ; if ( ! VAR_13 -> VAR_55 ) return 0 ; <S2SV_ModEnd> VAR_60 = METHOD_15 <S2SV_ModStart> ( VAR_60 ) , VAR_59 ) ) ; if ( ! VAR_60 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * VAR_59 = VAR_60 ; return 0 ; } <S2SV_ModEnd> VAR_60 = METHOD_15 <S2SV_ModStart> + 1 ) , VAR_59 ) ) ; if ( ! VAR_60 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = VAR_55 ; VAR_55 = VAR_41 ; <S2SV_ModEnd> VAR_60 = METHOD_15 <S2SV_ModStart> + 1 ) , VAR_59 ) ) ; if ( ! VAR_60 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * VAR_59 = VAR_60 ; return 0 ; } <S2SV_ModEnd> VAR_60 = METHOD_15 <S2SV_ModStart> + 1 ) , VAR_59 ) ) ; if ( ! VAR_60 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == '}' ) return VAR_60 + 1 ; * VAR_59 = VAR_60 ; <S2SV_ModEnd> return 0 ;","CWE-119 <S2SV_StartBug> static const char * parse_object ( cJSON * item , const char * value ) <S2SV_EndBug> { cJSON * child ; if ( * value != '{' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } item -> type = cJSON_Object ; value = skip ( value + 1 ) ; if ( * value == '}' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * value == '}' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ep = value ; return 0 ; }","<S2SV_ModStart> char * value , const char * * ep <S2SV_ModStart> '{' ) { * ep = value ; return 0 ; <S2SV_ModEnd> } item -> <S2SV_ModStart> == '}' ) return value + 1 ; <S2SV_ModEnd> item -> child <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> value = skip <S2SV_ModStart> ( value ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * ep = value ; return 0 ; } <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = child ; child = new_item ; <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * ep = value ; return 0 ; } <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == '}' ) return value + 1 ; * ep = value ; <S2SV_ModEnd> return 0 ;"
12,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 VAR_2 ; TYPE_4 VAR_3 = 0 ; const enum VAR_4 * VAR_5 = VAR_6 ; TYPE_5 VAR_7 = 0 ; if ( METHOD_1 ( & VAR_8 -> VAR_9 ) < 36 ) return VAR_10 ; VAR_11 -> VAR_12 -> VAR_13 = METHOD_2 ( & VAR_14 -> VAR_15 ) ; VAR_16 -> VAR_17 = METHOD_3 ( & VAR_18 -> VAR_19 ) ; VAR_20 -> VAR_21 = METHOD_4 ( & VAR_22 -> VAR_23 ) ; VAR_24 -> VAR_25 = METHOD_5 ( & VAR_26 -> VAR_27 ) ; VAR_28 -> VAR_29 = METHOD_6 ( & VAR_30 -> VAR_31 ) ; VAR_32 -> VAR_33 = METHOD_7 ( & VAR_34 -> VAR_35 ) ; VAR_36 -> VAR_37 = METHOD_8 ( & VAR_38 -> VAR_39 ) ; VAR_40 -> VAR_41 = METHOD_9 ( & VAR_42 -> VAR_43 ) ; VAR_44 -> VAR_45 = METHOD_10 ( & VAR_46 -> VAR_47 ) ; <S2SV_StartBug> VAR_48 = METHOD_11 ( & VAR_49 -> VAR_50 ) ; <S2SV_EndBug> if ( VAR_51 <= 0 ) { METHOD_12 ( VAR_52 -> VAR_53 , VAR_54 , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , VAR_55 -> VAR_56 ) ; return VAR_57 ; } if ( VAR_58 > 4 ) { METHOD_13 ( VAR_59 -> VAR_60 , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , VAR_61 -> VAR_62 ) ; return VAR_63 ; } VAR_64 -> VAR_65 = VAR_66 ; if ( VAR_67 -> VAR_68 <= 0 || VAR_69 -> VAR_70 <= 0 ) { METHOD_14 ( VAR_71 -> VAR_72 , VAR_73 , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , VAR_74 -> VAR_75 , VAR_76 -> VAR_77 ) ; return VAR_78 ; } if ( METHOD_15 ( & VAR_79 -> VAR_80 ) < 3 * VAR_81 -> VAR_82 ) return VAR_83 ; for ( VAR_84 = 0 ; VAR_85 < VAR_86 -> VAR_87 ; VAR_88 ++ ) { TYPE_6 VAR_89 = METHOD_16 ( & VAR_90 -> VAR_91 ) ; VAR_92 -> VAR_93 [ VAR_94 ] = ( VAR_95 & 0x7f ) + 1 ; VAR_96 -> VAR_97 = METHOD_17 ( VAR_98 -> VAR_99 [ VAR_100 ] , VAR_101 -> VAR_102 ) ; VAR_103 -> VAR_104 [ VAR_105 ] = ! ! ( VAR_106 & 0x80 ) ; VAR_107 -> VAR_108 [ VAR_109 ] = METHOD_18 ( & VAR_110 -> VAR_111 ) ; VAR_112 -> VAR_113 [ VAR_114 ] = METHOD_19 ( & VAR_115 -> VAR_116 ) ; if ( ! VAR_117 -> VAR_118 [ VAR_119 ] || VAR_120 -> VAR_121 [ VAR_122 ] == 3 || VAR_123 -> VAR_124 [ VAR_125 ] > 4 || ! VAR_126 -> VAR_127 [ VAR_128 ] || VAR_129 -> VAR_130 [ VAR_131 ] == 3 || VAR_132 -> VAR_133 [ VAR_134 ] > 4 ) { METHOD_20 ( VAR_135 -> VAR_136 , VAR_137 , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , VAR_138 -> VAR_139 [ VAR_140 ] , VAR_141 -> VAR_142 [ VAR_143 ] ) ; return VAR_144 ; } VAR_145 |= VAR_146 -> VAR_147 [ VAR_148 ] >> 1 << VAR_149 * 4 | VAR_150 -> VAR_151 [ VAR_152 ] >> 1 << VAR_153 * 4 + 2 ; } VAR_154 -> VAR_155 = METHOD_21 ( VAR_156 -> VAR_157 - VAR_158 -> VAR_159 , VAR_160 -> VAR_161 ) ; VAR_162 -> VAR_163 = METHOD_22 ( VAR_164 -> VAR_165 - VAR_166 -> VAR_167 , VAR_168 -> VAR_169 ) ; if ( VAR_170 -> VAR_171 * ( TYPE_7 ) VAR_172 -> VAR_173 > VAR_174 / sizeof ( * VAR_175 -> VAR_176 ) ) { VAR_177 -> VAR_178 = VAR_179 -> VAR_180 = 0 ; return METHOD_23 ( VAR_181 ) ; } VAR_182 -> VAR_183 = METHOD_24 ( VAR_184 -> VAR_185 * VAR_186 -> VAR_187 , sizeof ( * VAR_188 -> VAR_189 ) ) ; if ( ! VAR_190 -> VAR_191 ) { VAR_192 -> VAR_193 = VAR_194 -> VAR_195 = 0 ; return METHOD_25 ( VAR_196 ) ; } for ( VAR_197 = 0 ; VAR_198 < VAR_199 -> VAR_200 * VAR_201 -> VAR_202 ; VAR_203 ++ ) { TYPE_8 * VAR_204 = VAR_205 -> VAR_206 + VAR_207 ; VAR_208 -> VAR_209 = METHOD_26 ( VAR_210 -> VAR_211 * sizeof ( * VAR_212 -> VAR_213 ) ) ; if ( ! VAR_214 -> VAR_215 ) return METHOD_27 ( VAR_216 ) ; } VAR_217 -> VAR_218 -> VAR_219 = METHOD_28 ( VAR_220 -> VAR_221 - VAR_222 -> VAR_223 , VAR_224 -> VAR_225 ) ; VAR_226 -> VAR_227 -> VAR_228 = METHOD_29 ( VAR_229 -> VAR_230 - VAR_231 -> VAR_232 , VAR_233 -> VAR_234 ) ; if ( VAR_235 -> VAR_236 -> VAR_237 == VAR_238 || VAR_239 -> VAR_240 -> VAR_241 == VAR_242 ) { VAR_243 = VAR_244 ; VAR_245 = METHOD_30 ( VAR_246 ) ; } else { switch ( VAR_247 -> VAR_248 ) { case 16 : VAR_249 = VAR_250 ; VAR_251 = METHOD_31 ( VAR_252 ) ; break ; case 17 : VAR_253 = VAR_254 ; VAR_255 = METHOD_32 ( VAR_256 ) ; break ; case 18 : VAR_257 = VAR_258 ; VAR_259 = METHOD_33 ( VAR_260 ) ; break ; default : VAR_261 = VAR_262 ; VAR_263 = METHOD_34 ( VAR_264 ) ; break ; } } for ( VAR_265 = 0 ; VAR_266 < VAR_267 ; ++ VAR_268 ) { if ( METHOD_35 ( VAR_269 [ VAR_270 ] , VAR_271 , VAR_272 -> VAR_273 , VAR_274 , VAR_275 -> VAR_276 ) ) { VAR_277 -> VAR_278 -> VAR_279 = VAR_280 [ VAR_281 ] ; break ; } } if ( VAR_282 -> VAR_283 -> VAR_284 == VAR_285 ) { METHOD_36 ( VAR_286 -> VAR_287 , VAR_288 , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , VAR_289 -> VAR_290 -> VAR_291 , VAR_292 -> VAR_293 , VAR_294 , VAR_295 -> VAR_296 , VAR_297 > 2 ? VAR_298 -> VAR_299 [ 1 ] : 0 , VAR_300 > 2 ? VAR_301 -> VAR_302 [ 1 ] : 0 , VAR_303 > 2 ? VAR_304 -> VAR_305 [ 2 ] : 0 , VAR_306 > 2 ? VAR_307 -> VAR_308 [ 2 ] : 0 ) ; } VAR_309 -> VAR_310 -> VAR_311 = VAR_312 -> VAR_313 ; return 0 ; }","<S2SV_ModStart> VAR_116 ) ; if ( VAR_312 -> VAR_223 || VAR_312 -> VAR_232 ) { METHOD_13 ( VAR_312 -> VAR_310 , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return VAR_63 ; }","CWE-119 static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; <S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }","<S2SV_ModStart> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; }"
13,"CWE-190 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { if ( VAR_1 -> VAR_2 . VAR_3 && VAR_4 -> VAR_5 ) { const TYPE_2 * VAR_6 = ( const TYPE_3 * ) VAR_7 -> VAR_8 . VAR_9 ; TYPE_4 VAR_10 = VAR_11 -> VAR_12 . VAR_13 ; TYPE_5 * VAR_14 = VAR_15 -> VAR_16 ; <S2SV_StartBug> METHOD_1 ( VAR_17 , VAR_18 -> VAR_19 , METHOD_2 ( VAR_20 , VAR_21 , VAR_22 ) ) ; <S2SV_EndBug> } }","<S2SV_ModStart> ; METHOD_1 ( VAR_18 <S2SV_ModEnd> , VAR_18 ->","CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->"
14,CWE-119 static TYPE_0 TYPE_1 METHOD_0 ( TYPE_2 * VAR_0 ) { TYPE_3 * VAR_1 = VAR_2 -> VAR_3 ; METHOD_1 ( & VAR_4 -> VAR_5 ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> },<S2SV_ModStart> VAR_5 ) ; METHOD_1 ( & VAR_4 -> VAR_6 ) ; VAR_4 -> VAR_7 = 0 ;,CWE-119 static av_cold int xpm_decode_close ( AVCodecContext * avctx ) { XPMDecContext * x = avctx -> priv_data ; av_freep ( & x -> pixels ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> },<S2SV_ModStart> pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
15,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 * VAR_5 , * VAR_6 , VAR_7 ; TYPE_7 * VAR_8 ; VAR_9 = METHOD_1 ( VAR_10 ) ; if ( ( VAR_11 = METHOD_2 ( VAR_12 , "".pdf"" ) ) ) * VAR_13 = '\\0' ; <S2SV_StartBug> VAR_14 = METHOD_3 ( METHOD_4 ( VAR_15 ) + METHOD_5 ( VAR_16 ) + 16 ) ; <S2SV_EndBug> METHOD_6 ( VAR_17 , METHOD_7 ( VAR_18 ) + METHOD_8 ( VAR_19 ) + 16 , ""%s/%s-version-%d.pdf"" , VAR_20 , VAR_21 , VAR_22 -> VAR_23 ) ; if ( ! ( VAR_24 = METHOD_9 ( VAR_25 , ""w"" ) ) ) { METHOD_10 ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , VAR_26 ) ; METHOD_11 ( VAR_27 , VAR_28 , VAR_29 ) ; METHOD_12 ( VAR_30 ) ; return ; } METHOD_13 ( VAR_31 , 0 , VAR_32 ) ; while ( METHOD_14 ( & VAR_33 , 1 , 1 , VAR_34 ) ) METHOD_15 ( & VAR_35 , 1 , 1 , VAR_36 ) ; METHOD_16 ( VAR_37 , ""\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF"" , VAR_38 -> VAR_39 ) ; METHOD_17 ( VAR_40 ) ; METHOD_18 ( VAR_41 ) ; METHOD_19 ( VAR_42 , VAR_43 , VAR_44 ) ; }",<S2SV_ModStart> ; VAR_41 = METHOD_20 <S2SV_ModEnd> ( METHOD_8 (,"CWE-787 static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , "".pdf"" ) ) ) * c = '\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , ""\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF"" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }",<S2SV_ModStart> ; new_fname = safe_calloc <S2SV_ModEnd> ( strlen (
16,"CWE-254 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = VAR_1 -> STRUCT_OR_UNION_3 ; if ( ! VAR_2 -> VAR_3 . VAR_4 ) METHOD_1 ( VAR_5 ) ; while ( 1 ) { if ( METHOD_2 ( & VAR_6 -> VAR_7 , & VAR_8 -> VAR_9 ) ) break ; if ( VAR_10 -> VAR_11 . STRUCT_OR_UNION_4 != VAR_12 -> VAR_13 . VAR_14 -> VAR_15 ) { struct STRUCT_OR_UNION_5 * VAR_16 = VAR_17 -> VAR_18 . STRUCT_OR_UNION_6 ; struct STRUCT_OR_UNION_7 * VAR_19 = VAR_20 -> VAR_21 ; unsigned VAR_22 ; STRUCT_OR_UNION_8 = VAR_23 -> VAR_24 ; VAR_25 = METHOD_3 ( & VAR_26 -> VAR_27 ) ; if ( METHOD_4 ( METHOD_5 ( & VAR_28 -> VAR_29 , VAR_30 -> VAR_31 ) ) ) return - VAR_32 ; VAR_33 -> VAR_34 . STRUCT_OR_UNION_9 = VAR_35 ; VAR_36 -> VAR_37 = VAR_38 ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct STRUCT_OR_UNION_10 * VAR_39 = METHOD_6 ( VAR_40 -> VAR_41 . VAR_42 ) ; struct STRUCT_OR_UNION_11 * VAR_43 = VAR_44 -> VAR_45 ; struct STRUCT_OR_UNION_12 * VAR_46 = VAR_47 -> VAR_48 ; struct STRUCT_OR_UNION_13 * VAR_49 = VAR_50 -> VAR_51 ; unsigned VAR_52 = METHOD_7 ( & VAR_53 -> VAR_54 ) ; if ( METHOD_8 ( METHOD_9 ( & VAR_55 , VAR_56 -> VAR_57 ) ) ) return - VAR_58 ; if ( & VAR_59 -> VAR_60 == VAR_61 -> VAR_62 . VAR_63 ) break ; VAR_64 -> VAR_65 . STRUCT_OR_UNION_14 = VAR_66 ; VAR_67 -> VAR_68 . VAR_69 = & VAR_70 -> VAR_71 ; STRUCT_OR_UNION_15 = VAR_72 ; VAR_73 -> VAR_74 = VAR_75 ; } } while ( METHOD_10 ( METHOD_11 ( VAR_76 -> VAR_77 . STRUCT_OR_UNION_16 ) ) ) { struct STRUCT_OR_UNION_17 * VAR_78 ; VAR_79 = METHOD_12 ( VAR_80 -> VAR_81 . VAR_82 , VAR_83 -> VAR_84 . STRUCT_OR_UNION_18 ) ; if ( METHOD_13 ( METHOD_14 ( & VAR_85 , VAR_86 -> VAR_87 ) ) ) return - VAR_88 ; if ( ! VAR_89 ) break ; VAR_90 -> VAR_91 . VAR_92 = & VAR_93 -> VAR_94 ; VAR_95 -> VAR_96 . STRUCT_OR_UNION_19 = VAR_97 -> VAR_98 . VAR_99 ; STRUCT_OR_UNION_20 = VAR_100 -> VAR_101 . STRUCT_OR_UNION_21 -> VAR_102 ; VAR_103 -> VAR_104 = METHOD_15 ( & VAR_105 -> VAR_106 . STRUCT_OR_UNION_22 -> VAR_107 ) ; } VAR_108 -> STRUCT_OR_UNION_23 = STRUCT_OR_UNION_24 ; return 0 ; }",<S2SV_ModStart> = VAR_104 ; if ( METHOD_13 ( ! METHOD_16 ( & VAR_108 -> VAR_106 ) ) ) return - VAR_109 ;,"CWE-254 static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }",<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
17,"CWE-200 static TYPE_0 STRUCT_OR_UNION_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 ) { struct STRUCT_OR_UNION_3 VAR_2 ; <S2SV_StartBug> METHOD_0 ( VAR_3 . VAR_4 , ""akcipher"" , sizeof ( VAR_5 . VAR_6 ) ) ; <S2SV_EndBug> if ( METHOD_1 ( VAR_7 , VAR_8 , sizeof ( struct STRUCT_OR_UNION_4 ) , & VAR_9 ) ) goto VAR_10 ; return 0 ; VAR_11 : return - VAR_12 ; }",<S2SV_ModStart> STRUCT_OR_UNION_4 VAR_9 ; METHOD_2 <S2SV_ModEnd> ( VAR_9 .,"CWE-200 static int crypto_report_akcipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ; <S2SV_StartBug> strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }",<S2SV_ModStart> crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher .
18,"CWE-77 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 ) <S2SV_EndBug> { static const TYPE_4 VAR_3 [ ] = ""\\""\\\\"" ; TYPE_5 * VAR_4 = VAR_5 ; const TYPE_6 * VAR_6 = VAR_7 ; * VAR_8 ++ = \'""\' ; VAR_9 -= 2 ; for ( ; * VAR_10 && VAR_11 ; VAR_12 ++ ) { if ( METHOD_1 ( VAR_13 , * VAR_14 ) ) { VAR_15 -= 2 ; if ( VAR_16 == 0 ) break ; * VAR_17 ++ = '\\\\' ; * VAR_18 ++ = * VAR_19 ; } else { * VAR_20 ++ = * VAR_21 ; VAR_22 -- ; } } * VAR_23 ++ = \'""\' ; * VAR_24 = '\\0' ; }","<S2SV_ModStart> TYPE_6 * VAR_7 , TYPE_7 VAR_25 ) { const TYPE_6 * VAR_13 = ""`\\""\\\\"" ; if ( ! VAR_25 ) VAR_13 ++ <S2SV_ModEnd> ; TYPE_6 *","CWE-77 <S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> { static const char quote [ ] = ""\\""\\\\"" ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }","<S2SV_ModStart> char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char *"
19,"CWE-320 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { TYPE_2 VAR_2 [ 1024 ] ; TYPE_3 VAR_3 ; struct STRUCT_OR_UNION_1 VAR_4 ; <S2SV_StartBug> TYPE_4 VAR_5 ; <S2SV_EndBug> if ( METHOD_1 ( VAR_6 , & VAR_7 ) < 0 ) return VAR_8 ; if ( ( VAR_9 . VAR_10 & ( VAR_11 | VAR_12 | VAR_13 ) ) == 0 && VAR_14 . VAR_15 > VAR_16 ) return VAR_17 ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> if ( ( VAR_18 = METHOD_2 ( VAR_19 , VAR_20 , VAR_21 , sizeof ( VAR_22 ) ) ) == 0 ) { if ( VAR_23 == VAR_24 ) break ; VAR_25 = VAR_26 ; goto VAR_27 ; } if ( ( VAR_28 = METHOD_3 ( VAR_29 , VAR_30 , VAR_31 ) ) != 0 ) goto VAR_32 ; if ( METHOD_4 ( VAR_33 ) > VAR_34 ) { VAR_35 = VAR_36 ; goto VAR_37 ; } } if ( ( VAR_38 . VAR_39 & ( VAR_40 | VAR_41 | VAR_42 ) ) == 0 && VAR_43 . VAR_44 != ( TYPE_5 ) METHOD_5 ( VAR_45 ) ) { VAR_46 = VAR_47 ; goto VAR_48 ; } VAR_49 = 0 ; VAR_50 : METHOD_6 ( VAR_51 , sizeof ( VAR_52 ) ) ; if ( VAR_53 != 0 ) METHOD_7 ( VAR_54 ) ; return VAR_55 ; }","<S2SV_ModStart> ; TYPE_4 VAR_55 , VAR_56 = 0 <S2SV_ModStart> return VAR_36 ; if ( ( VAR_43 . VAR_39 & VAR_57 ) == 0 || VAR_43 . VAR_44 <= 0 ) { VAR_43 . VAR_44 = 64 * 1024 ; VAR_56 = 1 ; } if ( ( VAR_55 = METHOD_8 ( VAR_54 , VAR_43 . VAR_44 ) ) != 0 || ( VAR_56 && ( VAR_55 = METHOD_9 ( VAR_54 , VAR_43 . VAR_44 ) ) != 0 ) ) return VAR_55 ;","CWE-320 int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ; <S2SV_StartBug> int r ; <S2SV_EndBug> if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }","<S2SV_ModStart> ; int r , dontmax = 0 <S2SV_ModStart> return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;"
20,CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { if ( VAR_1 -> VAR_2 . VAR_3 == 0 || <S2SV_StartBug> VAR_4 -> VAR_5 . VAR_6 > VAR_7 / VAR_8 -> VAR_9 . VAR_10 ) <S2SV_EndBug> return - VAR_11 ; if ( VAR_12 -> VAR_13 . VAR_14 == 0 || VAR_15 -> VAR_16 . VAR_17 > VAR_18 ) return - VAR_19 ; if ( VAR_20 -> VAR_21 . VAR_22 == 0 || VAR_23 -> VAR_24 . VAR_25 == 0 ) return - VAR_26 ; return 0 ; },<S2SV_ModStart> . VAR_6 > VAR_27 <S2SV_ModEnd> / VAR_23 ->,CWE-000 static int snd_compress_check_input ( struct snd_compr_params * params ) { if ( params -> buffer . fragment_size == 0 || <S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> return - EINVAL ; if ( params -> codec . id == 0 || params -> codec . id > SND_AUDIOCODEC_MAX ) return - EINVAL ; if ( params -> codec . ch_in == 0 || params -> codec . ch_out == 0 ) return - EINVAL ; return 0 ; },<S2SV_ModStart> . fragments > INT_MAX <S2SV_ModEnd> / params ->
21,"CWE-119 static TYPE_0 METHOD_0 ( const TYPE_1 * const VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; if ( VAR_6 == VAR_7 ) { <S2SV_StartBug> METHOD_1 ( VAR_8 , VAR_9 , sizeof ( TYPE_7 ) * VAR_10 ) ; <S2SV_EndBug> return ; } VAR_11 = METHOD_2 ( VAR_12 , VAR_13 ) ; if ( VAR_14 > 0 ) { TYPE_8 VAR_15 ; TYPE_9 * VAR_16 = VAR_17 ; TYPE_10 * VAR_18 = VAR_19 ; TYPE_11 * VAR_20 , * VAR_21 ; TYPE_12 VAR_22 = VAR_23 ; if ( ! VAR_24 ) { VAR_25 = ( TYPE_13 * ) METHOD_3 ( sizeof ( TYPE_14 ) * VAR_26 ) ; VAR_27 = VAR_28 ; } else { VAR_29 = VAR_30 ; } VAR_31 = VAR_32 + METHOD_4 ( VAR_33 , 1 ) ; for ( VAR_34 = 0 ; VAR_35 < VAR_36 ; ++ VAR_37 ) { const TYPE_15 VAR_38 = METHOD_5 ( VAR_39 , 1 ) ; const TYPE_16 * const VAR_40 = ( VAR_41 == 0 ? VAR_42 : VAR_43 ) ; if ( VAR_44 == VAR_45 - 1 && VAR_46 == VAR_47 ) VAR_48 = VAR_49 ; else VAR_50 = ( VAR_51 & 1 ? VAR_52 : VAR_53 ) ; if ( VAR_54 & 1 ) METHOD_6 ( VAR_55 , VAR_56 , VAR_57 ) ; else METHOD_7 ( VAR_58 , VAR_59 , VAR_60 ) ; VAR_61 = VAR_62 ; } if ( VAR_63 != VAR_64 ) { METHOD_8 ( VAR_65 , VAR_66 , VAR_67 , VAR_68 ) ; } if ( VAR_69 ) METHOD_9 ( VAR_70 ) ; } else { METHOD_10 ( VAR_71 , VAR_72 , VAR_73 , VAR_74 ) ; } }","<S2SV_ModStart> , sizeof ( VAR_73 [ 0 ] <S2SV_ModEnd> ) * VAR_72","CWE-119 static void resize_multistep ( const uint8_t * const input , int length , uint8_t * output , int olength , uint8_t * buf ) { int steps ; if ( length == olength ) { <S2SV_StartBug> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <S2SV_EndBug> return ; } steps = get_down2_steps ( length , olength ) ; if ( steps > 0 ) { int s ; uint8_t * out = NULL ; uint8_t * tmpbuf = NULL ; uint8_t * otmp , * otmp2 ; int filteredlength = length ; if ( ! tmpbuf ) { tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * length ) ; otmp = tmpbuf ; } else { otmp = buf ; } otmp2 = otmp + get_down2_length ( length , 1 ) ; for ( s = 0 ; s < steps ; ++ s ) { const int proj_filteredlength = get_down2_length ( filteredlength , 1 ) ; const uint8_t * const in = ( s == 0 ? input : out ) ; if ( s == steps - 1 && proj_filteredlength == olength ) out = output ; else out = ( s & 1 ? otmp2 : otmp ) ; if ( filteredlength & 1 ) down2_symodd ( in , filteredlength , out ) ; else down2_symeven ( in , filteredlength , out ) ; filteredlength = proj_filteredlength ; } if ( filteredlength != olength ) { interpolate ( out , filteredlength , output , olength ) ; } if ( tmpbuf ) free ( tmpbuf ) ; } else { interpolate ( input , length , output , olength ) ; } }","<S2SV_ModStart> , sizeof ( output [ 0 ] <S2SV_ModEnd> ) * length"
22,CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> if ( VAR_1 -> VAR_2 . VAR_3 ) { <S2SV_EndBug> METHOD_1 ( VAR_4 -> VAR_5 . VAR_6 ) ; VAR_7 -> VAR_8 . VAR_9 = VAR_10 ; } },<S2SV_ModStart> VAR_7 ) { <S2SV_ModEnd> VAR_7 -> VAR_8 <S2SV_ModStart> -> VAR_8 . VAR_11 = VAR_12 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,CWE-399 static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } },<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
23,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_2 * VAR_6 = VAR_7 -> VAR_8 ; struct STRUCT_OR_UNION_3 * VAR_9 = VAR_10 ; TYPE_3 VAR_11 = 0 ; unsigned TYPE_4 VAR_12 ; union { struct STRUCT_OR_UNION_4 VAR_13 ; struct STRUCT_OR_UNION_5 VAR_14 ; struct STRUCT_OR_UNION_6 VAR_15 ; struct STRUCT_OR_UNION_7 VAR_16 ; } VAR_17 ; VAR_18 = METHOD_1 ( VAR_19 ) ; if ( METHOD_2 ( VAR_20 ) > sizeof ( VAR_21 ) ) return - VAR_22 ; if ( VAR_23 & VAR_24 ) if ( METHOD_3 ( & VAR_25 , ( TYPE_5 TYPE_6 * ) VAR_26 , METHOD_4 ( VAR_27 ) ) ) return - VAR_28 ; switch ( VAR_29 ) { case VAR_30 : { struct STRUCT_OR_UNION_8 * VAR_31 ; VAR_32 = METHOD_5 ( VAR_33 , VAR_34 . VAR_35 . VAR_36 , VAR_37 . VAR_38 . VAR_39 , VAR_40 . VAR_41 . VAR_42 , VAR_43 . VAR_44 . VAR_45 ) ; if ( METHOD_6 ( VAR_46 ) ) return METHOD_7 ( VAR_47 ) ; VAR_48 . VAR_49 . VAR_50 = VAR_51 -> VAR_52 ; VAR_53 = VAR_54 ; break ; } case VAR_55 : { struct STRUCT_OR_UNION_9 * VAR_56 ; <S2SV_StartBug> VAR_57 = METHOD_8 ( VAR_58 , VAR_59 . VAR_60 . VAR_61 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( METHOD_9 ( VAR_62 ) ) <S2SV_EndBug> return METHOD_10 ( VAR_63 ) ; <S2SV_StartBug> METHOD_11 ( VAR_64 , VAR_65 ) ; <S2SV_EndBug> METHOD_12 ( VAR_66 ) ; break ; } case VAR_67 : case VAR_68 : { struct STRUCT_OR_UNION_10 * VAR_69 ; VAR_70 = METHOD_13 ( VAR_71 , VAR_72 . VAR_73 . VAR_74 ) ; if ( METHOD_14 ( VAR_75 ) ) return METHOD_15 ( VAR_76 ) ; VAR_77 . VAR_78 . VAR_79 = METHOD_16 ( VAR_80 , VAR_81 ) ; METHOD_17 ( VAR_82 ) ; if ( VAR_83 . VAR_84 . VAR_85 < 0 ) VAR_86 = VAR_87 . VAR_88 . VAR_89 ; break ; } case VAR_90 : { struct STRUCT_OR_UNION_11 * VAR_91 ; VAR_92 = METHOD_18 ( VAR_93 , VAR_94 . VAR_95 . VAR_96 ) ; if ( METHOD_19 ( VAR_97 ) ) VAR_98 = METHOD_20 ( VAR_99 ) ; else VAR_100 . VAR_101 . VAR_102 = VAR_103 -> VAR_104 ; break ; } case VAR_105 : { VAR_106 = METHOD_21 ( VAR_107 , VAR_108 . VAR_109 . VAR_110 ) ; break ; } case VAR_111 : { if ( ! VAR_112 -> METHOD_22 ) return - VAR_113 ; VAR_114 = VAR_115 -> METHOD_23 ( VAR_116 , VAR_117 . VAR_118 . VAR_119 , VAR_120 . VAR_121 . VAR_122 ) ; break ; } default : return - VAR_123 ; } if ( VAR_124 & VAR_125 ) { if ( METHOD_24 ( ( TYPE_7 TYPE_8 * ) VAR_126 , & VAR_127 , METHOD_25 ( VAR_128 ) ) ) { if ( VAR_129 ) METHOD_26 ( VAR_130 , VAR_131 ) ; return - VAR_132 ; } } return VAR_133 ; }","<S2SV_ModStart> * VAR_103 ; METHOD_27 ( & VAR_130 -> VAR_134 ) ; VAR_103 = METHOD_28 <S2SV_ModEnd> ( VAR_130 , <S2SV_ModStart> VAR_103 ) ) { METHOD_29 ( & VAR_130 -> VAR_134 ) ; <S2SV_ModStart> VAR_103 ) ; } METHOD_30 ( VAR_130 , VAR_103 ) ; METHOD_31 ( VAR_103 ) ; METHOD_29 ( & VAR_130 -> VAR_134 <S2SV_ModEnd> ) ; break","CWE-264 static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ; <S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> return PTR_ERR ( handle ) ; <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }","<S2SV_ModStart> * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> handle ) ) { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break"
24,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = ( struct STRUCT_OR_UNION_3 * ) ( VAR_3 + 1 ) ; struct STRUCT_OR_UNION_4 * VAR_4 ; METHOD_1 ( & VAR_5 -> VAR_6 [ VAR_7 ] ) ; VAR_8 = ( struct STRUCT_OR_UNION_5 * ) VAR_9 -> VAR_10 [ VAR_11 ] ; if ( VAR_12 ) METHOD_2 ( VAR_13 ) ; METHOD_3 ( & VAR_14 -> VAR_15 [ VAR_16 ] ) ; if ( VAR_17 == VAR_18 ) return ; if ( VAR_19 -> VAR_20 ) goto VAR_21 ; if ( VAR_22 -> VAR_23 != 0 ) { if ( ( ( VAR_24 -> VAR_25 - VAR_26 -> VAR_27 ) & 0x80 ) == 0 ) goto VAR_28 ; } VAR_29 -> VAR_30 = VAR_31 -> VAR_32 ; switch ( VAR_33 -> VAR_34 ) { case VAR_35 : { struct STRUCT_OR_UNION_6 * VAR_36 = ( struct STRUCT_OR_UNION_7 * ) VAR_37 ; <S2SV_StartBug> TYPE_1 VAR_38 = VAR_39 -> VAR_40 - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct STRUCT_OR_UNION_8 ) + 1 ; <S2SV_EndBug> TYPE_2 VAR_41 = METHOD_4 ( METHOD_5 ( & VAR_42 -> VAR_43 ) ) ; TYPE_3 VAR_44 = METHOD_6 ( METHOD_7 ( & VAR_45 -> VAR_46 ) ) ; METHOD_8 ( VAR_47 , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; METHOD_9 ( VAR_48 -> VAR_49 , VAR_50 -> VAR_51 , VAR_52 -> VAR_53 , VAR_54 -> VAR_55 , VAR_56 , VAR_57 , VAR_58 ) ; } break ; case VAR_59 : { struct STRUCT_OR_UNION_9 * VAR_60 = ( struct STRUCT_OR_UNION_10 * ) VAR_61 ; METHOD_10 ( VAR_62 -> VAR_63 , VAR_64 -> VAR_65 , VAR_66 -> VAR_67 , VAR_68 , 0 ) ; } break ; case VAR_69 : { struct STRUCT_OR_UNION_11 * VAR_70 = ( struct STRUCT_OR_UNION_12 * ) VAR_71 ; METHOD_11 ( VAR_72 -> VAR_73 , VAR_74 -> VAR_75 , VAR_76 -> VAR_77 , VAR_78 , 0 ) ; } break ; case VAR_79 : { struct STRUCT_OR_UNION_13 * VAR_80 = ( struct STRUCT_OR_UNION_14 * ) VAR_81 ; METHOD_12 ( VAR_82 -> VAR_83 , VAR_84 -> VAR_85 , VAR_86 -> VAR_87 , VAR_88 -> VAR_89 , VAR_90 -> VAR_91 - sizeof ( struct STRUCT_OR_UNION_15 ) + 1 ) ; } break ; case VAR_92 : METHOD_13 ( VAR_93 , VAR_94 , VAR_95 -> VAR_96 ) ; break ; } VAR_97 : METHOD_14 ( VAR_98 ) ; }","<S2SV_ModStart> ) VAR_94 ; TYPE_3 VAR_57 , VAR_58 ; TYPE_4 VAR_56 ; if ( VAR_95 -> VAR_96 < sizeof ( struct STRUCT_OR_UNION_8 ) - 1 ) break ; <S2SV_ModEnd> VAR_56 = VAR_95 <S2SV_ModStart> -> VAR_96 - ( <S2SV_ModStart> ( struct STRUCT_OR_UNION_8 ) - 1 ) ; VAR_57 = METHOD_6 ( METHOD_7 ( & VAR_88 -> VAR_43 ) ) ; VAR_58 = METHOD_6 ( METHOD_7 ( & VAR_88 -> VAR_58 ) ) ; METHOD_8 ( VAR_47 , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; METHOD_9 ( VAR_98 -> VAR_83 , VAR_88 -> VAR_85 , VAR_88 -> VAR_87 , VAR_88 -> VAR_89 , VAR_56 , VAR_57 , VAR_58 ) ; } break ; case VAR_59 : { struct STRUCT_OR_UNION_10 * VAR_88 = ( struct STRUCT_OR_UNION_10 * ) VAR_94 ; METHOD_12 ( VAR_98 -> VAR_83 , VAR_88 -> VAR_85 , VAR_88 -> VAR_87 , VAR_78 , 0 ) ; } break ; case VAR_69 : { struct STRUCT_OR_UNION_12 * VAR_88 = ( struct STRUCT_OR_UNION_12 * ) VAR_94 ; METHOD_12 ( VAR_98 -> VAR_83 , VAR_88 -> VAR_85 , VAR_88 -> VAR_87 , VAR_78 , 0 ) ; } break ; case VAR_79 : { struct STRUCT_OR_UNION_15 * VAR_88 = ( struct STRUCT_OR_UNION_15 * ) VAR_94 ; METHOD_12 ( VAR_98 -> VAR_83 , VAR_88 -> VAR_85 , VAR_88 -> VAR_87 , VAR_88 -> VAR_89 , VAR_95 -> VAR_96 - sizeof ( struct STRUCT_OR_UNION_15 <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }","CWE-119 void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }","<S2SV_ModStart> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> data_len = elt <S2SV_ModStart> -> length - ( <S2SV_ModStart> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }"
25,"CWE-119 TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , TYPE_7 VAR_6 ) { TYPE_8 * VAR_7 = VAR_8 ; TYPE_9 VAR_9 = 0 ; TYPE_10 * VAR_10 = VAR_11 ; TYPE_11 * VAR_12 = VAR_13 ; const TYPE_12 * VAR_14 ; TYPE_13 VAR_15 ; TYPE_14 VAR_16 , VAR_17 ; TYPE_15 VAR_18 = 0 ; if ( ( VAR_19 == VAR_20 ) || ( VAR_21 == VAR_22 ) || ( VAR_23 < 0 ) ) return ( VAR_24 ) ; VAR_25 = VAR_26 + VAR_27 ; if ( ( ( VAR_28 -> VAR_29 > 40 ) && ( ( VAR_30 -> VAR_31 & VAR_32 ) == 0 ) ) || ( VAR_33 -> VAR_34 > 1024 ) ) { METHOD_1 ( VAR_35 , VAR_36 , VAR_37 ) ; return ( VAR_38 ) ; } VAR_39 = VAR_40 ; VAR_41 = ( TYPE_16 * ) METHOD_2 ( VAR_42 * sizeof ( TYPE_17 ) ) ; if ( VAR_43 == VAR_44 ) goto VAR_45 ; if ( VAR_46 < VAR_47 ) VAR_48 = METHOD_3 ( VAR_49 , VAR_50 ) ; else VAR_51 = 0 ; while ( ( VAR_52 != 0 ) && ( VAR_53 != VAR_54 ) && ( VAR_55 != VAR_56 ) && ( VAR_57 != VAR_58 ) ) { if ( VAR_59 == 0 ) break ; if ( ( VAR_60 == '&' ) && ( VAR_61 [ 1 ] == '' ) ) { TYPE_18 VAR_62 = METHOD_4 ( VAR_63 , & VAR_64 ) ; if ( VAR_65 != 0 ) { METHOD_5 ( 0 , VAR_66 , VAR_67 , VAR_68 ) ; } if ( VAR_69 > VAR_70 - VAR_71 ) { METHOD_6 ( VAR_72 , VAR_73 ) ; } } else if ( ( VAR_74 == '&' ) && ( VAR_75 & VAR_76 ) ) { if ( VAR_77 ) METHOD_7 ( VAR_78 , ""String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , VAR_79 ) ; VAR_80 = METHOD_8 ( VAR_81 , & VAR_82 ) ; if ( ( VAR_83 -> VAR_84 . VAR_85 == VAR_86 ) || ( VAR_87 -> VAR_88 . VAR_89 == VAR_90 ) ) goto VAR_91 ; if ( VAR_92 != VAR_93 ) VAR_94 -> VAR_95 += VAR_96 -> VAR_97 ; if ( ( VAR_98 != VAR_99 ) && ( VAR_100 -> VAR_101 == VAR_102 ) ) { if ( VAR_103 -> VAR_104 != VAR_105 ) { METHOD_9 ( 0 , VAR_106 , VAR_107 , VAR_108 -> VAR_109 [ 0 ] ) ; if ( VAR_110 > VAR_111 - VAR_112 ) { METHOD_10 ( VAR_113 , VAR_114 ) ; } } else { METHOD_11 ( VAR_115 , VAR_116 , ""pred<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n"" ) ; } } else if ( ( VAR_117 != VAR_118 ) && ( VAR_119 -> VAR_120 != VAR_121 ) ) { VAR_122 -> VAR_123 ++ ; VAR_124 = METHOD_12 ( VAR_125 , VAR_126 -> VAR_127 , VAR_128 , 0 , 0 , 0 ) ; VAR_129 -> VAR_130 -- ; if ( VAR_131 != VAR_132 ) { VAR_133 = VAR_134 ; while ( * VAR_135 != 0 ) { VAR_136 [ VAR_137 ++ ] = * VAR_138 ++ ; if ( VAR_139 > VAR_140 - VAR_141 ) { if ( METHOD_13 ( VAR_142 , VAR_143 , VAR_144 ) ) goto VAR_145 ; METHOD_14 ( VAR_146 , VAR_147 ) ; } } METHOD_15 ( VAR_148 ) ; VAR_149 = VAR_150 ; } } else if ( VAR_151 != VAR_152 ) { TYPE_19 VAR_153 = METHOD_16 ( VAR_154 -> VAR_155 ) ; const TYPE_20 * VAR_156 = VAR_157 -> VAR_158 ; VAR_159 [ VAR_160 ++ ] = '&' ; if ( VAR_161 > VAR_162 - VAR_163 - VAR_164 ) { <S2SV_StartBug> METHOD_17 ( VAR_165 , VAR_166 ) ; <S2SV_EndBug> } for ( ; VAR_167 > 0 ; VAR_168 -- ) VAR_169 [ VAR_170 ++ ] = * VAR_171 ++ ; VAR_172 [ VAR_173 ++ ] = ';' ; } } else if ( VAR_174 == '%' && ( VAR_175 & VAR_176 ) ) { if ( VAR_177 ) METHOD_18 ( VAR_178 , ""String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , VAR_179 ) ; VAR_180 = METHOD_19 ( VAR_181 , & VAR_182 ) ; if ( VAR_183 -> VAR_184 . VAR_185 == VAR_186 ) goto VAR_187 ; if ( VAR_188 != VAR_189 ) VAR_190 -> VAR_191 += VAR_192 -> VAR_193 ; if ( VAR_194 != VAR_195 ) { if ( VAR_196 -> VAR_197 == VAR_198 ) { METHOD_20 ( VAR_199 , VAR_200 ) ; } VAR_201 -> VAR_202 ++ ; VAR_203 = METHOD_21 ( VAR_204 , VAR_205 -> VAR_206 , VAR_207 , 0 , 0 , 0 ) ; VAR_208 -> VAR_209 -- ; if ( VAR_210 != VAR_211 ) { VAR_212 = VAR_213 ; while ( * VAR_214 != 0 ) { VAR_215 [ VAR_216 ++ ] = * VAR_217 ++ ; if ( VAR_218 > VAR_219 - VAR_220 ) { if ( METHOD_22 ( VAR_221 , VAR_222 , VAR_223 ) ) goto VAR_224 ; METHOD_23 ( VAR_225 , VAR_226 ) ; } } METHOD_24 ( VAR_227 ) ; VAR_228 = VAR_229 ; } } } else { METHOD_25 ( VAR_230 , VAR_231 , VAR_232 , VAR_233 ) ; VAR_234 += VAR_235 ; if ( VAR_236 > VAR_237 - VAR_238 ) { METHOD_26 ( VAR_239 , VAR_240 ) ; } } if ( VAR_241 < VAR_242 ) VAR_243 = METHOD_27 ( VAR_244 , VAR_245 ) ; else VAR_246 = 0 ; } VAR_247 [ VAR_248 ] = 0 ; return ( VAR_249 ) ; VAR_250 : METHOD_28 ( VAR_251 , VAR_252 ) ; VAR_253 : if ( VAR_254 != VAR_255 ) METHOD_29 ( VAR_256 ) ; if ( VAR_257 != VAR_258 ) METHOD_30 ( VAR_259 ) ; return ( VAR_260 ) ; }","<S2SV_ModStart> ( VAR_259 , VAR_168 +","CWE-119 xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , ""pred<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n"" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }","<S2SV_ModStart> ( buffer , i +"
26,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , const TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; TYPE_7 VAR_6 = VAR_7 ; TYPE_8 VAR_8 ; if VAR_9 TYPE_9 VAR_10 = ( VAR_11 & VAR_12 ) ; TYPE_10 VAR_13 = ( VAR_14 & VAR_15 ) ; TYPE_11 VAR_16 = 0 ; METHOD_1 ( & VAR_17 , '\\0' , sizeof ( VAR_18 ) ) ; METHOD_2 ( & VAR_19 , '\\0' , sizeof ( VAR_20 ) ) ; VAR_21 = 0 ; while ( ( VAR_22 == 0 ) && ( 0 < VAR_23 ) && ( ( unsigned TYPE_12 ) VAR_24 > sizeof ( VAR_25 ) ) ) { TYPE_13 VAR_26 ; TYPE_14 VAR_27 ; METHOD_3 ( ( TYPE_15 * ) & VAR_28 , ( TYPE_16 * ) VAR_29 , sizeof ( VAR_30 ) ) ; METHOD_4 ( ( TYPE_17 * ) & VAR_31 , ( TYPE_18 * ) ( VAR_32 + sizeof ( VAR_33 ) ) , sizeof ( VAR_34 ) ) ; VAR_35 = METHOD_5 ( VAR_36 ) ; VAR_37 = METHOD_6 ( VAR_38 ) ; if ( VAR_39 > VAR_40 ) break ; if ( VAR_41 < ( 2 * sizeof ( TYPE_19 ) ) ) break ; if ( VAR_42 == VAR_43 ) { VAR_44 = METHOD_7 ( VAR_45 , & VAR_46 , & VAR_47 , VAR_48 ) ; if ( VAR_49 != 0 ) { METHOD_8 ( ""network<S2SV_blank>plugin:<S2SV_blank>Decrypting<S2SV_blank>AES256<S2SV_blank>"" ""part<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , VAR_50 ) ; break ; } } if VAR_51 else if ( ( VAR_52 -> VAR_53 . VAR_54 . VAR_55 == VAR_56 ) && ( VAR_57 == 0 ) ) { if ( VAR_58 == 0 ) { METHOD_9 ( ""network<S2SV_blank>plugin:<S2SV_blank>Unencrypted<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; VAR_59 = 1 ; } VAR_60 = ( ( TYPE_20 * ) VAR_61 ) + VAR_62 ; <S2SV_StartBug> continue ; <S2SV_EndBug> } else if ( VAR_63 == VAR_64 ) { VAR_65 = METHOD_10 ( VAR_66 , & VAR_67 , & VAR_68 , VAR_69 ) ; if ( VAR_70 != 0 ) { METHOD_11 ( ""network<S2SV_blank>plugin:<S2SV_blank>Verifying<S2SV_blank>HMAC-SHA-256<S2SV_blank>"" ""signature<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , VAR_71 ) ; break ; } } if VAR_72 else if ( ( VAR_73 -> VAR_74 . VAR_75 . VAR_76 == VAR_77 ) && ( VAR_78 == 0 ) && ( VAR_79 == 0 ) ) { if ( VAR_80 == 0 ) { METHOD_12 ( ""network<S2SV_blank>plugin:<S2SV_blank>Unsigned<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; VAR_81 = 1 ; } VAR_82 = ( ( TYPE_21 * ) VAR_83 ) + VAR_84 ; <S2SV_StartBug> continue ; <S2SV_EndBug> } else if ( VAR_85 == VAR_86 ) { VAR_87 = METHOD_13 ( & VAR_88 , & VAR_89 , & VAR_90 . VAR_91 , & VAR_92 . VAR_93 ) ; if ( VAR_94 != 0 ) break ; METHOD_14 ( & VAR_95 , VAR_96 ) ; METHOD_15 ( VAR_97 . VAR_98 ) ; } else if ( VAR_99 == VAR_100 ) { TYPE_22 VAR_101 = 0 ; VAR_102 = METHOD_16 ( & VAR_103 , & VAR_104 , & VAR_105 ) ; if ( VAR_106 == 0 ) { VAR_107 . VAR_108 = METHOD_17 ( VAR_109 ) ; VAR_110 . VAR_111 = METHOD_18 ( VAR_112 ) ; } } else if ( VAR_113 == VAR_114 ) { TYPE_23 VAR_115 = 0 ; VAR_116 = METHOD_19 ( & VAR_117 , & VAR_118 , & VAR_119 ) ; if ( VAR_120 == 0 ) { VAR_121 . VAR_122 = ( TYPE_24 ) VAR_123 ; VAR_124 . VAR_125 = ( TYPE_25 ) VAR_126 ; } } else if ( VAR_127 == VAR_128 ) { TYPE_26 VAR_129 = 0 ; VAR_130 = METHOD_20 ( & VAR_131 , & VAR_132 , & VAR_133 ) ; if ( VAR_134 == 0 ) VAR_135 . VAR_136 = METHOD_21 ( VAR_137 ) ; } else if ( VAR_138 == VAR_139 ) { TYPE_27 VAR_140 = 0 ; VAR_141 = METHOD_22 ( & VAR_142 , & VAR_143 , & VAR_144 ) ; if ( VAR_145 == 0 ) VAR_146 . VAR_147 = ( TYPE_28 ) VAR_148 ; } else if ( VAR_149 == VAR_150 ) { VAR_151 = METHOD_23 ( & VAR_152 , & VAR_153 , VAR_154 . VAR_155 , sizeof ( VAR_156 . VAR_157 ) ) ; if ( VAR_158 == 0 ) METHOD_24 ( VAR_159 . VAR_160 , VAR_161 . VAR_162 , sizeof ( VAR_163 . VAR_164 ) ) ; } else if ( VAR_165 == VAR_166 ) { VAR_167 = METHOD_25 ( & VAR_168 , & VAR_169 , VAR_170 . VAR_171 , sizeof ( VAR_172 . VAR_173 ) ) ; if ( VAR_174 == 0 ) METHOD_26 ( VAR_175 . VAR_176 , VAR_177 . VAR_178 , sizeof ( VAR_179 . VAR_180 ) ) ; } else if ( VAR_181 == VAR_182 ) { VAR_183 = METHOD_27 ( & VAR_184 , & VAR_185 , VAR_186 . VAR_187 , sizeof ( VAR_188 . VAR_189 ) ) ; if ( VAR_190 == 0 ) METHOD_28 ( VAR_191 . VAR_192 , VAR_193 . VAR_194 , sizeof ( VAR_195 . VAR_196 ) ) ; } else if ( VAR_197 == VAR_198 ) { VAR_199 = METHOD_29 ( & VAR_200 , & VAR_201 , VAR_202 . VAR_203 , sizeof ( VAR_204 . VAR_205 ) ) ; if ( VAR_206 == 0 ) METHOD_30 ( VAR_207 . VAR_208 , VAR_209 . VAR_210 , sizeof ( VAR_211 . VAR_212 ) ) ; } else if ( VAR_213 == VAR_214 ) { VAR_215 = METHOD_31 ( & VAR_216 , & VAR_217 , VAR_218 . VAR_219 , sizeof ( VAR_220 . VAR_221 ) ) ; if ( VAR_222 == 0 ) METHOD_32 ( VAR_223 . VAR_224 , VAR_225 . VAR_226 , sizeof ( VAR_227 . VAR_228 ) ) ; } else if ( VAR_229 == VAR_230 ) { VAR_231 = METHOD_33 ( & VAR_232 , & VAR_233 , VAR_234 . VAR_235 , sizeof ( VAR_236 . VAR_237 ) ) ; if ( VAR_238 != 0 ) { } else if ( ( VAR_239 . VAR_240 != VAR_241 ) && ( VAR_242 . VAR_243 != VAR_244 ) && ( VAR_245 . VAR_246 != VAR_247 ) ) { METHOD_34 ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>severity<S2SV_blank>%i."" , VAR_248 . VAR_249 ) ; } else if ( VAR_250 . VAR_251 <= 0 ) { METHOD_35 ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""time<S2SV_blank>==<S2SV_blank>0."" ) ; } else if ( METHOD_36 ( VAR_252 . VAR_253 ) <= 0 ) { METHOD_37 ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>empty<S2SV_blank>message."" ) ; } else { METHOD_38 ( & VAR_254 ) ; } } else if ( VAR_255 == VAR_256 ) { TYPE_29 VAR_257 = 0 ; VAR_258 = METHOD_39 ( & VAR_259 , & VAR_260 , & VAR_261 ) ; if ( VAR_262 == 0 ) VAR_263 . VAR_264 = ( TYPE_30 ) VAR_265 ; } else { METHOD_40 ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Unknown<S2SV_blank>part"" ""<S2SV_blank>type:<S2SV_blank>0x%04hx"" , VAR_266 ) ; VAR_267 = ( ( TYPE_31 * ) VAR_268 ) + VAR_269 ; <S2SV_StartBug> } <S2SV_EndBug> } if ( VAR_270 == 0 && VAR_271 > 0 ) METHOD_41 ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>"" ""packet,<S2SV_blank>try<S2SV_blank>increasing<S2SV_blank>`MaxPacketSize\'"" ) ; return ( VAR_272 ) ; }",<S2SV_ModStart> + VAR_269 ; VAR_271 -= ( TYPE_3 ) VAR_269 ; <S2SV_ModStart> + VAR_269 ; VAR_271 -= ( TYPE_3 ) VAR_269 ; <S2SV_ModStart> + VAR_269 ; VAR_271 -= ( TYPE_3 ) VAR_269 ;,"CWE-119 static int parse_packet ( sockent_t * se , void * buffer , size_t buffer_size , int flags , const char * username ) { int status ; value_list_t vl = VALUE_LIST_INIT ; notification_t n ;  if HAVE_LIBGCRYPT int packet_was_signed = ( flags & PP_SIGNED ) ; int packet_was_encrypted = ( flags & PP_ENCRYPTED ) ; int printed_ignore_warning = 0 ;   memset ( & vl , '\\0' , sizeof ( vl ) ) ; memset ( & n , '\\0' , sizeof ( n ) ) ; status = 0 ; while ( ( status == 0 ) && ( 0 < buffer_size ) && ( ( unsigned int ) buffer_size > sizeof ( part_header_t ) ) ) { uint16_t pkg_length ; uint16_t pkg_type ; memcpy ( ( void * ) & pkg_type , ( void * ) buffer , sizeof ( pkg_type ) ) ; memcpy ( ( void * ) & pkg_length , ( void * ) ( buffer + sizeof ( pkg_type ) ) , sizeof ( pkg_length ) ) ; pkg_length = ntohs ( pkg_length ) ; pkg_type = ntohs ( pkg_type ) ; if ( pkg_length > buffer_size ) break ; if ( pkg_length < ( 2 * sizeof ( uint16_t ) ) ) break ; if ( pkg_type == TYPE_ENCR_AES256 ) { status = parse_part_encr_aes256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Decrypting<S2SV_blank>AES256<S2SV_blank>"" ""part<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } }  if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_ENCRYPT ) && ( packet_was_encrypted == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unencrypted<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ; <S2SV_StartBug> continue ; <S2SV_EndBug> }   else if ( pkg_type == TYPE_SIGN_SHA256 ) { status = parse_part_sign_sha256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( ""network<S2SV_blank>plugin:<S2SV_blank>Verifying<S2SV_blank>HMAC-SHA-256<S2SV_blank>"" ""signature<S2SV_blank>failed<S2SV_blank>"" ""with<S2SV_blank>status<S2SV_blank>%i."" , status ) ; break ; } }  if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_SIGN ) && ( packet_was_encrypted == 0 ) && ( packet_was_signed == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>Unsigned<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>"" ""part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored."" ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ; <S2SV_StartBug> continue ; <S2SV_EndBug> }   else if ( pkg_type == TYPE_VALUES ) { status = parse_part_values ( & buffer , & buffer_size , & vl . values , & vl . values_len ) ; if ( status != 0 ) break ; network_dispatch_values ( & vl , username ) ; sfree ( vl . values ) ; } else if ( pkg_type == TYPE_TIME ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = TIME_T_TO_CDTIME_T ( tmp ) ; n . time = TIME_T_TO_CDTIME_T ( tmp ) ; } } else if ( pkg_type == TYPE_TIME_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = ( cdtime_t ) tmp ; n . time = ( cdtime_t ) tmp ; } } else if ( pkg_type == TYPE_INTERVAL ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = TIME_T_TO_CDTIME_T ( tmp ) ; } else if ( pkg_type == TYPE_INTERVAL_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = ( cdtime_t ) tmp ; } else if ( pkg_type == TYPE_HOST ) { status = parse_part_string ( & buffer , & buffer_size , vl . host , sizeof ( vl . host ) ) ; if ( status == 0 ) sstrncpy ( n . host , vl . host , sizeof ( n . host ) ) ; } else if ( pkg_type == TYPE_PLUGIN ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin , sizeof ( vl . plugin ) ) ; if ( status == 0 ) sstrncpy ( n . plugin , vl . plugin , sizeof ( n . plugin ) ) ; } else if ( pkg_type == TYPE_PLUGIN_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin_instance , sizeof ( vl . plugin_instance ) ) ; if ( status == 0 ) sstrncpy ( n . plugin_instance , vl . plugin_instance , sizeof ( n . plugin_instance ) ) ; } else if ( pkg_type == TYPE_TYPE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type , sizeof ( vl . type ) ) ; if ( status == 0 ) sstrncpy ( n . type , vl . type , sizeof ( n . type ) ) ; } else if ( pkg_type == TYPE_TYPE_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type_instance , sizeof ( vl . type_instance ) ) ; if ( status == 0 ) sstrncpy ( n . type_instance , vl . type_instance , sizeof ( n . type_instance ) ) ; } else if ( pkg_type == TYPE_MESSAGE ) { status = parse_part_string ( & buffer , & buffer_size , n . message , sizeof ( n . message ) ) ; if ( status != 0 ) { } else if ( ( n . severity != NOTIF_FAILURE ) && ( n . severity != NOTIF_WARNING ) && ( n . severity != NOTIF_OKAY ) ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>severity<S2SV_blank>%i."" , n . severity ) ; } else if ( n . time <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""time<S2SV_blank>==<S2SV_blank>0."" ) ; } else if ( strlen ( n . message ) <= 0 ) { INFO ( ""network<S2SV_blank>plugin:<S2SV_blank>"" ""Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>empty<S2SV_blank>message."" ) ; } else { network_dispatch_notification ( & n ) ; } } else if ( pkg_type == TYPE_SEVERITY ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) n . severity = ( int ) tmp ; } else { DEBUG ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Unknown<S2SV_blank>part"" ""<S2SV_blank>type:<S2SV_blank>0x%04hx"" , pkg_type ) ; buffer = ( ( char * ) buffer ) + pkg_length ; <S2SV_StartBug> } <S2SV_EndBug> } if ( status == 0 && buffer_size > 0 ) WARNING ( ""network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>"" ""packet,<S2SV_blank>try<S2SV_blank>increasing<S2SV_blank>`MaxPacketSize\'"" ) ; return ( status ) ; }",<S2SV_ModStart> + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> + pkg_length ; buffer_size -= ( size_t ) pkg_length ;
27,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , unsigned TYPE_1 VAR_2 ) { struct STRUCT_OR_UNION_4 * VAR_3 = METHOD_1 ( VAR_4 ) ; struct STRUCT_OR_UNION_5 * VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 ; struct STRUCT_OR_UNION_7 VAR_7 ; TYPE_2 VAR_8 ; VAR_9 = VAR_10 & METHOD_2 ( VAR_11 ) ; VAR_12 = METHOD_3 ( VAR_13 , VAR_14 , VAR_15 ) ; <S2SV_StartBug> VAR_16 = ( struct STRUCT_OR_UNION_8 * ) METHOD_4 ( STRUCT_OR_UNION_9 ) ; <S2SV_EndBug> METHOD_5 ( & VAR_17 -> VAR_18 ) ; METHOD_6 ( VAR_19 , & VAR_20 , & VAR_21 -> VAR_22 , VAR_23 , VAR_24 ) { if ( VAR_25 == VAR_26 ) continue ; if ( ! METHOD_7 ( VAR_27 , VAR_28 ) ) METHOD_8 ( VAR_29 , VAR_30 , VAR_31 + METHOD_9 ( VAR_32 ) , STRUCT_OR_UNION_10 ) ; } METHOD_10 ( & VAR_33 -> VAR_34 ) ; return 1 ; }",<S2SV_ModStart> ; VAR_33 = VAR_26 -> VAR_35 -> VAR_36 -> VAR_37 -> VAR_38 <S2SV_ModEnd> ; METHOD_5 (,"CWE-399 static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; <S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }",<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
28,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_EndBug> TYPE_2 VAR_1 [ 8 ] , VAR_2 [ 8 ] , VAR_3 [ 8 ] , VAR_4 [ 8 ] , VAR_5 [ 16 ] , VAR_6 [ 16 ] ; <S2SV_StartBug> const TYPE_3 VAR_7 = METHOD_1 ( VAR_8 ) ; <S2SV_EndBug> const TYPE_4 VAR_9 = METHOD_2 ( VAR_10 , - VAR_11 ) ; const TYPE_5 VAR_12 = METHOD_3 ( - VAR_13 , VAR_14 ) ; const TYPE_6 VAR_15 = METHOD_4 ( VAR_16 , VAR_17 ) ; <S2SV_StartBug> const TYPE_7 VAR_18 = METHOD_5 ( - VAR_19 , - VAR_20 ) ; <S2SV_EndBug> const TYPE_8 VAR_21 = METHOD_6 ( - VAR_22 , VAR_23 ) ; const TYPE_9 VAR_24 = METHOD_7 ( VAR_25 , VAR_26 ) ; const TYPE_10 VAR_27 = METHOD_8 ( - VAR_28 , VAR_29 ) ; const TYPE_11 VAR_30 = METHOD_9 ( VAR_31 , VAR_32 ) ; const TYPE_12 VAR_33 = METHOD_10 ( - VAR_34 , VAR_35 ) ; const TYPE_13 VAR_36 = METHOD_11 ( VAR_37 , VAR_38 ) ; const TYPE_14 VAR_39 = METHOD_12 ( VAR_40 , VAR_41 ) ; const TYPE_15 VAR_42 = METHOD_13 ( - VAR_43 , VAR_44 ) ; const TYPE_16 VAR_45 = METHOD_14 ( - VAR_46 , VAR_47 ) ; const TYPE_17 VAR_48 = METHOD_15 ( VAR_49 , VAR_50 ) ; const TYPE_18 VAR_51 = METHOD_16 ( VAR_52 , VAR_53 ) ; const TYPE_19 VAR_54 = METHOD_17 ( - VAR_55 , VAR_56 ) ; const TYPE_20 VAR_57 = METHOD_18 ( - VAR_58 , VAR_59 ) ; const TYPE_21 VAR_60 = METHOD_19 ( VAR_61 ) ; VAR_62 [ 0 ] = METHOD_20 ( VAR_63 [ 0 ] , VAR_64 [ 15 ] ) ; VAR_65 [ 1 ] = METHOD_21 ( VAR_66 [ 1 ] , VAR_67 [ 14 ] ) ; VAR_68 [ 2 ] = METHOD_22 ( VAR_69 [ 2 ] , VAR_70 [ 13 ] ) ; VAR_71 [ 3 ] = METHOD_23 ( VAR_72 [ 3 ] , VAR_73 [ 12 ] ) ; VAR_74 [ 4 ] = METHOD_24 ( VAR_75 [ 4 ] , VAR_76 [ 11 ] ) ; VAR_77 [ 5 ] = METHOD_25 ( VAR_78 [ 5 ] , VAR_79 [ 10 ] ) ; VAR_80 [ 6 ] = METHOD_26 ( VAR_81 [ 6 ] , VAR_82 [ 9 ] ) ; VAR_83 [ 7 ] = METHOD_27 ( VAR_84 [ 7 ] , VAR_85 [ 8 ] ) ; VAR_86 [ 0 ] = METHOD_28 ( VAR_87 [ 7 ] , VAR_88 [ 8 ] ) ; VAR_89 [ 1 ] = METHOD_29 ( VAR_90 [ 6 ] , VAR_91 [ 9 ] ) ; VAR_92 [ 2 ] = METHOD_30 ( VAR_93 [ 5 ] , VAR_94 [ 10 ] ) ; VAR_95 [ 3 ] = METHOD_31 ( VAR_96 [ 4 ] , VAR_97 [ 11 ] ) ; VAR_98 [ 4 ] = METHOD_32 ( VAR_99 [ 3 ] , VAR_100 [ 12 ] ) ; VAR_101 [ 5 ] = METHOD_33 ( VAR_102 [ 2 ] , VAR_103 [ 13 ] ) ; VAR_104 [ 6 ] = METHOD_34 ( VAR_105 [ 1 ] , VAR_106 [ 14 ] ) ; VAR_107 [ 7 ] = METHOD_35 ( VAR_108 [ 0 ] , VAR_109 [ 15 ] ) ; VAR_110 [ 0 ] = METHOD_36 ( VAR_111 [ 0 ] , VAR_112 [ 7 ] ) ; VAR_113 [ 1 ] = METHOD_37 ( VAR_114 [ 1 ] , VAR_115 [ 6 ] ) ; VAR_116 [ 2 ] = METHOD_38 ( VAR_117 [ 2 ] , VAR_118 [ 5 ] ) ; VAR_119 [ 3 ] = METHOD_39 ( VAR_120 [ 3 ] , VAR_121 [ 4 ] ) ; VAR_122 [ 4 ] = METHOD_40 ( VAR_123 [ 3 ] , VAR_124 [ 4 ] ) ; VAR_125 [ 5 ] = METHOD_41 ( VAR_126 [ 2 ] , VAR_127 [ 5 ] ) ; VAR_128 [ 6 ] = METHOD_42 ( VAR_129 [ 1 ] , VAR_130 [ 6 ] ) ; VAR_131 [ 7 ] = METHOD_43 ( VAR_132 [ 0 ] , VAR_133 [ 7 ] ) ; VAR_134 [ 0 ] = METHOD_44 ( VAR_135 [ 0 ] , VAR_136 [ 3 ] ) ; VAR_137 [ 1 ] = METHOD_45 ( VAR_138 [ 1 ] , VAR_139 [ 2 ] ) ; VAR_140 [ 2 ] = METHOD_46 ( VAR_141 [ 1 ] , VAR_142 [ 2 ] ) ; VAR_143 [ 3 ] = METHOD_47 ( VAR_144 [ 0 ] , VAR_145 [ 3 ] ) ; VAR_146 [ 0 ] = METHOD_48 ( VAR_147 [ 0 ] , VAR_148 [ 1 ] ) ; VAR_149 [ 1 ] = METHOD_49 ( VAR_150 [ 0 ] , VAR_151 [ 1 ] ) ; VAR_152 [ 2 ] = METHOD_50 ( VAR_153 [ 2 ] , VAR_154 [ 3 ] ) ; VAR_155 [ 3 ] = METHOD_51 ( VAR_156 [ 2 ] , VAR_157 [ 3 ] ) ; VAR_158 [ 0 ] = METHOD_52 ( VAR_159 [ 0 ] , VAR_160 ) ; VAR_161 [ 1 ] = METHOD_53 ( VAR_162 [ 1 ] , VAR_163 ) ; VAR_164 [ 2 ] = METHOD_54 ( VAR_165 [ 0 ] , VAR_166 ) ; VAR_167 [ 3 ] = METHOD_55 ( VAR_168 [ 1 ] , VAR_169 ) ; VAR_170 [ 4 ] = METHOD_56 ( VAR_171 [ 2 ] , VAR_172 ) ; VAR_173 [ 5 ] = METHOD_57 ( VAR_174 [ 3 ] , VAR_175 ) ; VAR_176 [ 6 ] = METHOD_58 ( VAR_177 [ 2 ] , VAR_178 ) ; VAR_179 [ 7 ] = METHOD_59 ( VAR_180 [ 3 ] , VAR_181 ) ; VAR_182 [ 0 ] = METHOD_60 ( VAR_183 [ 0 ] , VAR_184 ) ; VAR_185 [ 1 ] = METHOD_61 ( VAR_186 [ 1 ] , VAR_187 ) ; VAR_188 [ 2 ] = METHOD_62 ( VAR_189 [ 2 ] , VAR_190 ) ; VAR_191 [ 3 ] = METHOD_63 ( VAR_192 [ 3 ] , VAR_193 ) ; VAR_194 [ 4 ] = METHOD_64 ( VAR_195 [ 4 ] , VAR_196 ) ; VAR_197 [ 5 ] = METHOD_65 ( VAR_198 [ 5 ] , VAR_199 ) ; VAR_200 [ 6 ] = METHOD_66 ( VAR_201 [ 6 ] , VAR_202 ) ; VAR_203 [ 7 ] = METHOD_67 ( VAR_204 [ 7 ] , VAR_205 ) ; VAR_206 [ 0 ] = METHOD_68 ( VAR_207 [ 0 ] , VAR_208 ) ; VAR_209 [ 1 ] = METHOD_69 ( VAR_210 [ 1 ] , VAR_211 ) ; VAR_212 [ 2 ] = METHOD_70 ( VAR_213 [ 2 ] , VAR_214 ) ; VAR_215 [ 3 ] = METHOD_71 ( VAR_216 [ 3 ] , VAR_217 ) ; VAR_218 [ 4 ] = METHOD_72 ( VAR_219 [ 4 ] , VAR_220 ) ; VAR_221 [ 5 ] = METHOD_73 ( VAR_222 [ 5 ] , VAR_223 ) ; VAR_224 [ 6 ] = METHOD_74 ( VAR_225 [ 6 ] , VAR_226 ) ; VAR_227 [ 7 ] = METHOD_75 ( VAR_228 [ 7 ] , VAR_229 ) ; VAR_230 [ 0 ] = METHOD_76 ( VAR_231 [ 0 ] , VAR_232 [ 1 ] ) ; VAR_233 [ 4 ] = METHOD_77 ( VAR_234 [ 4 ] , VAR_235 [ 5 ] ) ; VAR_236 [ 8 ] = METHOD_78 ( VAR_237 [ 2 ] , VAR_238 [ 3 ] ) ; VAR_239 [ 12 ] = METHOD_79 ( VAR_240 [ 6 ] , VAR_241 [ 7 ] ) ; VAR_242 [ 0 ] = METHOD_80 ( VAR_243 [ 5 ] , VAR_244 [ 6 ] ) ; VAR_245 [ 1 ] = METHOD_81 ( VAR_246 [ 5 ] , VAR_247 [ 6 ] ) ; VAR_248 [ 0 ] = METHOD_82 ( VAR_249 [ 0 ] , VAR_250 ) ; VAR_251 [ 1 ] = METHOD_83 ( VAR_252 [ 1 ] , VAR_253 ) ; VAR_254 [ 2 ] = METHOD_84 ( VAR_255 [ 0 ] , VAR_256 ) ; VAR_257 [ 3 ] = METHOD_85 ( VAR_258 [ 1 ] , VAR_259 ) ; VAR_260 [ 0 ] = METHOD_86 ( VAR_261 [ 0 ] , VAR_262 ) ; VAR_263 [ 1 ] = METHOD_87 ( VAR_264 [ 1 ] , VAR_265 ) ; VAR_266 [ 2 ] = METHOD_88 ( VAR_267 [ 2 ] , VAR_268 ) ; VAR_269 [ 3 ] = METHOD_89 ( VAR_270 [ 3 ] , VAR_271 ) ; VAR_272 [ 0 ] = METHOD_90 ( VAR_273 [ 0 ] , VAR_274 ) ; VAR_275 [ 1 ] = METHOD_91 ( VAR_276 [ 1 ] , VAR_277 ) ; VAR_278 [ 2 ] = METHOD_92 ( VAR_279 [ 2 ] , VAR_280 ) ; VAR_281 [ 3 ] = METHOD_93 ( VAR_282 [ 3 ] , VAR_283 ) ; VAR_284 [ 0 ] = METHOD_94 ( VAR_285 [ 0 ] , VAR_286 [ 1 ] ) ; VAR_287 [ 1 ] = METHOD_95 ( VAR_288 [ 2 ] , VAR_289 [ 3 ] ) ; VAR_290 [ 0 ] = METHOD_96 ( VAR_291 [ 4 ] , VAR_292 [ 0 ] ) ; VAR_293 [ 1 ] = METHOD_97 ( VAR_294 [ 4 ] , VAR_295 [ 0 ] ) ; VAR_296 [ 2 ] = METHOD_98 ( VAR_297 [ 7 ] , VAR_298 [ 1 ] ) ; VAR_299 [ 3 ] = METHOD_99 ( VAR_300 [ 7 ] , VAR_301 [ 1 ] ) ; VAR_302 [ 0 ] = METHOD_100 ( VAR_303 [ 0 ] , VAR_304 [ 3 ] ) ; VAR_305 [ 1 ] = METHOD_101 ( VAR_306 [ 0 ] , VAR_307 [ 3 ] ) ; VAR_308 [ 2 ] = METHOD_102 ( VAR_309 [ 1 ] , VAR_310 [ 2 ] ) ; VAR_311 [ 3 ] = METHOD_103 ( VAR_312 [ 1 ] , VAR_313 [ 2 ] ) ; VAR_314 [ 0 ] = METHOD_104 ( VAR_315 [ 0 ] , VAR_316 ) ; VAR_317 [ 1 ] = METHOD_105 ( VAR_318 [ 1 ] , VAR_319 ) ; VAR_320 [ 2 ] = METHOD_106 ( VAR_321 [ 2 ] , VAR_322 ) ; VAR_323 [ 3 ] = METHOD_107 ( VAR_324 [ 3 ] , VAR_325 ) ; VAR_326 [ 4 ] = METHOD_108 ( VAR_327 [ 2 ] , VAR_328 ) ; VAR_329 [ 5 ] = METHOD_109 ( VAR_330 [ 3 ] , VAR_331 ) ; VAR_332 [ 6 ] = METHOD_110 ( VAR_333 [ 0 ] , VAR_334 ) ; VAR_335 [ 7 ] = METHOD_111 ( VAR_336 [ 1 ] , VAR_337 ) ; VAR_338 [ 0 ] = METHOD_112 ( VAR_339 [ 0 ] , VAR_340 ) ; VAR_341 [ 1 ] = METHOD_113 ( VAR_342 [ 1 ] , VAR_343 ) ; VAR_344 [ 2 ] = METHOD_114 ( VAR_345 [ 2 ] , VAR_346 ) ; VAR_347 [ 3 ] = METHOD_115 ( VAR_348 [ 3 ] , VAR_349 ) ; VAR_350 [ 4 ] = METHOD_116 ( VAR_351 [ 4 ] , VAR_352 ) ; VAR_353 [ 5 ] = METHOD_117 ( VAR_354 [ 5 ] , VAR_355 ) ; VAR_356 [ 6 ] = METHOD_118 ( VAR_357 [ 6 ] , VAR_358 ) ; VAR_359 [ 7 ] = METHOD_119 ( VAR_360 [ 7 ] , VAR_361 ) ; VAR_362 [ 0 ] = METHOD_120 ( VAR_363 [ 0 ] , VAR_364 ) ; VAR_365 [ 1 ] = METHOD_121 ( VAR_366 [ 1 ] , VAR_367 ) ; VAR_368 [ 2 ] = METHOD_122 ( VAR_369 [ 2 ] , VAR_370 ) ; VAR_371 [ 3 ] = METHOD_123 ( VAR_372 [ 3 ] , VAR_373 ) ; VAR_374 [ 4 ] = METHOD_124 ( VAR_375 [ 4 ] , VAR_376 ) ; VAR_377 [ 5 ] = METHOD_125 ( VAR_378 [ 5 ] , VAR_379 ) ; VAR_380 [ 6 ] = METHOD_126 ( VAR_381 [ 6 ] , VAR_382 ) ; VAR_383 [ 7 ] = METHOD_127 ( VAR_384 [ 7 ] , VAR_385 ) ; VAR_386 [ 2 ] = METHOD_128 ( VAR_387 [ 0 ] , VAR_388 [ 1 ] ) ; VAR_389 [ 6 ] = METHOD_129 ( VAR_390 [ 4 ] , VAR_391 [ 5 ] ) ; VAR_392 [ 10 ] = METHOD_130 ( VAR_393 [ 2 ] , VAR_394 [ 3 ] ) ; VAR_395 [ 14 ] = METHOD_131 ( VAR_396 [ 6 ] , VAR_397 [ 7 ] ) ; VAR_398 [ 0 ] = METHOD_132 ( VAR_399 [ 2 ] , VAR_400 [ 5 ] ) ; VAR_401 [ 1 ] = METHOD_133 ( VAR_402 [ 2 ] , VAR_403 [ 5 ] ) ; VAR_404 [ 2 ] = METHOD_134 ( VAR_405 [ 3 ] , VAR_406 [ 4 ] ) ; VAR_407 [ 3 ] = METHOD_135 ( VAR_408 [ 3 ] , VAR_409 [ 4 ] ) ; VAR_410 [ 0 ] = METHOD_136 ( VAR_411 [ 0 ] , VAR_412 ) ; VAR_413 [ 1 ] = METHOD_137 ( VAR_414 [ 1 ] , VAR_415 ) ; VAR_416 [ 2 ] = METHOD_138 ( VAR_417 [ 2 ] , VAR_418 ) ; VAR_419 [ 3 ] = METHOD_139 ( VAR_420 [ 3 ] , VAR_421 ) ; VAR_422 [ 4 ] = METHOD_140 ( VAR_423 [ 2 ] , VAR_424 ) ; VAR_425 [ 5 ] = METHOD_141 ( VAR_426 [ 3 ] , VAR_427 ) ; VAR_428 [ 6 ] = METHOD_142 ( VAR_429 [ 0 ] , VAR_430 ) ; VAR_431 [ 7 ] = METHOD_143 ( VAR_432 [ 1 ] , VAR_433 ) ; VAR_434 [ 0 ] = METHOD_144 ( VAR_435 [ 0 ] , VAR_436 ) ; VAR_437 [ 1 ] = METHOD_145 ( VAR_438 [ 1 ] , VAR_439 ) ; VAR_440 [ 2 ] = METHOD_146 ( VAR_441 [ 2 ] , VAR_442 ) ; VAR_443 [ 3 ] = METHOD_147 ( VAR_444 [ 3 ] , VAR_445 ) ; VAR_446 [ 4 ] = METHOD_148 ( VAR_447 [ 4 ] , VAR_448 ) ; VAR_449 [ 5 ] = METHOD_149 ( VAR_450 [ 5 ] , VAR_451 ) ; VAR_452 [ 6 ] = METHOD_150 ( VAR_453 [ 6 ] , VAR_454 ) ; VAR_455 [ 7 ] = METHOD_151 ( VAR_456 [ 7 ] , VAR_457 ) ; VAR_458 [ 0 ] = METHOD_152 ( VAR_459 [ 0 ] , VAR_460 ) ; VAR_461 [ 1 ] = METHOD_153 ( VAR_462 [ 1 ] , VAR_463 ) ; VAR_464 [ 2 ] = METHOD_154 ( VAR_465 [ 2 ] , VAR_466 ) ; VAR_467 [ 3 ] = METHOD_155 ( VAR_468 [ 3 ] , VAR_469 ) ; VAR_470 [ 4 ] = METHOD_156 ( VAR_471 [ 4 ] , VAR_472 ) ; VAR_473 [ 5 ] = METHOD_157 ( VAR_474 [ 5 ] , VAR_475 ) ; VAR_476 [ 6 ] = METHOD_158 ( VAR_477 [ 6 ] , VAR_478 ) ; VAR_479 [ 7 ] = METHOD_159 ( VAR_480 [ 7 ] , VAR_481 ) ; VAR_482 [ 2 ] = METHOD_160 ( VAR_483 [ 0 ] , VAR_484 [ 1 ] ) ; VAR_485 [ 3 ] = METHOD_161 ( VAR_486 [ 2 ] , VAR_487 [ 3 ] ) ; VAR_488 [ 4 ] = METHOD_162 ( VAR_489 [ 4 ] , VAR_490 [ 5 ] ) ; VAR_491 [ 5 ] = METHOD_163 ( VAR_492 [ 6 ] , VAR_493 [ 7 ] ) ; VAR_494 [ 0 ] = METHOD_164 ( VAR_495 [ 0 ] , VAR_496 [ 3 ] ) ; VAR_497 [ 1 ] = METHOD_165 ( VAR_498 [ 1 ] , VAR_499 [ 2 ] ) ; VAR_500 [ 2 ] = METHOD_166 ( VAR_501 [ 1 ] , VAR_502 [ 2 ] ) ; VAR_503 [ 3 ] = METHOD_167 ( VAR_504 [ 0 ] , VAR_505 [ 3 ] ) ; VAR_506 [ 4 ] = METHOD_168 ( VAR_507 [ 7 ] , VAR_508 [ 4 ] ) ; VAR_509 [ 5 ] = METHOD_169 ( VAR_510 [ 6 ] , VAR_511 [ 5 ] ) ; VAR_512 [ 6 ] = METHOD_170 ( VAR_513 [ 6 ] , VAR_514 [ 5 ] ) ; VAR_515 [ 7 ] = METHOD_171 ( VAR_516 [ 7 ] , VAR_517 [ 4 ] ) ; VAR_518 [ 0 ] = METHOD_172 ( VAR_519 [ 1 ] , VAR_520 [ 6 ] ) ; VAR_521 [ 1 ] = METHOD_173 ( VAR_522 [ 1 ] , VAR_523 [ 6 ] ) ; VAR_524 [ 2 ] = METHOD_174 ( VAR_525 [ 2 ] , VAR_526 [ 5 ] ) ; VAR_527 [ 3 ] = METHOD_175 ( VAR_528 [ 2 ] , VAR_529 [ 5 ] ) ; VAR_530 [ 0 ] = METHOD_176 ( VAR_531 [ 0 ] , VAR_532 ) ; VAR_533 [ 1 ] = METHOD_177 ( VAR_534 [ 1 ] , VAR_535 ) ; <S2SV_StartBug> VAR_536 [ 2 ] = METHOD_178 ( VAR_537 [ 2 ] , VAR_538 ) ; <S2SV_EndBug> VAR_539 [ 3 ] = METHOD_179 ( VAR_540 [ 3 ] , VAR_541 ) ; VAR_542 [ 4 ] = METHOD_180 ( VAR_543 [ 2 ] , VAR_544 ) ; VAR_545 [ 5 ] = METHOD_181 ( VAR_546 [ 3 ] , VAR_547 ) ; VAR_548 [ 6 ] = METHOD_182 ( VAR_549 [ 0 ] , VAR_550 ) ; <S2SV_StartBug> VAR_551 [ 7 ] = METHOD_183 ( VAR_552 [ 1 ] , VAR_553 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_554 [ 0 ] = METHOD_184 ( VAR_555 [ 0 ] , VAR_556 ) ; <S2SV_EndBug> VAR_557 [ 1 ] = METHOD_185 ( VAR_558 [ 1 ] , VAR_559 ) ; VAR_560 [ 2 ] = METHOD_186 ( VAR_561 [ 2 ] , VAR_562 ) ; VAR_563 [ 3 ] = METHOD_187 ( VAR_564 [ 3 ] , VAR_565 ) ; VAR_566 [ 4 ] = METHOD_188 ( VAR_567 [ 4 ] , VAR_568 ) ; VAR_569 [ 5 ] = METHOD_189 ( VAR_570 [ 5 ] , VAR_571 ) ; VAR_572 [ 6 ] = METHOD_190 ( VAR_573 [ 6 ] , VAR_574 ) ; VAR_575 [ 7 ] = METHOD_191 ( VAR_576 [ 7 ] , VAR_577 ) ; VAR_578 [ 0 ] = METHOD_192 ( VAR_579 [ 0 ] , VAR_580 ) ; VAR_581 [ 1 ] = METHOD_193 ( VAR_582 [ 1 ] , VAR_583 ) ; VAR_584 [ 2 ] = METHOD_194 ( VAR_585 [ 2 ] , VAR_586 ) ; VAR_587 [ 3 ] = METHOD_195 ( VAR_588 [ 3 ] , VAR_589 ) ; VAR_590 [ 4 ] = METHOD_196 ( VAR_591 [ 4 ] , VAR_592 ) ; VAR_593 [ 5 ] = METHOD_197 ( VAR_594 [ 5 ] , VAR_595 ) ; VAR_596 [ 6 ] = METHOD_198 ( VAR_597 [ 6 ] , VAR_598 ) ; VAR_599 [ 7 ] = METHOD_199 ( VAR_600 [ 7 ] , VAR_601 ) ; VAR_602 [ 1 ] = METHOD_200 ( VAR_603 [ 0 ] , VAR_604 [ 1 ] ) ; VAR_605 [ 2 ] = METHOD_201 ( VAR_606 [ 2 ] , VAR_607 [ 3 ] ) ; VAR_608 [ 5 ] = METHOD_202 ( VAR_609 [ 4 ] , VAR_610 [ 5 ] ) ; VAR_611 [ 6 ] = METHOD_203 ( VAR_612 [ 6 ] , VAR_613 [ 7 ] ) ; VAR_614 [ 0 ] = METHOD_204 ( VAR_615 [ 0 ] , VAR_616 [ 1 ] ) ; VAR_617 [ 1 ] = METHOD_205 ( VAR_618 [ 0 ] , VAR_619 [ 1 ] ) ; <S2SV_StartBug> VAR_620 [ 2 ] = METHOD_206 ( VAR_621 [ 3 ] , VAR_622 [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_623 [ 3 ] = METHOD_207 ( VAR_624 [ 3 ] , VAR_625 [ 2 ] ) ; <S2SV_EndBug> VAR_626 [ 4 ] = METHOD_208 ( VAR_627 [ 4 ] , VAR_628 [ 5 ] ) ; VAR_629 [ 5 ] = METHOD_209 ( VAR_630 [ 4 ] , VAR_631 [ 5 ] ) ; VAR_632 [ 6 ] = METHOD_210 ( VAR_633 [ 7 ] , VAR_634 [ 6 ] ) ; VAR_635 [ 7 ] = METHOD_211 ( VAR_636 [ 7 ] , VAR_637 [ 6 ] ) ; VAR_638 [ 0 ] = METHOD_212 ( VAR_639 [ 0 ] , VAR_640 [ 7 ] ) ; VAR_641 [ 1 ] = METHOD_213 ( VAR_642 [ 0 ] , VAR_643 [ 7 ] ) ; VAR_644 [ 2 ] = METHOD_214 ( VAR_645 [ 1 ] , VAR_646 [ 6 ] ) ; VAR_647 [ 3 ] = METHOD_215 ( VAR_648 [ 1 ] , VAR_649 [ 6 ] ) ; VAR_650 [ 4 ] = METHOD_216 ( VAR_651 [ 2 ] , VAR_652 [ 5 ] ) ; VAR_653 [ 5 ] = METHOD_217 ( VAR_654 [ 2 ] , VAR_655 [ 5 ] ) ; VAR_656 [ 6 ] = METHOD_218 ( VAR_657 [ 3 ] , VAR_658 [ 4 ] ) ; VAR_659 [ 7 ] = METHOD_219 ( VAR_660 [ 3 ] , VAR_661 [ 4 ] ) ; VAR_662 [ 0 ] = METHOD_220 ( VAR_663 [ 0 ] , VAR_664 ) ; VAR_665 [ 1 ] = METHOD_221 ( VAR_666 [ 1 ] , VAR_667 ) ; VAR_668 [ 2 ] = METHOD_222 ( VAR_669 [ 2 ] , VAR_670 ) ; VAR_671 [ 3 ] = METHOD_223 ( VAR_672 [ 3 ] , VAR_673 ) ; VAR_674 [ 4 ] = METHOD_224 ( VAR_675 [ 4 ] , VAR_676 ) ; VAR_677 [ 5 ] = METHOD_225 ( VAR_678 [ 5 ] , VAR_679 ) ; VAR_680 [ 6 ] = METHOD_226 ( VAR_681 [ 6 ] , VAR_682 ) ; VAR_683 [ 7 ] = METHOD_227 ( VAR_684 [ 7 ] , VAR_685 ) ; VAR_686 [ 8 ] = METHOD_228 ( VAR_687 [ 6 ] , VAR_688 ) ; VAR_689 [ 9 ] = METHOD_229 ( VAR_690 [ 7 ] , VAR_691 ) ; VAR_692 [ 10 ] = METHOD_230 ( VAR_693 [ 4 ] , VAR_694 ) ; VAR_695 [ 11 ] = METHOD_231 ( VAR_696 [ 5 ] , VAR_697 ) ; VAR_698 [ 12 ] = METHOD_232 ( VAR_699 [ 2 ] , VAR_700 ) ; VAR_701 [ 13 ] = METHOD_233 ( VAR_702 [ 3 ] , VAR_703 ) ; VAR_704 [ 14 ] = METHOD_234 ( VAR_705 [ 0 ] , VAR_706 ) ; VAR_707 [ 15 ] = METHOD_235 ( VAR_708 [ 1 ] , VAR_709 ) ; VAR_710 [ 0 ] = METHOD_236 ( VAR_711 [ 0 ] , VAR_712 ) ; VAR_713 [ 1 ] = METHOD_237 ( VAR_714 [ 1 ] , VAR_715 ) ; VAR_716 [ 2 ] = METHOD_238 ( VAR_717 [ 2 ] , VAR_718 ) ; VAR_719 [ 3 ] = METHOD_239 ( VAR_720 [ 3 ] , VAR_721 ) ; VAR_722 [ 4 ] = METHOD_240 ( VAR_723 [ 4 ] , VAR_724 ) ; VAR_725 [ 5 ] = METHOD_241 ( VAR_726 [ 5 ] , VAR_727 ) ; VAR_728 [ 6 ] = METHOD_242 ( VAR_729 [ 6 ] , VAR_730 ) ; VAR_731 [ 7 ] = METHOD_243 ( VAR_732 [ 7 ] , VAR_733 ) ; VAR_734 [ 8 ] = METHOD_244 ( VAR_735 [ 8 ] , VAR_736 ) ; VAR_737 [ 9 ] = METHOD_245 ( VAR_738 [ 9 ] , VAR_739 ) ; VAR_740 [ 10 ] = METHOD_246 ( VAR_741 [ 10 ] , VAR_742 ) ; VAR_743 [ 11 ] = METHOD_247 ( VAR_744 [ 11 ] , VAR_745 ) ; VAR_746 [ 12 ] = METHOD_248 ( VAR_747 [ 12 ] , VAR_748 ) ; VAR_749 [ 13 ] = METHOD_249 ( VAR_750 [ 13 ] , VAR_751 ) ; VAR_752 [ 14 ] = METHOD_250 ( VAR_753 [ 14 ] , VAR_754 ) ; VAR_755 [ 15 ] = METHOD_251 ( VAR_756 [ 15 ] , VAR_757 ) ; VAR_758 [ 0 ] = METHOD_252 ( VAR_759 [ 0 ] , VAR_760 ) ; VAR_761 [ 1 ] = METHOD_253 ( VAR_762 [ 1 ] , VAR_763 ) ; VAR_764 [ 2 ] = METHOD_254 ( VAR_765 [ 2 ] , VAR_766 ) ; VAR_767 [ 3 ] = METHOD_255 ( VAR_768 [ 3 ] , VAR_769 ) ; VAR_770 [ 4 ] = METHOD_256 ( VAR_771 [ 4 ] , VAR_772 ) ; VAR_773 [ 5 ] = METHOD_257 ( VAR_774 [ 5 ] , VAR_775 ) ; VAR_776 [ 6 ] = METHOD_258 ( VAR_777 [ 6 ] , VAR_778 ) ; VAR_779 [ 7 ] = METHOD_259 ( VAR_780 [ 7 ] , VAR_781 ) ; VAR_782 [ 8 ] = METHOD_260 ( VAR_783 [ 8 ] , VAR_784 ) ; VAR_785 [ 9 ] = METHOD_261 ( VAR_786 [ 9 ] , VAR_787 ) ; VAR_788 [ 10 ] = METHOD_262 ( VAR_789 [ 10 ] , VAR_790 ) ; VAR_791 [ 11 ] = METHOD_263 ( VAR_792 [ 11 ] , VAR_793 ) ; VAR_794 [ 12 ] = METHOD_264 ( VAR_795 [ 12 ] , VAR_796 ) ; VAR_797 [ 13 ] = METHOD_265 ( VAR_798 [ 13 ] , VAR_799 ) ; VAR_800 [ 14 ] = METHOD_266 ( VAR_801 [ 14 ] , VAR_802 ) ; VAR_803 [ 15 ] = METHOD_267 ( VAR_804 [ 15 ] , VAR_805 ) ; VAR_806 [ 1 ] = METHOD_268 ( VAR_807 [ 0 ] , VAR_808 [ 1 ] ) ; VAR_809 [ 9 ] = METHOD_269 ( VAR_810 [ 2 ] , VAR_811 [ 3 ] ) ; VAR_812 [ 5 ] = METHOD_270 ( VAR_813 [ 4 ] , VAR_814 [ 5 ] ) ; VAR_815 [ 13 ] = METHOD_271 ( VAR_816 [ 6 ] , VAR_817 [ 7 ] ) ; VAR_818 [ 3 ] = METHOD_272 ( VAR_819 [ 8 ] , VAR_820 [ 9 ] ) ; VAR_821 [ 11 ] = METHOD_273 ( VAR_822 [ 10 ] , VAR_823 [ 11 ] ) ; VAR_824 [ 7 ] = METHOD_274 ( VAR_825 [ 12 ] , VAR_826 [ 13 ] ) ; VAR_827 [ 15 ] = METHOD_275 ( VAR_828 [ 14 ] , VAR_829 [ 15 ] ) ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = METHOD_1 ( ( int16_t ) <S2SV_ModStart> ; const TYPE_21 VAR_830 <S2SV_ModEnd> = METHOD_18 ( <S2SV_ModStart> = METHOD_18 ( VAR_22 , - VAR_23 <S2SV_ModEnd> ) ; const <S2SV_ModStart> 2 ] , <S2SV_ModEnd> VAR_553 ) ; <S2SV_ModStart> ; VAR_829 [ 3 ] = METHOD_235 ( VAR_804 [ 3 <S2SV_ModEnd> ] , VAR_553 <S2SV_ModStart> VAR_553 ) ; VAR_829 [ 4 ] = METHOD_235 ( VAR_804 [ 2 ] , VAR_830 ) ; VAR_829 [ 5 ] = METHOD_235 ( VAR_804 [ 3 ] , VAR_830 ) ; VAR_829 [ 6 ] = METHOD_235 ( VAR_804 [ 0 ] , VAR_553 ) ; VAR_829 [ 7 ] = METHOD_235 ( VAR_804 [ 1 ] , VAR_553 ) ; <S2SV_ModStart> 2 ] = METHOD_211 ( VAR_636 [ 3 ] , VAR_637 [ 2 ] ) ; VAR_661 [ 3 ] = <S2SV_ModStart> ; VAR_661 [ 4 ] = METHOD_210 ( VAR_636 [ 4 ] , VAR_637 [ 5 ] ) ; VAR_661 [ 5 <S2SV_ModEnd> ] = METHOD_211 <S2SV_ModStart> ] = METHOD_211 <S2SV_ModEnd> ( VAR_636 [","CWE-119 <S2SV_StartBug> void fdct16_8col ( __m128i * in ) { <S2SV_EndBug> __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ; <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ; <S2SV_StartBug> const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ; <S2SV_EndBug> const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ; <S2SV_StartBug> v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ; <S2SV_EndBug> v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; <S2SV_StartBug> v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_EndBug> <S2SV_StartBug> u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; <S2SV_EndBug> u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ; <S2SV_StartBug> s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> ; const __m128i k__cospi_p08_m24 <S2SV_ModEnd> = pair_set_epi16 ( <S2SV_ModStart> = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 <S2SV_ModEnd> ) ; const <S2SV_ModStart> 2 ] , <S2SV_ModEnd> k__cospi_p24_p08 ) ; <S2SV_ModStart> ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 <S2SV_ModEnd> ] , k__cospi_p24_p08 <S2SV_ModStart> k__cospi_p24_p08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModStart> 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> ; s [ 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 <S2SV_ModEnd> ] = _mm_add_epi16 <S2SV_ModStart> ] = _mm_add_epi16 <S2SV_ModEnd> ( p ["
29,"CWE-835 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 VAR_4 ) { TYPE_6 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_7 * VAR_8 = VAR_9 -> VAR_10 ; TYPE_8 VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 ; TYPE_9 VAR_17 = VAR_18 , VAR_19 ; TYPE_10 VAR_20 ; VAR_21 : VAR_22 = METHOD_1 ( VAR_23 ) ; VAR_24 = METHOD_2 ( VAR_25 ) ; VAR_26 = METHOD_3 ( VAR_27 ) ; METHOD_4 ( VAR_28 ) ; VAR_29 = METHOD_5 ( VAR_30 ) ; VAR_31 = METHOD_6 ( VAR_32 ) ; VAR_33 = METHOD_7 ( VAR_34 ) ; VAR_35 = VAR_36 & 0x10 ; if ( VAR_37 != VAR_38 ) { METHOD_8 ( VAR_39 , VAR_40 , ""invalid<S2SV_blank>syncword\\n"" ) ; return METHOD_9 ( VAR_41 ) ; } if ( VAR_42 != VAR_43 && VAR_44 != VAR_45 ) { METHOD_10 ( VAR_46 , VAR_47 , ""invalid<S2SV_blank>streamid\\n"" ) ; return METHOD_11 ( VAR_48 ) ; } if ( VAR_49 != 0x55 ) { METHOD_12 ( VAR_50 , VAR_51 , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( VAR_52 > VAR_53 ) { METHOD_13 ( VAR_54 , VAR_55 , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , VAR_56 ) ; return METHOD_14 ( VAR_57 ) ; } if ( VAR_58 == VAR_59 && VAR_60 ) { VAR_61 = METHOD_15 ( VAR_62 ) ; VAR_63 -= 4 ; } else if ( VAR_64 == VAR_65 ) { if ( ! VAR_66 -> VAR_67 ) { TYPE_11 VAR_68 , VAR_69 , VAR_70 , VAR_71 ; unsigned TYPE_12 VAR_72 [ 256 ] ; VAR_73 = METHOD_16 ( VAR_74 ) ; METHOD_17 ( VAR_75 ) ; VAR_76 = METHOD_18 ( VAR_77 ) ; VAR_78 = METHOD_19 ( VAR_79 ) ; VAR_80 = METHOD_20 ( VAR_81 ) ; <S2SV_StartBug> if ( VAR_82 != 1 || VAR_83 == 0 ) { <S2SV_EndBug> METHOD_21 ( VAR_84 , VAR_85 , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; METHOD_22 ( VAR_86 , VAR_87 - 9 ) ; if ( ! VAR_88 ) return METHOD_23 ( VAR_89 ) ; goto VAR_90 ; } VAR_91 = METHOD_24 ( VAR_92 , VAR_93 , VAR_94 ) ; if ( VAR_95 != VAR_96 ) return VAR_97 < 0 ? VAR_98 : VAR_99 ; VAR_100 -= 9 + VAR_101 ; VAR_102 -= 3 + VAR_103 ; VAR_104 -> VAR_105 = VAR_106 ; if ( VAR_107 & 0x80 && ( VAR_108 [ 0 ] & 0xf0 ) == 0x20 ) { if ( VAR_109 < 5 ) { METHOD_25 ( VAR_110 , VAR_111 , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; METHOD_26 ( VAR_112 , VAR_113 ) ; return VAR_114 ; } VAR_115 = METHOD_27 ( VAR_116 ) ; } } VAR_117 -> VAR_118 -= VAR_119 ; if ( VAR_120 -> VAR_121 < 0 ) { METHOD_28 ( VAR_122 , VAR_123 , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; VAR_124 -> VAR_125 = 0 ; } } if ( VAR_126 != VAR_127 ) METHOD_29 ( VAR_128 -> VAR_129 [ VAR_130 - 1 ] , VAR_131 , VAR_132 , 0 , 0 , VAR_133 ) ; * VAR_134 = VAR_135 ; * VAR_136 = VAR_137 ; * VAR_138 = VAR_139 ; return 0 ; }",<S2SV_ModStart> ; if ( METHOD_30 ( VAR_112 ) ) { return VAR_140 ; } if (,"CWE-835 static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }",<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
30,"CWE-000 static struct STRUCT_OR_UNION_0 * METHOD_0 ( const struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 , struct STRUCT_OR_UNION_4 * VAR_3 , struct STRUCT_OR_UNION_5 * VAR_4 , TYPE_0 * VAR_5 ) { struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_7 * VAR_8 ; const struct STRUCT_OR_UNION_8 * VAR_9 = METHOD_2 ( VAR_10 ) ; struct STRUCT_OR_UNION_9 * VAR_11 ; struct STRUCT_OR_UNION_10 * VAR_12 ; struct STRUCT_OR_UNION_11 * VAR_13 ; struct STRUCT_OR_UNION_12 * VAR_14 ; if ( VAR_15 -> VAR_16 == METHOD_3 ( VAR_17 ) ) { VAR_18 = METHOD_4 ( VAR_19 , VAR_20 , VAR_21 , VAR_22 , VAR_23 , VAR_24 ) ; if ( VAR_25 == VAR_26 ) return VAR_27 ; VAR_28 = ( struct STRUCT_OR_UNION_13 * ) VAR_29 ; VAR_30 = METHOD_5 ( VAR_31 ) ; VAR_32 -> VAR_33 = & VAR_34 -> VAR_35 ; VAR_36 = METHOD_6 ( VAR_37 ) ; METHOD_7 ( VAR_38 , VAR_39 , sizeof ( struct STRUCT_OR_UNION_14 ) ) ; VAR_40 -> VAR_41 = VAR_42 -> VAR_43 ; METHOD_8 ( VAR_44 ) -> VAR_45 = & VAR_46 ; VAR_47 -> VAR_48 = VAR_49 ; VAR_50 -> VAR_51 = VAR_52 ; VAR_53 -> VAR_54 = VAR_55 ; <S2SV_StartBug> VAR_56 -> VAR_57 = METHOD_9 ( VAR_58 ) ; <S2SV_EndBug> VAR_59 -> VAR_60 = METHOD_10 ( VAR_61 ) -> VAR_62 ; METHOD_11 ( VAR_63 , METHOD_12 ( VAR_64 ) -> VAR_65 ) ; return VAR_66 ; } if ( METHOD_13 ( VAR_67 ) ) goto VAR_68 ; if ( ! VAR_69 ) { struct STRUCT_OR_UNION_15 VAR_70 ; VAR_71 = METHOD_14 ( VAR_72 , & VAR_73 , VAR_74 , VAR_75 ) ; if ( ! VAR_76 ) goto VAR_77 ; } VAR_78 = METHOD_15 ( VAR_79 , VAR_80 , VAR_81 ) ; if ( VAR_82 == VAR_83 ) goto VAR_84 ; METHOD_16 ( VAR_85 , VAR_86 , VAR_87 , VAR_88 ) ; VAR_89 -> VAR_90 = VAR_91 -> VAR_92 -> VAR_93 & ~ ( VAR_94 | VAR_95 ) ; VAR_96 = ( struct STRUCT_OR_UNION_16 * ) VAR_97 ; VAR_98 = METHOD_17 ( VAR_99 ) ; VAR_100 -> VAR_101 = & VAR_102 -> VAR_103 ; VAR_104 = METHOD_18 ( VAR_105 ) ; METHOD_19 ( VAR_106 , VAR_107 , sizeof ( struct STRUCT_OR_UNION_17 ) ) ; VAR_108 -> VAR_109 = VAR_110 -> VAR_111 ; VAR_112 -> VAR_113 = VAR_114 -> VAR_115 ; VAR_116 -> VAR_117 = VAR_118 -> VAR_119 ; VAR_120 -> VAR_121 = VAR_122 -> VAR_123 ; VAR_124 -> VAR_125 = VAR_126 ; VAR_127 -> VAR_128 . VAR_129 = VAR_130 -> VAR_131 . VAR_132 ; <S2SV_StartBug> VAR_133 -> VAR_134 = VAR_135 ; <S2SV_EndBug> VAR_136 -> VAR_137 = VAR_138 ; VAR_139 -> VAR_140 = METHOD_20 ( VAR_141 ) ; VAR_142 -> VAR_143 = METHOD_21 ( VAR_144 ) -> VAR_145 ; VAR_146 = VAR_147 -> VAR_148 ; if ( ! VAR_149 ) VAR_150 = METHOD_22 ( VAR_151 -> VAR_152 ) ; if ( VAR_153 ) { VAR_154 = METHOD_23 ( VAR_155 , VAR_156 ) ; METHOD_24 ( VAR_157 -> VAR_158 , VAR_159 ) ; } METHOD_25 ( VAR_160 ) -> VAR_161 = 0 ; if ( VAR_162 ) METHOD_26 ( VAR_163 ) -> VAR_164 = VAR_165 -> VAR_166 + VAR_167 -> VAR_168 ; METHOD_27 ( VAR_169 , METHOD_28 ( VAR_170 ) ) ; VAR_171 -> VAR_172 = VAR_173 -> VAR_174 = VAR_175 ; VAR_176 -> VAR_177 = VAR_178 ; if ( METHOD_29 ( VAR_179 , VAR_180 ) < 0 ) { METHOD_30 ( VAR_181 ) ; METHOD_31 ( VAR_182 ) ; goto VAR_183 ; } * VAR_184 = METHOD_32 ( VAR_185 , METHOD_33 ( VAR_186 ) ) ; if ( * VAR_187 && VAR_188 -> VAR_189 ) { VAR_190 -> VAR_191 = METHOD_34 ( VAR_192 -> VAR_193 , VAR_194 ) ; METHOD_35 ( VAR_195 -> VAR_196 ) ; VAR_197 -> VAR_198 = VAR_199 ; if ( VAR_200 -> VAR_201 ) METHOD_36 ( VAR_202 -> VAR_203 , VAR_204 ) ; } return VAR_205 ; VAR_206 : METHOD_37 ( METHOD_38 ( VAR_207 ) , VAR_208 ) ; VAR_209 : METHOD_39 ( VAR_210 ) ; VAR_211 : METHOD_40 ( METHOD_41 ( VAR_212 ) , VAR_213 ) ; return VAR_214 ; }",<S2SV_ModStart> ; VAR_202 -> VAR_215 = VAR_214 ; VAR_202 -> VAR_216 = VAR_214 ; VAR_202 -> VAR_217 = VAR_214 ; VAR_202 -> <S2SV_ModStart> ; VAR_202 -> VAR_215 = VAR_214 ; VAR_202 -> VAR_216 = VAR_214 ; VAR_202 -> VAR_217 = VAR_214 ; VAR_202 ->,"CWE-000 static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; <S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }",<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
31,"CWE-125 static VAR_0 TYPE_0 METHOD_0 ( TYPE_1 , TYPE_2 * VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> VAR_3 = METHOD_1 ( ( * VAR_4 ) + 2 , VAR_5 ) ; ( * VAR_6 ) += 2 ; if ( VAR_7 -> VAR_8 == VAR_9 ) { METHOD_2 ( * VAR_10 , VAR_11 ) ; } else { METHOD_3 ( VAR_12 , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'"" , VAR_13 -> VAR_14 ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } return VAR_15 ; }","<S2SV_ModStart> TYPE_3 VAR_15 ; if ( * VAR_6 >= VAR_16 - 2 ) { METHOD_3 ( VAR_12 , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ; return - 1 ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } return","CWE-125 static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce ) { <S2SV_StartBug> long elements ; <S2SV_EndBug> elements = parse_iv2 ( ( * p ) + 2 , p ) ; ( * p ) += 2 ; if ( ce -> serialize == NULL ) { object_init_ex ( * rval , ce ) ; } else { zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'"" , ce -> name ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } return elements ; }","<S2SV_ModStart> long elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ; return - 1 ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } return"
32,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = VAR_2 ; ++ VAR_3 -> VAR_4 . VAR_5 ; METHOD_1 ( VAR_6 ) ; <S2SV_StartBug> if ( ! METHOD_2 ( VAR_7 ) ) { <S2SV_EndBug> VAR_8 -> VAR_9 -> VAR_10 = VAR_11 ; VAR_12 -> VAR_13 -> VAR_14 . VAR_15 = VAR_16 ; VAR_17 -> VAR_18 -> VAR_19 . VAR_20 = 0 ; VAR_21 = VAR_22 ; } METHOD_3 ( VAR_23 , VAR_24 ) ; return VAR_25 ; }",<S2SV_ModStart> ( VAR_23 ) && VAR_26 -> METHOD_4 ( VAR_23 ) == 0,"CWE-362 static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = EMULATE_DONE ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; r = EMULATE_FAIL ; } kvm_queue_exception ( vcpu , UD_VECTOR ) ; return r ; }",<S2SV_ModStart> ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
33,"CWE-476 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , const struct STRUCT_OR_UNION_2 * VAR_0 , const struct STRUCT_OR_UNION_3 * VAR_1 , const TYPE_1 VAR_2 , TYPE_2 * VAR_3 , TYPE_3 * VAR_4 ) { struct STRUCT_OR_UNION_4 * VAR_5 = VAR_6 ; struct STRUCT_OR_UNION_5 * VAR_7 ; VAR_8 * VAR_9 ; struct STRUCT_OR_UNION_6 * VAR_10 ; struct STRUCT_OR_UNION_7 * VAR_11 , * VAR_12 = VAR_13 ; TYPE_4 VAR_14 = 0 ; struct STRUCT_OR_UNION_8 * VAR_15 ; struct STRUCT_OR_UNION_9 * VAR_16 ; if ( VAR_17 == METHOD_1 ( STRUCT_OR_UNION_10 -> VAR_18 . VAR_19 ) -> VAR_20 ) { METHOD_2 ( STRUCT_OR_UNION_11 , VAR_21 ) ; return METHOD_3 ( STRUCT_OR_UNION_12 , VAR_22 , VAR_23 , VAR_24 , VAR_25 , VAR_26 ) ; } if ( ! METHOD_4 ( VAR_27 , sizeof ( TYPE_5 ) ) ) return METHOD_5 ( STRUCT_OR_UNION_13 , VAR_28 , VAR_29 , VAR_30 , VAR_31 , VAR_32 ) ; VAR_33 = VAR_34 -> VAR_35 . VAR_36 ; if ( ! METHOD_6 ( VAR_37 , VAR_38 ) || ( METHOD_7 ( VAR_39 , VAR_40 ) && METHOD_8 ( VAR_41 ) ) ) return METHOD_9 ( STRUCT_OR_UNION_14 , VAR_42 , VAR_43 , VAR_44 , VAR_45 , VAR_46 ) ; VAR_47 -> VAR_48 . VAR_49 = ( struct STRUCT_OR_UNION_15 * ) VAR_50 -> VAR_51 -> VAR_52 ; if ( ! METHOD_10 ( VAR_53 -> VAR_54 , METHOD_11 ( VAR_55 -> VAR_56 -> VAR_57 ) - sizeof ( TYPE_6 ) ) ) goto VAR_58 ; VAR_59 = METHOD_12 ( VAR_60 , VAR_61 , VAR_62 , VAR_63 , & VAR_64 , & VAR_65 ) ; if ( ! VAR_66 ) { switch ( VAR_67 ) { case - VAR_68 : goto VAR_69 ; case - VAR_70 : METHOD_13 ( STRUCT_OR_UNION_16 , VAR_71 , VAR_72 , VAR_73 , VAR_74 , VAR_75 ) ; return METHOD_14 ( STRUCT_OR_UNION_17 , VAR_76 , VAR_77 , VAR_78 , VAR_79 , VAR_80 ) ; case - VAR_81 : default : return METHOD_15 ( STRUCT_OR_UNION_18 , VAR_82 , VAR_83 , VAR_84 , VAR_85 , VAR_86 ) ; } } VAR_87 = & VAR_88 -> VAR_89 . VAR_90 -> VAR_91 . VAR_92 [ 0 ] ; if ( ! METHOD_16 ( VAR_93 , VAR_94 , & VAR_95 -> VAR_96 . VAR_97 -> VAR_98 . VAR_99 , VAR_100 , VAR_101 ) ) goto VAR_102 ; VAR_103 = METHOD_17 ( VAR_104 , VAR_105 ) ; if ( VAR_106 ) goto VAR_107 ; if ( VAR_108 -> VAR_109 ) { struct STRUCT_OR_UNION_19 VAR_110 ; TYPE_7 VAR_111 ; <S2SV_StartBug> VAR_112 . VAR_113 = VAR_114 -> VAR_115 ; <S2SV_EndBug> VAR_116 . VAR_117 = VAR_118 -> VAR_119 ; VAR_120 . VAR_121 = VAR_122 -> VAR_123 ; VAR_124 . VAR_125 = ( TYPE_8 * ) METHOD_18 ( VAR_126 -> VAR_127 , sizeof ( TYPE_9 ) ) ; METHOD_19 ( VAR_128 -> VAR_129 , sizeof ( TYPE_10 ) ) ; VAR_130 . VAR_131 = VAR_132 -> VAR_133 ; VAR_134 = METHOD_20 ( STRUCT_OR_UNION_20 , VAR_135 , VAR_136 , VAR_137 , & VAR_138 ) ; METHOD_21 ( VAR_139 -> VAR_140 ) ; if ( VAR_141 != VAR_142 ) { METHOD_22 ( VAR_143 ) ; return METHOD_23 ( STRUCT_OR_UNION_21 , VAR_144 , VAR_145 , VAR_146 , VAR_147 , VAR_148 ) ; } } VAR_149 = METHOD_24 ( VAR_150 , VAR_151 ) ; if ( ! VAR_152 ) goto VAR_153 ; VAR_154 = METHOD_25 ( VAR_155 , 0 , VAR_156 , 0 , VAR_157 -> VAR_158 . VAR_159 , VAR_160 -> VAR_161 . VAR_162 , VAR_163 , VAR_164 ) ; if ( ! VAR_165 ) goto VAR_166 ; if ( VAR_167 -> VAR_168 . VAR_169 ) { VAR_170 = METHOD_26 ( VAR_171 , VAR_172 ) ; if ( ! VAR_173 ) goto VAR_174 ; } METHOD_27 ( VAR_175 , VAR_176 , METHOD_28 ( VAR_177 ) ) ; METHOD_29 ( VAR_178 , VAR_179 , METHOD_30 ( VAR_180 ) ) ; METHOD_31 ( STRUCT_OR_UNION_22 , VAR_181 ) ; METHOD_32 ( STRUCT_OR_UNION_23 , VAR_182 ) ; METHOD_33 ( VAR_183 , VAR_184 , METHOD_34 ( ) ) ; if ( VAR_185 -> VAR_186 [ VAR_187 ] ) METHOD_35 ( VAR_188 , VAR_189 , METHOD_36 ( VAR_190 ) ) ; METHOD_37 ( VAR_191 , VAR_192 , METHOD_38 ( VAR_193 ) ) ; METHOD_39 ( VAR_194 , VAR_195 , METHOD_40 ( VAR_196 ) ) ; if ( VAR_197 ) METHOD_41 ( VAR_198 , VAR_199 , METHOD_42 ( VAR_200 ) ) ; return VAR_201 ; VAR_202 : METHOD_43 ( VAR_203 ) ; VAR_204 : METHOD_44 ( VAR_205 ) ; VAR_206 : METHOD_45 ( VAR_207 ) ; VAR_208 : return VAR_209 ; }","<S2SV_ModStart> TYPE_7 VAR_141 ; if ( ! STRUCT_OR_UNION_23 -> VAR_18 . VAR_210 || ! VAR_207 -> VAR_168 . VAR_211 ) { METHOD_21 ( VAR_151 -> VAR_140 ) ; METHOD_45 ( VAR_207 ) ; return METHOD_23 ( STRUCT_OR_UNION_23 , VAR_144 , VAR_145 , VAR_146 , VAR_147 , VAR_198 ) ; }","CWE-476 sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ; <S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }","<S2SV_ModStart> sctp_ierror_t ret ; if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }"
34,"CWE-119 TYPE_0 METHOD_0 ( unsigned TYPE_1 VAR_0 , unsigned TYPE_2 VAR_1 , const struct STRUCT_OR_UNION_0 * VAR_2 , unsigned TYPE_3 VAR_3 ) { TYPE_4 VAR_4 ; struct STRUCT_OR_UNION_1 * VAR_5 ; const struct STRUCT_OR_UNION_2 * VAR_6 ; struct STRUCT_OR_UNION_3 * VAR_7 ; struct STRUCT_OR_UNION_4 * VAR_8 ; TYPE_5 VAR_9 ; TYPE_6 * VAR_10 = VAR_11 ; VAR_12 = METHOD_1 ( & VAR_13 ) ; if ( VAR_14 != VAR_15 ) return VAR_16 ; VAR_17 = METHOD_2 ( METHOD_3 ( VAR_18 -> VAR_19 ) , METHOD_4 ( VAR_20 ) , & VAR_21 ) ; if ( VAR_22 != VAR_23 ) return VAR_24 ; if ( ( VAR_25 -> VAR_26 . VAR_27 & VAR_28 ) != 0 ) return VAR_29 ; if ( ( VAR_30 -> VAR_31 . VAR_32 & VAR_33 ) != 0 ) return VAR_34 ; VAR_35 = METHOD_5 ( VAR_36 -> VAR_37 . VAR_38 ) ; if ( ! VAR_39 ) return VAR_40 ; if ( VAR_41 % VAR_42 -> VAR_43 != 0 ) return VAR_44 ; if ( VAR_45 < VAR_46 -> VAR_47 ) return VAR_48 ; if ( VAR_49 > VAR_50 -> VAR_51 ) return VAR_52 ; <S2SV_StartBug> VAR_53 = METHOD_6 ( sizeof ( TYPE_7 ) * VAR_54 ) ; <S2SV_EndBug> if ( ! VAR_55 ) return VAR_56 ; VAR_57 = METHOD_7 ( METHOD_8 ( VAR_58 -> VAR_59 ) , VAR_60 , VAR_61 , VAR_62 ) ; if ( VAR_63 != VAR_64 ) goto VAR_65 ; VAR_66 = METHOD_9 ( VAR_67 , VAR_68 , VAR_69 , VAR_70 ) ; if ( VAR_71 != VAR_72 ) goto VAR_73 ; switch ( VAR_74 -> VAR_75 . VAR_76 ) { case VAR_77 : case VAR_78 : case VAR_79 : case VAR_80 : case VAR_81 : case VAR_82 : case VAR_83 : case VAR_84 : case VAR_85 : case VAR_86 : VAR_87 = VAR_88 / 8 ; if ( VAR_89 -> VAR_90 . VAR_91 == VAR_92 || VAR_93 -> VAR_94 . VAR_95 == VAR_96 ) { VAR_97 = ( VAR_98 + VAR_99 / 7 ) / 8 ; } VAR_100 = ( struct STRUCT_OR_UNION_5 * ) VAR_101 -> VAR_102 ; if ( VAR_103 > VAR_104 -> VAR_105 ) { VAR_106 = VAR_107 ; goto VAR_108 ; } VAR_109 = METHOD_10 ( ( TYPE_8 * ) ( VAR_110 + 1 ) , VAR_111 ) ; if ( VAR_112 != VAR_113 ) goto VAR_114 ; VAR_115 -> VAR_116 = VAR_117 ; VAR_118 -> VAR_119 = ( 1 << VAR_120 -> VAR_121 ) - 1 ; break ; case VAR_122 : VAR_123 = METHOD_11 ( VAR_124 , VAR_125 , VAR_126 , VAR_127 , VAR_128 ) ; if ( VAR_129 != VAR_130 ) goto VAR_131 ; break ; case VAR_132 : VAR_133 = METHOD_12 ( VAR_134 , VAR_135 , VAR_136 ) ; if ( VAR_137 != VAR_138 ) goto VAR_139 ; break ; case VAR_140 : VAR_141 = METHOD_13 ( VAR_142 , VAR_143 , VAR_144 , VAR_145 , VAR_146 ) ; if ( VAR_147 != VAR_148 ) goto VAR_149 ; break ; case VAR_150 : case VAR_151 : VAR_152 = METHOD_14 ( VAR_153 , VAR_154 , VAR_155 , VAR_156 , VAR_157 ) ; if ( VAR_158 != VAR_159 ) goto VAR_160 ; break ; default : VAR_161 = VAR_162 ; } VAR_163 : METHOD_15 ( VAR_164 ) ; if ( VAR_165 == VAR_166 ) { VAR_167 -> VAR_168 . VAR_169 = VAR_170 ; VAR_171 -> VAR_172 . VAR_173 |= VAR_174 ; } return VAR_175 ; }","<S2SV_ModStart> return VAR_52 ; TYPE_5 VAR_105 = 0 ; if ( METHOD_16 ( sizeof ( TYPE_7 ) , VAR_157 , & VAR_105 ) ) return VAR_176 ; <S2SV_ModStart> = METHOD_6 ( VAR_105 <S2SV_ModEnd> ) ; if","CWE-119 TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }","<S2SV_ModStart> return TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if"
35,"CWE-120 TYPE_0 METHOD_0 ( TYPE_1 ) { const TYPE_2 * VAR_0 = ""FuseMuse"" ; TYPE_3 VAR_1 [ 32 ] ; TYPE_4 VAR_2 [ 32 ] ; TYPE_5 VAR_3 ; TYPE_6 VAR_4 ; VAR_5 = METHOD_1 ( VAR_6 , VAR_7 , 0 , 32 ) ; if ( ! METHOD_2 ( VAR_8 == 0 ) ) { METHOD_3 ( ""Expected:<S2SV_blank>%zu"" , 0 ) ; METHOD_4 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , VAR_9 ) ; } VAR_10 [ 0 ] = '\\0' ; <S2SV_StartBug> VAR_11 = METHOD_5 ( VAR_12 , VAR_13 ) ; <S2SV_EndBug> if ( ! METHOD_6 ( VAR_14 == - 1 ) ) { METHOD_7 ( ""Expected:<S2SV_blank>%zu"" , - 1 ) ; METHOD_8 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , VAR_15 ) ; } for ( TYPE_7 VAR_16 = 1 ; VAR_17 <= 8 ; ++ VAR_18 ) { VAR_19 = METHOD_9 ( VAR_20 , VAR_21 , VAR_22 , 32 ) ; TYPE_8 VAR_23 = ( ( VAR_24 + 2 ) / 3 ) << 2 ; if ( ! METHOD_10 ( VAR_25 == VAR_26 ) ) { METHOD_11 ( ""Expected:<S2SV_blank>%zu"" , VAR_27 ) ; METHOD_12 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , VAR_28 ) ; } <S2SV_StartBug> VAR_29 = METHOD_13 ( VAR_30 , VAR_31 ) ; <S2SV_EndBug> if ( ! METHOD_14 ( VAR_32 == VAR_33 ) ) { METHOD_15 ( ""Expected:<S2SV_blank>%zu"" , VAR_34 ) ; METHOD_16 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , VAR_35 ) ; } VAR_36 [ VAR_37 ] = '\\0' ; if ( ! METHOD_17 ( METHOD_18 ( VAR_38 , VAR_39 , VAR_40 ) == 0 ) ) { METHOD_19 ( ""Expected:<S2SV_blank>%s"" , VAR_41 ) ; METHOD_20 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , VAR_42 ) ; } } }","<S2SV_ModStart> VAR_42 , VAR_31 , sizeof ( VAR_42 ) <S2SV_ModStart> VAR_42 , VAR_31 , sizeof ( VAR_42 )","CWE-120 void test_base64_lengths ( void ) { const char * in = ""FuseMuse"" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , 0 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } out1 [ 0 ] = '\\0' ; <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , exp ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , i ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , in ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , out2 ) ; } } }","<S2SV_ModStart> out2 , out1 , sizeof ( out2 ) <S2SV_ModStart> out2 , out1 , sizeof ( out2 )"
36,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const struct STRUCT_OR_UNION_0 * VAR_2 , TYPE_3 VAR_3 ) { METHOD_1 ( VAR_4 , VAR_5 , 1 , 16383 ) ; METHOD_2 ( VAR_6 , VAR_7 , 1 , 16383 ) ; METHOD_3 ( VAR_8 , VAR_9 . VAR_10 , 1 , 1000000000 ) ; <S2SV_StartBug> METHOD_4 ( VAR_11 , VAR_12 . VAR_13 , 1 , VAR_14 -> VAR_15 . VAR_16 ) ; <S2SV_EndBug> METHOD_5 ( VAR_17 , VAR_18 , 3 ) ; METHOD_6 ( VAR_19 , VAR_20 , 63 ) ; METHOD_7 ( VAR_21 , VAR_22 , VAR_23 -> VAR_24 ) ; METHOD_8 ( VAR_25 , VAR_26 , 64 ) ; if VAR_27 METHOD_9 ( VAR_28 , VAR_29 , 0 ) ; else if VAR_30 if ( VAR_31 -> VAR_32 . VAR_33 . VAR_34 > 1 ) METHOD_10 ( VAR_35 , VAR_36 , 0 ) ; else METHOD_11 ( VAR_37 , VAR_38 , 25 ) ; METHOD_12 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; METHOD_13 ( VAR_43 , VAR_44 , 1000 ) ; METHOD_14 ( VAR_45 , VAR_46 , 1000 ) ; METHOD_15 ( VAR_47 , VAR_48 , 100 ) ; METHOD_16 ( VAR_49 , VAR_50 , VAR_51 , VAR_52 ) ; if VAR_53 if ( VAR_54 -> VAR_55 . VAR_56 . VAR_57 > 1 ) METHOD_17 ( VAR_58 , VAR_59 , 0 ) ; else METHOD_18 ( VAR_60 , VAR_61 ) ; METHOD_19 ( VAR_62 , VAR_63 , 100 ) ; METHOD_20 ( VAR_64 , VAR_65 , 100 ) ; METHOD_21 ( VAR_66 , VAR_67 , 100 ) ; if VAR_68 METHOD_22 ( VAR_69 , VAR_70 , VAR_71 , VAR_72 ) ; else if VAR_73 if ( VAR_74 -> VAR_75 . VAR_76 . VAR_77 > 1 ) METHOD_23 ( VAR_78 , VAR_79 , VAR_80 , VAR_81 ) ; else METHOD_24 ( VAR_82 , VAR_83 , VAR_84 , VAR_85 ) ; if ( VAR_86 -> VAR_87 != VAR_88 && VAR_89 -> VAR_90 != VAR_91 -> VAR_92 && VAR_93 -> VAR_94 > 0 ) METHOD_25 ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; METHOD_26 ( VAR_95 , VAR_96 ) ; METHOD_27 ( VAR_97 , VAR_98 , - 16 , 16 ) ; if VAR_99 && ! VAR_100 METHOD_28 ( VAR_101 , VAR_102 , 0 , 0 ) ; else METHOD_29 ( VAR_103 , VAR_104 , 6 ) ; METHOD_30 ( VAR_105 , VAR_106 , VAR_107 , VAR_108 ) ; METHOD_31 ( VAR_109 , VAR_110 , 7 ) ; METHOD_32 ( VAR_111 , VAR_112 , 0 , 15 ) ; METHOD_33 ( VAR_113 , VAR_114 , 6 ) ; METHOD_34 ( VAR_115 , VAR_116 , 1 , 3 ) ; <S2SV_StartBug> METHOD_35 ( VAR_117 , VAR_118 , 0 , 63 ) ; <S2SV_EndBug> if ( VAR_119 && ( VAR_120 -> VAR_121 == VAR_122 || VAR_123 -> VAR_124 == VAR_125 ) ) METHOD_36 ( VAR_126 , VAR_127 , VAR_128 -> VAR_129 , VAR_130 -> VAR_131 ) ; if ! ( VAR_132 ) if ( VAR_133 -> VAR_134 == VAR_135 ) { TYPE_4 VAR_136 = sizeof ( VAR_137 ) ; TYPE_5 VAR_138 = ( TYPE_6 ) ( VAR_139 -> VAR_140 . VAR_141 / VAR_142 ) ; VAR_143 * VAR_144 ; if ( ! VAR_145 -> VAR_146 . VAR_147 ) METHOD_37 ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( VAR_148 -> VAR_149 . VAR_150 % VAR_151 ) METHOD_38 ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; if ( VAR_152 -> VAR_153 . VAR_154 < 2 * VAR_155 ) METHOD_39 ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; VAR_156 = ( TYPE_7 * ) ( ( TYPE_8 * ) VAR_157 -> VAR_158 . VAR_159 + ( VAR_160 - 1 ) * VAR_161 ) ; if ( ( TYPE_9 ) ( VAR_162 -> VAR_163 + 0.5 ) != VAR_164 - 1 ) METHOD_40 ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; } METHOD_41 ( VAR_165 , VAR_166 , 1 , 5 ) ; if ( VAR_167 -> VAR_168 > 1 ) { unsigned TYPE_10 VAR_169 ; METHOD_42 ( VAR_170 , VAR_171 , 16 ) ; for ( VAR_172 = 1 ; VAR_173 < VAR_174 -> VAR_175 ; VAR_176 ++ ) <S2SV_StartBug> if ( VAR_177 -> VAR_178 [ VAR_179 ] <= VAR_180 -> VAR_181 [ VAR_182 - 1 ] ) <S2SV_EndBug> METHOD_43 ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ; METHOD_44 ( VAR_183 , VAR_184 [ VAR_185 -> VAR_186 - 1 ] , 1 , 1 ) ; for ( VAR_187 = VAR_188 -> VAR_189 - 2 ; VAR_190 > 0 ; VAR_191 -- ) if ( VAR_192 -> VAR_193 [ VAR_194 - 1 ] != 2 * VAR_195 -> VAR_196 [ VAR_197 ] ) METHOD_45 ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; METHOD_46 ( VAR_198 , VAR_199 [ VAR_200 ] , VAR_201 -> VAR_202 - 1 ) ; } if ( VAR_203 & VAR_204 ) if ( VAR_205 -> VAR_206 > ( 1 << VAR_207 -> VAR_208 ) ) METHOD_47 ( ""g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions"" ) ; return VAR_209 ; }","<S2SV_ModStart> , 1 , 1000000000 <S2SV_ModEnd> ) ; METHOD_46 <S2SV_ModStart> 0 , 63 ) ; METHOD_46 ( VAR_207 , VAR_210 , 2 <S2SV_ModStart> - 1 ] && VAR_205 -> VAR_211 > 0","CWE-119 static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; <S2SV_StartBug> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <S2SV_EndBug> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ;  if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ;  else if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ;  else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ;   RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ;  if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ;  else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ;   RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ;  if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ;  else if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ;  else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ;   if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ;  if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ;  else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ;   RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ; <S2SV_StartBug> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;  if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( ""rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set."" ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( ""rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet."" ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets."" ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ; }   RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ ) <S2SV_StartBug> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_EndBug> ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; }  if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( ""g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions"" ) ;   return VPX_CODEC_OK ; }","<S2SV_ModStart> , 1 , 1000000000 <S2SV_ModEnd> ) ; RANGE_CHECK_HI <S2SV_ModStart> 0 , 63 ) ; RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 <S2SV_ModStart> - 1 ] && cfg -> rc_target_bitrate > 0"
37,"CWE-189 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> TYPE_1 VAR_1 , VAR_2 , VAR_3 ; <S2SV_EndBug> TYPE_2 VAR_4 ; TYPE_3 VAR_5 ; if ( VAR_6 -> VAR_7 && ! METHOD_1 ( VAR_8 ) ) return - VAR_9 ; if ( ( VAR_10 -> VAR_11 & VAR_12 ) == VAR_13 ) { if ( VAR_14 -> VAR_15 != VAR_16 && VAR_17 -> VAR_18 != VAR_19 ) return - VAR_20 ; } if ( VAR_21 -> VAR_22 != VAR_23 && ( VAR_24 -> VAR_25 & VAR_26 ) ) if ( VAR_27 -> VAR_28 <= - VAR_29 || VAR_30 -> VAR_31 >= VAR_32 ) return - VAR_33 ; if ( VAR_34 -> VAR_35 & VAR_36 ) if ( VAR_37 -> VAR_38 < 900000 / VAR_39 || VAR_40 -> VAR_41 > 1100000 / VAR_42 ) return - VAR_43 ; METHOD_2 ( & VAR_44 ) ; VAR_45 = VAR_46 ; VAR_47 = VAR_48 ; if 0 VAR_49 &= ~ VAR_50 ; if ( VAR_51 -> VAR_52 ) { if ( VAR_53 -> VAR_54 & VAR_55 ) VAR_56 = ( VAR_57 -> VAR_58 & ~ VAR_59 ) | ( VAR_60 & VAR_61 ) ; if ( VAR_62 -> VAR_63 & VAR_64 ) { if ( VAR_65 -> VAR_66 > VAR_67 || VAR_68 -> VAR_69 < - VAR_70 ) { VAR_71 = - VAR_72 ; goto VAR_73 ; } VAR_74 = ( ( TYPE_4 ) VAR_75 -> VAR_76 * VAR_77 ) >> ( VAR_78 - VAR_79 ) ; } if ( VAR_80 -> VAR_81 & VAR_82 ) { if ( VAR_83 -> VAR_84 < 0 || VAR_85 -> VAR_86 >= VAR_87 ) { VAR_88 = - VAR_89 ; goto VAR_90 ; } VAR_91 = VAR_92 -> VAR_93 ; } if ( VAR_94 -> VAR_95 & VAR_96 ) { if ( VAR_97 -> VAR_98 < 0 || VAR_99 -> VAR_100 >= VAR_101 ) { VAR_102 = - VAR_103 ; goto VAR_104 ; } VAR_105 = VAR_106 -> VAR_107 ; } if ( VAR_108 -> VAR_109 & VAR_110 ) { if ( VAR_111 -> VAR_112 < 0 ) { VAR_113 = - VAR_114 ; goto VAR_115 ; } VAR_116 = METHOD_3 ( VAR_117 -> VAR_118 + 4 , ( TYPE_5 ) VAR_119 ) ; } if ( VAR_120 -> VAR_121 & VAR_122 ) { if ( VAR_123 -> VAR_124 == VAR_125 ) { VAR_126 = VAR_127 -> VAR_128 ; } else if ( VAR_129 & VAR_130 ) { VAR_131 = VAR_132 -> VAR_133 * VAR_134 ; VAR_135 = METHOD_4 ( VAR_136 , ( TYPE_6 ) VAR_137 * VAR_138 ) ; VAR_139 = METHOD_5 ( VAR_140 , ( TYPE_7 ) - VAR_141 * VAR_142 ) ; if ( VAR_143 & VAR_144 || VAR_145 == 0 ) VAR_146 = VAR_147 . VAR_148 ; VAR_149 = VAR_150 . VAR_151 - VAR_152 ; VAR_153 = VAR_154 . VAR_155 ; VAR_156 = VAR_157 * VAR_158 ; VAR_159 = METHOD_6 ( VAR_160 , VAR_161 * 2 + ( VAR_162 + 2 ) * 2 - VAR_163 ) ; if ( VAR_164 >= VAR_165 && ( VAR_166 & VAR_167 || VAR_168 > VAR_169 ) ) VAR_170 += METHOD_7 ( VAR_171 << ( VAR_172 - VAR_173 ) , VAR_174 ) ; VAR_175 += VAR_176 ; VAR_177 = METHOD_8 ( VAR_178 , ( TYPE_8 ) VAR_179 ) ; VAR_180 = METHOD_9 ( VAR_181 , ( TYPE_9 ) - VAR_182 ) ; <S2SV_StartBug> VAR_183 = METHOD_10 ( VAR_184 , <S2SV_EndBug> <S2SV_StartBug> VAR_185 , <S2SV_EndBug> & VAR_186 ) ; VAR_187 <<= VAR_188 ; } } if ( VAR_189 -> VAR_190 & VAR_191 ) VAR_192 = VAR_193 -> VAR_194 ; if ( VAR_195 -> VAR_196 & ( VAR_197 | VAR_198 | VAR_199 ) ) METHOD_11 ( ) ; } VAR_200 : if ( ( VAR_201 & ( VAR_202 | VAR_203 ) ) != 0 ) VAR_204 = VAR_205 ; if ( ( VAR_206 -> VAR_207 == VAR_208 ) || ( VAR_209 -> VAR_210 == VAR_211 ) ) VAR_212 -> VAR_213 = VAR_214 ; else VAR_215 -> VAR_216 = ( ( TYPE_10 ) METHOD_12 ( VAR_217 , VAR_218 ) ) * VAR_219 / 1000 ; VAR_220 -> VAR_221 = ( VAR_222 / VAR_223 ) << ( VAR_224 - VAR_225 ) ; VAR_226 -> VAR_227 = VAR_228 ; VAR_229 -> VAR_230 = VAR_231 ; VAR_232 -> VAR_233 = VAR_234 ; VAR_235 -> VAR_236 = VAR_237 ; VAR_238 -> VAR_239 = 1 ; VAR_240 -> VAR_241 = VAR_242 ; VAR_243 -> VAR_244 = VAR_245 ; VAR_246 -> VAR_247 = 0 ; VAR_248 -> VAR_249 = 0 ; VAR_250 -> VAR_251 = 0 ; VAR_252 -> VAR_253 = 0 ; VAR_254 -> VAR_255 = 0 ; VAR_256 -> VAR_257 = 0 ; VAR_258 -> VAR_259 = 0 ; VAR_260 -> VAR_261 = 0 ; METHOD_13 ( & VAR_262 ) ; METHOD_14 ( & VAR_263 -> VAR_264 ) ; METHOD_15 ( ) ; return ( VAR_265 ) ; }","<S2SV_ModStart> VAR_174 , VAR_214 <S2SV_ModEnd> ; TYPE_9 VAR_181 <S2SV_ModStart> ; VAR_217 = METHOD_7 <S2SV_ModEnd> ( VAR_217 , <S2SV_ModStart> VAR_217 , VAR_219 <S2SV_ModEnd> ) ; VAR_217","CWE-189 int do_adjtimex ( struct timex * txc ) { <S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ;  if 0 time_status &= ~ STA_CLOCKERR ;   if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }","<S2SV_ModStart> mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj <S2SV_ModStart> ; time_offset = div_s64 <S2SV_ModEnd> ( time_offset , <S2SV_ModStart> time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset"
38,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , register const TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 VAR_3 ; VAR_4 = METHOD_1 ( VAR_5 + sizeof ( struct STRUCT_OR_UNION_0 ) ) ; METHOD_2 ( ( VAR_6 , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , METHOD_3 ( VAR_7 , ""op%d"" , VAR_8 ) ) ) ; VAR_9 += sizeof ( struct STRUCT_OR_UNION_1 ) + 4 ; switch ( VAR_10 ) { case 10000 : METHOD_4 ( VAR_11 [ 0 ] , 4 ) ; VAR_12 = METHOD_5 ( VAR_13 ) ; VAR_14 += sizeof ( TYPE_5 ) ; METHOD_6 ( ( VAR_15 , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , VAR_16 ? ""yes"" : ""no"" ) ) ; METHOD_7 ( ( VAR_17 , ""<S2SV_blank>votestart"" ) ) ; METHOD_8 ( ) ; METHOD_9 ( ( VAR_18 , ""<S2SV_blank>dbversion"" ) ) ; METHOD_10 ( ) ; METHOD_11 ( ( VAR_19 , ""<S2SV_blank>tid"" ) ) ; METHOD_12 ( ) ; break ; case 10003 : METHOD_13 ( ( VAR_20 , ""<S2SV_blank>site"" ) ) ; METHOD_14 ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : METHOD_15 ( ( VAR_21 , ""<S2SV_blank>tid"" ) ) ; METHOD_16 ( ) ; break ; case 20002 : METHOD_17 ( ( VAR_22 , ""<S2SV_blank>tid"" ) ) ; METHOD_18 ( ) ; METHOD_19 ( ( VAR_23 , ""<S2SV_blank>file"" ) ) ; METHOD_20 ( ) ; METHOD_21 ( ( VAR_24 , ""<S2SV_blank>pos"" ) ) ; METHOD_22 ( ) ; METHOD_23 ( ( VAR_25 , ""<S2SV_blank>length"" ) ) ; METHOD_24 ( ) ; <S2SV_StartBug> VAR_26 = METHOD_25 ( VAR_27 ) ; <S2SV_EndBug> VAR_28 += sizeof ( TYPE_6 ) ; METHOD_26 ( VAR_29 , ""type<S2SV_blank>%d"" , VAR_30 ) ; break ; case 20003 : METHOD_27 ( ( VAR_31 , ""<S2SV_blank>tid"" ) ) ; METHOD_28 ( ) ; METHOD_29 ( ( VAR_32 , ""<S2SV_blank>file"" ) ) ; METHOD_30 ( ) ; METHOD_31 ( ( VAR_33 , ""<S2SV_blank>pos"" ) ) ; METHOD_32 ( ) ; break ; case 20005 : METHOD_33 ( ( VAR_34 , ""<S2SV_blank>file"" ) ) ; METHOD_34 ( ) ; break ; case 20006 : METHOD_35 ( ( VAR_35 , ""<S2SV_blank>file"" ) ) ; METHOD_36 ( ) ; METHOD_37 ( ( VAR_36 , ""<S2SV_blank>length"" ) ) ; METHOD_38 ( ) ; METHOD_39 ( ( VAR_37 , ""<S2SV_blank>dbversion"" ) ) ; METHOD_40 ( ) ; break ; case 20009 : METHOD_41 ( ( VAR_38 , ""<S2SV_blank>tid"" ) ) ; METHOD_42 ( ) ; METHOD_43 ( ( VAR_39 , ""<S2SV_blank>file"" ) ) ; METHOD_44 ( ) ; METHOD_45 ( ( VAR_40 , ""<S2SV_blank>length"" ) ) ; METHOD_46 ( ) ; break ; case 20012 : METHOD_47 ( ( VAR_41 , ""<S2SV_blank>tid"" ) ) ; METHOD_48 ( ) ; METHOD_49 ( ( VAR_42 , ""<S2SV_blank>oldversion"" ) ) ; METHOD_50 ( ) ; METHOD_51 ( ( VAR_43 , ""<S2SV_blank>newversion"" ) ) ; METHOD_52 ( ) ; break ; default : ; } return ; VAR_44 : METHOD_53 ( ( VAR_45 , ""<S2SV_blank>[|ubik]"" ) ) ; }",<S2SV_ModStart> ( ) ; METHOD_54 ( VAR_28 ) ;,"CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s"" , tok2str ( ubik_req , ""op%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>syncsite<S2SV_blank>%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""<S2SV_blank>site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; <S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type<S2SV_blank>%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""<S2SV_blank>tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|ubik]"" ) ) ; }",<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;
39,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , TYPE_2 VAR_2 , TYPE_3 * * VAR_3 , TYPE_4 * VAR_4 , TYPE_5 VAR_5 ) { TYPE_6 VAR_6 = ( VAR_7 ? VAR_8 : METHOD_1 ( VAR_9 ) ) + 1 ; TYPE_7 * VAR_10 = METHOD_2 ( VAR_11 ) ; unsigned TYPE_8 VAR_12 ; TYPE_9 VAR_13 = 0 ; unsigned TYPE_10 VAR_14 ; TYPE_11 VAR_15 ; if ( ! VAR_16 ) return VAR_17 ; while ( -- VAR_18 > 0 ) { VAR_19 = * VAR_20 ; <S2SV_StartBug> if ( ( '%' == VAR_21 ) && METHOD_3 ( VAR_22 [ 1 ] ) && METHOD_4 ( VAR_23 [ 2 ] ) ) { <S2SV_EndBug> TYPE_12 VAR_24 [ 3 ] ; TYPE_13 * VAR_25 ; VAR_26 [ 0 ] = VAR_27 [ 1 ] ; VAR_28 [ 1 ] = VAR_29 [ 2 ] ; VAR_30 [ 2 ] = 0 ; VAR_31 = METHOD_5 ( VAR_32 , & VAR_33 , 16 ) ; VAR_34 = METHOD_6 ( VAR_35 ) ; VAR_36 = METHOD_7 ( VAR_37 , & VAR_38 , 1 ) ; if ( VAR_39 ) { METHOD_8 ( VAR_40 ) ; return VAR_41 ; } VAR_42 += 2 ; VAR_43 -= 2 ; } if ( VAR_44 && ( VAR_45 < 0x20 ) ) { METHOD_9 ( VAR_46 ) ; return VAR_47 ; } VAR_48 [ VAR_49 ++ ] = VAR_50 ; VAR_51 ++ ; } VAR_52 [ VAR_53 ] = 0 ; if ( VAR_54 ) * VAR_55 = VAR_56 ; if ( VAR_57 ) * VAR_58 = VAR_59 ; return VAR_60 ; }",<S2SV_ModStart> VAR_50 ) && ( VAR_43 > 2 ) &&,"CWE-119 CURLcode Curl_urldecode ( struct SessionHandle * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) { size_t alloc = ( length ? length : strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; size_t strindex = 0 ; unsigned long hex ; CURLcode res ; if ( ! ns ) return CURLE_OUT_OF_MEMORY ; while ( -- alloc > 0 ) { in = * string ; <S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( data , & in , 1 ) ; if ( res ) { free ( ns ) ; return res ; } string += 2 ; alloc -= 2 ; } if ( reject_ctrl && ( in < 0x20 ) ) { free ( ns ) ; return CURLE_URL_MALFORMAT ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; if ( ostring ) * ostring = ns ; return CURLE_OK ; }",<S2SV_ModStart> in ) && ( alloc > 2 ) &&
40,"CWE-20 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> TYPE_4 VAR_3 ; TYPE_5 * VAR_4 ; <S2SV_StartBug> if ( VAR_5 -> VAR_6 < 5 ) <S2SV_EndBug> return VAR_7 ; <S2SV_StartBug> VAR_8 = VAR_9 -> VAR_10 * 4 - sizeof ( TYPE_6 ) ; <S2SV_EndBug> VAR_11 = 0 ; while ( VAR_12 < VAR_13 ) { VAR_14 = ( TYPE_7 * ) ( VAR_15 -> VAR_16 + VAR_17 ) ; <S2SV_StartBug> if ( VAR_18 -> VAR_19 == VAR_20 ) <S2SV_EndBug> { VAR_21 ++ ; <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( VAR_22 -> VAR_23 == VAR_24 ) break ; <S2SV_StartBug> if ( ( VAR_25 + 1 ) >= VAR_26 || ( VAR_27 + VAR_28 -> VAR_29 ) > VAR_30 ) <S2SV_EndBug> break ; if ( VAR_31 -> VAR_32 == VAR_33 ) return VAR_34 ; VAR_35 += VAR_36 -> VAR_37 ; } <S2SV_StartBug> return VAR_38 ; <S2SV_EndBug> }",<S2SV_ModStart> ) { TYPE_3 VAR_35 ; TYPE_3 VAR_37 <S2SV_ModEnd> ; TYPE_7 * <S2SV_ModStart> VAR_15 -> VAR_10 >= ( sizeof ( TYPE_6 ) / 4 ) ) { VAR_37 = ( <S2SV_ModEnd> VAR_15 -> VAR_10 <S2SV_ModStart> VAR_10 * 4 ) <S2SV_ModStart> -> VAR_33 == VAR_24 ) { break ; } else if ( VAR_36 -> VAR_33 == <S2SV_ModStart> VAR_35 ++ ; } else { <S2SV_ModEnd> if ( ( <S2SV_ModStart> ) >= VAR_37 ) break ; if ( VAR_36 -> VAR_37 < sizeof ( TYPE_7 ) <S2SV_ModStart> VAR_37 ; } } },"CWE-20 TcpOption * tcpGetOption ( TcpHeader * segment , uint8_t kind ) { <S2SV_StartBug> size_t length ; <S2SV_EndBug> uint_t i ; TcpOption * option ; <S2SV_StartBug> if ( segment -> dataOffset < 5 ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> i = 0 ; while ( i < length ) { option = ( TcpOption * ) ( segment -> options + i ) ; <S2SV_StartBug> if ( option -> kind == TCP_OPTION_NOP ) <S2SV_EndBug> { i ++ ; <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( option -> kind == TCP_OPTION_END ) break ; <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + option -> length ) > length ) <S2SV_EndBug> break ; if ( option -> kind == kind ) return option ; i += option -> length ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> }",<S2SV_ModStart> ) { size_t i ; size_t length <S2SV_ModEnd> ; TcpOption * <S2SV_ModStart> segment -> dataOffset >= ( sizeof ( TcpHeader ) / 4 ) ) { length = ( <S2SV_ModEnd> segment -> dataOffset <S2SV_ModStart> dataOffset * 4 ) <S2SV_ModStart> -> kind == TCP_OPTION_END ) { break ; } else if ( option -> kind == <S2SV_ModStart> i ++ ; } else { <S2SV_ModEnd> if ( ( <S2SV_ModStart> ) >= length ) break ; if ( option -> length < sizeof ( TcpOption ) <S2SV_ModStart> length ; } } }
41,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 , VAR_3 ; TYPE_4 VAR_4 = 0 ; unsigned TYPE_5 VAR_5 [ 5 ] ; TYPE_6 VAR_6 = 0x0000007f ; TYPE_7 VAR_7 = ( TYPE_8 ) VAR_8 ; if ( VAR_9 < 0 ) { VAR_10 = 1 ; VAR_11 = ( TYPE_9 ) - VAR_12 ; } for ( VAR_13 = 4 , VAR_14 = 0 ; VAR_15 >= 0 ; VAR_16 -- , VAR_17 += 7 ) { VAR_18 [ VAR_19 ] = ( unsigned TYPE_10 ) ( ( VAR_20 & VAR_21 ) >> VAR_22 ) ; VAR_23 [ VAR_24 ] |= 0x80 ; VAR_25 = VAR_26 << 7 ; } for ( VAR_27 = 0 ; VAR_28 < 4 ; VAR_29 ++ ) if ( VAR_30 [ VAR_31 ] & 0x7f ) break ; <S2SV_StartBug> if ( VAR_32 [ VAR_33 ] & 0x40 ) <S2SV_EndBug> VAR_34 -- ; VAR_35 [ VAR_36 ] &= 0x7f ; if ( VAR_37 ) VAR_38 [ VAR_39 ] |= 0x40 ; for ( VAR_40 = 4 ; VAR_41 >= VAR_42 ; VAR_43 -- ) METHOD_1 ( VAR_44 , VAR_45 [ VAR_46 ] ) ; }",<S2SV_ModStart> ] & 0x40 && VAR_42 > 0,"CWE-125 void bit_write_MC ( Bit_Chain * dat , BITCODE_MC val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; BITCODE_UMC mask = 0x0000007f ; BITCODE_UMC value = ( BITCODE_UMC ) val ; if ( val < 0 ) { negative = 1 ; value = ( BITCODE_UMC ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; <S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }",<S2SV_ModStart> ] & 0x40 && i > 0
42,"CWE-399 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 -> VAR_4 ; TYPE_4 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_5 * VAR_8 = VAR_9 -> VAR_10 [ 0 ] ; TYPE_6 VAR_11 ; TYPE_7 VAR_12 , VAR_13 ; VAR_14 -> VAR_15 ++ ; if ( VAR_16 -> VAR_17 == VAR_18 ) { if ( VAR_19 -> VAR_20 != VAR_21 ) { VAR_22 = METHOD_1 ( VAR_23 -> VAR_24 , VAR_25 ) ; if ( VAR_26 < 0 ) return VAR_27 ; if ( VAR_28 -> VAR_29 != VAR_30 && VAR_31 -> VAR_32 != VAR_33 ) { TYPE_8 VAR_34 = VAR_35 -> VAR_36 * VAR_37 ; VAR_38 = METHOD_2 ( METHOD_3 ( VAR_39 , VAR_40 ) , VAR_41 ) ; VAR_42 -> VAR_43 = VAR_44 -> VAR_45 = METHOD_4 ( VAR_46 , VAR_47 , VAR_48 -> VAR_49 ) ; METHOD_5 ( VAR_50 , VAR_51 , ""Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%"" PRId64 ""<S2SV_blank>out:%"" PRId64 "")\\n"" , VAR_52 -> VAR_53 , METHOD_6 ( VAR_54 , VAR_55 , VAR_56 -> VAR_57 ) ) ; } else { VAR_58 -> VAR_59 = VAR_60 -> VAR_61 = VAR_62 -> VAR_63 ; } } else { METHOD_7 ( VAR_64 , VAR_65 , ""Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>"" ""timestamp.\\n"" ) ; METHOD_8 ( & VAR_66 ) ; VAR_67 -> VAR_68 ++ ; } return 0 ; } <S2SV_StartBug> if ( VAR_69 -> VAR_70 == VAR_71 ) { <S2SV_EndBug> return METHOD_9 ( VAR_72 -> VAR_73 , VAR_74 ) ; } VAR_75 = METHOD_10 ( VAR_76 -> VAR_77 - VAR_78 -> VAR_79 , VAR_80 -> VAR_81 , VAR_82 -> VAR_83 , VAR_84 -> VAR_85 ) ; if ( VAR_86 < 1 ) { TYPE_9 * VAR_87 ; TYPE_10 VAR_88 = METHOD_11 ( VAR_89 -> VAR_90 ) / sizeof ( TYPE_11 * ) ; METHOD_12 ( VAR_91 , VAR_92 , ""Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n"" , VAR_93 ) ; VAR_94 -> VAR_95 += VAR_96 ; METHOD_13 ( VAR_97 -> VAR_98 , & VAR_99 , sizeof ( VAR_100 ) , VAR_101 ) ; METHOD_14 ( VAR_102 -> VAR_103 ) ; VAR_104 = METHOD_15 ( VAR_105 -> VAR_106 , VAR_107 ) ; METHOD_16 ( & VAR_108 ) ; return VAR_109 ; } for ( VAR_110 = 0 ; VAR_111 < VAR_112 ; VAR_113 ++ ) { TYPE_12 * VAR_114 ; METHOD_17 ( VAR_115 -> VAR_116 , & VAR_117 , sizeof ( VAR_118 ) , VAR_119 ) ; if ( ! METHOD_18 ( VAR_120 -> VAR_121 ) && VAR_122 < VAR_123 - 1 ) { TYPE_13 * VAR_124 = METHOD_19 ( VAR_125 ) ; METHOD_20 ( VAR_126 , VAR_127 , ""Duplicating<S2SV_blank>frame.\\n"" ) ; if ( VAR_128 ) VAR_129 = METHOD_21 ( VAR_130 -> VAR_131 , VAR_132 ) ; else VAR_133 = METHOD_22 ( VAR_134 ) ; if ( VAR_135 < 0 ) { METHOD_23 ( & VAR_136 ) ; METHOD_24 ( & VAR_137 ) ; return VAR_138 ; } VAR_139 -> VAR_140 ++ ; } VAR_141 -> VAR_142 = METHOD_25 ( VAR_143 -> VAR_144 , VAR_145 -> VAR_146 , VAR_147 -> VAR_148 ) + VAR_149 -> VAR_150 ; if ( ( VAR_151 = METHOD_26 ( VAR_152 , VAR_153 ) ) < 0 ) { METHOD_27 ( & VAR_154 ) ; return VAR_155 ; } VAR_156 -> VAR_157 ++ ; } METHOD_28 ( VAR_158 -> VAR_159 ) ; VAR_160 = METHOD_29 ( VAR_161 -> VAR_162 , VAR_163 ) ; VAR_164 -> VAR_165 = VAR_166 -> VAR_167 + METHOD_30 ( VAR_168 -> VAR_169 , VAR_170 -> VAR_171 , VAR_172 -> VAR_173 ) ; return VAR_174 ; }",<S2SV_ModStart> VAR_165 == VAR_71 || METHOD_18 ( VAR_168 -> VAR_162 ) <= 0,"CWE-399 static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , ""Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%"" PRId64 ""<S2SV_blank>out:%"" PRId64 "")\\n"" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>"" ""timestamp.\\n"" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; } <S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , ""Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n"" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , ""Duplicating<S2SV_blank>frame.\\n"" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }",<S2SV_ModStart> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
43,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 VAR_3 ; VAR_4 -> VAR_5 = VAR_6 ; VAR_7 -> VAR_8 = 1 ; VAR_9 -> VAR_10 = 1 ; VAR_11 -> VAR_12 = 'C' ; VAR_13 -> VAR_14 = 1 ; VAR_15 -> VAR_16 = 0 ; VAR_17 -> VAR_18 = 0 ; VAR_19 -> VAR_20 = 0 ; VAR_21 -> VAR_22 = 0 ; VAR_23 -> VAR_24 = 32 ; VAR_25 -> VAR_26 = 32 ; VAR_27 -> VAR_28 = 0 ; VAR_29 -> VAR_30 = - 1 ; VAR_31 -> VAR_32 = 1 ; VAR_33 -> VAR_34 = 1 ; VAR_35 -> VAR_36 = 1 ; if ( VAR_37 -> VAR_38 > 1 ) { METHOD_1 ( VAR_39 , VAR_40 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""1<S2SV_blank>single<S2SV_blank>quality<S2SV_blank>layer"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>layers<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" ""-><S2SV_blank>Rate<S2SV_blank>of<S2SV_blank>the<S2SV_blank>last<S2SV_blank>layer<S2SV_blank>(%3.1f)<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used"" , VAR_41 -> VAR_42 , VAR_43 -> VAR_44 [ VAR_45 -> VAR_46 - 1 ] ) ; VAR_47 -> VAR_48 [ 0 ] = VAR_49 -> VAR_50 [ VAR_51 -> VAR_52 - 1 ] ; VAR_53 -> VAR_54 = 1 ; } switch ( VAR_55 -> VAR_56 ) { case VAR_57 : if ( VAR_58 -> VAR_59 > 6 ) { METHOD_2 ( VAR_60 , VAR_61 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>(2k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank><=<S2SV_blank>5\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>5<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , VAR_62 -> VAR_63 + 1 ) ; VAR_64 -> VAR_65 = 6 ; } break ; case VAR_66 : if ( VAR_67 -> VAR_68 < 2 ) { METHOD_3 ( VAR_69 , VAR_70 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , VAR_71 -> VAR_72 + 1 ) ; VAR_73 -> VAR_74 = 1 ; } else if ( VAR_75 -> VAR_76 > 7 ) { METHOD_4 ( VAR_77 , VAR_78 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>6<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , VAR_79 -> VAR_80 + 1 ) ; VAR_81 -> VAR_82 = 7 ; } break ; default : break ; } VAR_83 -> VAR_84 |= 0x01 ; <S2SV_StartBug> VAR_85 -> VAR_86 = VAR_87 -> VAR_88 - 1 ; <S2SV_EndBug> for ( VAR_89 = 0 ; VAR_90 < VAR_91 -> VAR_92 ; VAR_93 ++ ) { VAR_94 -> VAR_95 [ VAR_96 ] = 256 ; <S2SV_StartBug> VAR_97 -> VAR_98 [ VAR_99 ] = 256 ; <S2SV_EndBug> } VAR_100 -> VAR_101 = VAR_102 ; if ( VAR_103 -> VAR_104 == VAR_105 ) { VAR_106 -> VAR_107 = ( TYPE_5 ) METHOD_5 ( VAR_108 -> VAR_109 , VAR_110 -> VAR_111 ) ; } else { VAR_112 -> VAR_113 = 0 ; } VAR_114 -> VAR_115 = 1 ; if ( VAR_116 -> VAR_117 <= 0 ) { VAR_118 -> VAR_119 = VAR_120 ; METHOD_6 ( VAR_121 , VAR_122 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( VAR_123 -> VAR_124 > VAR_125 ) { METHOD_7 ( VAR_126 , VAR_127 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1302083<S2SV_blank>bytes.\\n"" ) ; VAR_128 -> VAR_129 = VAR_130 ; } if ( VAR_131 -> VAR_132 <= 0 ) { VAR_133 -> VAR_134 = VAR_135 ; METHOD_8 ( VAR_136 , VAR_137 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( VAR_138 -> VAR_139 > VAR_140 ) { METHOD_9 ( VAR_141 , VAR_142 , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1041666<S2SV_blank>bytes.\\n"" ) ; VAR_143 -> VAR_144 = VAR_145 ; } VAR_146 -> VAR_147 [ 0 ] = ( TYPE_6 ) ( VAR_148 -> VAR_149 * VAR_150 -> VAR_151 [ 0 ] . VAR_152 * VAR_153 -> VAR_154 [ 0 ] . VAR_155 * VAR_156 -> VAR_157 [ 0 ] . VAR_158 ) / ( TYPE_7 ) ( ( ( TYPE_8 ) VAR_159 -> VAR_160 ) * 8 * VAR_161 -> VAR_162 [ 0 ] . VAR_163 * VAR_164 -> VAR_165 [ 0 ] . VAR_166 ) ; }",<S2SV_ModStart> |= 0x01 ; if ( VAR_159 -> VAR_111 == 1 ) { VAR_159 -> VAR_92 = 1 ; VAR_159 -> VAR_95 [ 0 ] = 128 ; VAR_159 -> VAR_98 [ 0 ] = 128 ; } else { <S2SV_ModStart> = 256 ; },"CWE-787 static void opj_j2k_set_cinema_parameters ( opj_cparameters_t * parameters , opj_image_t * image , opj_event_mgr_t * p_manager ) { int i ; parameters -> tile_size_on = OPJ_FALSE ; parameters -> cp_tdx = 1 ; parameters -> cp_tdy = 1 ; parameters -> tp_flag = 'C' ; parameters -> tp_on = 1 ; parameters -> cp_tx0 = 0 ; parameters -> cp_ty0 = 0 ; parameters -> image_offset_x0 = 0 ; parameters -> image_offset_y0 = 0 ; parameters -> cblockw_init = 32 ; parameters -> cblockh_init = 32 ; parameters -> mode = 0 ; parameters -> roi_compno = - 1 ; parameters -> subsampling_dx = 1 ; parameters -> subsampling_dy = 1 ; parameters -> irreversible = 1 ; if ( parameters -> tcp_numlayers > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""1<S2SV_blank>single<S2SV_blank>quality<S2SV_blank>layer"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>layers<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" ""-><S2SV_blank>Rate<S2SV_blank>of<S2SV_blank>the<S2SV_blank>last<S2SV_blank>layer<S2SV_blank>(%3.1f)<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used"" , parameters -> tcp_numlayers , parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ) ; parameters -> tcp_rates [ 0 ] = parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ; parameters -> tcp_numlayers = 1 ; } switch ( parameters -> rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( parameters -> numresolution > 6 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>(2k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank><=<S2SV_blank>5\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>5<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 6 ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( parameters -> numresolution < 2 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 1 ; } else if ( parameters -> numresolution > 7 ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n"" ""-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>6<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n"" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 7 ; } break ; default : break ; } parameters -> csty |= 0x01 ; <S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> for ( i = 0 ; i < parameters -> res_spec ; i ++ ) { parameters -> prcw_init [ i ] = 256 ; <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> } parameters -> prog_order = OPJ_CPRL ; if ( parameters -> rsiz == OPJ_PROFILE_CINEMA_4K ) { parameters -> numpocs = ( OPJ_UINT32 ) opj_j2k_initialise_4K_poc ( parameters -> POC , parameters -> numresolution ) ; } else { parameters -> numpocs = 0 ; } parameters -> cp_disto_alloc = 1 ; if ( parameters -> max_cs_size <= 0 ) { parameters -> max_cs_size = OPJ_CINEMA_24_CS ; opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( parameters -> max_cs_size > OPJ_CINEMA_24_CS ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1302083<S2SV_blank>bytes.\\n"" ) ; parameters -> max_cs_size = OPJ_CINEMA_24_CS ; } if ( parameters -> max_comp_size <= 0 ) { parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n"" ) ; } else if ( parameters -> max_comp_size > OPJ_CINEMA_24_COMP ) { opj_event_msg ( p_manager , EVT_WARNING , ""JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n"" ""Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n"" ""-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1041666<S2SV_blank>bytes.\\n"" ) ; parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; } parameters -> tcp_rates [ 0 ] = ( OPJ_FLOAT32 ) ( image -> numcomps * image -> comps [ 0 ] . w * image -> comps [ 0 ] . h * image -> comps [ 0 ] . prec ) / ( OPJ_FLOAT32 ) ( ( ( OPJ_UINT32 ) parameters -> max_cs_size ) * 8 * image -> comps [ 0 ] . dx * image -> comps [ 0 ] . dy ) ; }",<S2SV_ModStart> |= 0x01 ; if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> = 256 ; }
44,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 , TYPE_6 VAR_5 ) { TYPE_7 VAR_6 ; TYPE_8 VAR_7 , VAR_8 ; TYPE_9 VAR_9 = VAR_10 -> VAR_11 ; TYPE_10 VAR_12 ; TYPE_11 VAR_13 , VAR_14 ; const TYPE_12 VAR_15 = VAR_16 -> VAR_17 ; TYPE_13 VAR_18 ; TYPE_14 VAR_19 ; TYPE_15 VAR_20 ; TYPE_16 * const VAR_21 = VAR_22 -> VAR_23 ; TYPE_17 * VAR_24 = VAR_25 -> VAR_26 ; TYPE_18 * VAR_27 = VAR_28 -> VAR_29 ; TYPE_19 * VAR_30 = & VAR_31 -> VAR_32 ; VAR_33 * VAR_34 ; VAR_35 * VAR_36 ; VAR_37 * VAR_38 ; TYPE_20 VAR_39 ; TYPE_21 VAR_40 ; TYPE_22 VAR_41 ; TYPE_23 VAR_42 = VAR_43 -> VAR_44 ; VAR_45 * VAR_46 ; TYPE_24 VAR_47 ; if ( VAR_48 -> VAR_49 -> VAR_50 & VAR_51 ) { METHOD_1 ( VAR_52 ) ; return 0 ; } if ( VAR_53 -> VAR_54 -> VAR_55 && ( VAR_56 & 1 ) ) { VAR_57 ++ ; } VAR_58 -> VAR_59 -> VAR_60 = 0 ; if ( VAR_61 == 1 ) { VAR_62 -> VAR_63 -> VAR_64 = VAR_65 ; if ( ! VAR_66 -> VAR_67 ) { METHOD_2 ( VAR_68 , VAR_69 , VAR_70 -> VAR_71 -> VAR_72 ) ; VAR_73 -> VAR_74 . VAR_75 = VAR_76 -> VAR_77 -> VAR_78 ; } { TYPE_25 VAR_79 , VAR_80 , VAR_81 = 0 ; VAR_82 -> VAR_83 -> VAR_84 = 0 ; VAR_85 -> VAR_86 = VAR_87 ; VAR_88 -> VAR_89 = VAR_90 ; VAR_91 -> VAR_92 = VAR_93 ; if ( VAR_94 -> VAR_95 != VAR_96 ) VAR_97 = VAR_98 -> VAR_99 -> VAR_100 + 2 ; VAR_101 = - 1 ; for ( VAR_102 = 0 ; VAR_103 < VAR_104 ; VAR_105 ++ ) { if ( VAR_106 -> VAR_107 [ VAR_108 ] . VAR_109 == VAR_110 ) { if ( VAR_111 -> VAR_112 [ VAR_113 ] . VAR_114 -> VAR_115 == VAR_116 ) { VAR_117 = VAR_118 ; break ; } } } if ( VAR_119 == - 1 ) { <S2SV_StartBug> return VAR_120 ; <S2SV_EndBug> } if ( VAR_121 -> VAR_122 == 0 ) { VAR_123 -> VAR_124 -> VAR_125 = VAR_126 ; VAR_127 -> VAR_128 -> VAR_129 = 1 ; VAR_130 -> VAR_131 -> VAR_132 = 1 ; VAR_133 = METHOD_3 ( VAR_134 , VAR_135 , VAR_136 , VAR_137 -> VAR_138 -> VAR_139 , & VAR_140 -> VAR_141 [ VAR_142 ] ) ; if ( VAR_143 != VAR_144 ) { return VAR_145 ; } } VAR_146 -> VAR_147 [ 0 ] [ 0 ] -> VAR_148 = 0 ; VAR_149 -> VAR_150 = 0 ; { METHOD_4 ( VAR_151 , VAR_152 -> VAR_153 , & ( VAR_154 -> VAR_155 ) ) ; if ( 0 != VAR_156 -> VAR_157 . VAR_158 ) { VAR_159 -> VAR_160 = VAR_161 -> VAR_162 . VAR_163 ; } else VAR_164 -> VAR_165 = 1 ; } if ( VAR_166 -> VAR_167 == 1 ) { if ( VAR_168 -> VAR_169 == 0 ) { METHOD_5 ( VAR_170 -> VAR_171 , VAR_172 , ( TYPE_26 * ) VAR_173 , ( TYPE_27 * ) VAR_174 ) ; VAR_175 -> VAR_176 = 1 ; } if ( ( VAR_177 -> VAR_178 == 3 ) && ( ( VAR_179 -> VAR_180 == 0 ) || VAR_181 -> VAR_182 ) && ( VAR_183 -> VAR_184 == 0 ) ) { VAR_185 -> VAR_186 = 0 ; METHOD_6 ( VAR_187 -> VAR_188 , VAR_189 , ( TYPE_28 * ) VAR_190 , ( TYPE_29 * ) VAR_191 ) ; VAR_192 -> VAR_193 = 1 ; } } } VAR_194 -> VAR_195 = 0 ; } else { VAR_196 * VAR_197 ; VAR_198 = VAR_199 -> VAR_200 + VAR_201 -> VAR_202 ; if ( VAR_203 -> VAR_204 && VAR_205 == VAR_206 -> VAR_207 ) { if ( ( VAR_208 ) && ( VAR_209 -> VAR_210 & 1 ) ) { VAR_211 -> VAR_212 = VAR_213 -> VAR_214 - 1 ; VAR_215 -> VAR_216 -- ; } VAR_217 = VAR_218 -> VAR_219 ; if ( VAR_220 ) { VAR_221 = VAR_222 -> VAR_223 + VAR_224 - 1 ; } else { if ( VAR_225 -> VAR_226 ) { VAR_227 = VAR_228 -> VAR_229 ; } else { VAR_230 = VAR_231 -> VAR_232 + VAR_233 -> VAR_234 - 1 ; } } VAR_235 -> VAR_236 = VAR_237 -> VAR_238 ; VAR_239 -> VAR_240 = VAR_241 -> VAR_242 ; VAR_243 -> VAR_244 = VAR_245 -> VAR_246 ; if ( VAR_247 ) { VAR_248 -> VAR_249 = VAR_250 -> VAR_251 ; VAR_252 -> VAR_253 -- ; VAR_254 -> VAR_255 -= VAR_256 ; if ( VAR_257 -> VAR_258 == VAR_259 || VAR_260 -> VAR_261 == VAR_262 ) { VAR_263 -> METHOD_7 ( VAR_264 , VAR_265 , VAR_266 ) ; VAR_267 -> VAR_268 = VAR_269 -> VAR_270 ; } VAR_271 = VAR_272 - VAR_273 -> VAR_274 - 1 ; VAR_275 = ( ! VAR_276 ) && ( ! ( VAR_277 && ( VAR_278 & 0x01 ) ) ) ; VAR_279 = 1 ; VAR_280 = 1 ; VAR_281 -> VAR_282 = VAR_283 ; if ( VAR_284 -> VAR_285 ) { METHOD_8 ( VAR_286 , VAR_287 , VAR_288 , VAR_289 , VAR_290 , VAR_291 ) ; VAR_292 -> VAR_293 += VAR_294 ; } else { METHOD_9 ( VAR_295 , VAR_296 , VAR_297 , VAR_298 , VAR_299 , VAR_300 ) ; } VAR_301 -> VAR_302 += VAR_303 ; VAR_304 -> VAR_305 = 0 ; VAR_306 -> VAR_307 = 0 ; } if ( VAR_308 -> VAR_309 >= VAR_310 -> VAR_311 * VAR_312 -> VAR_313 ) { VAR_314 -> VAR_315 = 1 ; return 0 ; } if ( VAR_316 -> VAR_317 -> VAR_318 < ( TYPE_30 ) ( VAR_319 -> VAR_320 >> VAR_321 -> VAR_322 ) ) { VAR_323 -> VAR_324 = VAR_325 -> VAR_326 ; VAR_327 -> VAR_328 = VAR_329 -> VAR_330 ; VAR_331 -> VAR_332 ++ ; VAR_333 -> VAR_334 ++ ; } } else { VAR_335 -> VAR_336 = VAR_337 -> VAR_338 + VAR_339 -> VAR_340 ; } } { TYPE_31 VAR_341 ; TYPE_32 VAR_342 ; TYPE_33 * VAR_343 ; VAR_344 = METHOD_10 ( VAR_345 , VAR_346 -> VAR_347 ) ; VAR_348 = 2 * ( ( 2 * VAR_349 ) + 1 ) ; VAR_350 = VAR_351 * sizeof ( TYPE_34 * ) ; VAR_352 += VAR_353 * sizeof ( TYPE_35 * ) ; VAR_354 = ( TYPE_36 * ) VAR_355 -> VAR_356 ; VAR_357 += VAR_358 * VAR_359 -> VAR_360 ; VAR_361 -> VAR_362 -> VAR_363 = ( volatile TYPE_37 * * ) VAR_364 ; } VAR_365 -> VAR_366 -> VAR_367 = VAR_368 -> VAR_369 >> VAR_370 ; VAR_371 -> VAR_372 -> VAR_373 = 0 ; VAR_374 -> VAR_375 -> VAR_376 = 0 ; if ( VAR_377 -> VAR_378 -> VAR_379 ) VAR_380 -> VAR_381 = VAR_382 -> VAR_383 -> VAR_384 ; VAR_385 -> VAR_386 -> VAR_387 = VAR_388 -> VAR_389 >> VAR_390 ; VAR_391 -> VAR_392 -> VAR_393 = VAR_394 -> VAR_395 -> VAR_396 ; if ( VAR_397 -> VAR_398 ) { VAR_399 -> VAR_400 -> VAR_401 = VAR_402 -> VAR_403 ; } else { VAR_404 -> VAR_405 = VAR_406 -> VAR_407 ; } VAR_408 = VAR_409 ; VAR_410 = VAR_411 ; VAR_412 -> VAR_413 -> VAR_414 = VAR_415 ; VAR_416 -> VAR_417 -> VAR_418 = VAR_419 ; VAR_420 -> METHOD_11 = VAR_421 ; VAR_422 -> VAR_423 = VAR_424 -> VAR_425 ; VAR_426 -> VAR_427 = ( METHOD_12 ( VAR_428 -> VAR_429 -> VAR_430 - 1 , VAR_431 -> VAR_432 ) ) ; VAR_433 -> VAR_434 = ( METHOD_13 ( VAR_435 -> VAR_436 -> VAR_437 - 1 , VAR_438 -> VAR_439 ) ) ; VAR_440 -> VAR_441 <<= VAR_442 ; VAR_443 -> VAR_444 = 2 ; VAR_445 -> VAR_446 = VAR_447 -> VAR_448 ; METHOD_14 ( VAR_449 , 0 ) ; VAR_450 = VAR_451 -> VAR_452 ; VAR_453 = VAR_454 -> VAR_455 ; VAR_456 = VAR_457 ; VAR_458 = 0 ; VAR_459 = 0 ; VAR_460 = 0 ; VAR_461 = 0 ; VAR_462 = VAR_463 -> VAR_464 ; VAR_465 = VAR_466 ; while ( ! VAR_467 ) { TYPE_38 VAR_468 ; if ( VAR_469 > VAR_470 -> VAR_471 -> VAR_472 ) break ; VAR_473 = VAR_474 -> VAR_475 + VAR_476 ; VAR_477 -> VAR_478 = VAR_479 ; VAR_480 -> VAR_481 = 0 ; VAR_482 -> VAR_483 = ( VAR_484 >> VAR_485 ) ; VAR_486 = VAR_487 -> VAR_488 + VAR_489 ; VAR_490 -> VAR_491 = 0 ; VAR_492 -> VAR_493 = 1 ; VAR_494 -> VAR_495 = 0 ; if ( VAR_496 ) METHOD_15 ( VAR_497 , VAR_498 , VAR_499 , VAR_500 ) ; else METHOD_16 ( VAR_501 , VAR_502 , VAR_503 , VAR_504 ) ; if ( VAR_505 -> VAR_506 == 0 ) { METHOD_17 ( VAR_507 , VAR_508 , VAR_509 -> VAR_510 , VAR_511 -> VAR_512 ) ; } VAR_513 -> VAR_514 = 0 ; VAR_515 -> VAR_516 = 0 ; VAR_517 -> VAR_518 = VAR_519 ; VAR_520 -> VAR_521 = VAR_522 ; VAR_523 -> VAR_524 = 0 ; VAR_525 = VAR_526 -> VAR_527 ; VAR_528 -> VAR_529 = VAR_530 ; VAR_531 -> VAR_532 = 0 ; VAR_533 -> VAR_534 ++ ; METHOD_18 ( VAR_535 , VAR_536 , VAR_537 ) ; VAR_538 -> VAR_539 -> VAR_540 = VAR_541 ; VAR_542 -> VAR_543 |= VAR_544 ; VAR_545 -- ; VAR_546 -> VAR_547 = VAR_548 -> VAR_549 ; if ( VAR_550 ) { METHOD_19 ( VAR_551 , VAR_552 ) ; } VAR_553 ++ ; VAR_554 ++ ; VAR_555 ++ ; VAR_556 ++ ; VAR_557 = VAR_558 - VAR_559 -> VAR_560 - 1 ; VAR_561 = ( ! VAR_562 ) && ( ! ( VAR_563 && ( VAR_564 & 0x01 ) ) ) ; VAR_565 = ! VAR_566 ; VAR_567 = ( VAR_568 == VAR_569 -> VAR_570 ) || VAR_571 || VAR_572 ; VAR_573 = VAR_574 || VAR_575 ; VAR_576 -> VAR_577 = VAR_578 ; if ( VAR_579 ) { VAR_580 -> METHOD_20 ( VAR_581 , VAR_582 , VAR_583 ) ; VAR_584 = 0 ; VAR_585 = VAR_586 -> VAR_587 ; VAR_588 -> VAR_589 = VAR_590 -> VAR_591 ; if ( VAR_592 -> VAR_593 ) { METHOD_21 ( VAR_594 , VAR_595 , VAR_596 , VAR_597 , VAR_598 , VAR_599 ) ; VAR_600 -> VAR_601 += VAR_602 ; } else { METHOD_22 ( VAR_603 , VAR_604 , VAR_605 , VAR_606 , VAR_607 , VAR_608 ) ; } VAR_609 -> VAR_610 += VAR_611 ; if ( VAR_612 ) VAR_613 = 0 ; VAR_614 = VAR_615 ; VAR_616 -> VAR_617 = VAR_618 ; } } VAR_619 -> VAR_620 = 0 ; VAR_621 -> VAR_622 -> VAR_623 = VAR_624 - VAR_625 -> VAR_626 -> VAR_627 ; METHOD_23 ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , VAR_628 -> VAR_629 -> VAR_630 ) ; if ( VAR_631 -> VAR_632 != 0 ) { VAR_633 -> VAR_634 ++ ; VAR_635 -> VAR_636 ++ ; } VAR_637 -> VAR_638 = VAR_639 -> VAR_640 ; VAR_641 -> VAR_642 = VAR_643 -> VAR_644 ; if ( VAR_645 -> VAR_646 >= VAR_647 -> VAR_648 * VAR_649 -> VAR_650 ) { VAR_651 -> VAR_652 = 1 ; } return 0 ; }",<S2SV_ModStart> ) { return VAR_653 <S2SV_ModEnd> ; } if,"CWE-000 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",<S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } if
45,"CWE-834 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = VAR_2 -> VAR_3 ; TYPE_3 * VAR_4 = VAR_5 -> VAR_6 ; unsigned TYPE_4 TYPE_5 VAR_7 ; unsigned TYPE_6 VAR_8 ; TYPE_7 VAR_9 ; TYPE_8 VAR_10 ; TYPE_9 VAR_11 ; TYPE_10 VAR_12 ; VAR_13 -> VAR_14 = VAR_15 ; VAR_16 = METHOD_1 ( VAR_17 ) ; if ( VAR_18 < 28 ) return - 1 ; VAR_19 -> VAR_20 = VAR_21 ; VAR_22 = ( TYPE_11 ) METHOD_2 ( VAR_23 ) ; METHOD_3 ( VAR_24 , VAR_25 , ""NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n"" , VAR_26 ) ; METHOD_4 ( VAR_27 , VAR_28 , ""NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n"" , VAR_29 ) ; VAR_30 -> VAR_31 = VAR_32 = METHOD_5 ( VAR_33 ) ; METHOD_6 ( VAR_34 , VAR_35 , ""NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%"" PRId64 ""<S2SV_blank>ms\\n"" , VAR_36 ) ; VAR_37 = METHOD_7 ( VAR_38 ) ; VAR_39 = METHOD_8 ( VAR_40 ) ; VAR_41 = METHOD_9 ( VAR_42 ) ; METHOD_10 ( VAR_43 , VAR_44 , ""NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n"" , VAR_45 , VAR_46 , VAR_47 ) ; if ( METHOD_11 ( VAR_48 ) ) return - 1 ; METHOD_12 ( VAR_49 , VAR_50 , ""NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , METHOD_13 ( VAR_51 ) ) ; if ( VAR_52 > 0 ) { TYPE_12 * VAR_53 ; TYPE_13 * VAR_54 , * VAR_55 ; TYPE_14 * VAR_56 , * VAR_57 ; TYPE_15 VAR_58 ; VAR_59 = VAR_60 = METHOD_14 ( ( TYPE_16 ) VAR_61 + 1 ) ; if ( ! VAR_62 ) return METHOD_15 ( VAR_63 ) ; VAR_64 = VAR_65 + VAR_66 ; METHOD_16 ( VAR_67 , VAR_68 , VAR_69 ) ; while ( VAR_70 < VAR_71 ) { while ( * VAR_72 == '<S2SV_blank>' ) VAR_73 ++ ; if ( VAR_74 >= VAR_75 - 2 ) break ; VAR_76 = VAR_77 ; VAR_78 = METHOD_17 ( VAR_79 , '=' ) ; if ( ! VAR_80 || VAR_81 >= VAR_82 - 2 ) break ; * VAR_83 ++ = '\\0' ; VAR_84 = * VAR_85 ++ ; VAR_86 = VAR_87 ; VAR_88 = METHOD_18 ( VAR_89 , VAR_90 ) ; if ( ! VAR_91 || VAR_92 >= VAR_93 ) break ; * VAR_94 ++ = '\\0' ; METHOD_19 ( VAR_95 , VAR_96 , ""NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n"" , VAR_97 , VAR_98 ) ; METHOD_20 ( & VAR_99 -> VAR_100 , VAR_101 , VAR_102 , 0 ) ; } METHOD_21 ( VAR_103 ) ; } if ( METHOD_22 ( VAR_104 ) ) return - 1 ; METHOD_23 ( VAR_105 , VAR_106 , ""NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , METHOD_24 ( VAR_107 ) ) ; if ( VAR_108 > 0 ) { TYPE_17 VAR_109 ; VAR_110 -> VAR_111 = VAR_112 ; if ( ( unsigned ) VAR_113 >= VAR_114 / sizeof ( TYPE_18 ) ) return - 1 ; VAR_115 -> VAR_116 = METHOD_25 ( ( unsigned ) VAR_117 , sizeof ( TYPE_19 ) ) ; if ( ! VAR_118 -> VAR_119 ) return METHOD_26 ( VAR_120 ) ; <S2SV_StartBug> for ( VAR_121 = 0 ; VAR_122 < VAR_123 ; VAR_124 ++ ) <S2SV_EndBug> <S2SV_StartBug> VAR_125 -> VAR_126 [ VAR_127 ] = METHOD_27 ( VAR_128 ) + VAR_129 ; <S2SV_EndBug> if ( VAR_130 > VAR_131 && METHOD_28 ( VAR_132 ) == METHOD_29 ( 'T' , 'O' , 'C' , '2' ) ) { VAR_133 -> VAR_134 = METHOD_30 ( ( unsigned ) VAR_135 , sizeof ( TYPE_20 ) ) ; if ( ! VAR_136 -> VAR_137 ) return METHOD_31 ( VAR_138 ) ; for ( VAR_139 = 0 ; VAR_140 < VAR_141 ; VAR_142 ++ ) { VAR_143 -> VAR_144 [ VAR_145 ] = METHOD_32 ( VAR_146 ) ; } } } METHOD_33 ( VAR_147 , VAR_148 , ""NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , METHOD_34 ( VAR_149 ) ) ; METHOD_35 ( VAR_150 , VAR_151 -> VAR_152 + VAR_153 , VAR_154 ) ; if ( METHOD_36 ( VAR_155 ) ) return - 1 ; VAR_156 -> VAR_157 = VAR_158 ; return 0 ; }",<S2SV_ModStart> VAR_145 ++ ) { if ( METHOD_36 ( VAR_155 ) ) return VAR_159 ; <S2SV_ModStart> + VAR_153 ; },"CWE-834 static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n"" , size ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n"" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%"" PRId64 ""<S2SV_blank>ms\\n"" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n"" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n"" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ; <S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }",<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + size ; }
46,"CWE-264 const TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 ) { const TYPE_2 * VAR_1 ; switch ( VAR_2 ) { METHOD_1 ( VAR_3 ) case VAR_4 : VAR_5 = VAR_6 ; break ; METHOD_2 ( VAR_7 ) ; METHOD_3 ( VAR_8 ) ; METHOD_4 ( VAR_9 ) ; METHOD_5 ( VAR_10 ) ; METHOD_6 ( VAR_11 ) ; METHOD_7 ( VAR_12 ) ; METHOD_8 ( VAR_13 ) ; METHOD_9 ( VAR_14 ) ; METHOD_10 ( VAR_15 ) ; METHOD_11 ( VAR_16 ) ; METHOD_12 ( VAR_17 ) ; METHOD_13 ( VAR_18 ) ; METHOD_14 ( VAR_19 ) ; METHOD_15 ( VAR_20 ) ; <S2SV_StartBug> METHOD_16 <S2SV_EndBug> default : switch ( VAR_21 & 0xff ) { METHOD_17 ( VAR_22 , VAR_23 ) case VAR_24 : VAR_25 = VAR_26 ; break METHOD_18 ( 10 , VAR_27 ) ; METHOD_19 default : VAR_28 = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return VAR_29 ; }",<S2SV_ModStart> VAR_20 ) ; METHOD_19 ( VAR_30 ) ; METHOD_19 ( VAR_31 ) ; METHOD_19 ( VAR_32 ) ; METHOD_19 ( VAR_33 ) ; METHOD_19 ( VAR_34 ) ;,"CWE-264 const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) {   _ ( VAL ) case VAL : str =  VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <S2SV_StartBug>   _ <S2SV_EndBug> default : switch ( variable & 0xff ) {   _ ( VAL , VAR ) case VAL : str =  VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ;   _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }",<S2SV_ModStart> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
47,"CWE-269 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 TYPE_4 * VAR_2 , TYPE_5 TYPE_6 * VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 = STRUCT_OR_UNION_3 -> VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 ; struct STRUCT_OR_UNION_5 * VAR_7 ; TYPE_7 VAR_8 , VAR_9 ; TYPE_8 VAR_10 ; struct STRUCT_OR_UNION_6 * VAR_11 ; if ( VAR_12 != VAR_13 ) <S2SV_StartBug> return VAR_14 . METHOD_1 ( VAR_15 , VAR_16 , VAR_17 , VAR_18 , VAR_19 ) ; <S2SV_EndBug> if ( METHOD_2 ( VAR_20 , VAR_21 ) ) return - VAR_22 ; VAR_23 = min_t ( unsigned TYPE_9 , VAR_24 , sizeof ( TYPE_10 ) ) ; if ( VAR_25 < 0 ) return - VAR_26 ; VAR_27 = - VAR_28 ; if ( VAR_29 -> VAR_30 == VAR_31 ) goto VAR_32 ; VAR_33 = - VAR_34 ; VAR_35 = METHOD_3 ( VAR_36 ) ; if ( VAR_37 == VAR_38 ) goto VAR_39 ; VAR_40 = METHOD_4 ( VAR_41 ) ; if ( ( VAR_42 -> VAR_43 == 0 ) && ( VAR_44 -> VAR_45 == 0 ) ) { VAR_46 = - VAR_47 ; VAR_48 = METHOD_5 ( VAR_49 -> VAR_50 ) ; if ( VAR_51 == VAR_52 ) goto VAR_53 ; VAR_54 = METHOD_6 ( VAR_55 , VAR_56 , VAR_57 , & VAR_58 ) ; METHOD_7 ( VAR_59 -> VAR_60 ) ; } else VAR_61 = METHOD_8 ( VAR_62 , VAR_63 , VAR_64 , & VAR_65 ) ; VAR_66 = - VAR_67 ; if ( METHOD_9 ( VAR_68 , VAR_69 ) ) goto VAR_70 ; if ( METHOD_10 ( ( TYPE_11 TYPE_12 * ) VAR_71 , & VAR_72 , VAR_73 ) ) goto VAR_74 ; VAR_75 = 0 ; VAR_76 : METHOD_11 ( VAR_77 ) ; VAR_78 : return VAR_79 ; }",<S2SV_ModStart> VAR_13 ) return - VAR_26 <S2SV_ModEnd> ; if (,"CWE-269 static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }",<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
48,"CWE-284 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 VAR_3 = 0 ; TYPE_5 * VAR_4 ; TYPE_6 VAR_5 ; METHOD_1 ( VAR_6 [ 0 ] ) ; VAR_7 = VAR_8 ; if ( METHOD_2 ( ""my"" , VAR_9 , & VAR_10 , & VAR_11 ) ) METHOD_3 ( 1 ) ; VAR_12 = VAR_13 ; METHOD_4 ( & VAR_14 , & VAR_15 ) ; VAR_16 = 0 ; if ( VAR_17 ) { TYPE_7 * VAR_18 = VAR_19 [ VAR_20 - 1 ] , * VAR_21 ; for ( VAR_22 = VAR_23 ; * VAR_24 ; VAR_25 ++ , VAR_26 ++ ) { switch ( * VAR_27 ) { case '*' : * VAR_28 = '%' ; VAR_29 = 1 ; break ; case '?' : * VAR_30 = '_' ; VAR_31 = 1 ; break ; case '%' : case '_' : VAR_32 = 1 ; break ; case '\\\\' : VAR_33 ++ ; default : break ; } * VAR_34 = * VAR_35 ; } * VAR_36 = * VAR_37 ; } if ( VAR_38 ) VAR_39 = VAR_40 [ -- VAR_41 ] ; else if ( VAR_42 == 3 ) VAR_43 = VAR_44 [ -- VAR_45 ] ; if ( VAR_46 > 2 ) { METHOD_5 ( VAR_47 , ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>arguments\\n"" , VAR_48 ) ; METHOD_6 ( 1 ) ; } METHOD_7 ( & VAR_49 ) ; if ( VAR_50 ) METHOD_8 ( & VAR_51 , VAR_52 , VAR_53 ) ; <S2SV_StartBug> TYPE_8 TYPE_9 <S2SV_EndBug> if ( VAR_54 ) { METHOD_9 ( & VAR_55 , VAR_56 , VAR_57 , VAR_58 , VAR_59 , VAR_60 ) ; METHOD_10 ( & VAR_61 , VAR_62 , VAR_63 ) ; METHOD_11 ( & VAR_64 , VAR_65 , VAR_66 ) ; } METHOD_12 ( & VAR_67 , VAR_68 , ( TYPE_10 * ) & VAR_69 ) ; if ( VAR_70 ) METHOD_13 ( & VAR_71 , VAR_72 , ( TYPE_11 * ) & VAR_73 ) ; if ( VAR_74 ) METHOD_14 ( & VAR_75 , VAR_76 , VAR_77 ) ; if METHOD_15 ( VAR_78 ) && ! METHOD_16 ( VAR_79 ) if ( VAR_80 ) METHOD_17 ( & VAR_81 , VAR_82 , VAR_83 ) ; METHOD_18 ( & VAR_84 , VAR_85 , VAR_86 ) ; if ( VAR_87 && * VAR_88 ) METHOD_19 ( & VAR_89 , VAR_90 , VAR_91 ) ; if ( VAR_92 && * VAR_93 ) METHOD_20 ( & VAR_94 , VAR_95 , VAR_96 ) ; METHOD_21 ( & VAR_97 , VAR_98 , 0 ) ; METHOD_22 ( & VAR_99 , VAR_100 , ""program_name"" , ""mysqlshow"" ) ; if ( ! ( METHOD_23 ( & VAR_101 , VAR_102 , VAR_103 , VAR_104 , ( VAR_105 ) ? """" : VAR_106 [ 0 ] , VAR_107 , VAR_108 , 0 ) ) ) { METHOD_24 ( VAR_109 , ""%s:<S2SV_blank>%s\\n"" , VAR_110 , METHOD_25 ( & VAR_111 ) ) ; METHOD_26 ( 1 ) ; } VAR_112 . VAR_113 = 1 ; switch ( VAR_114 ) { case 0 : VAR_115 = METHOD_27 ( & VAR_116 , VAR_117 ) ; break ; case 1 : if ( VAR_118 ) VAR_119 = METHOD_28 ( & VAR_120 , VAR_121 [ 0 ] , VAR_122 ) ; else VAR_123 = METHOD_29 ( & VAR_124 , VAR_125 [ 0 ] , VAR_126 ) ; break ; default : if ( VAR_127 && ! VAR_128 ) VAR_129 = METHOD_30 ( & VAR_130 , VAR_131 [ 0 ] , VAR_132 [ 1 ] ) ; else VAR_133 = METHOD_31 ( & VAR_134 , VAR_135 [ 0 ] , VAR_136 [ 1 ] , VAR_137 ) ; break ; } METHOD_32 ( & VAR_138 ) ; METHOD_33 ( VAR_139 ) ; if METHOD_34 ( VAR_140 ) && ! METHOD_35 ( VAR_141 ) METHOD_36 ( VAR_142 ) ; METHOD_37 ( VAR_143 ) ; METHOD_38 ( VAR_144 ? 1 : 0 ) ; return 0 ; }",<S2SV_ModStart> VAR_53 ) ; METHOD_39 ( & VAR_138 ) ; <S2SV_ModEnd> if ( VAR_73,"CWE-284 int main ( int argc , char * * argv ) { int error ; my_bool first_argument_uses_wildcards = 0 ; char * wild ; MYSQL mysql ; MY_INIT ( argv [ 0 ] ) ; my_getopt_use_args_separator = TRUE ; if ( load_defaults ( ""my"" , load_default_groups , & argc , & argv ) ) exit ( 1 ) ; my_getopt_use_args_separator = FALSE ; get_options ( & argc , & argv ) ; wild = 0 ; if ( argc ) { char * pos = argv [ argc - 1 ] , * to ; for ( to = pos ; * pos ; pos ++ , to ++ ) { switch ( * pos ) { case '*' : * pos = '%' ; first_argument_uses_wildcards = 1 ; break ; case '?' : * pos = '_' ; first_argument_uses_wildcards = 1 ; break ; case '%' : case '_' : first_argument_uses_wildcards = 1 ; break ; case '\\\\' : pos ++ ; default : break ; } * to = * pos ; } * to = * pos ; } if ( first_argument_uses_wildcards ) wild = argv [ -- argc ] ; else if ( argc == 3 ) wild = argv [ -- argc ] ; if ( argc > 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>arguments\\n"" , my_progname ) ; exit ( 1 ) ; } mysql_init ( & mysql ) ; if ( opt_compress ) mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug>  ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;   if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql , MYSQL_OPT_BIND , opt_bind_addr ) ;  if d ( _WIN32 ) && ! d ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ;   mysql_options ( & mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlshow"" ) ; if ( ! ( mysql_real_connect ( & mysql , host , user , opt_password , ( first_argument_uses_wildcards ) ? """" : argv [ 0 ] , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>%s\\n"" , my_progname , mysql_error ( & mysql ) ) ; exit ( 1 ) ; } mysql . reconnect = 1 ; switch ( argc ) { case 0 : error = list_dbs ( & mysql , wild ) ; break ; case 1 : if ( opt_status ) error = list_table_status ( & mysql , argv [ 0 ] , wild ) ; else error = list_tables ( & mysql , argv [ 0 ] , wild ) ; break ; default : if ( opt_status && ! wild ) error = list_table_status ( & mysql , argv [ 0 ] , argv [ 1 ] ) ; else error = list_fields ( & mysql , argv [ 0 ] , argv [ 1 ] , wild ) ; break ; } mysql_close ( & mysql ) ; my_free ( opt_password ) ;  if d ( _WIN32 ) && ! d ( EMBEDDED_LIBRARY ) my_free ( shared_memory_base_name ) ;   my_end ( my_end_arg ) ; exit ( error ? 1 : 0 ) ; return 0 ; }",<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> if ( opt_protocol
49,"CWE-000 struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , TYPE_0 VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; struct STRUCT_OR_UNION_3 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 ; struct STRUCT_OR_UNION_5 * VAR_7 ; struct STRUCT_OR_UNION_6 * VAR_8 ; TYPE_1 VAR_9 , VAR_10 ; TYPE_2 VAR_11 ; struct STRUCT_OR_UNION_7 * VAR_12 = VAR_13 ; if ( METHOD_1 ( VAR_14 ) -> VAR_15 == 0 ) { METHOD_2 ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n"" ) ; return VAR_16 ; } if ( METHOD_3 ( VAR_17 , & VAR_18 , & VAR_19 , & VAR_20 ) < 0 ) return VAR_21 ; VAR_22 = METHOD_4 ( VAR_23 , VAR_24 ) ; if ( VAR_25 == VAR_26 ) { METHOD_5 ( ""Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n"" ) ; return VAR_27 ; } METHOD_6 ( VAR_28 ) -> VAR_29 = VAR_30 ; if ( ! METHOD_7 ( VAR_31 , VAR_32 + sizeof ( * VAR_33 ) ) ) { METHOD_8 ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; goto VAR_34 ; } METHOD_9 ( VAR_35 , VAR_36 ) ; VAR_37 = METHOD_10 ( VAR_38 ) ; VAR_39 = ( struct STRUCT_OR_UNION_8 * ) METHOD_11 ( VAR_40 ) ; <S2SV_StartBug> if ( ! ( VAR_41 -> VAR_42 & METHOD_12 ( 0xFFF9 ) ) ) { <S2SV_EndBug> METHOD_13 ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n"" ) ; goto VAR_43 ; } if ( METHOD_14 ( & VAR_44 . VAR_45 ) > VAR_46 . VAR_47 ) METHOD_15 ( ) ; VAR_48 = METHOD_16 ( VAR_49 -> VAR_50 , VAR_51 , & VAR_52 -> VAR_53 , & VAR_54 -> VAR_55 ) ; if ( VAR_56 == VAR_57 ) { METHOD_17 ( ""Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n"" ) ; goto VAR_58 ; } METHOD_18 ( & VAR_59 -> VAR_60 . VAR_61 ) ; if ( STRUCT_OR_UNION_9 ( VAR_62 , VAR_63 , VAR_64 , VAR_65 ) < 0 ) { METHOD_19 ( & VAR_66 -> VAR_67 . VAR_68 ) ; METHOD_20 ( ""Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n"" ) ; METHOD_21 ( VAR_69 ) ; goto VAR_70 ; } if ( VAR_71 -> VAR_72 . VAR_73 == ( VAR_74 | VAR_75 ) && VAR_76 -> VAR_77 . VAR_78 == VAR_79 -> VAR_80 . VAR_81 ) { VAR_82 = METHOD_22 ( VAR_83 , VAR_84 ) ; if ( VAR_85 == VAR_86 ) METHOD_23 ( ""Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n"" ) ; } METHOD_24 ( & VAR_87 -> VAR_88 . VAR_89 ) ; METHOD_25 ( VAR_90 ) ; return VAR_91 ; VAR_92 : METHOD_26 ( VAR_93 ) ; return VAR_94 ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> METHOD_14 ( &,"CWE-000 struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n"" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n"" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n"" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n"" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( ""Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n"" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( ""Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n"" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
50,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 VAR_4 ; VAR_5 = METHOD_1 ( VAR_6 ) - VAR_7 ; if ( VAR_8 > 1536 ) { METHOD_2 ( & VAR_9 -> VAR_10 ) ; return VAR_11 ; } if ( ! VAR_12 -> VAR_13 ) { METHOD_3 ( & VAR_14 -> VAR_15 ) ; return VAR_16 ; } <S2SV_StartBug> if ( METHOD_4 ( VAR_17 , VAR_18 ) & VAR_19 ) <S2SV_EndBug> { return VAR_20 ; } <S2SV_StartBug> METHOD_5 ( VAR_21 , VAR_22 , VAR_23 ) ; <S2SV_EndBug> METHOD_6 ( VAR_24 , VAR_25 , VAR_26 , VAR_27 ) ; <S2SV_StartBug> METHOD_7 ( VAR_28 , VAR_29 , VAR_30 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_8 ( VAR_31 , VAR_32 , VAR_33 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_9 ( VAR_34 , VAR_35 , VAR_36 | VAR_37 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_10 ( VAR_38 , VAR_39 , VAR_40 ) ; <S2SV_EndBug> return VAR_41 ; }","<S2SV_ModStart> ( VAR_38 , VAR_42 ) & VAR_43 <S2SV_ModEnd> ) { return <S2SV_ModStart> ( VAR_38 , VAR_44 <S2SV_ModEnd> , VAR_30 ) <S2SV_ModStart> ( VAR_38 , VAR_45 <S2SV_ModEnd> , VAR_30 ) <S2SV_ModStart> ( VAR_38 , ENC624J600_ETXLEN <S2SV_ModEnd> , VAR_33 ) <S2SV_ModStart> ( VAR_38 , VAR_46 , VAR_47 | VAR_48 <S2SV_ModEnd> ) ; METHOD_10 <S2SV_ModStart> ( VAR_38 , VAR_42 , VAR_43 <S2SV_ModEnd> ) ; return","CWE-20 error_t enc624j600SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> { return ERROR_FAILURE ; } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }","<S2SV_ModStart> ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , ENC624J600_EGPWRPT <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXST <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXLEN <S2SV_ModEnd> , length ) <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) ; return"
51,"CWE-189 TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 * VAR_2 = METHOD_1 ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( TYPE_4 ) + sizeof ( TYPE_5 ) * ( VAR_3 + VAR_4 ) ) ; <S2SV_EndBug> if ( VAR_5 ) { VAR_6 -> VAR_7 = sizeof ( TYPE_6 ) ; VAR_8 -> VAR_9 = VAR_10 ; VAR_11 -> VAR_12 = VAR_13 ; } return VAR_14 ; }",<S2SV_ModStart> VAR_13 ) { if ( VAR_10 < 0 || VAR_13 < 0 || VAR_10 > VAR_15 || VAR_13 > VAR_16 ) { return VAR_17 ; } TYPE_7 VAR_18 = <S2SV_ModEnd> sizeof ( TYPE_6 <S2SV_ModStart> TYPE_6 ) + ( <S2SV_ModStart> + VAR_13 ) ) ; TYPE_6 * VAR_14 = METHOD_1 ( VAR_18,"CWE-189 native_handle_t * native_handle_create ( int numFds , int numInts ) { <S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> if ( h ) { h -> version = sizeof ( native_handle_t ) ; h -> numFds = numFds ; h -> numInts = numInts ; } return h ; }",<S2SV_ModStart> numInts ) { if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = <S2SV_ModEnd> sizeof ( native_handle_t <S2SV_ModStart> native_handle_t ) + ( <S2SV_ModStart> + numInts ) ) ; native_handle_t * h = malloc ( mallocSize
52,"CWE-119 static VAR_0 TYPE_0 METHOD_0 ( TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) <S2SV_StartBug> { if ( VAR_3 -> VAR_4 < METHOD_1 ( VAR_5 -> VAR_6 ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { VAR_7 -> VAR_8 [ VAR_9 -> VAR_10 ++ ] = ( VAR_11 >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_12 -> VAR_13 [ VAR_14 -> VAR_15 ++ ] = ( VAR_16 >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_17 -> VAR_18 [ VAR_19 -> VAR_20 ++ ] = VAR_21 ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }",<S2SV_ModStart> VAR_21 ) { <S2SV_ModEnd> VAR_19 -> VAR_18 <S2SV_ModStart> VAR_19 -> VAR_18 . VAR_22 [ <S2SV_ModEnd> VAR_19 -> VAR_18 <S2SV_ModStart> VAR_19 -> VAR_18 . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> VAR_19 -> VAR_18 . VAR_22 <S2SV_ModStart> [ VAR_19 -> VAR_18 . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> VAR_19 -> VAR_18 . VAR_22 <S2SV_ModStart> [ VAR_19 -> VAR_18 . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> VAR_21 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,"CWE-119 static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }",<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
53,"CWE-264 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , unsigned TYPE_2 VAR_1 , unsigned TYPE_3 VAR_2 , struct STRUCT_OR_UNION_0 * VAR_3 ) { VAR_4 * VAR_5 ; unsigned TYPE_4 VAR_6 ; TYPE_5 VAR_7 = 0 ; VAR_8 = METHOD_1 ( VAR_9 , VAR_10 ) ; do { VAR_11 : VAR_12 = METHOD_2 ( VAR_13 , VAR_14 ) ; if ( METHOD_3 ( * VAR_15 ) ) { if ( VAR_16 -> METHOD_4 ) VAR_17 = VAR_18 -> METHOD_5 ( VAR_19 , VAR_20 , VAR_21 ) ; if ( VAR_22 ) break ; continue ; } if ( VAR_23 -> METHOD_6 ) VAR_24 = VAR_25 -> METHOD_7 ( VAR_26 , VAR_27 , VAR_28 , VAR_29 ) ; if ( VAR_30 ) break ; if ( ! VAR_31 -> VAR_32 ) continue ; METHOD_8 ( VAR_33 -> VAR_34 , VAR_35 ) ; <S2SV_StartBug> if ( METHOD_9 ( VAR_36 ) ) <S2SV_EndBug> goto VAR_37 ; VAR_38 = METHOD_10 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; if ( VAR_43 ) break ; } while ( VAR_44 ++ , VAR_45 = VAR_46 , VAR_47 != VAR_48 ) ; return VAR_49 ; }",<S2SV_ModStart> ; if ( METHOD_11 <S2SV_ModEnd> ( VAR_44 ),"CWE-264 static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }",<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
54,"CWE-254 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { VAR_1 * VAR_2 ; VAR_3 = & VAR_4 -> VAR_5 ; METHOD_1 ( VAR_6 , VAR_7 ) ; METHOD_2 ( VAR_8 , 10 ) ; VAR_9 -> VAR_10 = ( TYPE_2 ) METHOD_3 ( VAR_11 , 3 ) ; if ( ( VAR_12 -> VAR_13 < VAR_14 ) || ( VAR_15 -> VAR_16 > VAR_17 ) ) { METHOD_4 ( VAR_18 , VAR_19 ) ; return VAR_20 ; } METHOD_5 ( VAR_21 , 16 ) ; if ( VAR_22 -> VAR_23 == VAR_24 || VAR_25 -> VAR_26 == VAR_27 ) { VAR_28 -> VAR_29 = METHOD_6 ( VAR_30 ) ; VAR_31 -> VAR_32 = METHOD_7 ( VAR_33 , 3 ) ; } if ( VAR_34 -> VAR_35 == VAR_36 ) { VAR_37 -> VAR_38 = METHOD_8 ( VAR_39 ) ; VAR_40 -> VAR_41 = METHOD_9 ( VAR_42 , 3 ) ; } if ( VAR_43 -> VAR_44 == 0 ) { VAR_45 -> VAR_46 [ 0 ] [ 0 ] = VAR_47 -> VAR_48 [ 0 ] [ 1 ] = VAR_49 -> VAR_50 ; VAR_51 -> VAR_52 [ 1 ] [ 0 ] = VAR_53 -> VAR_54 [ 1 ] [ 1 ] = VAR_55 -> VAR_56 ; } <S2SV_StartBug> while ( METHOD_10 ( VAR_57 , 1 ) == 1 ) <S2SV_EndBug> { METHOD_11 ( VAR_58 , 9 ) ; } METHOD_12 ( VAR_59 ) ; METHOD_13 ( VAR_60 ) ; return ( TYPE_3 ) VAR_61 ; }",<S2SV_ModStart> ) == 1 && VAR_59 -> VAR_62 < VAR_59 -> VAR_63,"CWE-254 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }",<S2SV_ModStart> ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
55,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , const struct STRUCT_OR_UNION_0 * VAR_4 , const struct STRUCT_OR_UNION_1 * VAR_5 ) { TYPE_5 VAR_6 , VAR_7 , VAR_8 , VAR_9 ; TYPE_6 VAR_10 ; TYPE_7 VAR_11 ; TYPE_8 VAR_12 ; if ( VAR_13 < 3 ) { METHOD_1 ( ( VAR_14 , ""[|llc]"" ) ) ; METHOD_2 ( ( const TYPE_9 * ) VAR_15 , VAR_16 ) ; return ( VAR_17 ) ; } if ( VAR_18 < 3 ) { METHOD_3 ( ( VAR_19 , ""[|llc]"" ) ) ; METHOD_4 ( ( const TYPE_10 * ) VAR_20 , VAR_21 ) ; return ( VAR_22 ) ; } VAR_23 = * VAR_24 ; VAR_25 = * ( VAR_26 + 1 ) ; VAR_27 = * ( VAR_28 + 2 ) ; if ( ( VAR_29 & VAR_30 ) == VAR_31 ) { VAR_32 = 1 ; VAR_33 = 3 ; } else { if ( VAR_34 < 4 ) { METHOD_5 ( ( VAR_35 , ""[|llc]"" ) ) ; METHOD_6 ( ( const TYPE_11 * ) VAR_36 , VAR_37 ) ; return ( VAR_38 ) ; } if ( VAR_39 < 4 ) { METHOD_7 ( ( VAR_40 , ""[|llc]"" ) ) ; METHOD_8 ( ( const TYPE_12 * ) VAR_41 , VAR_42 ) ; return ( VAR_43 ) ; } VAR_44 = METHOD_9 ( VAR_45 + 2 ) ; VAR_46 = 0 ; VAR_47 = 4 ; } if ( VAR_48 == VAR_49 && VAR_50 == VAR_51 ) { if ( VAR_52 -> VAR_53 ) METHOD_10 ( ( VAR_54 , ""IPX<S2SV_blank>802.3:<S2SV_blank>"" ) ) ; METHOD_11 ( VAR_55 , VAR_56 , VAR_57 ) ; return ( 0 ) ; } VAR_58 = VAR_59 & ~ VAR_60 ; VAR_61 = VAR_62 & ~ VAR_63 ; if ( VAR_64 -> VAR_65 ) { METHOD_12 ( ( VAR_66 , ""LLC,<S2SV_blank>dsap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s,<S2SV_blank>ssap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s"" , METHOD_13 ( VAR_67 , ""Unknown"" , VAR_68 ) , VAR_69 , METHOD_14 ( VAR_70 , ""Unknown"" , VAR_71 & VAR_72 ) , METHOD_15 ( VAR_73 , ""Unknown"" , VAR_74 ) , VAR_75 , METHOD_16 ( VAR_76 , ""Unknown"" , VAR_77 & VAR_78 ) ) ) ; if ( VAR_79 ) { METHOD_17 ( ( VAR_80 , "",<S2SV_blank>ctrl<S2SV_blank>0x%02x:<S2SV_blank>"" , VAR_81 ) ) ; } else { METHOD_18 ( ( VAR_82 , "",<S2SV_blank>ctrl<S2SV_blank>0x%04x:<S2SV_blank>"" , VAR_83 ) ) ; } } VAR_84 += VAR_85 ; VAR_86 -= VAR_87 ; VAR_88 -= VAR_89 ; if ( VAR_90 == VAR_91 && VAR_92 == VAR_93 && VAR_94 == VAR_95 ) { if ( ! METHOD_19 ( VAR_96 , VAR_97 , VAR_98 , VAR_99 , VAR_100 , VAR_101 , 2 ) ) { return ( - ( VAR_102 + 5 ) ) ; } else return ( VAR_103 + 5 ) ; } if ( VAR_104 == VAR_105 && VAR_106 == VAR_107 && VAR_108 == VAR_109 ) { METHOD_20 ( VAR_110 , VAR_111 , VAR_112 ) ; return ( VAR_113 ) ; } if ( VAR_114 == VAR_115 && VAR_116 == VAR_117 && VAR_118 == VAR_119 ) { METHOD_21 ( VAR_120 , VAR_121 , VAR_122 ) ; return ( VAR_123 ) ; } if ( VAR_124 == VAR_125 && VAR_126 == VAR_127 && VAR_128 == VAR_129 ) { if ( VAR_130 -> VAR_131 ) METHOD_22 ( ( VAR_132 , ""IPX<S2SV_blank>802.2:<S2SV_blank>"" ) ) ; METHOD_23 ( VAR_133 , VAR_134 , VAR_135 ) ; return ( VAR_136 ) ; } TYPE_13 TYPE_14 if ( VAR_137 == VAR_138 && VAR_139 == VAR_140 && ( ! ( VAR_141 & VAR_142 ) || VAR_143 == VAR_144 ) ) { METHOD_24 ( VAR_145 , VAR_146 , VAR_147 , VAR_148 ) ; return ( VAR_149 ) ; } if ( VAR_150 == VAR_151 && VAR_152 == VAR_153 && VAR_154 == VAR_155 ) { <S2SV_StartBug> METHOD_25 ( VAR_156 , VAR_157 , VAR_158 , VAR_159 ) ; <S2SV_EndBug> return ( VAR_160 ) ; } if ( ! VAR_161 -> VAR_162 ) { if ( VAR_163 == VAR_164 ) { if ( VAR_165 == VAR_166 || VAR_167 == VAR_168 ) METHOD_26 ( ( VAR_169 , ""%s<S2SV_blank>"" , METHOD_27 ( VAR_170 , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , VAR_171 ) ) ) ; else METHOD_28 ( ( VAR_172 , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( VAR_173 -> VAR_174 ) ( VAR_175 , VAR_176 -> VAR_177 ) , ( VAR_178 -> VAR_179 ) ( VAR_180 , VAR_181 -> VAR_182 ) , METHOD_29 ( VAR_183 , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , VAR_184 ) ) ) ; } else { if ( VAR_185 == VAR_186 || VAR_187 == VAR_188 ) METHOD_30 ( ( VAR_189 , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>"" , METHOD_31 ( VAR_190 , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , VAR_191 ) , METHOD_32 ( VAR_192 , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , VAR_193 ) ) ) ; else METHOD_33 ( ( VAR_194 , ""%s<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( VAR_195 -> VAR_196 ) ( VAR_197 , VAR_198 -> VAR_199 ) , METHOD_34 ( VAR_200 , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , VAR_201 ) , ( VAR_202 -> VAR_203 ) ( VAR_204 , VAR_205 -> VAR_206 ) , METHOD_35 ( VAR_207 , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , VAR_208 ) ) ) ; } } if ( VAR_209 ) { METHOD_36 ( ( VAR_210 , ""Unnumbered,<S2SV_blank>%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , METHOD_37 ( VAR_211 , ""%02x"" , METHOD_38 ( VAR_212 ) ) , METHOD_39 ( VAR_213 , ""?"" , ( VAR_214 & VAR_215 ) | ( VAR_216 & VAR_217 ) ) , VAR_218 + VAR_219 ) ) ; if ( ( VAR_220 & ~ VAR_221 ) == VAR_222 ) { if ( VAR_223 == 0 ) { return ( VAR_224 ) ; } if ( VAR_225 < 1 ) { METHOD_40 ( ( VAR_226 , ""[|llc]"" ) ) ; if ( VAR_227 > 0 ) METHOD_41 ( ( const TYPE_15 * ) VAR_228 , VAR_229 ) ; return ( VAR_230 ) ; } if ( * VAR_231 == VAR_232 ) { if ( VAR_233 < 3 || VAR_234 < 3 ) { METHOD_42 ( ( VAR_235 , ""[|llc]"" ) ) ; if ( VAR_236 > 0 ) METHOD_43 ( ( const TYPE_16 * ) VAR_237 , VAR_238 ) ; } else METHOD_44 ( ( VAR_239 , "":<S2SV_blank>%02x<S2SV_blank>%02x"" , VAR_240 [ 1 ] , VAR_241 [ 2 ] ) ) ; return ( VAR_242 ) ; } } } else { if ( ( VAR_243 & VAR_244 ) == VAR_245 ) { METHOD_45 ( ( VAR_246 , ""Supervisory,<S2SV_blank>%s,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , METHOD_46 ( VAR_247 , ""?"" , METHOD_47 ( VAR_248 ) ) , METHOD_48 ( VAR_249 ) , METHOD_49 ( VAR_250 , ""?"" , ( VAR_251 & VAR_252 ) | ( VAR_253 & VAR_254 ) ) , VAR_255 + VAR_256 ) ) ; return ( VAR_257 ) ; } else { METHOD_50 ( ( VAR_258 , ""Information,<S2SV_blank>send<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , METHOD_51 ( VAR_259 ) , METHOD_52 ( VAR_260 ) , METHOD_53 ( VAR_261 , ""?"" , ( VAR_262 & VAR_263 ) | ( VAR_264 & VAR_265 ) ) , VAR_266 + VAR_267 ) ) ; } } return ( - VAR_268 ) ; }","<S2SV_ModStart> VAR_241 , VAR_266 <S2SV_ModEnd> ) ; return","CWE-125 int llc_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { uint8_t dsap_field , dsap , ssap_field , ssap ; uint16_t control ; int hdrlen ; int is_u ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } dsap_field = * p ; ssap_field = * ( p + 1 ) ; control = * ( p + 2 ) ; if ( ( control & LLC_U_FMT ) == LLC_U_FMT ) { is_u = 1 ; hdrlen = 3 ; } else { if ( caplen < 4 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 4 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } control = EXTRACT_LE_16BITS ( p + 2 ) ; is_u = 0 ; hdrlen = 4 ; } if ( ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IPX<S2SV_blank>802.3:<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 0 ) ; } dsap = dsap_field & ~ LLC_IG ; ssap = ssap_field & ~ LLC_GSAP ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""LLC,<S2SV_blank>dsap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s,<S2SV_blank>ssap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s"" , tok2str ( llc_values , ""Unknown"" , dsap ) , dsap , tok2str ( llc_ig_flag_values , ""Unknown"" , dsap_field & LLC_IG ) , tok2str ( llc_values , ""Unknown"" , ssap ) , ssap , tok2str ( llc_flag_values , ""Unknown"" , ssap_field & LLC_GSAP ) ) ) ; if ( is_u ) { ND_PRINT ( ( ndo , "",<S2SV_blank>ctrl<S2SV_blank>0x%02x:<S2SV_blank>"" , control ) ) ; } else { ND_PRINT ( ( ndo , "",<S2SV_blank>ctrl<S2SV_blank>0x%04x:<S2SV_blank>"" , control ) ) ; } } p += hdrlen ; length -= hdrlen ; caplen -= hdrlen ; if ( ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP && control == LLC_UI ) { if ( ! snap_print ( ndo , p , length , caplen , src , dst , 2 ) ) { return ( - ( hdrlen + 5 ) ) ; } else return ( hdrlen + 5 ) ; } if ( ssap == LLCSAP_8021D && dsap == LLCSAP_8021D && control == LLC_UI ) { stp_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IP && dsap == LLCSAP_IP && control == LLC_UI ) { ip_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IPX && dsap == LLCSAP_IPX && control == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IPX<S2SV_blank>802.2:<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( hdrlen ) ; }  ifdef ENABLE_SMB if ( ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI && ( ! ( control & LLC_S_FMT ) || control == LLC_U_FMT ) ) { netbeui_print ( ndo , control , p , length ) ; return ( hdrlen ) ; }   if ( ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS && control == LLC_UI ) { <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> return ( hdrlen ) ; } if ( ! ndo -> ndo_eflag ) { if ( ssap == dsap ) { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( src -> addr_string ) ( ndo , src -> addr ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; } else { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>"" , tok2str ( llc_values , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , ssap ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; else ND_PRINT ( ( ndo , ""%s<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" , ( src -> addr_string ) ( ndo , src -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x"" , ssap ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , ""Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x"" , dsap ) ) ) ; } } if ( is_u ) { ND_PRINT ( ( ndo , ""Unnumbered,<S2SV_blank>%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( llc_cmd_values , ""%02x"" , LLC_U_CMD ( control ) ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_U_POLL ) ) , length + hdrlen ) ) ; if ( ( control & ~ LLC_U_POLL ) == LLC_XID ) { if ( length == 0 ) { return ( hdrlen ) ; } if ( caplen < 1 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( hdrlen ) ; } if ( * p == LLC_XID_FI ) { if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , ""[|llc]"" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; } else ND_PRINT ( ( ndo , "":<S2SV_blank>%02x<S2SV_blank>%02x"" , p [ 1 ] , p [ 2 ] ) ) ; return ( hdrlen ) ; } } } else { if ( ( control & LLC_S_FMT ) == LLC_S_FMT ) { ND_PRINT ( ( ndo , ""Supervisory,<S2SV_blank>%s,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( llc_supervisory_values , ""?"" , LLC_S_CMD ( control ) ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; return ( hdrlen ) ; } else { ND_PRINT ( ( ndo , ""Information,<S2SV_blank>send<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , LLC_I_NS ( control ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , ""?"" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; } } return ( - hdrlen ) ; }","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; return"
56,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 , VAR_2 ; TYPE_3 VAR_3 , VAR_4 ; VAR_5 * VAR_6 ; unsigned TYPE_4 * VAR_7 = VAR_8 ; unsigned TYPE_5 VAR_9 ; VAR_10 * VAR_11 ; unsigned TYPE_6 VAR_12 ; VAR_13 = & ( VAR_14 -> VAR_15 -> VAR_16 ) ; METHOD_1 ( VAR_17 ) ; if ( METHOD_2 ( VAR_18 ) ) return 1 ; VAR_19 : if ( ( VAR_20 -> VAR_21 != VAR_22 ) || ( VAR_23 -> VAR_24 < VAR_25 ) ) { VAR_26 = METHOD_3 ( VAR_27 , VAR_28 , VAR_29 -> VAR_30 -> VAR_31 . VAR_32 , 0 ) ; if ( VAR_33 <= 0 ) return ( VAR_34 ) ; if ( VAR_35 -> VAR_36 != VAR_37 ) { VAR_38 -> VAR_39 = 0 ; goto VAR_40 ; } VAR_41 -> VAR_42 = VAR_43 ; VAR_44 = VAR_45 -> VAR_46 ; if ( VAR_47 -> METHOD_4 ) VAR_48 -> METHOD_5 ( 0 , 0 , VAR_49 , VAR_50 , VAR_51 , VAR_52 , VAR_53 -> VAR_54 ) ; VAR_55 -> VAR_56 = * ( VAR_57 ++ ) ; VAR_58 = * ( VAR_59 ++ ) ; VAR_60 = * ( VAR_61 ++ ) ; VAR_62 = ( VAR_63 << 8 ) | VAR_64 ; METHOD_6 ( VAR_65 , VAR_66 -> VAR_67 ) ; METHOD_7 ( & ( VAR_68 -> VAR_69 -> VAR_70 [ 2 ] ) , VAR_71 , 6 ) ; VAR_72 += 6 ; METHOD_8 ( VAR_73 , VAR_74 -> VAR_75 ) ; if ( ! VAR_76 -> VAR_77 ) { if ( VAR_78 != VAR_79 -> VAR_80 ) { VAR_81 -> VAR_82 = 0 ; VAR_83 -> VAR_84 = 0 ; goto VAR_85 ; } } if ( ( VAR_86 & 0xff00 ) != ( VAR_87 -> VAR_88 & 0xff00 ) ) { VAR_89 -> VAR_90 = 0 ; VAR_91 -> VAR_92 = 0 ; goto VAR_93 ; } if ( VAR_94 -> VAR_95 > VAR_96 ) { VAR_97 -> VAR_98 = 0 ; VAR_99 -> VAR_100 = 0 ; goto VAR_101 ; } } if ( VAR_102 -> VAR_103 > VAR_104 -> VAR_105 - VAR_106 ) { VAR_107 = VAR_108 -> VAR_109 ; VAR_110 = METHOD_9 ( VAR_111 , VAR_112 , VAR_113 , 1 ) ; if ( VAR_114 != VAR_115 ) { VAR_116 -> VAR_117 = 0 ; VAR_118 -> VAR_119 = 0 ; goto VAR_120 ; } } VAR_121 -> VAR_122 = VAR_123 ; VAR_124 = METHOD_10 ( VAR_125 , VAR_126 , & VAR_127 ) ; if ( VAR_128 == VAR_129 ) { VAR_130 -> VAR_131 = 0 ; VAR_132 -> VAR_133 = 0 ; goto VAR_134 ; } TYPE_7 TYPE_8 if ( ! METHOD_11 ( METHOD_12 ( VAR_135 ) ) ) { if ( ! ( VAR_136 -> VAR_137 -> VAR_138 && VAR_139 -> VAR_140 == VAR_141 && <S2SV_StartBug> * VAR_142 == VAR_143 ) && <S2SV_EndBug> ! METHOD_13 ( VAR_144 , VAR_145 ) ) { VAR_146 -> VAR_147 = 0 ; VAR_148 -> VAR_149 = 0 ; goto VAR_150 ; } TYPE_9 TYPE_10 } if ( VAR_151 -> VAR_152 == 0 ) goto VAR_153 ; if ( VAR_154 ) { if ( ( METHOD_14 ( VAR_155 ) || VAR_156 -> VAR_157 ) && ! VAR_158 -> VAR_159 -> VAR_160 ) { METHOD_15 ( VAR_161 , & ( VAR_162 -> VAR_163 -> VAR_164 ) , VAR_165 -> VAR_166 ) ; } VAR_167 -> VAR_168 = 0 ; VAR_169 -> VAR_170 = 0 ; goto VAR_171 ; } if ( ! METHOD_16 ( VAR_172 ) ) { VAR_173 -> VAR_174 = 0 ; VAR_175 -> VAR_176 = 0 ; goto VAR_177 ; } return ( 1 ) ; }",<S2SV_ModStart> == VAR_141 && VAR_175 -> VAR_176 > VAR_106 && VAR_175 -> VAR_46 [ VAR_106 ] <S2SV_ModEnd> == VAR_143 ),"CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; }  ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) {   if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && <S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; }  ifndef OPENSSL_NO_SCTP }   if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }",<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
57,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 ) { TYPE_2 VAR_2 = VAR_3 ; TYPE_3 VAR_4 ; METHOD_1 ( VAR_5 , VAR_6 ) ; METHOD_2 ( METHOD_3 ( VAR_7 , 0 ) , VAR_8 ) ; METHOD_4 ( METHOD_5 ( VAR_9 , - 1 ) , VAR_10 ) ; VAR_11 = METHOD_6 ( VAR_12 , METHOD_7 ( VAR_13 , 1 ) ) ; if ( ! VAR_14 ) return VAR_15 ; if ( METHOD_8 ( VAR_16 ) == 3 ) { VAR_17 = VAR_18 ; VAR_19 = VAR_20 ; } else if ( METHOD_9 ( VAR_21 ) == 5 ) { VAR_22 = METHOD_10 ( VAR_23 , VAR_24 , VAR_25 , METHOD_11 ( VAR_26 ) , VAR_27 -> VAR_28 , VAR_29 -> VAR_30 ) ; if ( ! VAR_31 ) return VAR_32 ; VAR_33 = VAR_34 ; } else { <S2SV_StartBug> VAR_35 = METHOD_12 ( VAR_36 , METHOD_13 ( VAR_37 , 3 ) , VAR_38 ) ; <S2SV_EndBug> if ( ! VAR_39 ) return VAR_40 ; VAR_41 = VAR_42 ; } return VAR_43 ; }","<S2SV_ModStart> ) , VAR_41 , VAR_44","CWE-125 static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = NULL ; expr_ty name_expr ; REQ ( n , decorator ) ; REQ ( CHILD ( n , 0 ) , AT ) ; REQ ( RCHILD ( n , - 1 ) , NEWLINE ) ; name_expr = ast_for_dotted_name ( c , CHILD ( n , 1 ) ) ; if ( ! name_expr ) return NULL ; if ( NCH ( n ) == 3 ) { d = name_expr ; name_expr = NULL ; } else if ( NCH ( n ) == 5 ) { d = Call ( name_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return NULL ; name_expr = NULL ; } else { <S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> if ( ! d ) return NULL ; name_expr = NULL ; } return d ; }","<S2SV_ModStart> ) , name_expr , true"
58,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_3 VAR_6 , * VAR_7 ; unsigned TYPE_2 VAR_8 ; TYPE_3 VAR_9 ; struct STRUCT_OR_UNION_4 * VAR_10 ; TYPE_4 VAR_11 , VAR_12 ; if ( ! VAR_13 && VAR_14 -> VAR_15 >= VAR_16 ) return - VAR_17 ; if ( VAR_18 -> VAR_19 < 1 ) return - VAR_20 ; VAR_21 = VAR_22 -> VAR_23 == 0 ? VAR_24 : ( VAR_25 -> VAR_26 & ( VAR_27 | VAR_28 | VAR_29 ) ) ; VAR_30 -> VAR_31 . VAR_32 = 0 ; METHOD_1 ( & VAR_33 , 0 , sizeof ( VAR_34 ) ) ; METHOD_2 ( & VAR_35 -> VAR_36 ) ; VAR_37 = METHOD_3 ( VAR_38 , & VAR_39 -> VAR_40 ) ; VAR_41 = 0 ; if ( VAR_42 ) { if ( VAR_43 ) VAR_44 = METHOD_4 ( VAR_45 , VAR_46 ) ; else VAR_47 = - VAR_48 ; } else { if ( VAR_49 ) VAR_50 = - VAR_51 ; } METHOD_5 ( & VAR_52 -> VAR_53 ) ; if ( VAR_54 < 0 ) return VAR_55 ; METHOD_6 ( & VAR_56 . VAR_57 , & VAR_58 -> VAR_59 , sizeof ( VAR_60 -> VAR_61 ) ) ; VAR_62 . VAR_63 = VAR_64 -> VAR_65 ? VAR_66 -> VAR_67 : 1 ; VAR_68 |= VAR_69 ; if ( VAR_70 -> VAR_71 == VAR_72 ) VAR_73 . VAR_74 = VAR_75 ; else VAR_76 . VAR_77 = VAR_78 ; if ( VAR_79 & VAR_80 ) VAR_81 . VAR_82 = VAR_83 ; if ( VAR_84 & VAR_85 ) VAR_86 . VAR_87 = VAR_88 ; if ( VAR_89 & VAR_90 ) { VAR_91 . VAR_92 . VAR_93 = VAR_94 ; VAR_95 |= VAR_96 ; } switch ( VAR_97 -> VAR_98 ) { case VAR_99 : case VAR_100 : VAR_101 = sizeof ( TYPE_5 ) ; if ( VAR_102 -> VAR_103 > 128 ) return - VAR_104 ; break ; case VAR_105 : VAR_106 = sizeof ( TYPE_6 TYPE_7 ) ; if ( VAR_107 -> VAR_108 > 64 ) return - VAR_109 ; break ; case VAR_110 : VAR_111 = sizeof ( unsigned TYPE_8 ) ; if ( VAR_112 -> VAR_113 > 128 || VAR_114 -> VAR_115 . VAR_116 . VAR_117 == 0 ) return - VAR_118 ; break ; case VAR_119 : VAR_120 = sizeof ( unsigned TYPE_9 ) ; if ( VAR_121 -> VAR_122 > 512 ) return - VAR_123 ; break ; case VAR_124 : VAR_125 = sizeof ( struct STRUCT_OR_UNION_5 ) ; if ( VAR_126 -> VAR_127 != 1 ) return - VAR_128 ; break ; default : return - VAR_129 ; } VAR_130 *= VAR_131 -> VAR_132 ; VAR_133 = METHOD_7 ( sizeof ( struct STRUCT_OR_UNION_6 ) + VAR_134 , VAR_135 ) ; if ( VAR_136 == VAR_137 ) return - VAR_138 ; <S2SV_StartBug> VAR_139 -> VAR_140 = * VAR_141 ; <S2SV_EndBug> VAR_142 -> VAR_143 . VAR_144 = 0 ; VAR_145 -> VAR_146 = ( TYPE_10 * ) VAR_147 + sizeof ( * VAR_148 ) ; VAR_149 -> VAR_150 = VAR_151 ; if ( VAR_152 -> VAR_153 . VAR_154 == VAR_155 ) { VAR_156 = METHOD_8 ( VAR_157 ) ; if ( VAR_158 < 0 ) { METHOD_9 ( VAR_159 ) ; return VAR_160 ; } } VAR_161 . VAR_162 = VAR_163 ; VAR_164 = METHOD_10 ( & VAR_165 , VAR_166 ) ; if ( VAR_167 == VAR_168 ) { METHOD_11 ( VAR_169 -> VAR_170 ) ; METHOD_12 ( VAR_171 ) ; return - VAR_172 ; } VAR_173 -> VAR_174 = VAR_175 ; for ( VAR_176 = 0 ; VAR_177 < VAR_178 -> VAR_179 ; VAR_180 ++ ) VAR_181 -> VAR_182 [ VAR_183 ] . VAR_184 = VAR_185 ; VAR_186 = METHOD_13 ( VAR_187 , VAR_188 ) ; if ( VAR_189 < 0 ) return VAR_190 ; METHOD_14 ( & VAR_191 -> VAR_192 ) ; VAR_193 -> VAR_194 ++ ; METHOD_15 ( & VAR_195 -> VAR_196 ) ; return 0 ; }",<S2SV_ModStart> ; VAR_175 -> VAR_195 = VAR_195 ; VAR_175 ->,"CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; <S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }",<S2SV_ModStart> ; ue -> card = card ; ue ->
59,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * * VAR_1 ) { TYPE_1 * VAR_2 = ( TYPE_2 * ) METHOD_1 ( VAR_3 ) ; struct STRUCT_OR_UNION_2 * VAR_4 = * VAR_5 ; struct STRUCT_OR_UNION_3 * * VAR_6 ; TYPE_3 VAR_7 , VAR_8 ; VAR_9 = ( VAR_10 -> VAR_11 - METHOD_2 ( sizeof ( struct STRUCT_OR_UNION_4 ) ) ) / sizeof ( TYPE_4 ) ; if ( VAR_12 <= 0 ) return 0 ; if ( VAR_13 > VAR_14 ) return - VAR_15 ; if ( ! VAR_16 ) { VAR_17 = METHOD_3 ( sizeof ( struct STRUCT_OR_UNION_5 ) , VAR_18 ) ; if ( ! VAR_19 ) return - VAR_20 ; * VAR_21 = VAR_22 ; VAR_23 -> VAR_24 = 0 ; VAR_25 -> VAR_26 = VAR_27 ; <S2SV_StartBug> } <S2SV_EndBug> VAR_28 = & VAR_29 -> VAR_30 [ VAR_31 -> VAR_32 ] ; if ( VAR_33 -> VAR_34 + VAR_35 > VAR_36 -> VAR_37 ) return - VAR_38 ; for ( VAR_39 = 0 ; VAR_40 < VAR_41 ; VAR_42 ++ ) { TYPE_5 VAR_43 = VAR_44 [ VAR_45 ] ; struct STRUCT_OR_UNION_6 * STRUCT_OR_UNION_7 ; if ( VAR_46 < 0 || ! ( STRUCT_OR_UNION_8 = METHOD_4 ( VAR_47 ) ) ) return - VAR_48 ; * VAR_49 ++ = STRUCT_OR_UNION_9 ; VAR_50 -> VAR_51 ++ ; } <S2SV_StartBug> return VAR_52 ; <S2SV_EndBug> }",<S2SV_ModStart> = VAR_27 ; VAR_50 -> VAR_53 = VAR_54 ; <S2SV_ModStart> ++ ; } if ( ! VAR_50 -> VAR_53 ) VAR_50 -> VAR_53 = METHOD_6 ( METHOD_5 ( ) ) ;,"CWE-399 static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; <S2SV_StartBug> } <S2SV_EndBug> fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } <S2SV_StartBug> return num ; <S2SV_EndBug> }",<S2SV_ModStart> = SCM_MAX_FD ; fpl -> user = NULL ; <S2SV_ModStart> ++ ; } if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;
60,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = METHOD_1 ( VAR_5 ) ; TYPE_1 VAR_6 = METHOD_2 ( VAR_7 -> VAR_8 ) ; TYPE_2 VAR_9 , VAR_10 ; TYPE_3 VAR_11 , VAR_12 ; TYPE_4 VAR_13 , VAR_14 ; <S2SV_StartBug> TYPE_5 VAR_15 = ( METHOD_3 ( VAR_16 -> VAR_17 ) == VAR_18 ) ? 64 : 32 ; <S2SV_EndBug> VAR_19 = VAR_20 . VAR_21 ; VAR_22 = VAR_23 . VAR_24 ; VAR_25 = VAR_26 . VAR_27 ; VAR_28 = VAR_29 . VAR_30 ; VAR_31 = METHOD_4 ( VAR_32 . VAR_33 ) ; VAR_34 = METHOD_5 ( VAR_35 -> VAR_36 ) ; if ( ( VAR_37 && ( VAR_38 != VAR_39 || VAR_40 != VAR_41 ) ) || VAR_42 > VAR_43 || VAR_44 > VAR_45 ) { METHOD_6 ( VAR_46 ) ; return 0 ; } if ( ! VAR_47 && VAR_48 != VAR_49 && VAR_50 != VAR_51 && VAR_52 != VAR_53 ) { METHOD_7 ( VAR_54 ) ; return 0 ; } switch ( VAR_55 ) { case VAR_56 : if ( METHOD_8 ( VAR_57 -> VAR_58 , VAR_59 ) || METHOD_9 ( VAR_60 -> VAR_61 , VAR_62 ) ) { VAR_63 -> VAR_64 = VAR_65 ; VAR_66 -> VAR_67 = VAR_68 ; } else { VAR_69 -> VAR_70 += VAR_71 ; VAR_72 -> VAR_73 += VAR_74 ; } if ( VAR_75 -> VAR_76 + VAR_77 < VAR_78 || VAR_79 -> VAR_80 + VAR_81 < VAR_82 ) { VAR_83 -> VAR_84 = 0 ; VAR_85 -> VAR_86 = VAR_87 ; } else { VAR_88 -> VAR_89 += VAR_90 ; VAR_91 -> VAR_92 += VAR_93 ; } VAR_94 -> VAR_95 = METHOD_10 ( VAR_96 -> VAR_97 , VAR_98 . VAR_99 ) ; break ; case VAR_100 : if ( METHOD_11 ( VAR_101 -> VAR_102 , VAR_103 ) || METHOD_12 ( VAR_104 -> VAR_105 , VAR_106 ) ) { VAR_107 -> VAR_108 = VAR_109 ; VAR_110 -> VAR_111 = VAR_112 ; } else { VAR_113 -> VAR_114 -= VAR_115 ; VAR_116 -> VAR_117 -= VAR_118 ; } if ( VAR_119 -> VAR_120 < VAR_121 ) { VAR_122 -> VAR_123 = 0 ; VAR_124 -> VAR_125 = VAR_126 ; } else { VAR_127 -> VAR_128 -= VAR_129 ; VAR_130 -> VAR_131 -= VAR_132 ; } VAR_133 -> VAR_134 = METHOD_13 ( VAR_135 -> VAR_136 , VAR_137 . VAR_138 ) ; break ; case VAR_139 : VAR_140 -> VAR_141 = METHOD_14 ( VAR_142 -> VAR_143 , VAR_144 . VAR_145 ) ; if ( VAR_146 < 0 || VAR_147 -> VAR_148 < 0 ) { METHOD_15 ( VAR_149 ) ; METHOD_16 ( VAR_150 ) ; break ; } if ( VAR_151 > VAR_152 || VAR_153 -> VAR_154 > VAR_155 ) { METHOD_17 ( VAR_156 ) ; METHOD_18 ( VAR_157 ) ; break ; } VAR_158 -> VAR_159 *= VAR_160 ; VAR_161 -> VAR_162 *= VAR_163 ; if ( VAR_164 -> VAR_165 > VAR_166 ) { VAR_167 -> VAR_168 = VAR_169 ; VAR_170 -> VAR_171 = VAR_172 ; } else { VAR_173 -> VAR_174 = VAR_175 -> VAR_176 ; VAR_177 -> VAR_178 = VAR_179 -> VAR_180 ; } break ; case VAR_181 : if ( VAR_182 && VAR_183 ) { METHOD_19 ( VAR_184 , VAR_185 -> VAR_186 . VAR_187 & VAR_188 . VAR_189 . VAR_190 ) ; break ; } VAR_191 -> VAR_192 = METHOD_20 ( VAR_193 -> VAR_194 , VAR_195 . VAR_196 ) ; VAR_197 -> VAR_198 = VAR_199 -> VAR_200 . VAR_201 ; VAR_202 -> VAR_203 = METHOD_21 ( VAR_204 -> VAR_205 , VAR_206 ) ; if ( VAR_207 -> VAR_208 < 0 || VAR_209 < 0 ) { VAR_210 -> VAR_211 = VAR_212 ; VAR_213 -> VAR_214 = VAR_215 ; } else { VAR_216 -> VAR_217 = VAR_218 -> VAR_219 ; VAR_220 -> VAR_221 = VAR_222 -> VAR_223 ; } METHOD_22 ( VAR_224 ) ; break ; case VAR_225 : if ( VAR_226 && VAR_227 ) { METHOD_23 ( VAR_228 , VAR_229 -> VAR_230 . VAR_231 | VAR_232 . VAR_233 . VAR_234 ) ; break ; } VAR_235 -> VAR_236 = METHOD_24 ( VAR_237 -> VAR_238 , VAR_239 . VAR_240 ) ; VAR_241 -> VAR_242 = METHOD_25 ( VAR_243 -> VAR_244 , VAR_245 ) ; VAR_246 -> VAR_247 = VAR_248 -> VAR_249 . VAR_250 | VAR_251 -> VAR_252 . VAR_253 ; if ( VAR_254 -> VAR_255 < 0 || VAR_256 < 0 ) { VAR_257 -> VAR_258 = VAR_259 ; VAR_260 -> VAR_261 = VAR_262 ; } else { VAR_263 -> VAR_264 = VAR_265 -> VAR_266 ; VAR_267 -> VAR_268 = VAR_269 -> VAR_270 ; } METHOD_26 ( VAR_271 ) ; break ; case VAR_272 : if ( VAR_273 >= VAR_274 ) { METHOD_27 ( VAR_275 , VAR_276 , VAR_277 -> VAR_278 ) ; break ; } VAR_279 -> VAR_280 = VAR_281 ; VAR_282 -> VAR_283 = VAR_284 ; if ( VAR_285 -> VAR_286 > 1ULL << ( 63 - VAR_287 ) ) { VAR_288 -> VAR_289 = 0 ; VAR_290 -> VAR_291 = VAR_292 ; } else { VAR_293 -> VAR_294 <<= VAR_295 ; VAR_296 -> VAR_297 <<= VAR_298 ; } VAR_299 -> VAR_300 = METHOD_28 ( VAR_301 -> VAR_302 , VAR_303 ) ; METHOD_29 ( VAR_304 ) ; break ; case VAR_305 : if ( VAR_306 >= VAR_307 ) { METHOD_30 ( VAR_308 , VAR_309 , VAR_310 -> VAR_311 ) ; break ; } VAR_312 -> VAR_313 = VAR_314 ; VAR_315 -> VAR_316 = VAR_317 ; VAR_318 -> VAR_319 = METHOD_31 ( VAR_320 -> VAR_321 , VAR_322 ) ; VAR_323 -> VAR_324 >>= VAR_325 ; VAR_326 -> VAR_327 >>= VAR_328 ; METHOD_32 ( VAR_329 ) ; break ; case VAR_330 : if ( VAR_331 >= VAR_332 ) { METHOD_33 ( VAR_333 , VAR_334 , VAR_335 -> VAR_336 ) ; break ; } VAR_337 -> VAR_338 >>= VAR_339 ; VAR_340 -> VAR_341 >>= VAR_342 ; VAR_343 -> VAR_344 = METHOD_34 ( VAR_345 -> VAR_346 , VAR_347 ) ; VAR_348 -> VAR_349 = 0 ; VAR_350 -> VAR_351 = VAR_352 ; METHOD_35 ( VAR_353 ) ; break ; default : METHOD_36 ( VAR_354 , VAR_355 , VAR_356 -> VAR_357 ) ; break ; } if ( METHOD_37 ( VAR_358 -> VAR_359 ) != VAR_360 ) { METHOD_38 ( VAR_361 , 4 ) ; <S2SV_StartBug> METHOD_39 ( & VAR_362 , 4 ) ; <S2SV_EndBug> } METHOD_40 ( VAR_363 ) ; METHOD_41 ( VAR_364 ) ; return 0 ; }","<S2SV_ModStart> : 32 ; if ( VAR_332 == 32 ) { METHOD_39 ( VAR_364 , 4 ) ; METHOD_39 ( & VAR_362 , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } METHOD_40 (","CWE-125 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds ("
61,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 TYPE_2 * VAR_0 , TYPE_3 VAR_1 , TYPE_4 * VAR_2 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = STRUCT_OR_UNION_4 -> VAR_3 ; struct STRUCT_OR_UNION_5 * STRUCT_OR_UNION_6 ; TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; if ( ( STRUCT_OR_UNION_7 -> VAR_6 & VAR_7 ) && ( STRUCT_OR_UNION_8 -> VAR_8 == 0 ) ) return - VAR_9 ; if ( ( ! VAR_10 ) || ( VAR_11 < sizeof ( struct STRUCT_OR_UNION_9 ) ) ) return - VAR_12 ; if ( ! METHOD_1 ( VAR_13 , VAR_14 , VAR_15 ) ) return - VAR_16 ; VAR_17 = METHOD_2 ( STRUCT_OR_UNION_10 -> VAR_18 , STRUCT_OR_UNION_11 -> VAR_19 ) ; if ( VAR_20 ) return VAR_21 ; METHOD_3 ( & STRUCT_OR_UNION_12 -> VAR_22 ) ; STRUCT_OR_UNION_13 = list_first_entry ( & STRUCT_OR_UNION_14 -> VAR_23 , struct STRUCT_OR_UNION_15 , VAR_24 ) ; METHOD_4 ( & STRUCT_OR_UNION_16 -> VAR_25 ) ; STRUCT_OR_UNION_17 -> VAR_26 -- ; METHOD_5 ( & STRUCT_OR_UNION_18 -> VAR_27 ) ; <S2SV_StartBug> VAR_28 = METHOD_6 ( VAR_29 , & STRUCT_OR_UNION_19 -> STRUCT_OR_UNION_20 , <S2SV_EndBug> <S2SV_StartBug> STRUCT_OR_UNION_21 -> VAR_30 ) ; <S2SV_EndBug> VAR_31 = STRUCT_OR_UNION_22 -> VAR_32 ; METHOD_7 ( STRUCT_OR_UNION_23 ) ; if ( VAR_33 ) return - VAR_34 ; return VAR_35 ; }","<S2SV_ModStart> VAR_27 ) ; VAR_35 = METHOD_8 ( VAR_15 , STRUCT_OR_UNION_23 -> VAR_32 ) ; <S2SV_ModStart> -> STRUCT_OR_UNION_20 , VAR_35 ) <S2SV_ModEnd> ; METHOD_7 (","CWE-119 static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }","<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree ("
62,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 VAR_2 ; TYPE_4 * VAR_3 ; METHOD_1 ( ( TYPE_5 * ) & VAR_4 , 1 ) switch ( VAR_5 . VAR_6 ) { case VAR_7 : METHOD_2 ( ( ( TYPE_6 * ) & VAR_8 ) + 1 , VAR_9 - 1 ) VAR_10 -> VAR_11 . VAR_12 = VAR_13 . VAR_14 . VAR_15 . VAR_16 ; VAR_17 -> VAR_18 . VAR_19 = VAR_20 . VAR_21 . VAR_22 . VAR_23 ; VAR_24 -> VAR_25 . VAR_26 = ( VAR_27 . VAR_28 . VAR_29 . VAR_30 ? 1 : 0 ) ; VAR_31 -> VAR_32 . VAR_33 = ( VAR_34 . VAR_35 . VAR_36 . VAR_37 ? 1 : 0 ) ; VAR_38 -> VAR_39 . VAR_40 = METHOD_3 ( VAR_41 . VAR_42 . VAR_43 . VAR_44 ) ; VAR_45 -> VAR_46 . VAR_47 = METHOD_4 ( VAR_48 . VAR_49 . VAR_50 . VAR_51 ) ; VAR_52 -> VAR_53 . VAR_54 = METHOD_5 ( VAR_55 . VAR_56 . VAR_57 . VAR_58 ) ; VAR_59 -> VAR_60 . VAR_61 = VAR_62 . VAR_63 . VAR_64 . VAR_65 ; VAR_66 -> VAR_67 . VAR_68 = VAR_69 . VAR_70 . VAR_71 . VAR_72 ; VAR_73 -> VAR_74 . VAR_75 = VAR_76 . VAR_77 . VAR_78 . VAR_79 ; VAR_80 -> VAR_81 = VAR_82 ; METHOD_6 ( VAR_83 ) ; return ; case VAR_84 : METHOD_7 ( ( ( TYPE_7 * ) & VAR_85 ) + 1 , VAR_86 - 1 ) TYPE_8 ( ""rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\n"" ) ; METHOD_8 ( VAR_87 ) ; return ; case VAR_88 : { TYPE_9 VAR_89 ; TYPE_10 VAR_90 ; TYPE_11 VAR_91 = ! VAR_92 -> VAR_93 ; TYPE_12 VAR_94 = ! VAR_95 -> VAR_96 ; TYPE_13 VAR_97 = ! VAR_98 -> VAR_99 ; TYPE_14 VAR_100 = VAR_101 ; METHOD_9 ( ( ( TYPE_15 * ) & VAR_102 ) + 1 , VAR_103 - 1 ) VAR_104 . VAR_105 . VAR_106 = METHOD_10 ( VAR_107 . VAR_108 . VAR_109 ) ; VAR_110 -> VAR_111 = - 1 ; VAR_112 -> VAR_113 = VAR_114 ; VAR_115 -> VAR_116 = VAR_117 ; VAR_118 -> VAR_119 = VAR_120 ; VAR_121 -> VAR_122 = VAR_123 ; VAR_124 -> VAR_125 = VAR_126 ; VAR_127 -> VAR_128 = VAR_129 ; VAR_130 -> VAR_131 = - 1 ; VAR_132 -> VAR_133 = - 1 ; for ( VAR_134 = 0 ; VAR_135 < VAR_136 . VAR_137 . VAR_138 ; VAR_139 ++ ) { METHOD_11 ( ( TYPE_16 * ) & VAR_140 , 4 ) VAR_141 = METHOD_12 ( VAR_142 ) ; switch ( VAR_143 ) { case VAR_144 : VAR_145 -> VAR_146 = VAR_147 ; break ; case VAR_148 : if ( VAR_149 -> VAR_150 == - 1 ) { VAR_151 -> VAR_152 = VAR_153 ; TYPE_17 ( ""Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_154 -> VAR_155 ) ; } break ; case VAR_156 : if ( VAR_157 -> VAR_158 == - 1 ) { VAR_159 -> VAR_160 = VAR_161 ; TYPE_18 ( ""Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_162 -> VAR_163 ) ; } break ; case VAR_164 : if ( VAR_165 -> VAR_166 == - 1 ) { VAR_167 -> VAR_168 = VAR_169 ; TYPE_19 ( ""Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_170 -> VAR_171 ) ; } break ; case VAR_172 : if ( VAR_173 -> VAR_174 == - 1 ) { VAR_175 -> VAR_176 = VAR_177 ; TYPE_20 ( ""Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_178 -> VAR_179 ) ; } break ; case VAR_180 : if ( VAR_181 -> VAR_182 == - 1 ) { VAR_183 -> VAR_184 = VAR_185 ; TYPE_21 ( ""Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_186 -> VAR_187 ) ; } break ; case VAR_188 : if ( VAR_189 -> VAR_190 == - 1 ) { VAR_191 -> VAR_192 = VAR_193 ; TYPE_22 ( ""Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_194 -> VAR_195 ) ; } break ; case VAR_196 : if ( VAR_197 -> VAR_198 == - 1 ) { VAR_199 -> VAR_200 = VAR_201 ; TYPE_23 ( ""Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_202 -> VAR_203 ) ; } break ; case VAR_204 : if ( VAR_205 -> VAR_206 == - 1 ) { VAR_207 -> VAR_208 = VAR_209 ; TYPE_24 ( ""Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_210 -> VAR_211 ) ; } break ; case VAR_212 : if ( ! VAR_213 -> VAR_214 ) { TYPE_25 ( ""Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_215 -> VAR_216 ) ; VAR_217 -> VAR_218 = VAR_219 ; VAR_220 -> VAR_221 = VAR_222 ; VAR_223 -> VAR_224 = VAR_225 ; } break ; case VAR_226 : if ( ! VAR_227 -> VAR_228 ) { TYPE_26 ( ""Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_229 -> VAR_230 ) ; VAR_231 -> VAR_232 = VAR_233 ; VAR_234 -> VAR_235 = VAR_236 ; VAR_237 -> VAR_238 = VAR_239 ; } break ; case VAR_240 : if ( ! VAR_241 -> VAR_242 ) { TYPE_27 ( ""Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_243 -> VAR_244 ) ; VAR_245 -> VAR_246 = VAR_247 ; VAR_248 -> VAR_249 = VAR_250 ; VAR_251 -> VAR_252 = - 1 ; VAR_253 -> VAR_254 = - 1 ; } break ; case VAR_255 : if ( ! VAR_256 -> VAR_257 ) { TYPE_28 ( ""Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_258 -> VAR_259 ) ; VAR_260 -> VAR_261 = VAR_262 ; } break ; case VAR_263 : if ( ! VAR_264 -> VAR_265 ) { TYPE_29 ( ""Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_266 -> VAR_267 ) ; VAR_268 -> VAR_269 = VAR_270 ; } break ; case VAR_271 : if ( ! VAR_272 -> VAR_273 ) { TYPE_30 ( ""Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_274 -> VAR_275 ) ; VAR_276 -> VAR_277 = VAR_278 ; } break ; case VAR_279 : if ( ! VAR_280 -> VAR_281 ) { if ( ! VAR_282 ) { TYPE_31 ( ""Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_283 -> VAR_284 ) ; VAR_285 -> VAR_286 = VAR_287 ; } else TYPE_32 ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case VAR_288 : if ( ! VAR_289 -> VAR_290 ) { if ( ! VAR_291 ) { TYPE_33 ( ""Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_292 -> VAR_293 ) ; VAR_294 -> VAR_295 = VAR_296 ; } else TYPE_34 ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case VAR_297 : if ( ! VAR_298 -> VAR_299 ) { TYPE_35 ( ""Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_300 -> VAR_301 ) ; VAR_302 -> VAR_303 = VAR_304 ; } break ; default : if ( VAR_305 >= ( TYPE_36 ) VAR_306 && VAR_307 <= ( TYPE_37 ) VAR_308 ) { VAR_309 -> VAR_310 = VAR_311 & 0x0F ; VAR_312 -> VAR_313 = VAR_314 & 0x0F ; if ( VAR_315 -> VAR_316 == VAR_317 ) VAR_318 = VAR_319 ; else TYPE_38 ( ""Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_320 -> VAR_321 , VAR_322 -> VAR_323 ) ; if ( VAR_324 == - 1 ) { if ( VAR_325 -> VAR_326 >= 5 ) { if ( ! METHOD_13 ( VAR_327 ) ) { METHOD_14 ( VAR_328 ) ; return ; } } else METHOD_15 ( VAR_329 ) ; } } else if ( VAR_330 >= ( TYPE_39 ) VAR_331 && VAR_332 <= ( TYPE_40 ) VAR_333 ) { VAR_334 -> VAR_335 = VAR_336 & 0xFF ; TYPE_41 ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_337 -> VAR_338 , VAR_339 -> VAR_340 ) ; } else if ( VAR_341 >= ( TYPE_42 ) VAR_342 && VAR_343 <= ( TYPE_43 ) VAR_344 ) { VAR_345 -> VAR_346 = VAR_347 [ VAR_348 & 0x0F ] ; VAR_349 -> VAR_350 = VAR_351 [ VAR_352 & 0x0F ] ; VAR_353 -> VAR_354 = VAR_355 & 0x0F ; if ( VAR_356 -> VAR_357 == VAR_358 ) TYPE_44 ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_359 -> VAR_360 , VAR_361 -> VAR_362 , VAR_363 -> VAR_364 ) ; else TYPE_45 ( ""Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_365 -> VAR_366 , VAR_367 -> VAR_368 ) ; } else if ( VAR_369 >= ( TYPE_46 ) VAR_370 + 1 && VAR_371 <= ( TYPE_47 ) VAR_372 ) { VAR_373 -> VAR_374 = VAR_375 & 0xFF ; TYPE_48 ( ""Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_376 -> VAR_377 , VAR_378 -> VAR_379 ) ; } else { TYPE_49 ( ""rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\n"" , ( TYPE_50 ) VAR_380 , ( TYPE_51 ) VAR_381 ) ; } } } if ( VAR_382 -> VAR_383 == - 1 ) VAR_384 -> VAR_385 = VAR_386 ; if ( VAR_387 -> VAR_388 == VAR_389 && VAR_390 ) TYPE_52 ( ""Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , METHOD_16 ( VAR_391 ) , VAR_392 -> VAR_393 ) ; if ( VAR_394 -> VAR_395 && ! VAR_396 -> VAR_397 ) { TYPE_53 ( ""Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , VAR_398 -> VAR_399 ) ; VAR_400 -> VAR_401 = VAR_402 ; } if ( VAR_403 -> VAR_404 && VAR_405 ) { if ( ! METHOD_17 ( VAR_406 , VAR_407 , 0 , VAR_408 ) ) return ; } if ( VAR_409 -> VAR_410 && VAR_411 -> VAR_412 && VAR_413 ) { if ( ! METHOD_18 ( VAR_414 ) ) return ; } if ( VAR_415 -> VAR_416 && VAR_417 ) { TYPE_54 VAR_418 ; VAR_419 . VAR_420 = VAR_421 ; VAR_422 . VAR_423 = VAR_424 | VAR_425 ; VAR_426 . VAR_427 = METHOD_19 ( VAR_428 - 4 ) ; VAR_429 . VAR_430 = VAR_431 . VAR_432 = METHOD_20 ( 1 ) ; if ( METHOD_21 ( VAR_433 , ( TYPE_55 * ) & VAR_434 , VAR_435 ) < 0 ) { METHOD_22 ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; METHOD_23 ( VAR_436 ) ; return ; } } return ; } case VAR_437 : { TYPE_56 VAR_438 ; TYPE_57 TYPE_58 ; METHOD_24 ( ( ( TYPE_59 * ) & VAR_439 ) + 1 , VAR_440 - 1 ) TYPE_60 . VAR_441 = METHOD_25 ( VAR_442 . VAR_443 . VAR_444 ) ; TYPE_61 . VAR_445 = METHOD_26 ( VAR_446 . VAR_447 . VAR_448 ) ; TYPE_62 . VAR_449 = TYPE_63 . VAR_450 + METHOD_27 ( VAR_451 . VAR_452 . VAR_453 ) ; TYPE_64 . VAR_454 = TYPE_65 . VAR_455 + METHOD_28 ( VAR_456 . VAR_457 . VAR_458 ) ; METHOD_29 ( VAR_459 , & VAR_460 , & TYPE_66 , 0 ) ; if ( ! VAR_461 . VAR_462 . VAR_463 || ! VAR_464 -> VAR_465 ) METHOD_30 ( VAR_466 , & VAR_467 -> VAR_468 , & VAR_469 -> VAR_470 , & VAR_471 ) ; if ( ! VAR_472 -> VAR_473 ) { VAR_474 -> VAR_475 = VAR_476 ; if ( ! VAR_477 -> VAR_478 . VAR_479 ) { if ( ! METHOD_31 ( VAR_480 , 0 , 0 ) ) { METHOD_32 ( VAR_481 , & VAR_482 ) ; return ; } } } if ( ! VAR_483 . VAR_484 . VAR_485 ) { METHOD_33 ( VAR_486 , & VAR_487 -> VAR_488 , & VAR_489 -> VAR_490 , & VAR_491 ) ; METHOD_34 ( VAR_492 , & VAR_493 -> VAR_494 , & VAR_495 -> VAR_496 , & VAR_497 ) ; METHOD_35 ( VAR_498 , & VAR_499 -> VAR_500 , & VAR_501 -> VAR_502 , & VAR_503 ) ; VAR_504 -> VAR_505 = VAR_506 ; } if ( METHOD_36 ( VAR_507 ) && ( ! VAR_508 -> VAR_509 || VAR_510 == 0 || METHOD_37 ( ) - VAR_511 -> VAR_512 >= ( TYPE_67 ) VAR_513 ) ) { if ( METHOD_38 ( VAR_514 ) ) VAR_515 -> VAR_516 = VAR_517 ; } METHOD_39 ( VAR_518 , & VAR_519 ) ; return ; } case VAR_520 : VAR_521 -> VAR_522 ++ ; METHOD_40 ( ( ( TYPE_68 * ) & VAR_523 ) + 1 , VAR_524 - 1 ) if ( ! VAR_525 && ! VAR_526 -> VAR_527 ) METHOD_41 ( ( TYPE_69 ) METHOD_42 ( VAR_528 . VAR_529 . VAR_530 ) , VAR_531 . VAR_532 . VAR_533 ) ; return ; case VAR_534 : VAR_535 -> VAR_536 ++ ; METHOD_43 ( ( ( TYPE_70 * ) & VAR_537 ) + 1 , VAR_538 - 1 ) if ( VAR_539 && ( VAR_540 != VAR_541 ) ) return ; if ( VAR_542 . VAR_543 . VAR_544 == 0 ) VAR_545 = VAR_546 ; else VAR_547 = VAR_548 ; if ( ! VAR_549 && ! VAR_550 -> VAR_551 ) { VAR_552 -> VAR_553 = ( TYPE_71 ) METHOD_44 ( VAR_554 . VAR_555 . VAR_556 ) ; VAR_557 -> VAR_558 = ( TYPE_72 ) METHOD_45 ( VAR_559 . VAR_560 . VAR_561 ) ; METHOD_46 ( VAR_562 . VAR_563 . VAR_564 , VAR_565 -> VAR_566 , VAR_567 -> VAR_568 , VAR_569 ) ; } return ; case VAR_570 : { TYPE_73 VAR_571 = 0 ; METHOD_47 ( ( ( TYPE_74 * ) & VAR_572 ) + 1 , VAR_573 - 1 ) VAR_574 . VAR_575 . VAR_576 = METHOD_48 ( VAR_577 . VAR_578 . VAR_579 ) ; if ( VAR_580 . VAR_581 . VAR_582 > VAR_583 ) { TYPE_75 ( ""Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\n"" , VAR_584 . VAR_585 . VAR_586 , VAR_587 ) ; VAR_588 = VAR_589 . VAR_590 . VAR_591 - VAR_592 ; VAR_593 . VAR_594 . VAR_595 = VAR_596 ; } if ( VAR_597 . VAR_598 . VAR_599 <= 0 ) return ; VAR_600 = ( TYPE_76 * ) METHOD_49 ( VAR_601 . VAR_602 . VAR_603 ) ; if ( VAR_604 == VAR_605 ) { METHOD_50 ( ""rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; METHOD_51 ( VAR_606 ) ; return ; } if ( ( VAR_607 = METHOD_52 ( VAR_608 , VAR_609 , VAR_610 . VAR_611 . VAR_612 ) ) <= 0 ) { if ( VAR_613 != 0 ) METHOD_53 ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; METHOD_54 ( VAR_614 ) ; METHOD_55 ( VAR_615 ) ; return ; } if ( VAR_616 > 0 ) { if ( ( VAR_617 = METHOD_56 ( VAR_618 , VAR_619 ) ) <= 0 ) { if ( VAR_620 != 0 ) METHOD_57 ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; METHOD_58 ( VAR_621 ) ; METHOD_59 ( VAR_622 ) ; return ; } } if ( ! VAR_623 && ! VAR_624 -> VAR_625 && ! VAR_626 ) { METHOD_60 ( VAR_627 , VAR_628 . VAR_629 . VAR_630 ) ; if ( VAR_631 ) METHOD_61 ( VAR_632 , VAR_633 . VAR_634 . VAR_635 ) ; } METHOD_62 ( VAR_636 ) ; return ; } case VAR_637 : { TYPE_77 TYPE_78 ; METHOD_63 ( ( ( TYPE_79 * ) & VAR_638 ) + 1 , VAR_639 - 1 ) if ( ! VAR_640 -> VAR_641 || ! VAR_642 -> VAR_643 ) { TYPE_80 ( ""Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\n"" ) ; TYPE_81 ( ""support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\n"" ) ; return ; } TYPE_82 . VAR_644 = METHOD_64 ( VAR_645 . VAR_646 . VAR_647 ) ; TYPE_83 . VAR_648 = METHOD_65 ( VAR_649 . VAR_650 . VAR_651 ) ; TYPE_84 . VAR_652 = TYPE_85 . VAR_653 + METHOD_66 ( VAR_654 . VAR_655 . VAR_656 ) ; TYPE_86 . VAR_657 = TYPE_87 . VAR_658 + METHOD_67 ( VAR_659 . VAR_660 . VAR_661 ) ; METHOD_68 ( VAR_662 , & VAR_663 -> VAR_664 , & TYPE_88 , 0 ) ; VAR_665 -> VAR_666 = VAR_667 . VAR_668 . VAR_669 ; if ( VAR_670 -> VAR_671 ) { METHOD_69 ( VAR_672 , & VAR_673 -> VAR_674 ) ; if ( ! METHOD_70 ( VAR_675 ) ) return ; } else { if ( ! METHOD_71 ( VAR_676 ) ) return ; } TYPE_89 ( ""Continuous<S2SV_blank>updates<S2SV_blank>%s\\n"" , VAR_677 -> VAR_678 ? ""enabled"" : ""disabled"" ) ; return ; } case VAR_679 : { TYPE_90 VAR_680 ; TYPE_91 VAR_681 [ 64 ] ; METHOD_72 ( ( ( TYPE_92 * ) & VAR_682 ) + 1 , VAR_683 - 1 ) VAR_684 = METHOD_73 ( VAR_685 . VAR_686 . VAR_687 ) ; <S2SV_StartBug> METHOD_74 ( VAR_688 , VAR_689 . VAR_690 . VAR_691 ) <S2SV_EndBug> <S2SV_StartBug> if ( VAR_692 . VAR_693 . VAR_694 > sizeof ( VAR_695 ) ) <S2SV_EndBug> TYPE_93 ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n"" , VAR_696 . VAR_697 . VAR_698 ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> METHOD_75 ( VAR_699 , VAR_700 , VAR_701 . VAR_702 . VAR_703 , VAR_704 ) ; <S2SV_EndBug> return ; } METHOD_76 ( VAR_705 , VAR_706 ... ) { if ( ! METHOD_77 ( VAR_707 ) ) snprintf ( VAR_708 , 256 , ""Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>"" VAR_709 ""\\n"" , VAR_710 ) ; VAR_711 = VAR_712 ; } case VAR_713 : { TYPE_94 VAR_714 ; struct STRUCT_OR_UNION_0 VAR_715 ; TYPE_95 VAR_716 ; TYPE_96 VAR_717 = VAR_718 ; TYPE_97 VAR_719 [ 256 ] = ""\\0"" ; TYPE_98 VAR_720 = VAR_721 . VAR_722 [ 0 ] ; METHOD_78 ( ( ( TYPE_99 * ) & VAR_723 ) + 1 , VAR_724 - 1 ) if ( VAR_725 . VAR_726 . VAR_727 < 1 ) METHOD_79 ( ""Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid"" , VAR_728 . VAR_729 . VAR_730 ) ; VAR_731 . VAR_732 . VAR_733 = METHOD_80 ( VAR_734 . VAR_735 . VAR_736 ) ; VAR_737 . VAR_738 . VAR_739 = METHOD_81 ( VAR_740 . VAR_741 . VAR_742 ) ; if ( VAR_743 . VAR_744 . VAR_745 < 1 || VAR_746 . VAR_747 . VAR_748 < 1 ) METHOD_82 ( ""Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , VAR_749 . VAR_750 . VAR_751 , VAR_752 . VAR_753 . VAR_754 ) ; METHOD_83 ( & VAR_755 ) ; for ( VAR_756 = 0 ; VAR_757 < VAR_758 . VAR_759 . VAR_760 ; VAR_761 ++ ) { TYPE_100 * VAR_762 = METHOD_84 ( 0 , 0 , 0 , 0 , 0 , 0 ) ; METHOD_85 ( ( TYPE_101 * ) & VAR_763 -> VAR_764 , sizeof ( VAR_765 ) ) VAR_766 -> VAR_767 . VAR_768 = METHOD_86 ( VAR_769 -> VAR_770 . VAR_771 ) ; VAR_772 -> VAR_773 . VAR_774 = METHOD_87 ( VAR_775 -> VAR_776 . VAR_777 ) ; VAR_778 -> VAR_779 . VAR_780 = METHOD_88 ( VAR_781 -> VAR_782 . VAR_783 ) ; VAR_784 -> VAR_785 . VAR_786 = METHOD_89 ( VAR_787 -> VAR_788 . VAR_789 ) ; VAR_790 -> VAR_791 . VAR_792 = METHOD_90 ( VAR_793 -> VAR_794 . VAR_795 ) ; VAR_796 -> VAR_797 . VAR_798 = METHOD_91 ( VAR_799 -> VAR_800 . VAR_801 ) ; if ( VAR_802 -> VAR_803 . VAR_804 < 1 || VAR_805 -> VAR_806 . VAR_807 < 1 ) METHOD_92 ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , ( unsigned TYPE_102 ) VAR_808 -> VAR_809 . VAR_810 , VAR_811 -> VAR_812 . VAR_813 , VAR_814 -> VAR_815 . VAR_816 ) ; if ( VAR_817 -> VAR_818 . VAR_819 >= VAR_820 . VAR_821 . VAR_822 || VAR_823 -> VAR_824 . VAR_825 >= VAR_826 . VAR_827 . VAR_828 || VAR_829 -> VAR_830 . VAR_831 + VAR_832 -> VAR_833 . VAR_834 > VAR_835 . VAR_836 . VAR_837 || VAR_838 -> VAR_839 . VAR_840 + VAR_841 -> VAR_842 . VAR_843 > VAR_844 . VAR_845 . VAR_846 ) METHOD_93 ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions"" , ( unsigned TYPE_103 ) VAR_847 -> VAR_848 . VAR_849 , VAR_850 -> VAR_851 . VAR_852 , VAR_853 -> VAR_854 . VAR_855 , VAR_856 -> VAR_857 . VAR_858 , VAR_859 -> VAR_860 . VAR_861 ) ; if ( METHOD_94 ( & VAR_862 , VAR_863 -> VAR_864 . VAR_865 ) ) { METHOD_95 ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID"" , ( unsigned TYPE_104 ) VAR_866 -> VAR_867 . VAR_868 ) ; METHOD_96 ( VAR_869 ) ; } else METHOD_97 ( & VAR_870 , VAR_871 ) ; } if ( VAR_872 -> VAR_873 ) { TYPE_105 ( ""NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\n"" ) ; VAR_874 = VAR_875 ; } else if ( VAR_876 == VAR_877 ) { VAR_878 = METHOD_98 ( VAR_879 , VAR_880 , VAR_881 . VAR_882 . VAR_883 , VAR_884 . VAR_885 . VAR_886 , & VAR_887 ) ; if ( VAR_888 == VAR_889 ) return ; } else TYPE_106 ( VAR_890 ) ; METHOD_99 ( & VAR_891 ) ; for ( VAR_892 = VAR_893 ; VAR_894 ; VAR_895 = VAR_896 -> VAR_897 ) { if ( VAR_898 == VAR_899 ) { VAR_900 -> VAR_901 = VAR_902 ; VAR_903 -> VAR_904 = VAR_905 ; VAR_906 -> VAR_907 = VAR_908 ; METHOD_100 ( VAR_909 ) ; break ; } } return ; } case VAR_910 : { TYPE_107 VAR_911 , VAR_912 , VAR_913 ; METHOD_101 ( ( TYPE_108 * ) & VAR_914 , 1 ) ; VAR_915 = ( VAR_916 & VAR_917 ) ? 0 : 1 ; VAR_918 = VAR_919 & ~ VAR_920 ; switch ( VAR_921 ) { case VAR_922 : METHOD_102 ( ( TYPE_109 * ) & VAR_923 . VAR_924 . VAR_925 , VAR_926 - 2 ) ; if ( VAR_927 != * ( const TYPE_110 * ) & VAR_928 ) { VAR_929 . VAR_930 . VAR_931 = METHOD_103 ( VAR_932 . VAR_933 . VAR_934 ) ; VAR_935 . VAR_936 . VAR_937 = METHOD_104 ( VAR_938 . VAR_939 . VAR_940 ) ; } if ( VAR_941 . VAR_942 . VAR_943 != VAR_944 - 4 || VAR_945 . VAR_946 . VAR_947 < 1 ) { TYPE_111 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\n"" ) ; METHOD_105 ( VAR_948 ) ; return ; } TYPE_112 ( ""Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\n"" , VAR_949 . VAR_950 . VAR_951 ) ; break ; case VAR_952 : { TYPE_113 VAR_953 ; TYPE_114 VAR_954 ; TYPE_115 VAR_955 ; METHOD_106 ( & VAR_956 , 0 , sizeof ( VAR_957 ) ) ; VAR_958 . VAR_959 = 0 ; METHOD_107 ( ( TYPE_116 * ) & VAR_960 . VAR_961 . VAR_962 , VAR_963 - 2 ) ; if ( VAR_964 != * ( const TYPE_117 * ) & VAR_965 ) { VAR_966 . VAR_967 . VAR_968 = METHOD_108 ( VAR_969 . VAR_970 . VAR_971 ) ; VAR_972 . VAR_973 . VAR_974 = METHOD_109 ( VAR_975 . VAR_976 . VAR_977 ) ; VAR_978 . VAR_979 . VAR_980 = METHOD_110 ( VAR_981 . VAR_982 . VAR_983 ) ; VAR_984 . VAR_985 . VAR_986 = METHOD_111 ( VAR_987 . VAR_988 . VAR_989 ) ; VAR_990 . VAR_991 . VAR_992 = METHOD_112 ( VAR_993 . VAR_994 . VAR_995 ) ; VAR_996 . VAR_997 . VAR_998 = METHOD_113 ( VAR_999 . VAR_1000 . VAR_1001 ) ; VAR_1002 . VAR_1003 . VAR_1004 = METHOD_114 ( VAR_1005 . VAR_1006 . VAR_1007 ) ; } TYPE_118 ( ""GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\n"" , VAR_1008 . VAR_1009 . VAR_1010 ) ; TYPE_119 TYPE_120 TYPE_121 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\n"" , VAR_1011 . VAR_1012 . VAR_1013 ) ; TYPE_122 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\n"" , VAR_1014 . VAR_1015 . VAR_1016 ) ; TYPE_123 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\n"" , VAR_1017 . VAR_1018 . VAR_1019 ) ; TYPE_124 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\n"" , VAR_1020 . VAR_1021 . VAR_1022 ) ; TYPE_125 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\n"" , VAR_1023 . VAR_1024 . VAR_1025 ) ; TYPE_126 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\n"" , VAR_1026 . VAR_1027 . VAR_1028 ) ; if ( VAR_1029 . VAR_1030 . VAR_1031 != VAR_1032 - 4 + VAR_1033 . VAR_1034 . VAR_1035 * VAR_1036 ) { TYPE_127 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; METHOD_115 ( VAR_1037 ) ; return ; } if ( VAR_1038 . VAR_1039 . VAR_1040 > VAR_1041 ) { TYPE_128 ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , VAR_1042 . VAR_1043 . VAR_1044 , VAR_1045 ) ; METHOD_116 ( VAR_1046 . VAR_1047 . VAR_1048 * VAR_1049 ) ; goto VAR_1050 ; } if ( VAR_1051 . VAR_1052 . VAR_1053 > VAR_1054 ) { TYPE_129 ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , VAR_1055 . VAR_1056 . VAR_1057 , VAR_1058 ) ; METHOD_117 ( VAR_1059 . VAR_1060 . VAR_1061 * VAR_1062 ) ; goto VAR_1063 ; } METHOD_118 ( & VAR_1064 . VAR_1065 , VAR_1066 . VAR_1067 . VAR_1068 , 32 ) ; VAR_1069 . VAR_1070 = VAR_1071 . VAR_1072 . VAR_1073 ; VAR_1074 . VAR_1075 = VAR_1076 . VAR_1077 . VAR_1078 ; VAR_1079 . VAR_1080 = VAR_1081 . VAR_1082 . VAR_1083 ; VAR_1084 . VAR_1085 = ( VAR_1086 . VAR_1087 & VAR_1088 ) ? VAR_1089 : VAR_1090 ; VAR_1091 . VAR_1092 = VAR_1093 . VAR_1094 . VAR_1095 ; if ( VAR_1096 . VAR_1097 == VAR_1098 ) { TYPE_130 ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\n"" ) ; METHOD_119 ( VAR_1099 . VAR_1100 . VAR_1101 * VAR_1102 ) ; goto VAR_1103 ; } for ( VAR_1104 = 0 ; VAR_1105 < VAR_1106 . VAR_1107 ; VAR_1108 ++ ) { TYPE_131 * VAR_1109 = & VAR_1110 . VAR_1111 [ VAR_1112 ] ; METHOD_120 ( ( TYPE_132 * ) VAR_1113 , VAR_1114 ) ; if ( VAR_1115 != * ( const TYPE_133 * ) & VAR_1116 ) { VAR_1117 -> VAR_1118 = METHOD_121 ( VAR_1119 -> VAR_1120 ) ; VAR_1121 -> VAR_1122 = METHOD_122 ( ( TYPE_134 ) VAR_1123 -> VAR_1124 ) ; VAR_1125 -> VAR_1126 = METHOD_123 ( ( TYPE_135 ) VAR_1127 -> VAR_1128 ) ; VAR_1129 -> VAR_1130 = METHOD_124 ( ( TYPE_136 ) VAR_1131 -> VAR_1132 ) ; VAR_1133 -> VAR_1134 = METHOD_125 ( VAR_1135 -> VAR_1136 ) ; VAR_1137 -> VAR_1138 = METHOD_126 ( ( TYPE_137 ) VAR_1139 -> VAR_1140 ) ; VAR_1141 -> VAR_1142 = METHOD_127 ( ( TYPE_138 ) VAR_1143 -> VAR_1144 ) ; VAR_1145 -> VAR_1146 = METHOD_128 ( ( TYPE_139 ) VAR_1147 -> VAR_1148 ) ; VAR_1149 -> VAR_1150 = METHOD_129 ( ( TYPE_140 ) VAR_1151 -> VAR_1152 ) ; } TYPE_141 TYPE_142 TYPE_143 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\n"" , VAR_1153 -> VAR_1154 , VAR_1155 -> VAR_1156 ) ; TYPE_144 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\n"" , VAR_1157 -> VAR_1158 ) ; TYPE_145 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\n"" , VAR_1159 -> VAR_1160 , VAR_1161 -> VAR_1162 , VAR_1163 -> VAR_1164 ) ; TYPE_146 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\n"" , VAR_1165 -> VAR_1166 ) ; TYPE_147 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\n"" , VAR_1167 -> VAR_1168 ) ; TYPE_148 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\n"" , VAR_1169 -> VAR_1170 ) ; TYPE_149 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\n"" , VAR_1171 -> VAR_1172 ) ; TYPE_150 ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\n"" , VAR_1173 -> VAR_1174 ) ; } for ( VAR_1175 = 0 ; VAR_1176 < VAR_1177 -> VAR_1178 ; VAR_1179 ++ ) { if ( ! METHOD_130 ( VAR_1180 . VAR_1181 , VAR_1182 -> VAR_1183 [ VAR_1184 ] . VAR_1185 ) ) { TYPE_151 ( ""Device<S2SV_blank>\\\'%s\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\n"" , VAR_1186 . VAR_1187 , VAR_1188 + 1 ) ; VAR_1189 . VAR_1190 = METHOD_131 ( VAR_1191 + 1 ) ; goto VAR_1192 ; } } if ( VAR_1193 || METHOD_132 ( & VAR_1194 ) ) { METHOD_133 ( & VAR_1195 -> VAR_1196 [ VAR_1197 -> VAR_1198 ] , & VAR_1199 , sizeof ( VAR_1200 ) ) ; VAR_1201 -> VAR_1202 ++ ; VAR_1203 . VAR_1204 = METHOD_134 ( VAR_1205 -> VAR_1206 ) ; } TYPE_152 ( ""GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\n"" , VAR_1207 -> VAR_1208 ) ; VAR_1209 : VAR_1210 . VAR_1211 = VAR_1212 ; VAR_1213 . VAR_1214 = VAR_1215 | VAR_1216 ; VAR_1217 . VAR_1218 = METHOD_135 ( VAR_1219 - 4 ) ; if ( METHOD_136 ( VAR_1220 , ( TYPE_153 * ) & VAR_1221 , VAR_1222 ) < 0 ) { METHOD_137 ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; METHOD_138 ( VAR_1223 ) ; return ; } break ; } case VAR_1224 : METHOD_139 ( ( TYPE_154 * ) & VAR_1225 . VAR_1226 . VAR_1227 , VAR_1228 - 2 ) ; if ( VAR_1229 != * ( const TYPE_155 * ) & VAR_1230 ) { VAR_1231 . VAR_1232 . VAR_1233 = METHOD_140 ( VAR_1234 . VAR_1235 . VAR_1236 ) ; VAR_1237 . VAR_1238 . VAR_1239 = METHOD_141 ( VAR_1240 . VAR_1241 . VAR_1242 ) ; } if ( VAR_1243 . VAR_1244 . VAR_1245 != VAR_1246 - 4 ) { TYPE_156 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; METHOD_142 ( VAR_1247 ) ; return ; } METHOD_143 ( VAR_1248 , VAR_1249 . VAR_1250 . VAR_1251 - 1 ) ; break ; case VAR_1252 : { TYPE_157 VAR_1253 ; METHOD_144 ( ( TYPE_158 * ) & VAR_1254 , sizeof ( TYPE_159 ) ) ; if ( VAR_1255 != * ( const TYPE_160 * ) & VAR_1256 ) VAR_1257 = METHOD_145 ( VAR_1258 ) ; while ( VAR_1259 > 0 ) { TYPE_161 VAR_1260 , VAR_1261 ; METHOD_146 ( ( TYPE_162 * ) & VAR_1262 , 1 ) ; METHOD_147 ( ( TYPE_163 * ) & VAR_1263 , 1 ) ; switch ( VAR_1264 ) { case VAR_1265 : case VAR_1266 : { TYPE_164 VAR_1267 ; TYPE_165 * VAR_1268 ; METHOD_148 ( ( TYPE_166 * ) & VAR_1269 . VAR_1270 , VAR_1271 - 2 ) ; if ( VAR_1272 != * ( const TYPE_167 * ) & VAR_1273 ) { VAR_1274 . VAR_1275 = METHOD_149 ( VAR_1276 . VAR_1277 ) ; VAR_1278 . VAR_1279 = METHOD_150 ( VAR_1280 . VAR_1281 ) ; } if ( VAR_1282 != VAR_1283 || VAR_1284 . VAR_1285 <= 0 || VAR_1286 . VAR_1287 < 1 ) { TYPE_168 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\n"" ) ; METHOD_151 ( VAR_1288 ) ; return ; } if ( VAR_1289 > VAR_1290 ) { TYPE_169 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; METHOD_152 ( VAR_1291 ) ; return ; } VAR_1292 -= VAR_1293 ; if ( VAR_1294 . VAR_1295 < 1 || VAR_1296 . VAR_1297 > VAR_1298 -> VAR_1299 ) { TYPE_170 ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , VAR_1300 . VAR_1301 ) ; METHOD_153 ( VAR_1302 ) ; return ; } VAR_1303 = & VAR_1304 -> VAR_1305 [ VAR_1306 . VAR_1307 - 1 ] ; if ( ( VAR_1308 == VAR_1309 && ( VAR_1310 -> VAR_1311 & VAR_1312 ) == 0 ) || ( VAR_1313 == VAR_1314 && ( VAR_1315 -> VAR_1316 & VAR_1317 ) == 0 ) ) { TYPE_171 ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\n"" , VAR_1318 . VAR_1319 ) ; METHOD_154 ( VAR_1320 ) ; return ; } if ( VAR_1321 . VAR_1322 > VAR_1323 -> VAR_1324 ) { TYPE_172 ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\n"" , VAR_1325 . VAR_1326 , VAR_1327 . VAR_1328 , VAR_1329 -> VAR_1330 ) ; METHOD_155 ( VAR_1331 ) ; return ; } TYPE_173 TYPE_174 TYPE_175 ( ""Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\n"" , VAR_1332 . VAR_1333 , VAR_1334 . VAR_1335 , VAR_1336 == VAR_1337 ? ""PRESS"" : ""release"" ) ; METHOD_156 ( VAR_1338 ) ; METHOD_157 ( VAR_1339 , VAR_1340 == VAR_1341 ? VAR_1342 : VAR_1343 , VAR_1344 . VAR_1345 ) ; break ; } case VAR_1346 : case VAR_1347 : { TYPE_176 VAR_1348 ; TYPE_177 VAR_1349 ; TYPE_178 * VAR_1350 ; METHOD_158 ( ( TYPE_179 * ) & VAR_1351 . VAR_1352 , VAR_1353 - 2 ) ; if ( VAR_1354 != * ( const TYPE_180 * ) & VAR_1355 ) { VAR_1356 . VAR_1357 = METHOD_159 ( VAR_1358 . VAR_1359 ) ; VAR_1360 . VAR_1361 = METHOD_160 ( VAR_1362 . VAR_1363 ) ; VAR_1364 . VAR_1365 = METHOD_161 ( VAR_1366 . VAR_1367 ) ; } if ( VAR_1368 != VAR_1369 + sizeof ( TYPE_181 ) * VAR_1370 . VAR_1371 ) { TYPE_182 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\n"" ) ; METHOD_162 ( VAR_1372 ) ; return ; } if ( VAR_1373 > VAR_1374 ) { TYPE_183 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; METHOD_163 ( VAR_1375 ) ; return ; } VAR_1376 -= VAR_1377 ; if ( VAR_1378 . VAR_1379 < 1 || VAR_1380 . VAR_1381 > VAR_1382 -> VAR_1383 ) { TYPE_184 ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , VAR_1384 . VAR_1385 ) ; METHOD_164 ( VAR_1386 ) ; return ; } VAR_1387 = & VAR_1388 -> VAR_1389 [ VAR_1390 . VAR_1391 - 1 ] ; if ( ( VAR_1392 == VAR_1393 && ( VAR_1394 -> VAR_1395 & VAR_1396 ) == 0 ) || ( VAR_1397 == VAR_1398 && ( VAR_1399 -> VAR_1400 & VAR_1401 ) == 0 ) ) { TYPE_185 ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\n"" , VAR_1402 . VAR_1403 ) ; METHOD_165 ( VAR_1404 ) ; return ; } if ( VAR_1405 . VAR_1406 + VAR_1407 . VAR_1408 > VAR_1409 -> VAR_1410 ) { TYPE_186 ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\n"" , VAR_1411 . VAR_1412 , VAR_1413 -> VAR_1414 ) ; METHOD_166 ( VAR_1415 ) ; return ; } TYPE_187 TYPE_188 TYPE_189 ( ""Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\n"" , VAR_1416 . VAR_1417 , VAR_1418 == VAR_1419 ? ""rel"" : ""ABS"" , VAR_1420 . VAR_1421 , VAR_1422 . VAR_1423 ) ; for ( VAR_1424 = VAR_1425 . VAR_1426 ; VAR_1427 < VAR_1428 . VAR_1429 + VAR_1430 . VAR_1431 ; VAR_1432 ++ ) { METHOD_167 ( ( TYPE_190 * ) & VAR_1433 -> VAR_1434 [ VAR_1435 ] , sizeof ( TYPE_191 ) ) ; if ( VAR_1436 != * ( const TYPE_192 * ) & VAR_1437 ) VAR_1438 -> VAR_1439 [ VAR_1440 ] = METHOD_168 ( ( TYPE_193 ) VAR_1441 -> VAR_1442 [ VAR_1443 ] ) ; TYPE_194 TYPE_195 VAR_1444 ( VAR_1445 , ""v[%d]=%d<S2SV_blank>"" , VAR_1446 , VAR_1447 -> VAR_1448 [ VAR_1449 ] ) ; } TYPE_196 TYPE_197 VAR_1450 ( VAR_1451 , ""\\n"" ) ; if ( VAR_1452 . VAR_1453 > 0 ) { VAR_1454 -> VAR_1455 = VAR_1456 . VAR_1457 ; VAR_1458 -> VAR_1459 = VAR_1460 . VAR_1461 ; VAR_1462 -> VAR_1463 = VAR_1464 == VAR_1465 ? VAR_1466 : VAR_1467 ; METHOD_169 ( VAR_1468 , VAR_1469 , 0 ) ; } break ; } default : TYPE_198 ( ""ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\n"" , VAR_1470 ) ; METHOD_170 ( VAR_1471 ) ; return ; } } if ( VAR_1472 != 0 ) { TYPE_199 ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; METHOD_171 ( VAR_1473 ) ; return ; } break ; } } return ; } default : TYPE_200 ( ""rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\n"" , VAR_1474 . VAR_1475 ) ; TYPE_201 ( ""<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\n"" ) ; METHOD_172 ( VAR_1476 ) ; return ; } }","<S2SV_ModStart> VAR_801 ) ; <S2SV_ModEnd> if ( VAR_1474 <S2SV_ModStart> VAR_704 ) ) { <S2SV_ModStart> VAR_1472 ) ; METHOD_119 ( VAR_1474 . VAR_702 . VAR_1472 ) } else { METHOD_167 ( VAR_704 , VAR_1474 . VAR_702 . VAR_1472 ) <S2SV_ModEnd> METHOD_75 ( VAR_1476 <S2SV_ModStart> VAR_704 ) ; }","CWE-787 static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) { int n ; rfbClientToServerMsg msg ; char * str ; READ ( ( char * ) & msg , 1 ) switch ( msg . type ) { case rfbSetPixelFormat : READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ; cl -> format . depth = msg . spf . format . depth ; cl -> format . bigEndian = ( msg . spf . format . bigEndian ? 1 : 0 ) ; cl -> format . trueColour = ( msg . spf . format . trueColour ? 1 : 0 ) ; cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ; cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ; cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ; cl -> format . redShift = msg . spf . format . redShift ; cl -> format . greenShift = msg . spf . format . greenShift ; cl -> format . blueShift = msg . spf . format . blueShift ; cl -> readyForSetColourMapEntries = TRUE ; rfbSetTranslateFunction ( cl ) ; return ; case rfbFixColourMapEntries : READ ( ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\n"" ) ; rfbCloseClient ( cl ) ; return ; case rfbSetEncodings : { int i ; CARD32 enc ; Bool firstFence = ! cl -> enableFence ; Bool firstCU = ! cl -> enableCU ; Bool firstGII = ! cl -> enableGII ; Bool logTightCompressLevel = FALSE ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ; cl -> preferredEncoding = - 1 ; cl -> useCopyRect = FALSE ; cl -> enableCursorShapeUpdates = FALSE ; cl -> enableCursorPosUpdates = FALSE ; cl -> enableLastRectEncoding = FALSE ; cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ; cl -> tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP ; cl -> tightQualityLevel = - 1 ; cl -> imageQualityLevel = - 1 ; for ( i = 0 ; i < msg . se . nEncodings ; i ++ ) { READ ( ( char * ) & enc , 4 ) enc = Swap32IfLE ( enc ) ; switch ( enc ) { case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ; break ; case rfbEncodingRaw : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingCoRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingHextile : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZlib : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingZYWRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingTight : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( ""Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; } break ; case rfbEncodingXCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = FALSE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingRichCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = TRUE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) { rfbLog ( ""Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorPosUpdates = TRUE ; cl -> cursorWasMoved = TRUE ; cl -> cursorX = - 1 ; cl -> cursorY = - 1 ; } break ; case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) { rfbLog ( ""Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableLastRectEncoding = TRUE ; } break ; case rfbEncodingFence : if ( ! cl -> enableFence ) { rfbLog ( ""Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableFence = TRUE ; } break ; case rfbEncodingContinuousUpdates : if ( ! cl -> enableCU ) { rfbLog ( ""Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCU = TRUE ; } break ; case rfbEncodingNewFBSize : if ( ! cl -> enableDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( ""Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableDesktopSize = TRUE ; } else rfbLog ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case rfbEncodingExtendedDesktopSize : if ( ! cl -> enableExtDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( ""Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableExtDesktopSize = TRUE ; } else rfbLog ( ""WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n"" ) ; } break ; case rfbEncodingGII : if ( ! cl -> enableGII ) { rfbLog ( ""Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableGII = TRUE ; } break ; default : if ( enc >= ( CARD32 ) rfbEncodingCompressLevel0 && enc <= ( CARD32 ) rfbEncodingCompressLevel9 ) { cl -> zlibCompressLevel = enc & 0x0F ; cl -> tightCompressLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) logTightCompressLevel = TRUE ; else rfbLog ( ""Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightCompressLevel , cl -> host ) ; if ( rfbInterframe == - 1 ) { if ( cl -> tightCompressLevel >= 5 ) { if ( ! InterframeOn ( cl ) ) { rfbCloseClient ( cl ) ; return ; } } else InterframeOff ( cl ) ; } } else if ( enc >= ( CARD32 ) rfbEncodingSubsamp1X && enc <= ( CARD32 ) rfbEncodingSubsampGray ) { cl -> tightSubsampLevel = enc & 0xFF ; rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightSubsampLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingQualityLevel0 && enc <= ( CARD32 ) rfbEncodingQualityLevel9 ) { cl -> tightQualityLevel = JPEG_QUAL [ enc & 0x0F ] ; cl -> tightSubsampLevel = JPEG_SUBSAMP [ enc & 0x0F ] ; cl -> imageQualityLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightSubsampLevel , cl -> tightQualityLevel , cl -> host ) ; else rfbLog ( ""Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> imageQualityLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( CARD32 ) rfbEncodingFineQualityLevel100 ) { cl -> tightQualityLevel = enc & 0xFF ; rfbLog ( ""Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> tightQualityLevel , cl -> host ) ; } else { rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\n"" , ( int ) enc , ( int ) enc ) ; } } } if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = rfbEncodingTight ; if ( cl -> preferredEncoding == rfbEncodingTight && logTightCompressLevel ) rfbLog ( ""Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , rfbTightCompressLevel ( cl ) , cl -> host ) ; if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) { rfbLog ( ""Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n"" , cl -> host ) ; cl -> enableCursorPosUpdates = FALSE ; } if ( cl -> enableFence && firstFence ) { if ( ! rfbSendFence ( cl , rfbFenceFlagRequest , 0 , NULL ) ) return ; } if ( cl -> enableCU && cl -> enableFence && firstCU ) { if ( ! rfbSendEndOfCU ( cl ) ) return ; } if ( cl -> enableGII && firstGII ) { rfbGIIServerVersionMsg msg ; msg . type = rfbGIIServer ; msg . endianAndSubType = rfbGIIVersion | rfbGIIBE ; msg . length = Swap16IfLE ( sz_rfbGIIServerVersionMsg - 4 ) ; msg . maximumVersion = msg . minimumVersion = Swap16IfLE ( 1 ) ; if ( WriteExact ( cl , ( char * ) & msg , sz_rfbGIIServerVersionMsg ) < 0 ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return ; } } return ; } case rfbFramebufferUpdateRequest : { RegionRec tmpRegion ; BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) box . x1 = Swap16IfLE ( msg . fur . x ) ; box . y1 = Swap16IfLE ( msg . fur . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . fur . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . fur . h ) ; SAFE_REGION_INIT ( pScreen , & tmpRegion , & box , 0 ) ; if ( ! msg . fur . incremental || ! cl -> continuousUpdates ) REGION_UNION ( pScreen , & cl -> requestedRegion , & cl -> requestedRegion , & tmpRegion ) ; if ( ! cl -> readyForSetColourMapEntries ) { cl -> readyForSetColourMapEntries = TRUE ; if ( ! cl -> format . trueColour ) { if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) { REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } } } if ( ! msg . fur . incremental ) { REGION_UNION ( pScreen , & cl -> modifiedRegion , & cl -> modifiedRegion , & tmpRegion ) ; REGION_SUBTRACT ( pScreen , & cl -> copyRegion , & cl -> copyRegion , & tmpRegion ) ; REGION_UNION ( pScreen , & cl -> ifRegion , & cl -> ifRegion , & tmpRegion ) ; cl -> pendingExtDesktopResize = TRUE ; } if ( FB_UPDATE_PENDING ( cl ) && ( ! cl -> deferredUpdateScheduled || rfbDeferUpdateTime == 0 || gettime ( ) - cl -> deferredUpdateStart >= ( double ) rfbDeferUpdateTime ) ) { if ( rfbSendFramebufferUpdate ( cl ) ) cl -> deferredUpdateScheduled = FALSE ; } REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } case rfbKeyEvent : cl -> rfbKeyEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) if ( ! rfbViewOnly && ! cl -> viewOnly ) KeyEvent ( ( KeySym ) Swap32IfLE ( msg . ke . key ) , msg . ke . down ) ; return ; case rfbPointerEvent : cl -> rfbPointerEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) if ( pointerClient && ( pointerClient != cl ) ) return ; if ( msg . pe . buttonMask == 0 ) pointerClient = NULL ; else pointerClient = cl ; if ( ! rfbViewOnly && ! cl -> viewOnly ) { cl -> cursorX = ( int ) Swap16IfLE ( msg . pe . x ) ; cl -> cursorY = ( int ) Swap16IfLE ( msg . pe . y ) ; PtrAddEvent ( msg . pe . buttonMask , cl -> cursorX , cl -> cursorY , cl ) ; } return ; case rfbClientCutText : { int ignoredBytes = 0 ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) msg . cct . length = Swap32IfLE ( msg . cct . length ) ; if ( msg . cct . length > rfbMaxClipboard ) { rfbLog ( ""Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\n"" , msg . cct . length , rfbMaxClipboard ) ; ignoredBytes = msg . cct . length - rfbMaxClipboard ; msg . cct . length = rfbMaxClipboard ; } if ( msg . cct . length <= 0 ) return ; str = ( char * ) malloc ( msg . cct . length ) ; if ( str == NULL ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; rfbCloseClient ( cl ) ; return ; } if ( ( n = ReadExact ( cl , str , msg . cct . length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } if ( ignoredBytes > 0 ) { if ( ( n = SkipExact ( cl , ignoredBytes ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>read"" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } } if ( ! rfbViewOnly && ! cl -> viewOnly && ! rfbAuthDisableCBRecv ) { vncClientCutText ( str , msg . cct . length ) ; if ( rfbSyncCutBuffer ) rfbSetXCutText ( str , msg . cct . length ) ; } free ( str ) ; return ; } case rfbEnableContinuousUpdates : { BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbEnableContinuousUpdatesMsg - 1 ) if ( ! cl -> enableFence || ! cl -> enableCU ) { rfbLog ( ""Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\n"" ) ; rfbLog ( ""support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\n"" ) ; return ; } box . x1 = Swap16IfLE ( msg . ecu . x ) ; box . y1 = Swap16IfLE ( msg . ecu . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . ecu . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . ecu . h ) ; SAFE_REGION_INIT ( pScreen , & cl -> cuRegion , & box , 0 ) ; cl -> continuousUpdates = msg . ecu . enable ; if ( cl -> continuousUpdates ) { REGION_EMPTY ( pScreen , & cl -> requestedRegion ) ; if ( ! rfbSendFramebufferUpdate ( cl ) ) return ; } else { if ( ! rfbSendEndOfCU ( cl ) ) return ; } rfbLog ( ""Continuous<S2SV_blank>updates<S2SV_blank>%s\\n"" , cl -> continuousUpdates ? ""enabled"" : ""disabled"" ) ; return ; } case rfbFence : { CARD32 flags ; char data [ 64 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFenceMsg - 1 ) flags = Swap32IfLE ( msg . f . flags ) ; <S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n"" , msg . f . length ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> return ; }   EDSERROR ( format , args ... ) { if ( ! strlen ( errMsg ) ) snprintf ( errMsg , 256 , ""Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>"" format ""\\n"" , args ) ; result = rfbEDSResultInvalid ; } case rfbSetDesktopSize : { int i ; struct xorg_list newScreens ; rfbClientPtr cl2 ; int result = rfbEDSResultSuccess ; char errMsg [ 256 ] = ""\\0"" ; ScreenPtr pScreen = screenInfo . screens [ 0 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetDesktopSizeMsg - 1 ) if ( msg . sds . numScreens < 1 ) EDSERROR ( ""Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid"" , msg . sds . numScreens ) ; msg . sds . w = Swap16IfLE ( msg . sds . w ) ; msg . sds . h = Swap16IfLE ( msg . sds . h ) ; if ( msg . sds . w < 1 || msg . sds . h < 1 ) EDSERROR ( ""Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , msg . sds . w , msg . sds . h ) ; xorg_list_init ( & newScreens ) ; for ( i = 0 ; i < msg . sds . numScreens ; i ++ ) { rfbScreenInfo * screen = rfbNewScreen ( 0 , 0 , 0 , 0 , 0 , 0 ) ; READ ( ( char * ) & screen -> s , sizeof ( rfbScreenDesc ) ) screen -> s . id = Swap32IfLE ( screen -> s . id ) ; screen -> s . x = Swap16IfLE ( screen -> s . x ) ; screen -> s . y = Swap16IfLE ( screen -> s . y ) ; screen -> s . w = Swap16IfLE ( screen -> s . w ) ; screen -> s . h = Swap16IfLE ( screen -> s . h ) ; screen -> s . flags = Swap32IfLE ( screen -> s . flags ) ; if ( screen -> s . w < 1 || screen -> s . h < 1 ) EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid"" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h ) ; if ( screen -> s . x >= msg . sds . w || screen -> s . y >= msg . sds . h || screen -> s . x + screen -> s . w > msg . sds . w || screen -> s . y + screen -> s . h > msg . sds . h ) EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions"" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h , screen -> s . x , screen -> s . y ) ; if ( rfbFindScreenID ( & newScreens , screen -> s . id ) ) { EDSERROR ( ""Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID"" , ( unsigned int ) screen -> s . id ) ; free ( screen ) ; } else rfbAddScreen ( & newScreens , screen ) ; } if ( cl -> viewOnly ) { rfbLog ( ""NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\n"" ) ; result = rfbEDSResultProhibited ; } else if ( result == rfbEDSResultSuccess ) { result = ResizeDesktop ( pScreen , cl , msg . sds . w , msg . sds . h , & newScreens ) ; if ( result == rfbEDSResultSuccess ) return ; } else rfbLog ( errMsg ) ; rfbRemoveScreens ( & newScreens ) ; for ( cl2 = rfbClientHead ; cl2 ; cl2 = cl2 -> next ) { if ( cl2 == cl ) { cl2 -> pendingExtDesktopResize = TRUE ; cl2 -> reason = rfbEDSReasonClient ; cl2 -> result = result ; rfbSendFramebufferUpdate ( cl2 ) ; break ; } } return ; } case rfbGIIClient : { CARD8 endianAndSubType , littleEndian , subType ; READ ( ( char * ) & endianAndSubType , 1 ) ; littleEndian = ( endianAndSubType & rfbGIIBE ) ? 0 : 1 ; subType = endianAndSubType & ~ rfbGIIBE ; switch ( subType ) { case rfbGIIVersion : READ ( ( char * ) & msg . giicv . length , sz_rfbGIIClientVersionMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giicv . length = Swap16 ( msg . giicv . length ) ; msg . giicv . version = Swap16 ( msg . giicv . version ) ; } if ( msg . giicv . length != sz_rfbGIIClientVersionMsg - 4 || msg . giicv . version < 1 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } rfbLog ( ""Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\n"" , msg . giicv . version ) ; break ; case rfbGIIDeviceCreate : { int i ; rfbDevInfo dev ; rfbGIIDeviceCreatedMsg dcmsg ; memset ( & dev , 0 , sizeof ( dev ) ) ; dcmsg . deviceOrigin = 0 ; READ ( ( char * ) & msg . giidc . length , sz_rfbGIIDeviceCreateMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidc . length = Swap16 ( msg . giidc . length ) ; msg . giidc . vendorID = Swap32 ( msg . giidc . vendorID ) ; msg . giidc . productID = Swap32 ( msg . giidc . productID ) ; msg . giidc . canGenerate = Swap32 ( msg . giidc . canGenerate ) ; msg . giidc . numRegisters = Swap32 ( msg . giidc . numRegisters ) ; msg . giidc . numValuators = Swap32 ( msg . giidc . numValuators ) ; msg . giidc . numButtons = Swap32 ( msg . giidc . numButtons ) ; } rfbLog ( ""GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\n"" , msg . giidc . deviceName ) ;  ifdef GII_DEBUG rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\n"" , msg . giidc . vendorID ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\n"" , msg . giidc . productID ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\n"" , msg . giidc . canGenerate ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\n"" , msg . giidc . numRegisters ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\n"" , msg . giidc . numValuators ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\n"" , msg . giidc . numButtons ) ;   if ( msg . giidc . length != sz_rfbGIIDeviceCreateMsg - 4 + msg . giidc . numValuators * sz_rfbGIIValuator ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( msg . giidc . numButtons > MAX_BUTTONS ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , msg . giidc . numButtons , MAX_BUTTONS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } if ( msg . giidc . numValuators > MAX_VALUATORS ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n"" , msg . giidc . numValuators , MAX_VALUATORS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } memcpy ( & dev . name , msg . giidc . deviceName , 32 ) ; dev . numButtons = msg . giidc . numButtons ; dev . numValuators = msg . giidc . numValuators ; dev . eventMask = msg . giidc . canGenerate ; dev . mode = ( dev . eventMask & rfbGIIValuatorAbsoluteMask ) ? Absolute : Relative ; dev . productID = msg . giidc . productID ; if ( dev . mode == Relative ) { rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\n"" ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } for ( i = 0 ; i < dev . numValuators ; i ++ ) { rfbGIIValuator * v = & dev . valuators [ i ] ; READ ( ( char * ) v , sz_rfbGIIValuator ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v -> index = Swap32 ( v -> index ) ; v -> rangeMin = Swap32 ( ( CARD32 ) v -> rangeMin ) ; v -> rangeCenter = Swap32 ( ( CARD32 ) v -> rangeCenter ) ; v -> rangeMax = Swap32 ( ( CARD32 ) v -> rangeMax ) ; v -> siUnit = Swap32 ( v -> siUnit ) ; v -> siAdd = Swap32 ( ( CARD32 ) v -> siAdd ) ; v -> siMul = Swap32 ( ( CARD32 ) v -> siMul ) ; v -> siDiv = Swap32 ( ( CARD32 ) v -> siDiv ) ; v -> siShift = Swap32 ( ( CARD32 ) v -> siShift ) ; }  ifdef GII_DEBUG rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\n"" , v -> longName , v -> shortName ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\n"" , v -> index ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\n"" , v -> rangeMin , v -> rangeCenter , v -> rangeMax ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\n"" , v -> siUnit ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\n"" , v -> siAdd ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\n"" , v -> siMul ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\n"" , v -> siDiv ) ; rfbLog ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\n"" , v -> siShift ) ;   } for ( i = 0 ; i < cl -> numDevices ; i ++ ) { if ( ! strcmp ( dev . name , cl -> devices [ i ] . name ) ) { rfbLog ( ""Device<S2SV_blank>\\\'%s\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\n"" , dev . name , i + 1 ) ; dcmsg . deviceOrigin = Swap32IfLE ( i + 1 ) ; goto sendMessage ; } } if ( rfbVirtualTablet || AddExtInputDevice ( & dev ) ) { memcpy ( & cl -> devices [ cl -> numDevices ] , & dev , sizeof ( dev ) ) ; cl -> numDevices ++ ; dcmsg . deviceOrigin = Swap32IfLE ( cl -> numDevices ) ; } rfbLog ( ""GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\n"" , cl -> numDevices ) ; sendMessage : dcmsg . type = rfbGIIServer ; dcmsg . endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE ; dcmsg . length = Swap16IfLE ( sz_rfbGIIDeviceCreatedMsg - 4 ) ; if ( WriteExact ( cl , ( char * ) & dcmsg , sz_rfbGIIDeviceCreatedMsg ) < 0 ) { rfbLogPerror ( ""rfbProcessClientNormalMessage:<S2SV_blank>write"" ) ; rfbCloseClient ( cl ) ; return ; } break ; } case rfbGIIDeviceDestroy : READ ( ( char * ) & msg . giidd . length , sz_rfbGIIDeviceDestroyMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidd . length = Swap16 ( msg . giidd . length ) ; msg . giidd . deviceOrigin = Swap32 ( msg . giidd . deviceOrigin ) ; } if ( msg . giidd . length != sz_rfbGIIDeviceDestroyMsg - 4 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } RemoveExtInputDevice ( cl , msg . giidd . deviceOrigin - 1 ) ; break ; case rfbGIIEvent : { CARD16 length ; READ ( ( char * ) & length , sizeof ( CARD16 ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) length = Swap16 ( length ) ; while ( length > 0 ) { CARD8 eventSize , eventType ; READ ( ( char * ) & eventSize , 1 ) ; READ ( ( char * ) & eventType , 1 ) ; switch ( eventType ) { case rfbGIIButtonPress : case rfbGIIButtonRelease : { rfbGIIButtonEvent b ; rfbDevInfo * dev ; READ ( ( char * ) & b . pad , sz_rfbGIIButtonEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { b . deviceOrigin = Swap32 ( b . deviceOrigin ) ; b . buttonNumber = Swap32 ( b . buttonNumber ) ; } if ( eventSize != sz_rfbGIIButtonEvent || b . deviceOrigin <= 0 || b . buttonNumber < 1 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( b . deviceOrigin < 1 || b . deviceOrigin > cl -> numDevices ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ b . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIButtonPress && ( dev -> eventMask & rfbGIIButtonPressMask ) == 0 ) || ( eventType == rfbGIIButtonRelease && ( dev -> eventMask & rfbGIIButtonReleaseMask ) == 0 ) ) { rfbLog ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\n"" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( b . buttonNumber > dev -> numButtons ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\n"" , b . buttonNumber , b . deviceOrigin , dev -> numButtons ) ; rfbCloseClient ( cl ) ; return ; }  ifdef GII_DEBUG rfbLog ( ""Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\n"" , b . deviceOrigin , b . buttonNumber , eventType == rfbGIIButtonPress ? ""PRESS"" : ""release"" ) ; fflush ( stderr ) ;   ExtInputAddEvent ( dev , eventType == rfbGIIButtonPress ? ButtonPress : ButtonRelease , b . buttonNumber ) ; break ; } case rfbGIIValuatorRelative : case rfbGIIValuatorAbsolute : { rfbGIIValuatorEvent v ; int i ; rfbDevInfo * dev ; READ ( ( char * ) & v . pad , sz_rfbGIIValuatorEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v . deviceOrigin = Swap32 ( v . deviceOrigin ) ; v . first = Swap32 ( v . first ) ; v . count = Swap32 ( v . count ) ; } if ( eventSize != sz_rfbGIIValuatorEvent + sizeof ( int ) * v . count ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\n"" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( v . deviceOrigin < 1 || v . deviceOrigin > cl -> numDevices ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n"" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ v . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIValuatorRelative && ( dev -> eventMask & rfbGIIValuatorRelativeMask ) == 0 ) || ( eventType == rfbGIIValuatorAbsolute && ( dev -> eventMask & rfbGIIValuatorAbsoluteMask ) == 0 ) ) { rfbLog ( ""ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\n"" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( v . first + v . count > dev -> numValuators ) { rfbLog ( ""ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\n"" , v . deviceOrigin , dev -> numValuators ) ; rfbCloseClient ( cl ) ; return ; }  ifdef GII_DEBUG rfbLog ( ""Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\n"" , v . deviceOrigin , eventType == rfbGIIValuatorRelative ? ""rel"" : ""ABS"" , v . first , v . count ) ;   for ( i = v . first ; i < v . first + v . count ; i ++ ) { READ ( ( char * ) & dev -> values [ i ] , sizeof ( int ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) dev -> values [ i ] = Swap32 ( ( CARD32 ) dev -> values [ i ] ) ;  ifdef GII_DEBUG fprintf ( stderr , ""v[%d]=%d<S2SV_blank>"" , i , dev -> values [ i ] ) ;   }  ifdef GII_DEBUG fprintf ( stderr , ""\\n"" ) ;   if ( v . count > 0 ) { dev -> valFirst = v . first ; dev -> valCount = v . count ; dev -> mode = eventType == rfbGIIValuatorAbsolute ? Absolute : Relative ; ExtInputAddEvent ( dev , MotionNotify , 0 ) ; } break ; } default : rfbLog ( ""ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\n"" , eventType ) ; rfbCloseClient ( cl ) ; return ; } } if ( length != 0 ) { rfbLog ( ""ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n"" ) ; rfbCloseClient ( cl ) ; return ; } break ; } } return ; } default : rfbLog ( ""rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\n"" , msg . type ) ; rfbLog ( ""<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\n"" ) ; rfbCloseClient ( cl ) ; return ; } }","<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( msg <S2SV_ModStart> data ) ) { <S2SV_ModStart> length ) ; SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> HandleFence ( cl <S2SV_ModStart> data ) ; }"
63,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = METHOD_1 ( VAR_4 ) -> VAR_5 ; TYPE_5 VAR_6 = VAR_7 -> VAR_8 . VAR_9 / 8 ; TYPE_6 VAR_10 = VAR_11 / VAR_12 ; TYPE_7 VAR_13 ; TYPE_8 * VAR_14 = ( TYPE_9 * ) VAR_15 ; <S2SV_StartBug> TYPE_10 * VAR_16 = ( TYPE_11 * ) METHOD_2 ( VAR_17 ) ; <S2SV_EndBug> if ( ( VAR_18 % ( VAR_19 * VAR_20 ) ) != 0 ) { METHOD_3 ( VAR_21 -> VAR_22 , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_StartBug> if ( ! VAR_23 ) <S2SV_EndBug> return 0 ; METHOD_4 ( VAR_24 , VAR_25 , VAR_26 ) ; for ( VAR_27 = 0 ; VAR_28 < VAR_29 ; VAR_30 ++ ) { TYPE_12 VAR_31 ; for ( VAR_32 = 0 ; VAR_33 < VAR_34 ; VAR_35 ++ ) { if VAR_36 VAR_37 [ VAR_38 * VAR_39 + VAR_40 ] = VAR_41 [ VAR_42 * VAR_43 + VAR_44 ] ; else VAR_45 [ ( VAR_46 - VAR_47 - 1 ) * VAR_48 + VAR_49 ] = VAR_50 [ VAR_51 * VAR_52 + VAR_53 ] ; } } METHOD_5 ( VAR_54 ) ; VAR_55 = ( TYPE_13 * ) VAR_56 ; VAR_57 += VAR_58 - VAR_59 - 1 ; for ( VAR_60 = VAR_61 ; VAR_62 > VAR_63 ; VAR_64 -= VAR_65 ) REPEAT4 ( VAR_66 , VAR_67 [ VAR_68 ] = ( unsigned TYPE_14 ) ( ( VAR_69 [ VAR_70 ] - VAR_71 [ 0 ] ) & 0xff ) ; VAR_72 -- ) return 1 ; }",<S2SV_ModStart> TYPE_13 * VAR_54 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } VAR_54 = ( TYPE_13 * ) METHOD_2 ( VAR_61 ) ;,"CWE-119 static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) {  if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ;  else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ;   } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }",<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
64,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { unsigned TYPE_2 VAR_3 , VAR_4 ; TYPE_3 * VAR_5 , * VAR_6 ; struct STRUCT_OR_UNION_2 * VAR_7 ; if ( ! ( VAR_8 = METHOD_1 ( VAR_9 , & VAR_10 -> VAR_11 ) ) || ! ( VAR_12 = METHOD_2 ( VAR_13 , & VAR_14 -> VAR_15 , & VAR_16 -> VAR_17 ) ) ) return 0 ; VAR_18 = METHOD_3 ( VAR_19 , & VAR_20 -> VAR_21 ) ; VAR_22 = METHOD_4 ( * VAR_23 ++ ) ; if ( VAR_24 == 0 || VAR_25 > VAR_26 || VAR_27 >= VAR_28 ) return 0 ; VAR_29 -> VAR_30 = VAR_31 = METHOD_5 ( * ( VAR_32 -> VAR_33 ++ ) ) ; VAR_34 -> VAR_35 = VAR_36 ; VAR_37 = ( TYPE_4 * ) VAR_38 ; VAR_39 = & VAR_40 -> VAR_41 . VAR_42 [ 0 ] ; <S2SV_StartBug> VAR_43 = VAR_44 -> VAR_45 - ( VAR_46 - ( TYPE_5 * ) VAR_47 -> VAR_48 ) ; <S2SV_EndBug> while ( VAR_49 && VAR_50 && * VAR_51 ) { * VAR_52 ++ = * VAR_53 ++ ; VAR_54 -- ; VAR_55 -- ; } if ( VAR_56 && ! VAR_57 && VAR_58 -> VAR_59 . VAR_60 ) { VAR_61 = min_t ( unsigned TYPE_6 , VAR_62 -> VAR_63 . VAR_64 , VAR_65 ) ; VAR_66 = METHOD_6 ( VAR_67 -> VAR_68 . VAR_69 [ 0 ] ) ; } while ( VAR_70 && VAR_71 && * VAR_72 ) { * VAR_73 ++ = * VAR_74 ++ ; VAR_75 -- ; VAR_76 -- ; } * VAR_77 = '\\0' ; if ( VAR_78 ) return 0 ; return 1 ; }",<S2SV_ModStart> 0 ] ; if ( ( TYPE_7 * ) VAR_74 > VAR_47 -> VAR_48 + VAR_47 -> VAR_45 ) return 0 ;,"CWE-119 int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) { unsigned int len , avail ; char * old , * new ; struct kvec * vec ; if ( ! ( p = decode_fh ( p , & args -> ffh ) ) || ! ( p = decode_filename ( p , & args -> fname , & args -> flen ) ) ) return 0 ; p = decode_sattr3 ( p , & args -> attrs ) ; len = ntohl ( * p ++ ) ; if ( len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE ) return 0 ; args -> tname = new = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; args -> tlen = len ; old = ( char * ) p ; vec = & rqstp -> rq_arg . head [ 0 ] ; <S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } if ( len && ! avail && rqstp -> rq_arg . page_len ) { avail = min_t ( unsigned int , rqstp -> rq_arg . page_len , PAGE_SIZE ) ; old = page_address ( rqstp -> rq_arg . pages [ 0 ] ) ; } while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } * new = '\\0' ; if ( len ) return 0 ; return 1 ; }",<S2SV_ModStart> 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
65,"CWE-000 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , TYPE_0 VAR_2 ) { struct STRUCT_OR_UNION_3 VAR_3 ; <S2SV_StartBug> struct STRUCT_OR_UNION_4 * VAR_4 ; <S2SV_EndBug> VAR_5 = METHOD_1 ( VAR_6 , VAR_7 ) ; if ( ! VAR_8 ) return METHOD_2 ( - VAR_9 ) ; VAR_10 . VAR_11 = VAR_12 ; VAR_13 . VAR_14 = VAR_15 ; VAR_16 . VAR_17 = VAR_18 ; VAR_19 . VAR_20 = 0 ; <S2SV_StartBug> if ( METHOD_3 ( VAR_21 , 0 , & VAR_22 ) ) { <S2SV_EndBug> METHOD_4 ( VAR_23 ) ; <S2SV_StartBug> return VAR_24 ; <S2SV_EndBug> } return VAR_25 ; }",<S2SV_ModStart> STRUCT_OR_UNION_4 * VAR_25 ; TYPE_1 VAR_26 <S2SV_ModStart> = 0 ; VAR_26 = <S2SV_ModEnd> METHOD_3 ( VAR_21 <S2SV_ModStart> & VAR_22 ) ; if ( VAR_26 <S2SV_ModStart> ) ; return METHOD_2 ( VAR_26 ) <S2SV_ModEnd> ; } return,"CWE-000 static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }",<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
66,"CWE-120 enum VAR_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , const TYPE_0 * VAR_2 ) { TYPE_1 VAR_3 [ VAR_4 * 2 ] , VAR_5 [ VAR_6 ] ; unsigned TYPE_2 VAR_7 [ VAR_8 ] ; TYPE_3 VAR_9 ; TYPE_4 VAR_10 ; if ( ! METHOD_1 ( VAR_11 -> VAR_12 , VAR_13 ) ) return VAR_14 ; METHOD_2 ( METHOD_3 ( ""Authenticating<S2SV_blank>(CRAM-MD5)..."" ) ) ; if ( METHOD_4 ( & VAR_15 -> VAR_16 -> VAR_17 ) < 0 ) return VAR_18 ; if ( METHOD_5 ( & VAR_19 -> VAR_20 -> VAR_21 ) < 0 ) return VAR_22 ; METHOD_6 ( VAR_23 , ""AUTHENTICATE<S2SV_blank>CRAM-MD5"" ) ; do VAR_24 = METHOD_7 ( VAR_25 ) ; while ( VAR_26 == VAR_27 ) ; if ( VAR_28 != VAR_29 ) { METHOD_8 ( 1 , ""Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n"" , VAR_30 ) ; goto VAR_31 ; } <S2SV_StartBug> VAR_32 = METHOD_9 ( VAR_33 , VAR_34 -> VAR_35 + 2 ) ; <S2SV_EndBug> if ( VAR_36 == - 1 ) { METHOD_10 ( 1 , ""Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n"" ) ; goto VAR_37 ; } VAR_38 [ VAR_39 ] = '\\0' ; METHOD_11 ( 2 , ""CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n"" , VAR_40 ) ; METHOD_12 ( VAR_41 -> VAR_42 -> VAR_43 . VAR_44 , VAR_45 , VAR_46 ) ; TYPE_5 VAR_47 = METHOD_13 ( VAR_48 , sizeof ( VAR_49 ) , ""%s<S2SV_blank>"" , VAR_50 -> VAR_51 -> VAR_52 . VAR_53 ) ; METHOD_14 ( VAR_54 , VAR_55 + VAR_56 ) ; METHOD_15 ( 2 , ""CRAM<S2SV_blank>response:<S2SV_blank>%s\\n"" , VAR_57 ) ; METHOD_16 ( VAR_58 , VAR_59 , METHOD_17 ( VAR_60 ) , sizeof ( VAR_61 ) - 2 ) ; METHOD_18 ( VAR_62 , sizeof ( VAR_63 ) , ""\\r\\n"" ) ; METHOD_19 ( VAR_64 -> VAR_65 , VAR_66 ) ; do VAR_67 = METHOD_20 ( VAR_68 ) ; while ( VAR_69 == VAR_70 ) ; if ( VAR_71 != VAR_72 ) { METHOD_21 ( 1 , ""Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; goto VAR_73 ; } if ( METHOD_22 ( VAR_74 -> VAR_75 ) ) return VAR_76 ; VAR_77 : METHOD_23 ( METHOD_24 ( ""CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed."" ) ) ; return VAR_78 ; }","<S2SV_ModStart> VAR_75 + 2 , sizeof ( VAR_60 )","CWE-120 enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( ""Authenticating<S2SV_blank>(CRAM-MD5)..."" ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , ""AUTHENTICATE<S2SV_blank>CRAM-MD5"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n"" , ibuf ) ; goto bail ; } <S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> if ( len == - 1 ) { mutt_debug ( 1 , ""Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n"" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , ""CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n"" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , ""%s<S2SV_blank>"" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , ""CRAM<S2SV_blank>response:<S2SV_blank>%s\\n"" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , ""Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( ""CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }","<S2SV_ModStart> buf + 2 , sizeof ( obuf )"
67,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 , unsigned TYPE_2 VAR_3 , unsigned TYPE_3 VAR_4 , struct STRUCT_OR_UNION_2 * * VAR_5 ) { <S2SV_StartBug> TYPE_4 VAR_6 = VAR_7 -> VAR_8 & VAR_9 ; <S2SV_EndBug> struct STRUCT_OR_UNION_3 * VAR_10 = METHOD_1 ( VAR_11 ) ; TYPE_5 VAR_12 ; VAR_13 * VAR_14 ; TYPE_6 VAR_15 ; struct STRUCT_OR_UNION_4 * STRUCT_OR_UNION_5 ; if ( ! * VAR_16 ) { VAR_17 = - VAR_18 ; STRUCT_OR_UNION_6 = METHOD_2 ( VAR_19 , VAR_20 , 0 ) ; if ( METHOD_3 ( STRUCT_OR_UNION_7 ) ) goto VAR_21 ; VAR_22 = METHOD_4 ( STRUCT_OR_UNION_8 , ( const TYPE_7 TYPE_8 * ) VAR_23 , METHOD_5 ( VAR_24 ) , VAR_25 ) ; if ( METHOD_6 ( VAR_26 ) ) { VAR_27 = - VAR_28 ; * VAR_29 = STRUCT_OR_UNION_9 ; goto VAR_30 ; } } else { STRUCT_OR_UNION_10 = * VAR_31 ; * VAR_32 = VAR_33 ; } METHOD_7 ( STRUCT_OR_UNION_11 ) ; METHOD_8 ( STRUCT_OR_UNION_12 ) ; <S2SV_StartBug> if ( VAR_34 ) { <S2SV_EndBug> <S2SV_StartBug> struct STRUCT_OR_UNION_13 * VAR_35 = VAR_36 -> VAR_37 -> VAR_38 ; <S2SV_EndBug> TYPE_9 VAR_39 = METHOD_9 ( VAR_40 , VAR_41 , VAR_42 ) ; VAR_43 = METHOD_10 ( STRUCT_OR_UNION_14 , VAR_44 , VAR_45 ) ; if ( VAR_46 ) goto VAR_47 ; } VAR_48 = METHOD_11 ( VAR_49 , VAR_50 , VAR_51 ) ; <S2SV_StartBug> METHOD_12 ( VAR_52 ) ; <S2SV_EndBug> VAR_53 = - VAR_54 ; if ( ! METHOD_13 ( METHOD_14 ( VAR_55 ) ) ) goto VAR_56 ; if ( VAR_57 ) { METHOD_15 ( STRUCT_OR_UNION_15 , VAR_58 ) ; } else { METHOD_16 ( STRUCT_OR_UNION_16 ) ; METHOD_17 ( STRUCT_OR_UNION_17 , VAR_59 , VAR_60 ) ; } VAR_61 = METHOD_18 ( VAR_62 , STRUCT_OR_UNION_18 , VAR_63 -> VAR_64 & VAR_65 ) ; if ( VAR_66 -> VAR_67 & VAR_68 ) VAR_69 = METHOD_19 ( VAR_70 ) ; VAR_71 = METHOD_20 ( VAR_72 ) ; METHOD_21 ( VAR_73 , VAR_74 , VAR_75 , VAR_76 ) ; ( TYPE_10 ) METHOD_22 ( VAR_77 , VAR_78 , VAR_79 , VAR_80 , VAR_81 -> VAR_82 & VAR_83 ) ; METHOD_23 ( METHOD_24 ( VAR_84 ) , VAR_85 ) ; METHOD_25 ( VAR_86 , VAR_87 , VAR_88 ) ; METHOD_26 ( VAR_89 ) ; if ( VAR_90 ) METHOD_27 ( STRUCT_OR_UNION_19 ) ; VAR_91 = 0 ; VAR_92 : return VAR_93 ; VAR_94 : METHOD_28 ( VAR_95 ) ; if ( VAR_96 ) METHOD_29 ( STRUCT_OR_UNION_20 ) ; VAR_97 : METHOD_30 ( STRUCT_OR_UNION_21 ) ; goto VAR_98 ; }","<S2SV_ModStart> VAR_32 ) { struct STRUCT_OR_UNION_13 * VAR_44 ; TYPE_9 VAR_45 ; unsigned TYPE_3 VAR_99 ; <S2SV_ModStart> STRUCT_OR_UNION_21 ) ; VAR_44 = VAR_86 -> VAR_37 -> VAR_38 ; VAR_45 = METHOD_9 ( VAR_84 , VAR_86 , VAR_87 ) ; <S2SV_ModStart> VAR_96 ) { VAR_99 = METHOD_31 ( VAR_44 -> VAR_100 ) >> METHOD_32 ( VAR_84 ) ; VAR_93 = - VAR_28 ; if ( VAR_45 >= VAR_99 ) goto VAR_97 <S2SV_ModEnd> ; VAR_93 = <S2SV_ModStart> ( VAR_95 ) ; VAR_99 = METHOD_31 ( VAR_44 -> VAR_100 ) >> METHOD_32 ( VAR_84 ) ; VAR_93 = - VAR_28 ; if ( VAR_45 >= VAR_99 ) goto VAR_94","CWE-119 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { <S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }","<S2SV_ModStart> pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock"
68,"CWE-000 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 ) { <S2SV_StartBug> TYPE_4 VAR_3 [ 1024 ] , * VAR_4 ; <S2SV_EndBug> VAR_5 * VAR_6 ; TYPE_5 VAR_7 ; <S2SV_StartBug> VAR_8 = METHOD_1 ( VAR_9 , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , VAR_10 , ""`"" , VAR_11 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_12 && VAR_13 [ 0 ] ) <S2SV_EndBug> METHOD_2 ( VAR_14 , ""<S2SV_blank>like<S2SV_blank>\'"" , VAR_15 , ""\'"" , VAR_16 ) ; if ( METHOD_3 ( VAR_17 , VAR_18 ) || ! ( VAR_19 = METHOD_4 ( VAR_20 ) ) ) { METHOD_5 ( VAR_21 , ""%s:<S2SV_blank>Cannot<S2SV_blank>get<S2SV_blank>status<S2SV_blank>for<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , VAR_22 , VAR_23 , VAR_24 ? VAR_25 : """" , METHOD_6 ( VAR_26 ) ) ; if ( METHOD_7 ( VAR_27 ) == VAR_28 ) METHOD_8 ( VAR_29 , ""This<S2SV_blank>error<S2SV_blank>probably<S2SV_blank>means<S2SV_blank>that<S2SV_blank>your<S2SV_blank>MySQL<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>the\\n\\\'show<S2SV_blank>table<S2SV_blank>status\'<S2SV_blank>command.\\n"" ) ; return 1 ; } METHOD_9 ( ""Database:<S2SV_blank>%s"" , VAR_30 ) ; if ( VAR_31 ) METHOD_10 ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , VAR_32 ) ; METHOD_11 ( '\\n' ) ; METHOD_12 ( VAR_33 ) ; while ( ( VAR_34 = METHOD_13 ( VAR_35 ) ) ) METHOD_14 ( VAR_36 , VAR_37 ) ; METHOD_15 ( VAR_38 ) ; METHOD_16 ( VAR_39 ) ; return 0 ; }","<S2SV_ModStart> TYPE_4 VAR_18 [ VAR_40 + 100 ] ; TYPE_0 VAR_41 <S2SV_ModEnd> ; VAR_5 * <S2SV_ModStart> TYPE_5 VAR_37 ; VAR_41 = sizeof ( VAR_18 ) ; VAR_41 -= METHOD_17 ( VAR_18 , VAR_41 , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , VAR_30 <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && VAR_41 ) METHOD_19 ( VAR_18 + METHOD_18 ( VAR_18 ) , VAR_41 <S2SV_ModEnd> , ""<S2SV_blank>like<S2SV_blank>\'"" ,","CWE-000 static int list_table_status ( MYSQL * mysql , const char * db , const char * wild ) { <S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> MYSQL_RES * result ; MYSQL_ROW row ; <S2SV_StartBug> end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\'"" , wild , ""\'"" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>get<S2SV_blank>status<S2SV_blank>for<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , wild ? wild : """" , mysql_error ( mysql ) ) ; if ( mysql_errno ( mysql ) == ER_PARSE_ERROR ) fprintf ( stderr , ""This<S2SV_blank>error<S2SV_blank>probably<S2SV_blank>means<S2SV_blank>that<S2SV_blank>your<S2SV_blank>MySQL<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>the\\n\\\'show<S2SV_blank>table<S2SV_blank>status\'<S2SV_blank>command.\\n"" ) ; return 1 ; } printf ( ""Database:<S2SV_blank>%s"" , db ) ; if ( wild ) printf ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; mysql_free_result ( result ) ; return 0 ; }","<S2SV_ModStart> char query [ NAME_LEN + 100 ] ; int len <S2SV_ModEnd> ; MYSQL_RES * <S2SV_ModStart> MYSQL_ROW row ; len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> , ""<S2SV_blank>like<S2SV_blank>\'"" ,"
69,"CWE-772 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { static TYPE_2 VAR_2 ; TYPE_3 * VAR_3 ; <S2SV_StartBug> TYPE_4 VAR_4 , <S2SV_EndBug> VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; const TYPE_7 * VAR_8 = VAR_9 ; METHOD_1 ( VAR_10 , & VAR_11 ) ; if ( ( VAR_12 . VAR_13 = METHOD_2 ( VAR_14 -> VAR_15 , VAR_16 , & VAR_17 ) ) ) goto VAR_18 ; if ( ( VAR_19 . VAR_20 = METHOD_3 ( ( TYPE_8 * ) VAR_21 ) ) ) goto VAR_22 ; VAR_23 . VAR_24 = VAR_25 -> VAR_26 ; if ( METHOD_4 ( VAR_27 , & VAR_28 , & VAR_29 ) < 0 ) { VAR_30 . VAR_31 = VAR_32 ; goto VAR_33 ; } if ( METHOD_5 ( VAR_34 -> VAR_35 , VAR_36 -> VAR_37 , & VAR_38 ) ) { VAR_39 . VAR_40 = VAR_41 ; goto VAR_42 ; } if ( METHOD_6 ( VAR_43 ) || ! METHOD_7 ( VAR_44 -> VAR_45 , METHOD_8 ( VAR_46 ) , VAR_47 , VAR_48 -> VAR_49 , VAR_50 ) ) { VAR_51 . VAR_52 = VAR_53 ; METHOD_9 ( ""kadm5_delete_principal"" , VAR_54 , & VAR_55 , & VAR_56 , VAR_57 ) ; } else { VAR_58 . VAR_59 = METHOD_10 ( ( TYPE_9 * ) VAR_60 , VAR_61 -> VAR_62 ) ; if ( VAR_63 . VAR_64 != 0 ) VAR_65 = METHOD_11 ( VAR_66 -> VAR_67 , VAR_68 . VAR_69 ) ; METHOD_12 ( ""kadm5_delete_principal"" , VAR_70 , VAR_71 , & VAR_72 , & VAR_73 , VAR_74 ) ; if ( VAR_75 != VAR_76 ) METHOD_13 ( VAR_77 -> VAR_78 , VAR_79 ) ; } METHOD_14 ( VAR_80 ) ; <S2SV_StartBug> METHOD_15 ( & VAR_81 , & VAR_82 ) ; <S2SV_EndBug> METHOD_16 ( & VAR_83 , & VAR_84 ) ; <S2SV_StartBug> VAR_85 : <S2SV_EndBug> METHOD_17 ( VAR_86 ) ; return & VAR_87 ; }",<S2SV_ModStart> ; TYPE_4 VAR_82 = VAR_88 ; TYPE_4 VAR_84 = VAR_88 <S2SV_ModEnd> ; TYPE_5 VAR_83 <S2SV_ModStart> VAR_80 ) ; VAR_85 : <S2SV_ModStart> VAR_84 ) ; <S2SV_ModEnd> METHOD_17 ( VAR_86,"CWE-772 generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( ""kadm5_delete_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_delete_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
70,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 , unsigned TYPE_3 VAR_3 ) { struct STRUCT_OR_UNION_1 * VAR_4 = VAR_5 -> VAR_6 ; struct STRUCT_OR_UNION_2 * VAR_7 = STRUCT_OR_UNION_3 ( VAR_8 ) ; struct STRUCT_OR_UNION_4 * VAR_9 = VAR_10 -> VAR_11 ; TYPE_4 TYPE_5 * VAR_12 = ( TYPE_6 TYPE_7 * ) VAR_13 ; TYPE_8 VAR_14 ; METHOD_1 ( 1 , METHOD_2 ( VAR_15 , VAR_16 , ""sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>"" ""cmd=0x%x\\n"" , VAR_17 -> VAR_18 , VAR_19 ) ) ; <S2SV_StartBug> VAR_20 = METHOD_3 ( VAR_21 , VAR_22 , VAR_23 , <S2SV_EndBug> ( VAR_24 & VAR_25 ) != 0 ) ; if ( ! METHOD_4 ( VAR_26 ) || ! VAR_27 ) goto VAR_28 ; switch ( VAR_29 ) { case VAR_30 : case VAR_31 : VAR_32 = METHOD_5 ( VAR_33 , VAR_34 , VAR_35 ) ; break ; default : VAR_36 = METHOD_6 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; if ( VAR_41 != - VAR_42 ) break ; VAR_43 = METHOD_7 ( VAR_44 , VAR_45 , VAR_46 ) ; break ; } VAR_47 : return VAR_48 ; }","<S2SV_ModStart> ; VAR_48 = METHOD_8 ( VAR_37 , VAR_45 ) ; if ( VAR_48 < 0 ) return VAR_48 ; VAR_48 =","CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , ""sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>"" ""cmd=0x%x\\n"" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }","<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error ="
71,"CWE-200 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 ) { struct STRUCT_OR_UNION_3 VAR_2 ; struct STRUCT_OR_UNION_4 * VAR_3 ; TYPE_2 VAR_4 ; TYPE_3 VAR_5 = 0 ; TYPE_4 VAR_6 = 0 ; TYPE_5 VAR_7 = 0 ; <S2SV_StartBug> if ( ! METHOD_1 ( STRUCT_OR_UNION_5 -> VAR_8 ) -> VAR_9 ) <S2SV_EndBug> return 0 ; * VAR_10 = 0 ; METHOD_2 ( & VAR_11 , STRUCT_OR_UNION_6 ) ; METHOD_3 ( VAR_12 , STRUCT_OR_UNION_7 , & VAR_13 ) ; VAR_14 : while ( VAR_15 . VAR_16 > 2 ) { VAR_17 = ( struct STRUCT_OR_UNION_8 * ) VAR_18 . VAR_19 ; if ( VAR_20 -> VAR_21 < 3 ) goto VAR_22 ; VAR_23 = METHOD_4 ( VAR_24 . VAR_25 ) ; if ( METHOD_5 ( & VAR_26 , VAR_27 ) ) goto VAR_28 ; VAR_29 . VAR_30 += VAR_31 -> VAR_32 ; VAR_33 . VAR_34 -= VAR_35 -> VAR_36 ; if ( VAR_37 . VAR_38 < 0 ) goto VAR_39 ; switch ( VAR_40 ) { case METHOD_6 ( 'R' , 'R' ) : if ( ( VAR_41 -> VAR_42 . VAR_43 . VAR_44 [ 0 ] & VAR_45 ) == 0 ) goto VAR_46 ; break ; case METHOD_7 ( 'S' , 'P' ) : if ( METHOD_8 ( VAR_47 , STRUCT_OR_UNION_9 ) ) goto VAR_48 ; break ; case METHOD_9 ( 'C' , 'E' ) : VAR_49 . VAR_50 = METHOD_10 ( VAR_51 -> VAR_52 . VAR_53 . VAR_54 ) ; VAR_55 . VAR_56 = METHOD_11 ( VAR_57 -> VAR_58 . VAR_59 . VAR_60 ) ; VAR_61 . VAR_62 = METHOD_12 ( VAR_63 -> VAR_64 . VAR_65 . VAR_66 ) ; break ; case METHOD_13 ( 'N' , 'M' ) : if ( VAR_67 ) break ; if ( VAR_68 -> VAR_69 < 5 ) break ; if ( VAR_70 -> VAR_71 . VAR_72 . VAR_73 & 6 ) break ; if ( VAR_74 -> VAR_75 . VAR_76 . VAR_77 & ~ 1 ) { METHOD_14 ( ""Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n"" , VAR_78 -> VAR_79 . VAR_80 . VAR_81 ) ; break ; } <S2SV_StartBug> if ( ( METHOD_15 ( VAR_82 ) + VAR_83 -> VAR_84 - 5 ) >= 254 ) { <S2SV_EndBug> VAR_85 = 1 ; break ; } <S2SV_StartBug> METHOD_16 ( VAR_86 , VAR_87 -> VAR_88 . VAR_89 . VAR_90 , VAR_91 -> VAR_92 - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_93 += VAR_94 -> VAR_95 - 5 ; <S2SV_EndBug> break ; case METHOD_17 ( 'R' , 'E' ) : METHOD_18 ( VAR_96 . VAR_97 ) ; return - 1 ; default : break ; } } VAR_98 = METHOD_19 ( & VAR_99 ) ; if ( VAR_100 == 0 ) goto VAR_101 ; if ( VAR_102 == 1 ) return VAR_103 ; VAR_104 : METHOD_20 ( VAR_105 . VAR_106 ) ; return VAR_107 ; VAR_108 : VAR_109 = - VAR_110 ; goto VAR_111 ; }","<S2SV_ModStart> = 0 ; TYPE_1 * VAR_112 ; TYPE_5 VAR_95 ; <S2SV_ModStart> break ; } VAR_95 = <S2SV_ModEnd> VAR_94 -> VAR_95 <S2SV_ModStart> VAR_95 - 5 ; if ( VAR_103 + VAR_95 <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } VAR_112 = METHOD_21 ( VAR_94 -> VAR_88 . VAR_89 . VAR_90 , '\\0' , VAR_95 ) ; if ( unlikely ( VAR_112 ) ) VAR_95 = VAR_112 - VAR_94 -> VAR_88 . VAR_89 . VAR_90 ; memcpy ( VAR_86 + VAR_103 <S2SV_ModEnd> , VAR_94 -> <S2SV_ModStart> . VAR_90 , VAR_95 <S2SV_ModEnd> ) ; VAR_103 <S2SV_ModStart> ; VAR_103 += VAR_95 ; VAR_86 [ VAR_103 ] = '\\0' <S2SV_ModEnd> ; break ;","CWE-200 int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ; <S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( ""Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n"" , rr -> u . NM . flags ) ; break ; } <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> truncate = 1 ; break ; } <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","<S2SV_ModStart> = 0 ; char * p ; int len ; <S2SV_ModStart> break ; } len = <S2SV_ModEnd> rr -> len <S2SV_ModStart> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> <S2SV_ModStart> . name , len <S2SV_ModEnd> ) ; retnamlen <S2SV_ModStart> ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ;"
72,CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; while ( VAR_2 ) { VAR_3 = VAR_4 -> VAR_5 ; if ( ! ( VAR_6 -> VAR_7 & VAR_8 ) && VAR_9 -> VAR_10 ) METHOD_1 ( VAR_11 -> VAR_12 ) ; if ( ! ( VAR_13 -> VAR_14 & VAR_15 ) && VAR_16 -> VAR_17 ) METHOD_2 ( VAR_18 -> VAR_19 ) ; <S2SV_StartBug> if ( VAR_20 -> VAR_21 ) <S2SV_EndBug> METHOD_3 ( VAR_22 -> VAR_23 ) ; METHOD_4 ( VAR_24 ) ; VAR_25 = VAR_26 ; } },<S2SV_ModStart> ; if ( ! ( VAR_25 -> VAR_14 & VAR_27 ) &&,CWE-119 void cJSON_Delete ( cJSON * c ) { cJSON * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ; if ( ! ( c -> type & cJSON_IsReference ) && c -> valuestring ) cJSON_free ( c -> valuestring ) ; <S2SV_StartBug> if ( c -> string ) <S2SV_EndBug> cJSON_free ( c -> string ) ; cJSON_free ( c ) ; c = next ; } },<S2SV_ModStart> ; if ( ! ( c -> type & cJSON_StringIsConst ) &&
73,CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_EndBug> <S2SV_StartBug> TYPE_2 * const VAR_1 = ( VAR_2 -> VAR_3 > 1 ) <S2SV_EndBug> ? & VAR_4 -> VAR_5 [ VAR_6 -> VAR_7 ] : & VAR_8 -> VAR_9 [ VAR_10 -> VAR_11 ] ; ++ VAR_12 -> VAR_13 ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> TYPE_0 METHOD_0 ( TYPE_3 * const VAR_14 <S2SV_ModEnd> ) { TYPE_2 <S2SV_ModStart> const VAR_12 = & VAR_14 -> VAR_10 . VAR_9 [ VAR_14 -> VAR_10 . VAR_11 * VAR_14 -> VAR_10 . VAR_3 <S2SV_ModEnd> ] ; ++ <S2SV_ModStart> -> VAR_13 ; ++ VAR_12 -> VAR_15 ;,CWE-119 <S2SV_StartBug> void vp9_inc_frame_in_layer ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 ) <S2SV_EndBug> ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ; ++ lc -> current_video_frame_in_layer ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> void vp9_inc_frame_in_layer ( VP9_COMP * const cpi <S2SV_ModEnd> ) { LAYER_CONTEXT <S2SV_ModStart> const lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers <S2SV_ModEnd> ] ; ++ <S2SV_ModStart> -> current_video_frame_in_layer ; ++ lc -> frames_from_key_frame ;
74,"CWE-269 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { VAR_3 * VAR_4 ; TYPE_4 VAR_5 ; <S2SV_StartBug> if ( ! VAR_6 ) <S2SV_EndBug> METHOD_1 ( VAR_7 , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; <S2SV_StartBug> for ( VAR_8 = VAR_9 ; VAR_10 ; VAR_11 = VAR_12 -> VAR_13 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> VAR_14 = METHOD_2 ( VAR_15 , VAR_16 , VAR_17 , VAR_18 , VAR_19 ) ; if ( VAR_20 == VAR_21 ) { if ( VAR_22 > 0 ) return VAR_23 ; } else { if ( VAR_24 >= 0 && * VAR_25 ) return VAR_26 ; } } TYPE_5 TYPE_6 if ( VAR_27 ) METHOD_3 ( VAR_28 , ""%s\\n"" , VAR_29 ) ; if ( VAR_30 ) { * VAR_31 = 0 ; return - 1 ; } else { return 0 ; } }","<S2SV_ModStart> TYPE_4 VAR_26 ; TYPE_3 VAR_32 ; <S2SV_ModStart> ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; VAR_32 = ! METHOD_4 ( VAR_29 , ""autoexec.cfg"" ) || ! METHOD_4 ( VAR_29 , VAR_33 ) ; <S2SV_ModStart> VAR_13 ) { if ( VAR_32 && VAR_16 -> VAR_34 ) continue ;","CWE-269 long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } }  ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , ""%s\\n"" , filename ) ;   if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }","<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;"
75,"CWE-189 static VAR_0 TYPE_0 METHOD_0 ( unsigned TYPE_1 VAR_1 , struct STRUCT_OR_UNION_0 * VAR_2 ) { TYPE_2 VAR_3 = ( TYPE_3 ) VAR_4 * VAR_5 ; <S2SV_StartBug> TYPE_4 VAR_6 ; <S2SV_EndBug> <S2SV_StartBug> VAR_7 -> VAR_8 = METHOD_1 ( VAR_9 , VAR_10 , & VAR_11 ) ; <S2SV_EndBug> VAR_12 -> VAR_13 = VAR_14 / VAR_15 ; }","<S2SV_ModStart> * VAR_5 ; TYPE_5 <S2SV_ModEnd> VAR_14 ; VAR_12 <S2SV_ModStart> -> VAR_8 = METHOD_2 <S2SV_ModEnd> ( VAR_9 ,","CWE-189 static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }","<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,"
76,"CWE-125 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 , * VAR_3 = VAR_4 , * VAR_5 ; register TYPE_4 * VAR_6 ; unsigned TYPE_5 VAR_7 ; TYPE_6 VAR_8 ; TYPE_7 VAR_9 ; TYPE_8 VAR_10 ; TYPE_9 * VAR_11 ; TYPE_10 * VAR_12 ; TYPE_11 VAR_13 ; TYPE_12 VAR_14 ; unsigned TYPE_13 * VAR_15 = VAR_16 ; TYPE_14 VAR_17 , VAR_18 ; unsigned VAR_19 , VAR_20 ; unsigned VAR_21 ; TYPE_15 VAR_22 ; TYPE_16 VAR_23 ; TYPE_17 VAR_24 = 0x80 ; VAR_25 * VAR_26 ; TYPE_18 VAR_27 ; unsigned TYPE_19 ( * METHOD_1 ) ( TYPE_20 * VAR_28 ) ; unsigned TYPE_21 ( * METHOD_2 ) ( TYPE_22 * VAR_29 ) ; TYPE_23 ( * METHOD_3 ) ( TYPE_24 * VAR_30 , TYPE_25 VAR_31 , TYPE_26 * VAR_32 ) ; TYPE_27 ( * METHOD_4 ) ( TYPE_28 * VAR_33 , TYPE_29 VAR_34 , TYPE_30 * VAR_35 ) ; METHOD_5 ( VAR_36 != ( const TYPE_31 * ) VAR_37 ) ; METHOD_6 ( VAR_38 -> VAR_39 == VAR_40 ) ; METHOD_7 ( VAR_41 != ( TYPE_32 * ) VAR_42 ) ; METHOD_8 ( VAR_43 -> VAR_44 == VAR_45 ) ; VAR_46 = METHOD_9 ( VAR_47 , METHOD_10 ( ) , ""enter"" ) ; VAR_48 = METHOD_11 ( VAR_49 , VAR_50 ) ; VAR_51 = METHOD_12 ( VAR_52 , VAR_53 , VAR_54 , VAR_55 ) ; if ( VAR_56 == VAR_57 ) { VAR_58 = METHOD_13 ( VAR_59 ) ; return ( ( TYPE_33 * ) VAR_60 ) ; } VAR_61 = METHOD_14 ( VAR_62 ) ; if ( METHOD_15 ( VAR_63 , 124 , ( unsigned TYPE_34 * ) & VAR_64 . VAR_65 ) != 124 ) METHOD_16 ( VAR_66 , ""ImproperImageHeader"" ) ; VAR_67 . VAR_68 = METHOD_17 ( VAR_69 ) ; if ( METHOD_18 ( VAR_70 , 2 , ( unsigned TYPE_35 * ) & VAR_71 . VAR_72 ) != 2 ) METHOD_19 ( VAR_73 , ""ImproperImageHeader"" ) ; if ( VAR_74 ) ( TYPE_36 ) METHOD_20 ( VAR_75 , METHOD_21 ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , VAR_76 . VAR_77 [ 0 ] , VAR_78 . VAR_79 [ 1 ] ) ; if ( ! METHOD_22 ( VAR_80 . VAR_81 , ""IM"" , 2 ) ) { METHOD_23 = VAR_82 ; METHOD_24 = METHOD_25 ; METHOD_26 = VAR_83 ; METHOD_27 = VAR_84 ; VAR_85 -> VAR_86 = VAR_87 ; } else if ( ! METHOD_28 ( VAR_88 . VAR_89 , ""MI"" , 2 ) ) { METHOD_29 = VAR_90 ; METHOD_30 = VAR_91 ; METHOD_31 = VAR_92 ; METHOD_32 = VAR_93 ; VAR_94 -> VAR_95 = VAR_96 ; } else goto VAR_97 ; if ( METHOD_33 ( VAR_98 . VAR_99 , ""MATLAB"" , 6 ) ) VAR_100 : METHOD_34 ( VAR_101 , ""ImproperImageHeader"" ) ; VAR_102 = METHOD_35 ( VAR_103 ) ; while ( ! METHOD_36 ( VAR_104 ) ) { VAR_105 = 1 ; ( TYPE_37 ) METHOD_37 ( VAR_106 , VAR_107 , VAR_108 ) ; VAR_109 . VAR_110 = METHOD_38 ( VAR_111 ) ; if ( METHOD_39 ( VAR_112 ) ) break ; VAR_113 . VAR_114 = METHOD_40 ( VAR_115 ) ; if ( METHOD_41 ( VAR_116 ) ) break ; VAR_117 += VAR_118 . VAR_119 + 4 + 4 ; VAR_120 = VAR_121 ; if d ( VAR_122 ) if ( VAR_123 . VAR_124 == VAR_125 ) { VAR_126 = METHOD_42 ( VAR_127 , VAR_128 . VAR_129 , VAR_130 , VAR_131 ) ; if ( VAR_132 == VAR_133 ) continue ; VAR_134 . VAR_135 = METHOD_43 ( VAR_136 ) ; } if ( VAR_137 . VAR_138 != VAR_139 ) continue ; VAR_140 . VAR_141 = METHOD_44 ( VAR_142 ) ; VAR_143 . VAR_144 = METHOD_45 ( VAR_145 ) ; VAR_146 . VAR_147 = METHOD_46 ( VAR_148 ) ; VAR_149 . VAR_150 = VAR_151 . VAR_152 & 0xFF ; VAR_153 . VAR_154 = ( VAR_155 . VAR_156 >> 8 ) & 0xFF ; VAR_157 . VAR_158 = METHOD_47 ( VAR_159 ) ; if ( VAR_160 != VAR_161 ) VAR_162 . VAR_163 = METHOD_48 ( VAR_164 ) ; VAR_165 . VAR_166 = METHOD_49 ( VAR_167 ) ; VAR_168 . VAR_169 = METHOD_50 ( VAR_170 ) ; VAR_171 . VAR_172 = METHOD_51 ( VAR_173 ) ; VAR_174 . VAR_175 = METHOD_52 ( VAR_176 ) ; switch ( VAR_177 . VAR_178 ) { case 8 : VAR_179 = VAR_180 = 1 ; break ; case 12 : VAR_181 = VAR_182 = METHOD_53 ( VAR_183 ) ; ( TYPE_38 ) METHOD_54 ( VAR_184 ) ; if ( VAR_185 != 3 ) METHOD_55 ( VAR_186 , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : VAR_187 = VAR_188 = METHOD_56 ( VAR_189 ) ; if ( VAR_190 != 3 && VAR_191 != 1 ) METHOD_57 ( VAR_192 , ""MultidimensionalMatricesAreNotSupported"" ) ; VAR_193 = METHOD_58 ( VAR_194 ) ; break ; default : METHOD_59 ( VAR_195 , ""MultidimensionalMatricesAreNotSupported"" ) ; } VAR_196 . VAR_197 = METHOD_60 ( VAR_198 ) ; VAR_199 . VAR_200 = METHOD_61 ( VAR_201 ) ; if ( VAR_202 ) ( TYPE_39 ) METHOD_62 ( VAR_203 , METHOD_63 ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , VAR_204 . VAR_205 ) ; if ( VAR_206 . VAR_207 != VAR_208 && VAR_209 . VAR_210 != VAR_211 && VAR_212 . VAR_213 != VAR_214 && VAR_215 . VAR_216 != VAR_217 && VAR_218 . VAR_219 != VAR_220 && VAR_221 . VAR_222 != VAR_223 && VAR_224 . VAR_225 != VAR_226 && VAR_227 . VAR_228 != VAR_229 && VAR_230 . VAR_231 != VAR_232 && VAR_233 . VAR_234 != VAR_235 && VAR_236 . VAR_237 != VAR_238 ) METHOD_64 ( VAR_239 , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( VAR_240 . VAR_241 ) { case 0 : VAR_242 = METHOD_65 ( VAR_243 ) ; VAR_244 = 4 * ( TYPE_40 ) ( ( VAR_245 + 3 + 1 ) / 4 ) ; ( TYPE_41 ) METHOD_66 ( VAR_246 , VAR_247 , VAR_248 ) ; break ; case 1 : case 2 : case 3 : case 4 : ( TYPE_42 ) METHOD_67 ( VAR_249 , 4 , ( unsigned TYPE_43 * ) & VAR_250 ) ; break ; default : goto VAR_251 ; } VAR_252 = METHOD_68 ( VAR_253 ) ; if ( VAR_254 ) ( TYPE_44 ) METHOD_69 ( VAR_255 , METHOD_70 ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( TYPE_45 ) VAR_256 ) ; ( TYPE_46 ) METHOD_71 ( VAR_257 , 4 , ( unsigned TYPE_47 * ) & VAR_258 ) ; VAR_259 : switch ( VAR_260 ) { case VAR_261 : case VAR_262 : VAR_263 = 8 ; if ( VAR_264 . VAR_265 & VAR_266 ) VAR_267 -> VAR_268 = 1 ; else VAR_269 -> VAR_270 = 8 ; VAR_271 = ( TYPE_48 ) VAR_272 . VAR_273 ; break ; case VAR_274 : case VAR_275 : VAR_276 = 16 ; VAR_277 -> VAR_278 = 16 ; VAR_279 = ( TYPE_49 ) ( 2 * VAR_280 . VAR_281 ) ; break ; case VAR_282 : case VAR_283 : VAR_284 = 32 ; VAR_285 -> VAR_286 = 32 ; VAR_287 = ( TYPE_50 ) ( 4 * VAR_288 . VAR_289 ) ; break ; case VAR_290 : case VAR_291 : VAR_292 = 64 ; VAR_293 -> VAR_294 = 64 ; VAR_295 = ( TYPE_51 ) ( 8 * VAR_296 . VAR_297 ) ; break ; case VAR_298 : VAR_299 = 32 ; VAR_300 -> VAR_301 = 32 ; ( TYPE_52 ) METHOD_72 ( VAR_302 , ""quantum:format"" , ""floating-point"" ) ; if ( VAR_303 . VAR_304 & VAR_305 ) { } VAR_306 = ( TYPE_53 ) ( 4 * VAR_307 . VAR_308 ) ; break ; case VAR_309 : VAR_310 = 64 ; VAR_311 -> VAR_312 = 64 ; ( TYPE_54 ) METHOD_73 ( VAR_313 , ""quantum:format"" , ""floating-point"" ) ; METHOD_74 ( 4127 ) if ( sizeof ( TYPE_55 ) != 8 ) TYPE_56 METHOD_75 ( VAR_314 , ""IncompatibleSizeOfDouble"" ) ; if ( VAR_315 . VAR_316 & VAR_317 ) { } VAR_318 = ( TYPE_57 ) ( 8 * VAR_319 . VAR_320 ) ; break ; default : METHOD_76 ( VAR_321 , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( TYPE_58 ) VAR_322 ; VAR_323 -> VAR_324 = VAR_325 . VAR_326 ; VAR_327 -> VAR_328 = VAR_329 . VAR_330 ; VAR_331 = METHOD_77 ( VAR_332 , VAR_333 ) ; if ( VAR_334 == ( TYPE_59 * ) VAR_335 ) METHOD_78 ( VAR_336 , ""MemoryAllocationFailed"" ) ; VAR_337 = 1 ; VAR_338 -> VAR_339 = VAR_340 << VAR_341 -> VAR_342 ; if ( VAR_343 -> VAR_344 == 0 || VAR_345 -> VAR_346 == 0 ) goto VAR_347 ; if ( ( VAR_348 . VAR_349 == 8 ) && ( ( VAR_350 . VAR_351 & VAR_352 ) == 0 ) ) { VAR_353 -> VAR_354 = VAR_355 ; METHOD_79 ( VAR_356 , VAR_357 , VAR_358 ) ; } if ( VAR_359 -> VAR_360 ) { TYPE_60 VAR_361 = VAR_362 -> VAR_363 ; VAR_364 -> VAR_365 = VAR_366 -> VAR_367 ; VAR_368 -> VAR_369 = VAR_370 ; goto VAR_371 ; } VAR_372 = METHOD_80 ( VAR_373 , VAR_374 -> VAR_375 , VAR_376 -> VAR_377 , VAR_378 ) ; if ( VAR_379 == VAR_380 ) return ( METHOD_81 ( VAR_381 ) ) ; VAR_382 = ( unsigned TYPE_61 * ) METHOD_82 ( ( TYPE_62 ) ( VAR_383 ) , sizeof ( TYPE_63 ) ) ; if ( VAR_384 == VAR_385 ) METHOD_83 ( VAR_386 , ""MemoryAllocationFailed"" ) ; VAR_387 = 0 ; VAR_388 = 0 ; if ( VAR_389 == VAR_390 || VAR_391 == VAR_392 ) { METHOD_84 ( VAR_393 , VAR_394 -> VAR_395 , VAR_396 . VAR_397 , VAR_398 . VAR_399 , VAR_400 , VAR_401 , VAR_402 , & VAR_403 -> VAR_404 , & VAR_405 -> VAR_406 ) ; } if ( VAR_407 == 1 ) VAR_408 = 0 ; do { for ( VAR_409 = 0 ; VAR_410 < ( TYPE_64 ) VAR_411 . VAR_412 ; VAR_413 ++ ) { VAR_414 = METHOD_85 ( VAR_415 , 0 , VAR_416 . VAR_417 - VAR_418 - 1 , VAR_419 -> VAR_420 , 1 , VAR_421 ) ; if ( VAR_422 == ( TYPE_65 * ) VAR_423 ) { if ( VAR_424 ) ( TYPE_66 ) METHOD_86 ( VAR_425 , METHOD_87 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( VAR_426 . VAR_427 - VAR_428 - 1 ) ) ; goto VAR_429 ; } if ( METHOD_88 ( VAR_430 , VAR_431 , ( unsigned TYPE_67 * ) VAR_432 ) != ( TYPE_68 ) VAR_433 ) { if ( VAR_434 ) ( TYPE_69 ) METHOD_89 ( VAR_435 , METHOD_90 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( VAR_436 . VAR_437 - VAR_438 - 1 ) ) ; goto VAR_439 ; } if ( ( VAR_440 == VAR_441 || VAR_442 == VAR_443 ) && ( VAR_444 . VAR_445 & VAR_446 ) ) { METHOD_91 ( ( unsigned TYPE_70 * ) VAR_447 , VAR_448 ) ; if ( METHOD_92 ( VAR_449 , ( TYPE_71 * ) VAR_450 , VAR_451 , VAR_452 [ VAR_453 ] , VAR_454 , VAR_455 ) <= 0 ) { VAR_456 : if ( VAR_457 ) ( TYPE_72 ) METHOD_93 ( VAR_458 , METHOD_94 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( VAR_459 . VAR_460 - VAR_461 - 1 ) ) ; break ; } } else { if ( METHOD_95 ( VAR_462 , ( TYPE_73 * ) VAR_463 , VAR_464 , VAR_465 [ VAR_466 ] , VAR_467 , VAR_468 ) <= 0 ) goto VAR_469 ; if ( VAR_470 <= 1 && ( VAR_471 == VAR_472 || VAR_473 == VAR_474 || VAR_475 == VAR_476 || VAR_477 == VAR_478 ) ) METHOD_96 ( VAR_479 , VAR_480 , VAR_481 . VAR_482 ) ; } if ( ! METHOD_97 ( VAR_483 , VAR_484 ) ) { if ( VAR_485 ) ( TYPE_74 ) METHOD_98 ( VAR_486 , METHOD_99 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( VAR_487 . VAR_488 - VAR_489 - 1 ) ) ; goto VAR_490 ; } } } while ( VAR_491 -- >= 2 ) ; <S2SV_StartBug> VAR_492 : <S2SV_EndBug> if ( VAR_493 . VAR_494 & VAR_495 ) { VAR_496 = METHOD_100 ( VAR_497 ) ; VAR_498 = METHOD_101 ( VAR_499 ) ; if ( VAR_500 == VAR_501 || VAR_502 == VAR_503 ) { METHOD_102 ( VAR_504 , VAR_505 -> VAR_506 , VAR_507 . VAR_508 , VAR_509 . VAR_510 , VAR_511 , VAR_512 , VAR_513 , & VAR_514 , & VAR_515 ) ; } if ( VAR_516 == VAR_517 ) for ( VAR_518 = 0 ; VAR_519 < ( TYPE_75 ) VAR_520 . VAR_521 ; VAR_522 ++ ) { METHOD_103 ( VAR_523 , VAR_524 , ( TYPE_76 * ) VAR_525 ) ; METHOD_104 ( VAR_526 , ( TYPE_77 * ) VAR_527 , VAR_528 , VAR_529 , VAR_530 , VAR_531 ) ; } if ( VAR_532 == VAR_533 ) for ( VAR_534 = 0 ; VAR_535 < ( TYPE_78 ) VAR_536 . VAR_537 ; VAR_538 ++ ) { METHOD_105 ( VAR_539 , VAR_540 , ( TYPE_79 * ) VAR_541 ) ; METHOD_106 ( VAR_542 , ( TYPE_80 * ) VAR_543 , VAR_544 , VAR_545 , VAR_546 , VAR_547 ) ; } } if ( ( VAR_548 . VAR_549 == 8 ) && ( ( VAR_550 . VAR_551 & VAR_552 ) == 0 ) ) VAR_553 -> VAR_554 = VAR_555 ; if ( VAR_556 -> VAR_557 == 1 ) VAR_558 -> VAR_559 = VAR_560 ; if ( VAR_561 == VAR_562 ) VAR_563 = VAR_564 ; VAR_565 = METHOD_107 ( VAR_566 , 90.0 , VAR_567 ) ; if ( VAR_568 != ( TYPE_81 * ) VAR_569 ) { VAR_570 -> VAR_571 . VAR_572 = 0 ; VAR_573 -> VAR_574 . VAR_575 = 0 ; VAR_576 = VAR_577 -> VAR_578 ; VAR_579 -> VAR_580 = VAR_581 -> VAR_582 ; VAR_583 -> VAR_584 = VAR_585 -> VAR_586 ; VAR_587 -> VAR_588 = VAR_589 ; METHOD_108 ( & VAR_590 , VAR_591 ) ; METHOD_109 ( & VAR_592 ) ; } VAR_593 : if ( VAR_594 != VAR_595 ) if ( VAR_596 != VAR_597 ) { METHOD_110 ( & VAR_598 ) ; if ( VAR_599 ) { if ( VAR_600 -> VAR_601 ) { METHOD_111 ( VAR_602 -> VAR_603 ) ; VAR_604 -> VAR_605 = VAR_606 ; ( TYPE_82 ) METHOD_112 ( VAR_607 -> VAR_608 ) ; } } } METHOD_113 ( VAR_609 , VAR_610 , VAR_611 ) ; if ( VAR_612 -> VAR_613 == ( TYPE_83 * ) VAR_614 ) break ; VAR_615 = METHOD_114 ( VAR_616 ) ; VAR_617 -> VAR_618 = VAR_619 -> VAR_620 = 0 ; VAR_621 -> VAR_622 = 0 ; METHOD_115 ( VAR_623 ) ; VAR_624 = VAR_625 ; if ( -- VAR_626 > 0 ) { VAR_627 = VAR_628 ; if ( VAR_629 == VAR_630 ) VAR_631 = VAR_632 ; goto VAR_633 ; } if ( ( VAR_634 != VAR_635 ) && ( VAR_636 != VAR_637 ) ) { METHOD_116 ( & VAR_638 ) ; if ( VAR_639 ) { if ( VAR_640 -> VAR_641 ) { METHOD_117 ( VAR_642 -> VAR_643 ) ; VAR_644 -> VAR_645 = VAR_646 ; ( TYPE_84 ) METHOD_118 ( VAR_647 -> VAR_648 ) ; } } } } VAR_649 = METHOD_119 ( VAR_650 ) ; METHOD_120 ( VAR_651 ) ; METHOD_121 ( VAR_652 ) ; { TYPE_85 * VAR_653 ; TYPE_86 VAR_654 = 0 ; VAR_655 = VAR_656 ; VAR_657 = VAR_658 ; while ( VAR_659 != ( TYPE_87 * ) VAR_660 ) { TYPE_88 * VAR_661 = VAR_662 ; if ( ( VAR_663 -> VAR_664 == 0 ) || ( VAR_665 -> VAR_666 == 0 ) ) { VAR_667 = VAR_668 -> VAR_669 ; METHOD_122 ( & VAR_670 ) ; } else { VAR_671 = VAR_672 ; VAR_673 = VAR_674 -> VAR_675 ; } } for ( VAR_676 = VAR_677 ; VAR_678 != ( TYPE_89 * ) VAR_679 ; VAR_680 = VAR_681 -> VAR_682 ) VAR_683 -> VAR_684 = VAR_685 ++ ; } if ( VAR_686 != VAR_687 ) { if ( VAR_688 -> VAR_689 ) { METHOD_123 ( VAR_690 -> VAR_691 ) ; VAR_692 -> VAR_693 = VAR_694 ; ( TYPE_90 ) METHOD_124 ( VAR_695 -> VAR_696 ) ; } METHOD_125 ( VAR_697 ) ; VAR_698 = VAR_699 ; } if ( VAR_700 ) ( TYPE_91 ) METHOD_126 ( VAR_701 , METHOD_127 ( ) , ""return"" ) ; if ( VAR_702 == VAR_703 ) METHOD_128 ( VAR_704 , ""ImproperImageHeader"" ) ; return ( VAR_705 ) ; }",<S2SV_ModStart> 2 ) ; VAR_464 = METHOD_129 ( VAR_464 ) ;,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ;  if d ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; }   if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
77,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { do { <S2SV_StartBug> METHOD_1 ( VAR_1 , VAR_2 , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( METHOD_2 ( VAR_3 , VAR_4 ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( METHOD_3 ( VAR_5 , VAR_6 ) & VAR_7 ) == 0 ) <S2SV_EndBug> { } <S2SV_StartBug> METHOD_4 ( VAR_8 , VAR_9 , VAR_10 ) ; <S2SV_EndBug> METHOD_5 ( 1 ) ; <S2SV_StartBug> if ( METHOD_6 ( VAR_11 , VAR_12 ) != 0x0000 ) <S2SV_EndBug> { return VAR_13 ; } METHOD_7 ( 1 ) ; return VAR_14 ; }","<S2SV_ModStart> ( VAR_11 , VAR_15 <S2SV_ModEnd> , 0x1234 ) <S2SV_ModStart> ( VAR_11 , VAR_15 <S2SV_ModEnd> ) != 0x1234 <S2SV_ModStart> ( VAR_11 , VAR_16 ) & VAR_17 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> ( VAR_11 , VAR_18 , VAR_19 <S2SV_ModEnd> ) ; METHOD_7 <S2SV_ModStart> ( VAR_11 , VAR_15 <S2SV_ModEnd> ) != 0x0000","CWE-20 error_t enc624j600SoftReset ( NetInterface * interface ) { do { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ; <S2SV_EndBug> sleep ( 1 ) ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 ) <S2SV_EndBug> { return ERROR_FAILURE ; } sleep ( 1 ) ; return NO_ERROR ; }","<S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> , 0x1234 ) <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x1234 <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY <S2SV_ModEnd> ) == 0 <S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST <S2SV_ModEnd> ) ; sleep <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x0000"
78,"CWE-416 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { TYPE_2 VAR_2 ; <S2SV_StartBug> TYPE_3 VAR_3 ; <S2SV_EndBug> if ( VAR_4 -> VAR_5 == VAR_6 ) return ; VAR_7 = VAR_8 -> VAR_9 - VAR_10 -> VAR_11 ; if ( VAR_12 -> VAR_13 ) VAR_14 += VAR_15 -> VAR_16 -> VAR_17 ; if ( VAR_18 -> VAR_19 + VAR_20 > VAR_21 -> VAR_22 ) VAR_23 = VAR_24 -> VAR_25 - VAR_26 -> VAR_27 ; for ( VAR_28 = 0 ; VAR_29 < VAR_30 ; VAR_31 ++ ) { TYPE_4 VAR_32 = VAR_33 -> VAR_34 [ VAR_35 ] ; if ( ! METHOD_1 ( VAR_36 ) ) { <S2SV_StartBug> if ( METHOD_2 ( VAR_37 ) -> VAR_38 == VAR_39 ) { <S2SV_EndBug> VAR_40 -> VAR_41 [ VAR_42 ] = METHOD_3 ( ) ; } else { METHOD_4 ( VAR_43 , METHOD_5 ( VAR_44 ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }",<S2SV_ModStart> ; TYPE_3 VAR_30 ; TYPE_4 VAR_45 <S2SV_ModStart> ) ) { <S2SV_ModEnd> METHOD_4 ( VAR_43 <S2SV_ModStart> ; } } VAR_30 = VAR_40 -> VAR_25 - VAR_40 -> VAR_41 ; VAR_45 = METHOD_3 ( ) ; for ( ; VAR_42 < VAR_30 ; VAR_42 ++ ) { VAR_40 -> VAR_41 [ VAR_42 ] = VAR_45 ;,"CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }",<S2SV_ModStart> ; size_t e ; mrb_value nil <S2SV_ModStart> ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb <S2SV_ModStart> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
79,"CWE-399 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { const TYPE_4 * VAR_3 = VAR_4 ; TYPE_5 VAR_5 = VAR_6 ; TYPE_6 * VAR_7 = VAR_8 ; TYPE_7 * VAR_9 = VAR_10 ; CRM_CHECK ( VAR_11 != VAR_12 , return VAR_13 ) ; CRM_CHECK ( VAR_14 != VAR_15 , return VAR_16 ) ; <S2SV_StartBug> if ( VAR_17 -> VAR_18 == VAR_19 ) { <S2SV_EndBug> METHOD_1 ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ; return VAR_20 ; } VAR_21 = METHOD_2 ( VAR_22 , VAR_23 ) ; METHOD_3 ( VAR_24 != VAR_25 ) ; if ( VAR_26 -> VAR_27 && METHOD_4 ( VAR_28 , VAR_29 ) ) { VAR_30 = VAR_31 ; } else if ( VAR_32 -> VAR_33 && METHOD_5 ( VAR_34 , VAR_35 ) ) { VAR_36 = VAR_37 ; } else if ( VAR_38 -> VAR_39 && METHOD_6 ( VAR_40 , VAR_41 ) ) { VAR_42 = VAR_43 ; } else if ( VAR_44 -> VAR_45 && METHOD_7 ( VAR_46 , VAR_47 ) ) { VAR_48 = VAR_49 ; } else if ( VAR_50 -> VAR_51 && METHOD_8 ( VAR_52 , VAR_53 ) ) { VAR_54 = VAR_55 ; } if ( VAR_56 ) { if ( VAR_57 -> VAR_58 ) { if ( METHOD_9 ( VAR_59 -> VAR_60 , 0 , VAR_61 , VAR_62 ) == VAR_63 ) { METHOD_10 ( ""Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed"" , VAR_64 -> VAR_65 , VAR_66 -> VAR_67 ) ; } TYPE_8 TYPE_9 } else if ( VAR_68 -> VAR_69 ) { METHOD_11 ( ""Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s"" , VAR_70 , VAR_71 -> VAR_72 , VAR_73 -> VAR_74 ) ; METHOD_12 ( VAR_75 -> VAR_76 , VAR_77 , VAR_78 -> VAR_79 ) ; } else { METHOD_13 ( ""Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s"" , VAR_80 -> VAR_81 ) ; } } return VAR_82 ; }",<S2SV_ModStart> VAR_60 == VAR_25 && VAR_80 -> VAR_76 == VAR_25,"CWE-399 gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( ""Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed"" , client -> name , client -> id ) ; }  ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( ""Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s"" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ;   } else { crm_err ( ""Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s"" , client -> name ) ; } } return FALSE ; }",<S2SV_ModStart> ipc == NULL && client -> session == NULL
80,"CWE-835 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , TYPE_2 VAR_2 , unsigned TYPE_3 VAR_3 ) { struct STRUCT_OR_UNION_3 * VAR_4 = STRUCT_OR_UNION_4 -> VAR_5 ; struct STRUCT_OR_UNION_5 VAR_6 = { . VAR_7 = VAR_8 , . VAR_9 = VAR_10 , . VAR_11 = VAR_12 , } ; TYPE_4 VAR_13 ; TYPE_5 VAR_14 ; TYPE_6 VAR_15 ; METHOD_1 ( VAR_16 ) ; if ( METHOD_2 ( * VAR_17 ) ) return - VAR_18 ; VAR_19 = VAR_20 = 0 ; METHOD_3 ( VAR_21 ) ; VAR_22 = METHOD_4 ( VAR_23 , STRUCT_OR_UNION_6 -> VAR_24 -> VAR_25 & VAR_26 ) ; while ( VAR_27 . VAR_28 ) { VAR_29 = METHOD_5 ( VAR_30 , & VAR_31 ) ; if ( VAR_32 < 0 ) break ; else if ( ! VAR_33 ) { if ( VAR_34 ) break ; if ( METHOD_6 ( VAR_35 , VAR_36 ) ) break ; if ( VAR_37 -> VAR_38 ) { VAR_39 = METHOD_7 ( VAR_40 ) ; break ; } if ( VAR_41 -> VAR_42 & VAR_43 ) break ; if ( VAR_44 -> VAR_45 == VAR_46 ) { if ( ! METHOD_8 ( VAR_47 , VAR_48 ) ) VAR_49 = - VAR_50 ; break ; } if ( ! VAR_51 ) { VAR_52 = - VAR_53 ; break ; } <S2SV_StartBug> METHOD_9 ( VAR_54 , & VAR_55 , VAR_56 ) ; <S2SV_EndBug> if ( METHOD_10 ( VAR_57 ) ) { VAR_58 = METHOD_11 ( VAR_59 ) ; break ; } continue ; } VAR_60 . VAR_61 -= VAR_62 ; VAR_63 += VAR_64 ; if ( ! VAR_65 ) break ; METHOD_12 ( VAR_66 ) ; METHOD_13 ( VAR_67 ) ; if ( VAR_68 -> VAR_69 || VAR_70 -> VAR_71 == VAR_72 || ( VAR_73 -> VAR_74 & VAR_75 ) || METHOD_14 ( VAR_76 ) ) break ; } METHOD_15 ( VAR_77 ) ; if ( VAR_78 ) return VAR_79 ; return VAR_80 ; }",<S2SV_ModStart> break ; } if ( ! METHOD_16 ( & VAR_77 -> VAR_81 ) ) break ;,"CWE-835 ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) { struct sock * sk = sock -> sk ; struct tcp_splice_state tss = { . pipe = pipe , . len = len , . flags = flags , } ; long timeo ; ssize_t spliced ; int ret ; sock_rps_record_flow ( sk ) ; if ( unlikely ( * ppos ) ) return - ESPIPE ; ret = spliced = 0 ; lock_sock ( sk ) ; timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; while ( tss . len ) { ret = __tcp_splice_read ( sk , & tss ) ; if ( ret < 0 ) break ; else if ( ! ret ) { if ( spliced ) break ; if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { ret = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) ret = - ENOTCONN ; break ; } if ( ! timeo ) { ret = - EAGAIN ; break ; } <S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> if ( signal_pending ( current ) ) { ret = sock_intr_errno ( timeo ) ; break ; } continue ; } tss . len -= ret ; spliced += ret ; if ( ! timeo ) break ; release_sock ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || signal_pending ( current ) ) break ; } release_sock ( sk ) ; if ( spliced ) return spliced ; return ret ; }",<S2SV_ModStart> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
81,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { TYPE_6 * VAR_5 ; VAR_6 * VAR_7 ; TYPE_7 * VAR_8 = VAR_9 -> VAR_10 ; TYPE_8 VAR_11 ; TYPE_9 VAR_12 ; TYPE_10 VAR_13 ; VAR_14 = ( TYPE_11 * ) METHOD_1 ( VAR_15 -> VAR_16 -> VAR_17 -> VAR_18 , & VAR_19 ) ; if ( VAR_20 != VAR_21 && VAR_22 != VAR_23 ) { return METHOD_2 ( VAR_24 -> VAR_25 , VAR_26 , VAR_27 , VAR_28 , VAR_29 ) ; } if ( ! VAR_30 ) { const TYPE_12 * VAR_31 , * VAR_32 ; VAR_33 -> VAR_34 = VAR_35 = METHOD_3 ( VAR_36 -> VAR_37 -> VAR_38 , sizeof ( * VAR_39 ) ) ; VAR_40 -> VAR_41 = VAR_42 ; if ( ! VAR_43 -> VAR_44 -> VAR_45 ) { VAR_46 -> VAR_47 = METHOD_4 ( VAR_48 -> VAR_49 ) ; } else { VAR_50 -> VAR_51 = 0 ; } VAR_52 = METHOD_5 ( VAR_53 -> VAR_54 -> VAR_55 , ""Transfer-Encoding"" ) ; VAR_56 = METHOD_6 ( VAR_57 -> VAR_58 -> VAR_59 , ""Content-Length"" ) ; if ( VAR_60 ) { if ( METHOD_7 ( VAR_61 , ""chunked"" ) == 0 || METHOD_8 ( VAR_62 -> VAR_63 -> VAR_64 , VAR_65 , ""chunked"" ) ) { VAR_66 -> VAR_67 = VAR_68 ; } else if ( VAR_69 -> VAR_70 -> VAR_71 == VAR_72 ) { ap_log_rerror ( VAR_73 , VAR_74 , 0 , VAR_75 -> VAR_76 , METHOD_9 ( 02555 ) <S2SV_StartBug> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;"" <S2SV_EndBug> ""<S2SV_blank>using<S2SV_blank>read-until-close"" , VAR_77 ) ; VAR_78 = VAR_79 ; } else { ap_log_rerror ( VAR_80 , VAR_81 , 0 , VAR_82 -> VAR_83 , METHOD_10 ( 01585 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s"" , VAR_84 ) ; return VAR_85 ; } VAR_86 = VAR_87 ; } if ( VAR_88 ) { TYPE_13 * VAR_89 ; VAR_90 -> VAR_91 = VAR_92 ; if ( METHOD_11 ( & VAR_93 -> VAR_94 , VAR_95 , & VAR_96 , 10 ) || VAR_97 == VAR_98 || * VAR_99 || VAR_100 -> VAR_101 < 0 ) { VAR_102 -> VAR_103 = 0 ; ap_log_rerror ( VAR_104 , VAR_105 , 0 , VAR_106 -> VAR_107 , METHOD_12 ( 01587 ) ""Invalid<S2SV_blank>Content-Length"" ) ; <S2SV_StartBug> return VAR_108 ; <S2SV_EndBug> } if ( VAR_109 -> VAR_110 && VAR_111 -> VAR_112 < VAR_113 -> VAR_114 ) { ap_log_rerror ( VAR_115 , VAR_116 , 0 , VAR_117 -> VAR_118 , METHOD_13 ( 01588 ) ""Requested<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%"" VAR_119 ""<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit"" ""<S2SV_blank>of<S2SV_blank>%"" VAR_120 , VAR_121 -> VAR_122 , VAR_123 -> VAR_124 ) ; return VAR_125 ; } } if ( VAR_126 -> VAR_127 == VAR_128 && VAR_129 -> VAR_130 -> VAR_131 != VAR_132 ) { VAR_133 = METHOD_14 ( VAR_134 -> VAR_135 -> VAR_136 ) ; METHOD_15 ( VAR_137 , VAR_138 ) ; VAR_139 -> VAR_140 = 1 ; return VAR_141 ; } if ( ( VAR_142 -> VAR_143 == VAR_144 || ( VAR_145 -> VAR_146 == VAR_147 && VAR_148 -> VAR_149 > 0 ) ) && VAR_150 -> VAR_151 -> VAR_152 && VAR_153 -> VAR_154 -> VAR_155 >= METHOD_16 ( 1 , 1 ) && ! ( VAR_156 -> VAR_157 -> VAR_158 || VAR_159 -> VAR_160 -> VAR_161 ) ) { if ( ! METHOD_17 ( VAR_162 -> VAR_163 -> VAR_164 ) ) { VAR_165 -> VAR_166 = VAR_167 ; VAR_168 -> VAR_169 = 1 ; } else { TYPE_14 * VAR_170 ; TYPE_15 VAR_171 ; TYPE_16 * VAR_172 ; VAR_173 = METHOD_18 ( VAR_174 -> VAR_175 -> VAR_176 , VAR_177 -> VAR_178 -> VAR_179 ) ; VAR_180 -> VAR_181 -> VAR_182 = 0 ; VAR_183 = apr_pstrcat ( VAR_184 -> VAR_185 -> VAR_186 , VAR_187 ""<S2SV_blank>"" , METHOD_19 ( VAR_188 ) , VAR_189 VAR_190 , VAR_191 ) ; VAR_192 = METHOD_20 ( VAR_193 ) ; METHOD_21 ( VAR_194 , VAR_195 ) ; VAR_196 = METHOD_22 ( VAR_197 , VAR_198 , VAR_199 -> VAR_200 -> VAR_201 , VAR_202 -> VAR_203 -> VAR_204 ) ; METHOD_23 ( VAR_205 , VAR_206 ) ; VAR_207 = METHOD_24 ( VAR_208 -> VAR_209 -> VAR_210 ) ; METHOD_25 ( VAR_211 , VAR_212 ) ; VAR_213 = METHOD_26 ( VAR_214 -> VAR_215 -> VAR_216 , VAR_217 ) ; <S2SV_StartBug> if ( VAR_218 != VAR_219 ) { <S2SV_EndBug> return VAR_220 ; } } } } if ( VAR_221 -> VAR_222 ) { VAR_223 = METHOD_27 ( VAR_224 -> VAR_225 -> VAR_226 ) ; METHOD_28 ( VAR_227 , VAR_228 ) ; return VAR_229 ; } do { METHOD_29 ( VAR_230 ) ; VAR_231 = 0 ; switch ( VAR_232 -> VAR_233 ) { case VAR_234 : case VAR_235 : case VAR_236 : <S2SV_StartBug> case VAR_237 : { <S2SV_EndBug> VAR_238 = METHOD_30 ( VAR_239 -> VAR_240 , VAR_241 , VAR_242 , VAR_243 , 0 ) ; if ( VAR_244 == VAR_245 && ( ( VAR_246 == VAR_247 && METHOD_31 ( VAR_248 ) ) || ( METHOD_32 ( VAR_249 ) ) ) ) { return VAR_250 ; } if ( VAR_251 == VAR_252 ) { return VAR_253 ; } if ( VAR_254 != VAR_255 ) { return VAR_256 ; } VAR_257 = METHOD_33 ( VAR_258 ) ; while ( VAR_259 != METHOD_34 ( VAR_260 ) ) { const TYPE_17 * VAR_261 ; TYPE_18 VAR_262 ; if ( ! METHOD_35 ( VAR_263 ) ) { VAR_264 = METHOD_36 ( VAR_265 , & VAR_266 , & VAR_267 , VAR_268 ) ; if ( VAR_269 == VAR_270 ) { VAR_271 = METHOD_37 ( VAR_272 , VAR_273 , VAR_274 , VAR_275 -> VAR_276 -> VAR_277 -> VAR_278 ) ; } if ( VAR_279 != VAR_280 ) { ap_log_rerror ( VAR_281 , VAR_282 , VAR_283 , VAR_284 -> VAR_285 , METHOD_38 ( 01590 ) ""Error<S2SV_blank>reading<S2SV_blank>chunk<S2SV_blank>%s<S2SV_blank>"" , ( VAR_286 == VAR_287 ) ? ""(overflow)"" : """" ) ; return VAR_288 ; } } METHOD_39 ( VAR_289 ) ; VAR_290 = METHOD_40 ( VAR_291 ) ; } VAR_292 = 1 ; if ( VAR_293 -> VAR_294 == VAR_295 ) { <S2SV_StartBug> TYPE_19 VAR_296 = <S2SV_EndBug> VAR_297 -> VAR_298 == VAR_299 ; return METHOD_41 ( VAR_300 , VAR_301 , VAR_302 , VAR_303 ) ; } break ; } case VAR_304 : case VAR_305 : case VAR_306 : { if ( VAR_307 -> VAR_308 != VAR_309 && VAR_310 -> VAR_311 < VAR_312 ) { VAR_313 = VAR_314 -> VAR_315 ; } if ( VAR_316 > 0 ) { VAR_317 = METHOD_42 ( VAR_318 -> VAR_319 , VAR_320 , VAR_321 , VAR_322 , VAR_323 ) ; if ( VAR_324 == VAR_325 && ( ( VAR_326 == VAR_327 && METHOD_43 ( VAR_328 ) ) || ( METHOD_44 ( VAR_329 ) ) ) ) { return VAR_330 ; } if ( VAR_331 == VAR_332 && VAR_333 -> VAR_334 != VAR_335 && VAR_336 -> VAR_337 > 0 ) { return VAR_338 ; } if ( VAR_339 != VAR_340 ) { return VAR_341 ; } METHOD_45 ( VAR_342 , 0 , & VAR_343 ) ; METHOD_46 ( VAR_344 >= 0 ) ; if ( VAR_345 -> VAR_346 != VAR_347 ) { VAR_348 -> VAR_349 -= VAR_350 ; if ( VAR_351 -> VAR_352 > 0 ) { VAR_353 = METHOD_47 ( VAR_354 ) ; if ( METHOD_48 ( VAR_355 ) ) { METHOD_49 ( VAR_356 ) ; return VAR_357 ; } } else if ( VAR_358 -> VAR_359 == VAR_360 ) { VAR_361 -> VAR_362 = VAR_363 ; VAR_364 -> VAR_365 = 0 ; } } } if ( VAR_366 -> VAR_367 == VAR_368 && VAR_369 -> VAR_370 == 0 ) { VAR_371 = METHOD_50 ( VAR_372 -> VAR_373 -> VAR_374 ) ; METHOD_51 ( VAR_375 , VAR_376 ) ; VAR_377 -> VAR_378 = 1 ; } if ( VAR_379 -> VAR_380 ) { VAR_381 -> VAR_382 += VAR_383 ; if ( VAR_384 -> VAR_385 < VAR_386 -> VAR_387 ) { ap_log_rerror ( VAR_388 , VAR_389 , 0 , VAR_390 -> VAR_391 , METHOD_52 ( 01591 ) ""Read<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%"" VAR_392 ""<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit"" ""<S2SV_blank>of<S2SV_blank>%"" VAR_393 , VAR_394 -> VAR_395 , VAR_396 -> VAR_397 ) ; return VAR_398 ; } } break ; } case VAR_399 : { VAR_400 = METHOD_53 ( VAR_401 -> VAR_402 , VAR_403 , VAR_404 , VAR_405 , VAR_406 ) ; if ( VAR_407 == VAR_408 && ( ( VAR_409 == VAR_410 && METHOD_54 ( VAR_411 ) ) || ( METHOD_55 ( VAR_412 ) ) ) ) { return VAR_413 ; } if ( VAR_414 != VAR_415 ) { return VAR_416 ; } break ; } default : { <S2SV_StartBug> break ; <S2SV_EndBug> } } } while ( VAR_417 ) ; return VAR_418 ; }","<S2SV_ModStart> ( 02555 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" <S2SV_ModEnd> , VAR_84 ) <S2SV_ModStart> ) ; return VAR_419 <S2SV_ModEnd> ; } if <S2SV_ModStart> VAR_217 ) ; METHOD_29 ( VAR_217 ) ; <S2SV_ModStart> VAR_236 : case VAR_420 : case VAR_363 : case VAR_421 <S2SV_ModEnd> : { VAR_416 <S2SV_ModStart> VAR_399 ) { return METHOD_41 ( VAR_396 , VAR_401 , VAR_411 , VAR_297 -> VAR_303 == VAR_299 <S2SV_ModEnd> ) ; } <S2SV_ModStart> default : { ap_log_rerror ( VAR_388 , VAR_422 , 0 , VAR_401 -> VAR_391 , METHOD_52 ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( TYPE_19 ) VAR_396 -> VAR_367 ) ; return VAR_85 <S2SV_ModEnd> ; } }","CWE-20 apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , ""Transfer-Encoding"" ) ; lenp = apr_table_get ( f -> r -> headers_in , ""Content-Length"" ) ; if ( tenc ) { if ( strcasecmp ( tenc , ""chunked"" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , ""chunked"" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <S2SV_StartBug> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;"" <S2SV_EndBug> ""<S2SV_blank>using<S2SV_blank>read-until-close"" , tenc ) ; tenc = NULL ; } else { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01585 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s"" , tenc ) ; return APR_EGENERAL ; } lenp = NULL ; } if ( lenp ) { char * endstr ; ctx -> state = BODY_LENGTH ; if ( apr_strtoff ( & ctx -> remaining , lenp , & endstr , 10 ) || endstr == lenp || * endstr || ctx -> remaining < 0 ) { ctx -> remaining = 0 ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01587 ) ""Invalid<S2SV_blank>Content-Length"" ) ; <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> } if ( ctx -> limit && ctx -> limit < ctx -> remaining ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01588 ) ""Requested<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT ""<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit"" ""<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT , ctx -> remaining , ctx -> limit ) ; return APR_ENOSPC ; } } if ( ctx -> state == BODY_NONE && f -> r -> proxyreq != PROXYREQ_RESPONSE ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; return APR_SUCCESS ; } if ( ( ctx -> state == BODY_CHUNK || ( ctx -> state == BODY_LENGTH && ctx -> remaining > 0 ) ) && f -> r -> expecting_100 && f -> r -> proto_num >= HTTP_VERSION ( 1 , 1 ) && ! ( f -> r -> eos_sent || f -> r -> bytes_sent ) ) { if ( ! ap_is_HTTP_SUCCESS ( f -> r -> status ) ) { ctx -> state = BODY_NONE ; ctx -> eos_sent = 1 ; } else { char * tmp ; int len ; apr_bucket_brigade * bb ; bb = apr_brigade_create ( f -> r -> pool , f -> c -> bucket_alloc ) ; f -> r -> expecting_100 = 0 ; tmp = apr_pstrcat ( f -> r -> pool , AP_SERVER_PROTOCOL ""<S2SV_blank>"" , ap_get_status_line ( HTTP_CONTINUE ) , CRLF CRLF , NULL ) ; len = strlen ( tmp ) ; ap_xlate_proto_to_ascii ( tmp , len ) ; e = apr_bucket_pool_create ( tmp , len , f -> r -> pool , f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_HEAD ( bb , e ) ; e = apr_bucket_flush_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( bb , e ) ; rv = ap_pass_brigade ( f -> c -> output_filters , bb ) ; <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> return AP_FILTER_ERROR ; } } } } if ( ctx -> eos_sent ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; return APR_SUCCESS ; } do { apr_brigade_cleanup ( b ) ; again = 0 ; switch ( ctx -> state ) { case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } e = APR_BRIGADE_FIRST ( b ) ; while ( e != APR_BRIGADE_SENTINEL ( b ) ) { const char * buffer ; apr_size_t len ; if ( ! APR_BUCKET_IS_METADATA ( e ) ) { rv = apr_bucket_read ( e , & buffer , & len , APR_BLOCK_READ ) ; if ( rv == APR_SUCCESS ) { rv = parse_chunk_size ( ctx , buffer , len , f -> r -> server -> limit_req_fieldsize ) ; } if ( rv != APR_SUCCESS ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) ""Error<S2SV_blank>reading<S2SV_blank>chunk<S2SV_blank>%s<S2SV_blank>"" , ( APR_ENOSPC == rv ) ? ""(overflow)"" : """" ) ; return rv ; } } apr_bucket_delete ( e ) ; e = APR_BRIGADE_FIRST ( b ) ; } again = 1 ; if ( ctx -> state == BODY_CHUNK_TRAILER ) { <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ; return read_chunked_trailers ( ctx , f , b , merge_trailers ) ; } break ; } case BODY_NONE : case BODY_LENGTH : case BODY_CHUNK_DATA : { if ( ctx -> state != BODY_NONE && ctx -> remaining < readbytes ) { readbytes = ctx -> remaining ; } if ( readbytes > 0 ) { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF && ctx -> state != BODY_NONE && ctx -> remaining > 0 ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } apr_brigade_length ( b , 0 , & totalread ) ; AP_DEBUG_ASSERT ( totalread >= 0 ) ; if ( ctx -> state != BODY_NONE ) { ctx -> remaining -= totalread ; if ( ctx -> remaining > 0 ) { e = APR_BRIGADE_LAST ( b ) ; if ( APR_BUCKET_IS_EOS ( e ) ) { apr_bucket_delete ( e ) ; return APR_INCOMPLETE ; } } else if ( ctx -> state == BODY_CHUNK_DATA ) { ctx -> state = BODY_CHUNK_END ; ctx -> chunk_used = 0 ; } } } if ( ctx -> state == BODY_LENGTH && ctx -> remaining == 0 ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; } if ( ctx -> limit ) { ctx -> limit_used += totalread ; if ( ctx -> limit < ctx -> limit_used ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) ""Read<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT ""<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit"" ""<S2SV_blank>of<S2SV_blank>%"" APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; return APR_ENOSPC ; } } break ; } case BODY_CHUNK_TRAILER : { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv != APR_SUCCESS ) { return rv ; } break ; } default : { <S2SV_StartBug> break ; <S2SV_EndBug> } } } while ( again ) ; return APR_SUCCESS ; }","<S2SV_ModStart> ( 02555 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" <S2SV_ModEnd> , tenc ) <S2SV_ModStart> ) ; return APR_EINVAL <S2SV_ModEnd> ; } if <S2SV_ModStart> bb ) ; apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { rv <S2SV_ModStart> BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; } <S2SV_ModStart> default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; } }"
82,"CWE-20 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 ; const TYPE_4 * VAR_4 ; const struct STRUCT_OR_UNION_1 * VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; METHOD_1 ( ( VAR_8 , ""<S2SV_blank>wb-id:"" ) ) ; if ( VAR_9 < sizeof ( * VAR_10 ) || ! METHOD_2 ( * VAR_11 ) ) return ( - 1 ) ; VAR_12 -= sizeof ( * VAR_13 ) ; METHOD_3 ( ( VAR_14 , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , METHOD_4 ( & VAR_15 -> VAR_16 . VAR_17 ) , METHOD_5 ( VAR_18 , & VAR_19 -> VAR_20 . VAR_21 . VAR_22 ) , METHOD_6 ( & VAR_23 -> VAR_24 . VAR_25 . VAR_26 ) , METHOD_7 ( & VAR_27 -> VAR_28 ) , METHOD_8 ( VAR_29 , & VAR_30 -> VAR_31 . VAR_32 ) , METHOD_9 ( & VAR_33 -> VAR_34 . VAR_35 ) ) ) ; VAR_36 = METHOD_10 ( & VAR_37 -> VAR_38 . VAR_39 ) ; VAR_40 -= sizeof ( * VAR_41 ) * VAR_42 ; VAR_43 = ( struct STRUCT_OR_UNION_2 * ) ( VAR_44 + 1 ) ; VAR_45 = ( TYPE_7 * ) ( VAR_46 + VAR_47 ) ; <S2SV_StartBug> if ( ! METHOD_11 ( VAR_48 , VAR_49 ) ) { <S2SV_EndBug> METHOD_12 ( ( VAR_50 , ""\\"""" ) ) ; fn_print ( VAR_51 , ( u_char * ) VAR_52 , ( u_char * ) VAR_53 + VAR_54 ) ; METHOD_13 ( ( VAR_55 , ""\\"""" ) ) ; } VAR_56 = '<' ; for ( VAR_57 = 0 ; VAR_58 < VAR_59 && METHOD_14 ( * VAR_60 ) ; ++ VAR_61 , ++ VAR_62 ) { METHOD_15 ( ( VAR_63 , ""%c%s:%u"" , VAR_64 , METHOD_16 ( VAR_65 , & VAR_66 -> VAR_67 ) , METHOD_17 ( & VAR_68 -> VAR_69 ) ) ) ; VAR_70 = ',' ; } if ( VAR_71 >= VAR_72 ) { METHOD_18 ( ( VAR_73 , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> METHOD_11 ( VAR_53,"CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-id:"" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\"""" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
83,"CWE-264 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 ) { struct STRUCT_OR_UNION_2 VAR_3 ; struct STRUCT_OR_UNION_3 * VAR_4 = METHOD_1 ( VAR_5 ) ; struct STRUCT_OR_UNION_4 * VAR_6 = METHOD_2 ( VAR_7 ) ; struct STRUCT_OR_UNION_5 * VAR_8 = METHOD_3 ( VAR_9 ) ; DECLARE_SOCKADDR ( struct STRUCT_OR_UNION_6 * , VAR_10 , VAR_11 -> VAR_12 ) ; struct STRUCT_OR_UNION_7 * VAR_13 , * VAR_14 , VAR_15 ; <S2SV_StartBug> struct STRUCT_OR_UNION_8 * VAR_16 = VAR_17 ; <S2SV_EndBug> struct STRUCT_OR_UNION_9 * VAR_18 = VAR_19 ; struct STRUCT_OR_UNION_10 VAR_20 ; struct STRUCT_OR_UNION_11 * VAR_21 ; TYPE_2 VAR_22 = VAR_23 -> VAR_24 ; TYPE_3 VAR_25 = VAR_26 ; TYPE_4 VAR_27 = - 1 ; TYPE_5 VAR_28 = - 1 ; TYPE_6 VAR_29 = - 1 ; TYPE_7 VAR_30 = VAR_31 -> VAR_32 || VAR_33 -> VAR_34 & VAR_35 ; TYPE_8 VAR_36 ; TYPE_9 VAR_37 = 0 ; TYPE_10 VAR_38 = METHOD_4 ( VAR_39 ) ; TYPE_11 ( * VAR_40 ) ( TYPE_12 * , TYPE_13 * , TYPE_14 , TYPE_15 , TYPE_16 , struct STRUCT_OR_UNION_12 * ) ; if ( VAR_41 ) { if ( VAR_42 < VAR_43 ( struct VAR_44 , VAR_45 ) ) return - VAR_46 ; switch ( VAR_47 -> VAR_48 ) { case VAR_49 : if ( VAR_50 < VAR_51 ) return - VAR_52 ; VAR_53 = & VAR_54 -> VAR_55 ; break ; case VAR_56 : goto VAR_57 ; case VAR_58 : VAR_59 -> VAR_60 = VAR_61 = VAR_62 ; VAR_63 -> VAR_64 = VAR_65 = 0 ; VAR_66 = VAR_67 ; break ; default : return - VAR_68 ; } } else if ( ! VAR_69 -> VAR_70 ) { if ( VAR_71 -> VAR_72 != VAR_73 ) return - VAR_74 ; VAR_75 = & VAR_76 -> VAR_77 ; } else VAR_78 = VAR_79 ; if ( VAR_80 ) { if ( METHOD_5 ( VAR_81 ) ) { struct STRUCT_OR_UNION_13 VAR_82 ; VAR_83 . VAR_84 = VAR_85 ; VAR_86 . VAR_87 = VAR_88 ? VAR_89 -> VAR_90 : VAR_91 -> VAR_92 ; VAR_93 . VAR_94 . VAR_95 = VAR_96 -> VAR_97 [ 3 ] ; VAR_98 -> VAR_99 = & VAR_100 ; VAR_101 -> VAR_102 = sizeof ( VAR_103 ) ; VAR_104 : if ( METHOD_6 ( VAR_105 ) ) return - VAR_106 ; return METHOD_7 ( VAR_107 , VAR_108 , VAR_109 ) ; } } if ( VAR_110 -> VAR_111 == VAR_112 ) return METHOD_8 ( VAR_113 , VAR_114 , VAR_115 ) ; if ( VAR_116 > VAR_117 - sizeof ( struct STRUCT_OR_UNION_14 ) ) return - VAR_118 ; VAR_119 = VAR_120 ? VAR_121 : VAR_122 ; if ( VAR_123 -> VAR_124 ) { METHOD_9 ( VAR_125 ) ; if ( METHOD_10 ( VAR_126 -> VAR_127 ) ) { if ( METHOD_11 ( VAR_128 -> VAR_129 != VAR_130 ) ) { METHOD_12 ( VAR_131 ) ; return - VAR_132 ; } VAR_133 = VAR_134 ; goto VAR_135 ; } METHOD_13 ( VAR_136 ) ; } VAR_137 += sizeof ( struct STRUCT_OR_UNION_15 ) ; METHOD_14 ( & VAR_138 , 0 , sizeof ( VAR_139 ) ) ; if ( VAR_140 ) { if ( VAR_141 -> VAR_142 == 0 ) return - VAR_143 ; VAR_144 . VAR_145 = VAR_146 -> VAR_147 ; VAR_148 = & VAR_149 -> VAR_150 ; if ( VAR_151 -> VAR_152 ) { VAR_153 . VAR_154 = VAR_155 -> VAR_156 & VAR_157 ; if ( VAR_158 . VAR_159 & VAR_160 ) { VAR_161 = METHOD_15 ( VAR_162 , VAR_163 . VAR_164 ) ; if ( ! VAR_165 ) return - VAR_166 ; } } if ( VAR_167 -> VAR_168 == VAR_169 && TYPE_17 ( VAR_170 , & VAR_171 -> VAR_172 ) ) VAR_173 = & VAR_174 -> VAR_175 ; if ( VAR_176 >= sizeof ( struct STRUCT_OR_UNION_16 ) && VAR_177 -> VAR_178 && METHOD_16 ( METHOD_17 ( VAR_179 ) ) ) VAR_180 . VAR_181 = VAR_182 -> VAR_183 ; } else { if ( VAR_184 -> VAR_185 != VAR_186 ) return - VAR_187 ; VAR_188 . VAR_189 = VAR_190 -> VAR_191 ; VAR_192 = & VAR_193 -> VAR_194 ; VAR_195 . VAR_196 = VAR_197 -> VAR_198 ; VAR_199 = 1 ; } if ( ! VAR_200 . VAR_201 ) VAR_202 . VAR_203 = VAR_204 -> VAR_205 ; if ( ! VAR_206 . VAR_207 ) VAR_208 . VAR_209 = VAR_210 -> VAR_211 . VAR_212 ; VAR_213 . VAR_214 = VAR_215 -> VAR_216 ; if ( VAR_217 -> VAR_218 ) { VAR_219 = & VAR_220 ; METHOD_18 ( VAR_221 , 0 , sizeof ( struct STRUCT_OR_UNION_17 ) ) ; VAR_222 -> VAR_223 = sizeof ( * VAR_224 ) ; VAR_225 = METHOD_19 ( METHOD_20 ( VAR_226 ) , VAR_227 , VAR_228 , & VAR_229 , VAR_230 , & VAR_231 , & VAR_232 , & VAR_233 ) ; if ( VAR_234 < 0 ) { METHOD_21 ( VAR_235 ) ; return VAR_236 ; } if ( ( VAR_237 . VAR_238 & VAR_239 ) && ! VAR_240 ) { VAR_241 = METHOD_22 ( VAR_242 , VAR_243 . VAR_244 ) ; if ( ! VAR_245 ) return - VAR_246 ; } if ( ! ( VAR_247 -> VAR_248 | VAR_249 -> VAR_250 ) ) VAR_251 = VAR_252 ; VAR_253 = 0 ; } <S2SV_StartBug> if ( ! VAR_254 ) <S2SV_EndBug> VAR_255 = VAR_256 -> VAR_257 ; if ( VAR_258 ) VAR_259 = METHOD_23 ( & VAR_260 , VAR_261 , VAR_262 ) ; VAR_263 = METHOD_24 ( & VAR_264 , VAR_265 ) ; VAR_266 . VAR_267 = VAR_268 -> VAR_269 ; if ( ! METHOD_25 ( VAR_270 ) ) VAR_271 . VAR_272 = * VAR_273 ; else VAR_274 . VAR_275 . VAR_276 [ 15 ] = 0x1 ; if ( METHOD_26 ( & VAR_277 . VAR_278 ) && ! METHOD_27 ( & VAR_279 -> VAR_280 ) ) VAR_281 . VAR_282 = VAR_283 -> VAR_284 ; VAR_285 . VAR_286 = VAR_287 -> VAR_288 ; VAR_289 = METHOD_28 ( & VAR_290 , VAR_291 , & VAR_292 ) ; if ( VAR_293 ) VAR_294 = 0 ; if ( ! VAR_295 . VAR_296 && METHOD_29 ( & VAR_297 . VAR_298 ) ) { VAR_299 . VAR_300 = VAR_301 -> VAR_302 ; VAR_303 = 0 ; } else if ( ! VAR_304 . VAR_305 ) VAR_306 . VAR_307 = VAR_308 -> VAR_309 ; METHOD_30 ( VAR_310 , METHOD_31 ( & VAR_311 ) ) ; VAR_312 = METHOD_32 ( VAR_313 , & VAR_314 , VAR_315 ) ; if ( METHOD_33 ( VAR_316 ) ) { VAR_317 = METHOD_34 ( VAR_318 ) ; VAR_319 = VAR_320 ; goto VAR_321 ; } if ( VAR_322 < 0 ) VAR_323 = METHOD_35 ( VAR_324 , & VAR_325 , VAR_326 ) ; if ( VAR_327 < 0 ) VAR_328 = VAR_329 -> VAR_330 ; if ( VAR_331 -> VAR_332 & VAR_333 ) goto VAR_334 ; VAR_335 : if ( ! VAR_336 ) { struct STRUCT_OR_UNION_18 * VAR_337 ; VAR_338 = METHOD_36 ( VAR_339 , VAR_340 , VAR_341 , VAR_342 , sizeof ( struct STRUCT_OR_UNION_19 ) , VAR_343 , VAR_344 , VAR_345 , & VAR_346 , ( struct STRUCT_OR_UNION_20 * ) VAR_347 , VAR_348 -> VAR_349 , VAR_350 ) ; VAR_351 = METHOD_37 ( VAR_352 ) ; if ( ! METHOD_38 ( VAR_353 ) ) VAR_354 = METHOD_39 ( VAR_355 , & VAR_356 ) ; goto VAR_357 ; } METHOD_40 ( VAR_358 ) ; if ( METHOD_41 ( VAR_359 -> VAR_360 ) ) { METHOD_42 ( VAR_361 ) ; METHOD_43 ( ""udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n"" ) ; VAR_362 = - VAR_363 ; goto VAR_364 ; } VAR_365 -> VAR_366 = VAR_367 ; VAR_368 : if ( VAR_369 < 0 ) VAR_370 = VAR_371 -> VAR_372 ; VAR_373 -> VAR_374 += VAR_375 ; VAR_376 = METHOD_44 ( VAR_377 , VAR_378 , VAR_379 , VAR_380 , sizeof ( struct STRUCT_OR_UNION_21 ) , VAR_381 , VAR_382 , VAR_383 , & VAR_384 , ( struct STRUCT_OR_UNION_22 * ) VAR_385 , VAR_386 ? VAR_387 -> VAR_388 | VAR_389 : VAR_390 -> VAR_391 , VAR_392 ) ; if ( VAR_393 ) METHOD_45 ( VAR_394 ) ; else if ( ! VAR_395 ) VAR_396 = METHOD_46 ( VAR_397 ) ; else if ( METHOD_47 ( METHOD_48 ( & VAR_398 -> VAR_399 ) ) ) VAR_400 -> VAR_401 = 0 ; if ( VAR_402 > 0 ) VAR_403 = VAR_404 -> VAR_405 ? METHOD_49 ( VAR_406 ) : 0 ; METHOD_50 ( VAR_407 ) ; VAR_408 : if ( VAR_409 ) { if ( VAR_410 ) { ip6_dst_store ( VAR_411 , VAR_412 , TYPE_18 ( & VAR_413 . VAR_414 , & VAR_415 -> VAR_416 ) ? & VAR_417 -> VAR_418 : VAR_419 , VAR_420 TYPE_19 TYPE_20 ( & VAR_421 . VAR_422 , & VAR_423 -> VAR_424 ) ? & VAR_425 -> VAR_426 : VAR_427 ) ; } else { METHOD_51 ( VAR_428 ) ; } VAR_429 = VAR_430 ; } VAR_431 : METHOD_52 ( VAR_432 ) ; <S2SV_StartBug> METHOD_53 ( VAR_433 ) ; <S2SV_EndBug> if ( ! VAR_434 ) return VAR_435 ; if ( VAR_436 == - VAR_437 || METHOD_54 ( VAR_438 , & VAR_439 -> VAR_440 -> VAR_441 ) ) { METHOD_55 ( METHOD_56 ( VAR_442 ) , VAR_443 , VAR_444 ) ; } return VAR_445 ; VAR_446 : METHOD_57 ( VAR_447 ) ; if ( ! ( VAR_448 -> VAR_449 & VAR_450 ) || VAR_451 ) goto VAR_452 ; VAR_453 = 0 ; goto VAR_454 ; }",<S2SV_ModStart> STRUCT_OR_UNION_17 * VAR_383 = VAR_430 ; struct STRUCT_OR_UNION_17 * VAR_455 <S2SV_ModStart> ! VAR_383 ) { VAR_383 = METHOD_58 ( VAR_425 ) ; VAR_455 = VAR_383 ; } <S2SV_ModEnd> if ( VAR_433 <S2SV_ModStart> METHOD_53 ( VAR_433 ) ; METHOD_59 ( VAR_455,"CWE-264 int udpv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <S2SV_StartBug> struct ipv6_txoptions * opt = NULL ; <S2SV_EndBug> struct ip6_flowlabel * flowlabel = NULL ; struct flowi6 fl6 ; struct dst_entry * dst ; int addr_len = msg -> msg_namelen ; int ulen = len ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int err ; int connected = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ; if ( sin6 ) { if ( addr_len < offsetof ( struct sockaddr , sa_data ) ) return - EINVAL ; switch ( sin6 -> sin6_family ) { case AF_INET6 : if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; break ; case AF_INET : goto do_udp_sendmsg ; case AF_UNSPEC : msg -> msg_name = sin6 = NULL ; msg -> msg_namelen = addr_len = 0 ; daddr = NULL ; break ; default : return - EINVAL ; } } else if ( ! up -> pending ) { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; } else daddr = NULL ; if ( daddr ) { if ( ipv6_addr_v4mapped ( daddr ) ) { struct sockaddr_in sin ; sin . sin_family = AF_INET ; sin . sin_port = sin6 ? sin6 -> sin6_port : inet -> inet_dport ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; msg -> msg_name = & sin ; msg -> msg_namelen = sizeof ( sin ) ; do_udp_sendmsg : if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; return udp_sendmsg ( sk , msg , len ) ; } } if ( up -> pending == AF_INET ) return udp_sendmsg ( sk , msg , len ) ; if ( len > INT_MAX - sizeof ( struct udphdr ) ) return - EMSGSIZE ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET6 ) ) { release_sock ( sk ) ; return - EAFNOSUPPORT ; } dst = NULL ; goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( sin6 ) { if ( sin6 -> sin6_port == 0 ) return - EINVAL ; fl6 . fl6_dport = sin6 -> sin6_port ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; fl6 . fl6_dport = inet -> inet_dport ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; connected = 1 ; } if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> sticky_pktinfo . ipi6_ifindex ; fl6 . flowi6_mark = sk -> sk_mark ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( * opt ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; connected = 0 ; } <S2SV_StartBug> if ( ! opt ) <S2SV_EndBug> opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; fl6 . fl6_sport = inet -> inet_sport ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( final_p ) connected = 0 ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) { fl6 . flowi6_oif = np -> mcast_oif ; connected = 0 ; } else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_sk_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( ! corkreq ) { struct sk_buff * skb ; skb = ip6_make_skb ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; err = PTR_ERR ( skb ) ; if ( ! IS_ERR_OR_NULL ( skb ) ) err = udp_v6_send_skb ( skb , & fl6 ) ; goto release_dst ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; net_dbg_ratelimited ( ""udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n"" ) ; err = - EINVAL ; goto out ; } up -> pending = AF_INET6 ; do_append_data : if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; up -> len += ulen ; err = ip6_append_data ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags , dontfrag ) ; if ( err ) udp_v6_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_v6_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; if ( err > 0 ) err = np -> recverr ? net_xmit_errno ( err ) : 0 ; release_sock ( sk ) ; release_dst : if ( dst ) { if ( connected ) { ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL ,  ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr :   NULL ) ; } else { dst_release ( dst ) ; } dst = NULL ; } out : dst_release ( dst ) ; <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }",<S2SV_ModStart> ipv6_txoptions * opt = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
84,"CWE-285 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_1 , TYPE_2 VAR_2 , struct STRUCT_OR_UNION_3 * VAR_3 , struct STRUCT_OR_UNION_4 * VAR_4 , struct STRUCT_OR_UNION_5 * VAR_5 ) { TYPE_3 VAR_6 ; TYPE_4 * VAR_7 = VAR_8 ; TYPE_5 VAR_9 = 0 ; TYPE_6 VAR_10 ; if ( METHOD_1 ( STRUCT_OR_UNION_6 -> VAR_11 ) ) return - VAR_12 ; switch ( VAR_13 ) { case VAR_14 : VAR_15 = VAR_16 ; if ( VAR_17 ) { <S2SV_StartBug> TYPE_7 VAR_18 = STRUCT_OR_UNION_7 -> VAR_19 ; <S2SV_EndBug> <S2SV_StartBug> VAR_20 = METHOD_2 ( VAR_21 , & VAR_22 ) ; <S2SV_EndBug> if ( VAR_23 < 0 ) return VAR_24 ; if ( VAR_25 == 0 ) VAR_26 = VAR_27 ; VAR_28 = METHOD_3 ( STRUCT_OR_UNION_8 , VAR_29 , VAR_30 , VAR_31 ) ; if ( VAR_32 ) return VAR_33 ; } break ; case VAR_34 : VAR_35 = VAR_36 ; if ( ! METHOD_4 ( STRUCT_OR_UNION_9 -> VAR_37 ) ) return VAR_38 ? - VAR_39 : 0 ; break ; default : return - VAR_40 ; } if ( VAR_41 ) { VAR_42 = METHOD_5 ( VAR_43 , & VAR_44 ) ; if ( METHOD_6 ( VAR_45 ) ) return ( TYPE_8 ) METHOD_7 ( VAR_46 ) ; } if ( VAR_47 ) VAR_48 = METHOD_8 ( VAR_49 , STRUCT_OR_UNION_10 , VAR_50 , VAR_51 , """" , VAR_52 , VAR_53 , 0 , VAR_54 , VAR_55 ) ; else VAR_56 = METHOD_9 ( STRUCT_OR_UNION_11 , VAR_57 , """" , VAR_58 , VAR_59 , 0 ) ; METHOD_10 ( VAR_60 ) ; return VAR_61 ; }","<S2SV_ModStart> { TYPE_7 VAR_31 ; VAR_61 = METHOD_11 ( STRUCT_OR_UNION_11 <S2SV_ModEnd> , & VAR_31 <S2SV_ModStart> , & VAR_31 , & VAR_43 ) ; if ( VAR_61 ) return VAR_61 <S2SV_ModEnd> ; VAR_61 =","CWE-285 int ocfs2_set_acl ( handle_t * handle , struct inode * inode , struct buffer_head * di_bh , int type , struct posix_acl * acl , struct ocfs2_alloc_context * meta_ac , struct ocfs2_alloc_context * data_ac ) { int name_index ; void * value = NULL ; size_t size = 0 ; int ret ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; ret = ocfs2_acl_set_mode ( inode , di_bh , handle , mode ) ; if ( ret ) return ret ; } break ; case ACL_TYPE_DEFAULT : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ocfs2_acl_to_xattr ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } if ( handle ) ret = ocfs2_xattr_set_handle ( handle , inode , di_bh , name_index , """" , value , size , 0 , meta_ac , data_ac ) ; else ret = ocfs2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; return ret ; }","<S2SV_ModStart> { umode_t mode ; ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; ret ="
85,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 ; TYPE_6 VAR_14 , VAR_15 ; <S2SV_StartBug> VAR_16 * VAR_17 ; <S2SV_EndBug> TYPE_7 * VAR_18 ; METHOD_1 ( ""pixFillMapHoles"" ) ; if ( ! VAR_19 || METHOD_2 ( VAR_20 ) != 8 ) return METHOD_3 ( ""pix<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>8<S2SV_blank>bpp"" , VAR_21 , 1 ) ; if ( METHOD_4 ( VAR_22 ) ) return METHOD_5 ( ""pix<S2SV_blank>is<S2SV_blank>colormapped"" , VAR_23 , 1 ) ; METHOD_6 ( VAR_24 , & VAR_25 , & VAR_26 , VAR_27 ) ; VAR_28 = METHOD_7 ( 0 ) ; VAR_29 = 0 ; VAR_30 = ( VAR_31 == VAR_32 ) ? 255 : 0 ; for ( VAR_33 = 0 ; VAR_34 < VAR_35 ; VAR_36 ++ ) { VAR_37 = VAR_38 ; for ( VAR_39 = 0 ; VAR_40 < VAR_41 ; VAR_42 ++ ) { METHOD_8 ( VAR_43 , VAR_44 , VAR_45 , & VAR_46 ) ; if ( VAR_47 != VAR_48 ) { VAR_49 = VAR_50 ; VAR_51 = VAR_52 ; break ; } } if ( VAR_53 == VAR_54 ) { METHOD_9 ( VAR_55 , 0 ) ; VAR_56 ++ ; } else { METHOD_10 ( VAR_57 , 1 ) ; for ( VAR_58 = VAR_59 - 1 ; VAR_60 >= 0 ; VAR_61 -- ) METHOD_11 ( VAR_62 , VAR_63 , VAR_64 , VAR_65 ) ; METHOD_12 ( VAR_66 , VAR_67 , 0 , & VAR_68 ) ; for ( VAR_69 = 1 ; VAR_70 < VAR_71 ; VAR_72 ++ ) { METHOD_13 ( VAR_73 , VAR_74 , VAR_75 , & VAR_76 ) ; if ( VAR_77 == VAR_78 ) METHOD_14 ( VAR_79 , VAR_80 , VAR_81 , VAR_82 ) ; else VAR_83 = VAR_84 ; } } } METHOD_15 ( VAR_85 , 0 ) ; if ( VAR_86 == VAR_87 ) { METHOD_16 ( & VAR_88 ) ; METHOD_17 ( ""no<S2SV_blank>bg<S2SV_blank>found;<S2SV_blank>no<S2SV_blank>data<S2SV_blank>in<S2SV_blank>any<S2SV_blank>column\\n"" , VAR_89 ) ; return 1 ; } if ( VAR_90 > 0 ) { <S2SV_StartBug> VAR_91 = METHOD_18 ( VAR_92 , VAR_93 ) ; <S2SV_EndBug> VAR_94 = 0 ; for ( VAR_95 = 0 ; VAR_96 < VAR_97 ; VAR_98 ++ ) { METHOD_19 ( VAR_99 , VAR_100 , & VAR_101 ) ; if ( VAR_102 == 1 ) { VAR_103 = VAR_104 ; break ; } } if ( VAR_105 > 0 ) { <S2SV_StartBug> for ( VAR_106 = VAR_107 - 1 ; VAR_108 >= 0 ; VAR_109 -- ) { <S2SV_EndBug> <S2SV_StartBug> METHOD_20 ( VAR_110 , VAR_111 , 0 , 1 , VAR_112 , VAR_113 , VAR_114 , VAR_115 + 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_21 ( VAR_116 , VAR_117 , 0 , 1 , VAR_118 , VAR_119 , VAR_120 , VAR_121 , 0 ) ; <S2SV_EndBug> } } for ( VAR_122 = VAR_123 + 1 ; VAR_124 < VAR_125 ; VAR_126 ++ ) { METHOD_22 ( VAR_127 , VAR_128 , & VAR_129 ) ; if ( VAR_130 == 0 ) { <S2SV_StartBug> METHOD_23 ( VAR_131 , VAR_132 , 0 , 1 , VAR_133 , VAR_134 , VAR_135 , VAR_136 - 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_24 ( VAR_137 , VAR_138 , 0 , 1 , VAR_139 , VAR_140 , VAR_141 , VAR_142 , 0 ) ; <S2SV_EndBug> } } METHOD_25 ( & VAR_143 ) ; } if ( VAR_144 > VAR_145 ) { for ( VAR_146 = 0 ; VAR_147 < VAR_148 ; VAR_149 ++ ) { METHOD_26 ( VAR_150 , VAR_151 - 2 , VAR_152 , & VAR_153 ) ; METHOD_27 ( VAR_154 , VAR_155 - 1 , VAR_156 , VAR_157 ) ; } } METHOD_28 ( & VAR_158 ) ; return 0 ; }","<S2SV_ModStart> VAR_16 * VAR_158 <S2SV_ModEnd> ; METHOD_1 ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> VAR_123 = 0 <S2SV_ModStart> VAR_142 -- ) <S2SV_ModEnd> METHOD_24 ( VAR_154 <S2SV_ModStart> , VAR_140 , VAR_154 <S2SV_ModEnd> , VAR_142 + <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } for ( <S2SV_ModStart> , VAR_140 , VAR_154 <S2SV_ModEnd> , VAR_142 - <S2SV_ModStart> 0 ) ; } } <S2SV_ModEnd> } if (","CWE-125 l_ok pixFillMapHoles ( PIX * pix , l_int32 nx , l_int32 ny , l_int32 filltype ) { l_int32 w , h , y , nmiss , goodcol , i , j , found , ival , valtest ; l_uint32 val , lastval ; <S2SV_StartBug> NUMA * na ; <S2SV_EndBug> PIX * pixt ; PROCNAME ( ""pixFillMapHoles"" ) ; if ( ! pix || pixGetDepth ( pix ) != 8 ) return ERROR_INT ( ""pix<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>8<S2SV_blank>bpp"" , procName , 1 ) ; if ( pixGetColormap ( pix ) ) return ERROR_INT ( ""pix<S2SV_blank>is<S2SV_blank>colormapped"" , procName , 1 ) ; pixGetDimensions ( pix , & w , & h , NULL ) ; na = numaCreate ( 0 ) ; nmiss = 0 ; valtest = ( filltype == L_FILL_WHITE ) ? 255 : 0 ; for ( j = 0 ; j < nx ; j ++ ) { found = FALSE ; for ( i = 0 ; i < ny ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val != valtest ) { y = i ; found = TRUE ; break ; } } if ( found == FALSE ) { numaAddNumber ( na , 0 ) ; nmiss ++ ; } else { numaAddNumber ( na , 1 ) ; for ( i = y - 1 ; i >= 0 ; i -- ) pixSetPixel ( pix , j , i , val ) ; pixGetPixel ( pix , j , 0 , & lastval ) ; for ( i = 1 ; i < h ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val == valtest ) pixSetPixel ( pix , j , i , lastval ) ; else lastval = val ; } } } numaAddNumber ( na , 0 ) ; if ( nmiss == nx ) { numaDestroy ( & na ) ; L_WARNING ( ""no<S2SV_blank>bg<S2SV_blank>found;<S2SV_blank>no<S2SV_blank>data<S2SV_blank>in<S2SV_blank>any<S2SV_blank>column\\n"" , procName ) ; return 1 ; } if ( nmiss > 0 ) { <S2SV_StartBug> pixt = pixCopy ( NULL , pix ) ; <S2SV_EndBug> goodcol = 0 ; for ( j = 0 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 1 ) { goodcol = j ; break ; } } if ( goodcol > 0 ) { <S2SV_StartBug> for ( j = goodcol - 1 ; j >= 0 ; j -- ) { <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> } } for ( j = goodcol + 1 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 0 ) { <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> } } pixDestroy ( & pixt ) ; } if ( w > nx ) { for ( i = 0 ; i < h ; i ++ ) { pixGetPixel ( pix , w - 2 , i , & val ) ; pixSetPixel ( pix , w - 1 , i , val ) ; } } numaDestroy ( & na ) ; return 0 ; }","<S2SV_ModStart> NUMA * na <S2SV_ModEnd> ; PROCNAME ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> goodcol = 0 <S2SV_ModStart> j -- ) <S2SV_ModEnd> pixRasterop ( pix <S2SV_ModStart> , PIX_SRC , pix <S2SV_ModEnd> , j + <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } for ( <S2SV_ModStart> , PIX_SRC , pix <S2SV_ModEnd> , j - <S2SV_ModStart> 0 ) ; } } <S2SV_ModEnd> } if ("
86,"CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 * VAR_6 ) { struct STRUCT_OR_UNION_3 * VAR_7 = METHOD_1 ( VAR_8 ) ; TYPE_5 VAR_9 = VAR_10 -> VAR_11 ; struct STRUCT_OR_UNION_4 * VAR_12 ; TYPE_6 VAR_13 , VAR_14 ; METHOD_2 ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , VAR_15 , VAR_16 -> VAR_17 ) ; VAR_18 = - VAR_19 ; if ( VAR_20 & VAR_21 ) goto VAR_22 ; if ( VAR_23 & VAR_24 ) { if ( VAR_25 == VAR_26 ) { return METHOD_3 ( VAR_27 , VAR_28 , VAR_29 ) ; if IS_ENABLED ( VAR_30 ) } else if ( VAR_31 == VAR_32 ) { return VAR_33 . METHOD_4 ( VAR_34 , VAR_35 , VAR_36 ) ; } } VAR_37 = METHOD_5 ( VAR_38 , VAR_39 , VAR_40 , & VAR_41 ) ; if ( ! VAR_42 ) goto VAR_43 ; VAR_44 = VAR_45 -> VAR_46 ; if ( VAR_47 > VAR_48 ) { VAR_49 -> VAR_50 |= VAR_51 ; VAR_52 = VAR_53 ; } VAR_54 = METHOD_6 ( VAR_55 , 0 , VAR_56 -> VAR_57 , VAR_58 ) ; if ( VAR_59 ) goto VAR_60 ; METHOD_7 ( VAR_61 , VAR_62 , VAR_63 ) ; if ( VAR_64 == VAR_65 ) { struct STRUCT_OR_UNION_5 * VAR_66 = ( struct STRUCT_OR_UNION_6 * ) VAR_67 -> VAR_68 ; <S2SV_StartBug> VAR_69 -> VAR_70 = VAR_71 ; <S2SV_EndBug> VAR_72 -> VAR_73 = 0 ; VAR_74 -> VAR_75 . VAR_76 = METHOD_8 ( VAR_77 ) -> VAR_78 ; METHOD_9 ( VAR_79 -> VAR_80 , 0 , sizeof ( VAR_81 -> VAR_82 ) ) ; * VAR_83 = sizeof ( * VAR_84 ) ; <S2SV_StartBug> if ( VAR_85 -> VAR_86 ) <S2SV_EndBug> METHOD_10 ( VAR_87 , VAR_88 ) ; if IS_ENABLED ( VAR_89 ) } else if ( VAR_90 == VAR_91 ) { struct STRUCT_OR_UNION_7 * VAR_92 = METHOD_11 ( VAR_93 ) ; struct STRUCT_OR_UNION_8 * VAR_94 = METHOD_12 ( VAR_95 ) ; struct STRUCT_OR_UNION_9 * VAR_96 = ( struct STRUCT_OR_UNION_10 * ) VAR_97 -> VAR_98 ; <S2SV_StartBug> VAR_99 -> VAR_100 = VAR_101 ; <S2SV_EndBug> VAR_102 -> VAR_103 = 0 ; VAR_104 -> VAR_105 = VAR_106 -> VAR_107 ; VAR_108 -> VAR_109 = 0 ; if ( VAR_110 -> VAR_111 ) VAR_112 -> VAR_113 = METHOD_13 ( VAR_114 ) ; VAR_115 -> VAR_116 = METHOD_14 ( & VAR_117 -> VAR_118 , METHOD_15 ( VAR_119 ) -> VAR_120 ) ; <S2SV_StartBug> * VAR_121 = sizeof ( * VAR_122 ) ; <S2SV_EndBug> if ( METHOD_16 ( VAR_123 ) -> VAR_124 . VAR_125 ) VAR_126 . METHOD_17 ( VAR_127 , VAR_128 , VAR_129 ) ; } else { METHOD_18 ( ) ; } VAR_130 = VAR_131 ; VAR_132 : METHOD_19 ( VAR_133 , VAR_134 ) ; VAR_135 : METHOD_20 ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , VAR_136 ) ; return VAR_137 ; }",<S2SV_ModStart> -> VAR_98 ; if ( VAR_84 ) { <S2SV_ModStart> VAR_84 ) ; } <S2SV_ModStart> -> VAR_98 ; if ( VAR_122 ) { <S2SV_ModStart> VAR_122 ) ; },"CWE-000 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; int family = sk -> sk_family ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ;  if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ;   } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> ip_cmsg_recv ( msg , skb ) ;  if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;   } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , err ) ; return err ; }",<S2SV_ModStart> -> msg_name ; if ( sin ) { <S2SV_ModStart> sin ) ; } <S2SV_ModStart> -> msg_name ; if ( sin6 ) { <S2SV_ModStart> sin6 ) ; }
87,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 , * VAR_2 ; METHOD_1 ( & VAR_3 -> VAR_4 ) ; while ( 1 ) { struct STRUCT_OR_UNION_2 * VAR_5 = VAR_6 ; METHOD_2 ( & VAR_7 -> VAR_8 ) ; while ( ! METHOD_3 ( & VAR_9 -> VAR_10 ) ) { TYPE_1 TYPE_2 ; VAR_11 = list_first_entry ( & VAR_12 -> VAR_13 , struct STRUCT_OR_UNION_3 , VAR_14 ) ; VAR_15 = VAR_16 -> VAR_17 -> VAR_18 ; TYPE_3 = METHOD_4 ( VAR_19 ) ; if ( ! TYPE_4 ) { METHOD_5 ( & VAR_20 -> VAR_21 ) ; VAR_22 = VAR_23 ; continue ; } break ; } METHOD_6 ( & VAR_24 -> VAR_25 ) ; if ( ! VAR_26 ) return ; <S2SV_StartBug> METHOD_7 ( & VAR_27 -> VAR_28 ) ; <S2SV_EndBug> METHOD_8 ( & VAR_29 -> VAR_30 ) ; METHOD_9 ( VAR_31 , VAR_32 , & VAR_33 -> VAR_34 , VAR_35 ) { struct STRUCT_OR_UNION_4 * VAR_36 = VAR_37 -> VAR_38 ; if ( VAR_39 -> VAR_40 != VAR_41 ) continue ; METHOD_10 ( & VAR_42 -> VAR_43 ) ; METHOD_11 ( VAR_44 , VAR_45 -> VAR_46 , VAR_47 -> VAR_48 - VAR_49 -> VAR_50 ) ; VAR_51 -> VAR_52 &= ~ ( VAR_53 | VAR_54 ) ; } METHOD_12 ( & VAR_55 -> VAR_56 ) ; <S2SV_StartBug> METHOD_13 ( & VAR_57 -> VAR_58 ) ; <S2SV_EndBug> METHOD_14 ( VAR_59 ) ; } }",<S2SV_ModStart> -> VAR_58 ) ; if ( ! METHOD_15 ( VAR_59 ) ) goto VAR_60 <S2SV_ModStart> VAR_56 ) ; VAR_60 :,"CWE-362 void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }",<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> umap_lock ) ; skip_mm :
88,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { VAR_3 * VAR_4 ; TYPE_4 VAR_5 , VAR_6 ; TYPE_5 VAR_7 = VAR_8 ; struct { const TYPE_6 * VAR_9 ; TYPE_7 VAR_10 ; } VAR_11 [ ] = { { ""SideBySideRF"" , VAR_12 } , { ""SideBySideLF"" , VAR_13 } , { ""OverUnderRT"" , VAR_14 } , { ""OverUnderLT"" , VAR_15 } , { ""DualStream"" , VAR_16 } } ; METHOD_1 ( VAR_17 , ""object<S2SV_blank>is<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>content<S2SV_blank>description"" ) ; VAR_18 = METHOD_2 ( ) ; if ( VAR_19 < 2 ) goto VAR_20 ; VAR_21 = METHOD_3 ( & VAR_22 , & VAR_23 ) ; for ( VAR_24 = 1 ; VAR_25 <= VAR_26 ; ++ VAR_27 ) { const TYPE_8 * VAR_28 ; TYPE_9 VAR_29 ; TYPE_10 VAR_30 ; TYPE_11 VAR_31 ; TYPE_12 VAR_32 = { 0 , } ; TYPE_13 VAR_33 , VAR_34 ; TYPE_14 * VAR_35 ; TYPE_15 * VAR_36 = VAR_37 ; TYPE_16 * VAR_38 ; if ( ! METHOD_4 ( & VAR_39 , & VAR_40 , & VAR_41 , & VAR_42 ) ) goto VAR_43 ; if ( VAR_44 < 2 ) { METHOD_5 ( VAR_45 ) ; goto VAR_46 ; } VAR_47 = METHOD_6 ( & VAR_48 , & VAR_49 ) ; if ( ! METHOD_7 ( & VAR_50 , & VAR_51 , & VAR_52 , & VAR_53 ) ) { METHOD_8 ( VAR_54 ) ; goto VAR_55 ; } VAR_56 = METHOD_9 ( VAR_57 , VAR_58 , ""UTF-8"" , ""UTF-16LE"" , & VAR_59 , & VAR_60 , VAR_61 ) ; if ( VAR_62 != VAR_63 ) { METHOD_10 ( ""Found<S2SV_blank>tag/metadata<S2SV_blank>%s"" , VAR_64 ) ; VAR_65 = METHOD_11 ( VAR_66 ) ; METHOD_12 ( ""gst_tag_name<S2SV_blank>%s"" , METHOD_13 ( VAR_67 ) ) ; switch ( VAR_68 ) { case VAR_69 : { TYPE_17 * VAR_70 ; VAR_71 = METHOD_14 ( VAR_72 , VAR_73 , ""UTF-8"" , ""UTF-16LE"" , & VAR_74 , & VAR_75 , VAR_76 ) ; if ( VAR_77 != VAR_78 && * VAR_79 != '\\0' ) { METHOD_15 ( ""string<S2SV_blank>value<S2SV_blank>%s"" , VAR_80 ) ; VAR_81 [ VAR_82 ] = '\\0' ; if ( VAR_83 != VAR_84 ) { if ( METHOD_16 ( VAR_85 , VAR_86 ) == 0 ) { TYPE_18 VAR_87 = METHOD_17 ( VAR_88 ) ; if ( VAR_89 > 0 ) { METHOD_18 ( & VAR_90 , VAR_91 ) ; METHOD_19 ( & VAR_92 , METHOD_20 ( VAR_93 ) ) ; } } else if ( METHOD_21 ( VAR_94 , VAR_95 ) == 0 ) { TYPE_19 VAR_96 ; const TYPE_20 * VAR_97 ; if ( METHOD_22 ( VAR_98 , ""(%u)"" , & VAR_99 ) == 1 && ( ( VAR_100 = METHOD_23 ( VAR_101 ) ) ) ) { METHOD_24 ( ""Genre:<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , VAR_102 , VAR_103 ) ; METHOD_25 ( VAR_104 ) ; VAR_105 = METHOD_26 ( VAR_106 ) ; } } else { TYPE_21 VAR_107 ; VAR_108 = METHOD_27 ( VAR_109 ) ; METHOD_28 ( & VAR_110 , VAR_111 ) ; if ( ! METHOD_29 ( & VAR_112 , VAR_113 ) ) { TYPE_22 VAR_114 = { 0 , } ; METHOD_30 ( & VAR_115 , VAR_116 ) ; METHOD_31 ( & VAR_117 , VAR_118 ) ; if ( ! METHOD_32 ( & VAR_119 , & VAR_120 ) ) { METHOD_33 ( VAR_121 , ""Could<S2SV_blank>not<S2SV_blank>transform<S2SV_blank>string<S2SV_blank>tag<S2SV_blank>to<S2SV_blank>"" ""%s<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%s"" , VAR_122 , METHOD_34 ( VAR_123 ) ) ; METHOD_35 ( & VAR_124 ) ; } METHOD_36 ( & VAR_125 ) ; } } } else { METHOD_37 ( ""Setting<S2SV_blank>metadata"" ) ; METHOD_38 ( & VAR_126 , VAR_127 ) ; METHOD_39 ( & VAR_128 , VAR_129 ) ; if ( VAR_130 ) { TYPE_23 VAR_131 ; if ( METHOD_40 ( ""StereoscopicLayout"" , VAR_132 , METHOD_41 ( VAR_133 ) ) == 0 ) { for ( VAR_134 = 0 ; VAR_135 < METHOD_42 ( VAR_136 ) ; VAR_137 ++ ) { if ( METHOD_43 ( VAR_138 [ VAR_139 ] . VAR_140 , VAR_141 ) ) { VAR_142 -> VAR_143 = VAR_144 [ VAR_145 ] . VAR_146 ; METHOD_44 ( ""find<S2SV_blank>interleave<S2SV_blank>type<S2SV_blank>%u"" , VAR_147 -> VAR_148 ) ; } } } METHOD_45 ( VAR_149 , ""3d<S2SV_blank>type<S2SV_blank>is<S2SV_blank>%u"" , VAR_150 -> VAR_151 ) ; } else { VAR_152 -> VAR_153 = VAR_154 ; METHOD_46 ( VAR_155 , ""None<S2SV_blank>3d<S2SV_blank>type"" ) ; } } } else if ( VAR_156 == VAR_157 ) { METHOD_47 ( ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>string<S2SV_blank>value<S2SV_blank>to<S2SV_blank>UTF8,<S2SV_blank>skipping"" ) ; } else { METHOD_48 ( ""Skipping<S2SV_blank>empty<S2SV_blank>string<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s"" , METHOD_49 ( VAR_158 ) ) ; } METHOD_50 ( VAR_159 ) ; break ; } case VAR_160 : { if ( VAR_161 ) { if ( ! METHOD_51 ( VAR_162 , VAR_163 ) ) { METHOD_52 ( ""Unhandled<S2SV_blank>byte<S2SV_blank>array<S2SV_blank>tag<S2SV_blank>%s"" , METHOD_53 ( VAR_164 ) ) ; break ; } else { METHOD_54 ( VAR_165 , ( TYPE_24 * ) VAR_166 , VAR_167 ) ; } } break ; } case VAR_168 : { <S2SV_StartBug> TYPE_25 VAR_169 = METHOD_55 ( VAR_170 ) ; <S2SV_EndBug> METHOD_56 ( & VAR_171 , VAR_172 ) ; if ( ! METHOD_57 ( VAR_173 , ""WM/Track"" ) ) ++ VAR_174 ; METHOD_58 ( & VAR_175 , VAR_176 ) ; break ; } case VAR_177 : { <S2SV_StartBug> TYPE_26 VAR_178 = METHOD_59 ( VAR_179 ) ; <S2SV_EndBug> if ( METHOD_60 ( ""Stereoscopic"" , VAR_180 , METHOD_61 ( VAR_181 ) ) == 0 ) { if ( VAR_182 ) { METHOD_62 ( VAR_183 , ""This<S2SV_blank>is<S2SV_blank>3D<S2SV_blank>contents"" ) ; VAR_184 = VAR_185 ; } else { METHOD_63 ( VAR_186 , ""This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>3D<S2SV_blank>contenst"" ) ; VAR_187 = VAR_188 ; } } break ; } default : { METHOD_64 ( ""Skipping<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d"" , VAR_189 , VAR_190 ) ; break ; } } if ( METHOD_65 ( & VAR_191 ) ) { if ( VAR_192 ) { TYPE_27 VAR_193 = VAR_194 ; if ( METHOD_66 ( VAR_195 , ""WM/TrackNumber"" ) == 0 ) VAR_196 = VAR_197 ; METHOD_67 ( VAR_198 , VAR_199 , VAR_200 , & VAR_201 , VAR_202 ) ; } else { METHOD_68 ( ""Setting<S2SV_blank>global<S2SV_blank>metadata<S2SV_blank>%s"" , VAR_203 ) ; METHOD_69 ( VAR_204 -> VAR_205 , VAR_206 , & VAR_207 ) ; } METHOD_70 ( & VAR_208 ) ; } } METHOD_71 ( VAR_209 ) ; METHOD_72 ( VAR_210 ) ; METHOD_73 ( VAR_211 ) ; } METHOD_74 ( VAR_212 , VAR_213 ) ; return VAR_214 ; VAR_215 : { METHOD_75 ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>parsing<S2SV_blank>ext<S2SV_blank>content<S2SV_blank>desc<S2SV_blank>object"" ) ; METHOD_76 ( VAR_216 ) ; return VAR_217 ; } }",<S2SV_ModStart> { TYPE_25 VAR_176 ; if ( VAR_167 < 4 ) break ; VAR_176 <S2SV_ModStart> { TYPE_26 VAR_182 ; if ( VAR_167 < 4 ) break ; VAR_182,"CWE-125 static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) { GstTagList * taglist ; guint16 blockcount , i ; gboolean content3D = FALSE ; struct { const gchar * interleave_name ; GstASF3DMode interleaving_type ; } stereoscopic_layout_map [ ] = { { ""SideBySideRF"" , GST_ASF_3D_SIDE_BY_SIDE_HALF_RL } , { ""SideBySideLF"" , GST_ASF_3D_SIDE_BY_SIDE_HALF_LR } , { ""OverUnderRT"" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL } , { ""OverUnderLT"" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR } , { ""DualStream"" , GST_ASF_3D_DUAL_STREAM } } ; GST_INFO_OBJECT ( demux , ""object<S2SV_blank>is<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>content<S2SV_blank>description"" ) ; taglist = gst_tag_list_new_empty ( ) ; if ( size < 2 ) goto not_enough_data ; blockcount = gst_asf_demux_get_uint16 ( & data , & size ) ; for ( i = 1 ; i <= blockcount ; ++ i ) { const gchar * gst_tag_name ; guint16 datatype ; guint16 value_len ; guint16 name_len ; GValue tag_value = { 0 , } ; gsize in , out ; gchar * name ; gchar * name_utf8 = NULL ; gchar * value ; if ( ! gst_asf_demux_get_string ( & name , & name_len , & data , & size ) ) goto not_enough_data ; if ( size < 2 ) { g_free ( name ) ; goto not_enough_data ; } datatype = gst_asf_demux_get_uint16 ( & data , & size ) ; if ( ! gst_asf_demux_get_string ( & value , & value_len , & data , & size ) ) { g_free ( name ) ; goto not_enough_data ; } name_utf8 = g_convert ( name , name_len , ""UTF-8"" , ""UTF-16LE"" , & in , & out , NULL ) ; if ( name_utf8 != NULL ) { GST_DEBUG ( ""Found<S2SV_blank>tag/metadata<S2SV_blank>%s"" , name_utf8 ) ; gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ; GST_DEBUG ( ""gst_tag_name<S2SV_blank>%s"" , GST_STR_NULL ( gst_tag_name ) ) ; switch ( datatype ) { case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING : { gchar * value_utf8 ; value_utf8 = g_convert ( value , value_len , ""UTF-8"" , ""UTF-16LE"" , & in , & out , NULL ) ; if ( value_utf8 != NULL && * value_utf8 != '\\0' ) { GST_DEBUG ( ""string<S2SV_blank>value<S2SV_blank>%s"" , value_utf8 ) ; value_utf8 [ out ] = '\\0' ; if ( gst_tag_name != NULL ) { if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) { guint year = atoi ( value_utf8 ) ; if ( year > 0 ) { g_value_init ( & tag_value , GST_TYPE_DATE_TIME ) ; g_value_take_boxed ( & tag_value , gst_date_time_new_y ( year ) ) ; } } else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) { guint id3v1_genre_id ; const gchar * genre_str ; if ( sscanf ( value_utf8 , ""(%u)"" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) { GST_DEBUG ( ""Genre:<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , value_utf8 , genre_str ) ; g_free ( value_utf8 ) ; value_utf8 = g_strdup ( genre_str ) ; } } else { GType tag_type ; tag_type = gst_tag_get_type ( gst_tag_name ) ; g_value_init ( & tag_value , tag_type ) ; if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) { GValue from_val = { 0 , } ; g_value_init ( & from_val , G_TYPE_STRING ) ; g_value_set_string ( & from_val , value_utf8 ) ; if ( ! g_value_transform ( & from_val , & tag_value ) ) { GST_WARNING_OBJECT ( demux , ""Could<S2SV_blank>not<S2SV_blank>transform<S2SV_blank>string<S2SV_blank>tag<S2SV_blank>to<S2SV_blank>"" ""%s<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%s"" , gst_tag_name , g_type_name ( tag_type ) ) ; g_value_unset ( & tag_value ) ; } g_value_unset ( & from_val ) ; } } } else { GST_DEBUG ( ""Setting<S2SV_blank>metadata"" ) ; g_value_init ( & tag_value , G_TYPE_STRING ) ; g_value_set_string ( & tag_value , value_utf8 ) ; if ( content3D ) { guint i ; if ( strncmp ( ""StereoscopicLayout"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { for ( i = 0 ; i < G_N_ELEMENTS ( stereoscopic_layout_map ) ; i ++ ) { if ( g_str_equal ( stereoscopic_layout_map [ i ] . interleave_name , value_utf8 ) ) { demux -> asf_3D_mode = stereoscopic_layout_map [ i ] . interleaving_type ; GST_INFO ( ""find<S2SV_blank>interleave<S2SV_blank>type<S2SV_blank>%u"" , demux -> asf_3D_mode ) ; } } } GST_INFO_OBJECT ( demux , ""3d<S2SV_blank>type<S2SV_blank>is<S2SV_blank>%u"" , demux -> asf_3D_mode ) ; } else { demux -> asf_3D_mode = GST_ASF_3D_NONE ; GST_INFO_OBJECT ( demux , ""None<S2SV_blank>3d<S2SV_blank>type"" ) ; } } } else if ( value_utf8 == NULL ) { GST_WARNING ( ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>string<S2SV_blank>value<S2SV_blank>to<S2SV_blank>UTF8,<S2SV_blank>skipping"" ) ; } else { GST_DEBUG ( ""Skipping<S2SV_blank>empty<S2SV_blank>string<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s"" , GST_STR_NULL ( gst_tag_name ) ) ; } g_free ( value_utf8 ) ; break ; } case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY : { if ( gst_tag_name ) { if ( ! g_str_equal ( gst_tag_name , GST_TAG_IMAGE ) ) { GST_FIXME ( ""Unhandled<S2SV_blank>byte<S2SV_blank>array<S2SV_blank>tag<S2SV_blank>%s"" , GST_STR_NULL ( gst_tag_name ) ) ; break ; } else { asf_demux_parse_picture_tag ( taglist , ( guint8 * ) value , value_len ) ; } } break ; } case ASF_DEMUX_DATA_TYPE_DWORD : { <S2SV_StartBug> guint uint_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> g_value_init ( & tag_value , G_TYPE_UINT ) ; if ( ! strcmp ( name_utf8 , ""WM/Track"" ) ) ++ uint_val ; g_value_set_uint ( & tag_value , uint_val ) ; break ; } case ASF_DEMUX_DATA_TYPE_BOOL : { <S2SV_StartBug> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { if ( bool_val ) { GST_INFO_OBJECT ( demux , ""This<S2SV_blank>is<S2SV_blank>3D<S2SV_blank>contents"" ) ; content3D = TRUE ; } else { GST_INFO_OBJECT ( demux , ""This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>3D<S2SV_blank>contenst"" ) ; content3D = FALSE ; } } break ; } default : { GST_DEBUG ( ""Skipping<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d"" , gst_tag_name , datatype ) ; break ; } } if ( G_IS_VALUE ( & tag_value ) ) { if ( gst_tag_name ) { GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND ; if ( strcmp ( name_utf8 , ""WM/TrackNumber"" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ; gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ; } else { GST_DEBUG ( ""Setting<S2SV_blank>global<S2SV_blank>metadata<S2SV_blank>%s"" , name_utf8 ) ; gst_structure_set_value ( demux -> global_metadata , name_utf8 , & tag_value ) ; } g_value_unset ( & tag_value ) ; } } g_free ( name ) ; g_free ( value ) ; g_free ( name_utf8 ) ; } gst_asf_demux_add_global_tags ( demux , taglist ) ; return GST_FLOW_OK ; not_enough_data : { GST_WARNING ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>parsing<S2SV_blank>ext<S2SV_blank>content<S2SV_blank>desc<S2SV_blank>object"" ) ; gst_tag_list_unref ( taglist ) ; return GST_FLOW_OK ; } }",<S2SV_ModStart> { guint uint_val ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> { gboolean bool_val ; if ( value_len < 4 ) break ; bool_val
89,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 STRUCT_OR_UNION_0 ) { TYPE_4 VAR_2 ; TYPE_5 VAR_3 ; struct STRUCT_OR_UNION_1 * VAR_4 ; TYPE_6 VAR_5 , VAR_6 , VAR_7 ; TYPE_7 VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 ; TYPE_8 VAR_15 , VAR_16 , VAR_17 , VAR_18 , VAR_19 , VAR_20 ; TYPE_9 * VAR_21 ; TYPE_10 * VAR_22 , * VAR_23 ; switch ( STRUCT_OR_UNION_2 ) { case VAR_24 : VAR_25 = & VAR_26 ; break ; case VAR_27 : VAR_28 = & VAR_29 ; break ; case VAR_30 : VAR_31 = & VAR_32 ; break ; default : return ( TYPE_11 ) METHOD_1 ( ""unsupported<S2SV_blank>resampling<S2SV_blank>filter"" ) ; } VAR_33 = VAR_34 = ( TYPE_12 ) VAR_35 -> VAR_36 / VAR_37 ; VAR_38 = VAR_39 -> VAR_40 ; if ( VAR_41 < 1.0 ) { VAR_42 = 1.0 ; } VAR_43 = VAR_44 * VAR_45 ; VAR_46 = ( TYPE_13 ) METHOD_2 ( VAR_47 ) * 2 + 1 ; <S2SV_StartBug> VAR_48 = METHOD_3 ( VAR_49 * VAR_50 * sizeof ( TYPE_14 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VAR_51 ) <S2SV_EndBug> return ( TYPE_15 ) METHOD_4 ( ) ; VAR_52 = METHOD_5 ( VAR_53 * 2 * sizeof ( TYPE_16 ) ) ; if ( ! VAR_54 ) { METHOD_6 ( VAR_55 ) ; return ( TYPE_17 ) METHOD_7 ( ) ; } for ( VAR_56 = 0 ; VAR_57 < VAR_58 ; VAR_59 ++ ) { VAR_60 = & VAR_61 [ VAR_62 * VAR_63 ] ; VAR_64 = ( VAR_65 + 0.5 ) * VAR_66 ; VAR_67 = 0.0 ; VAR_68 = 1.0 / VAR_69 ; VAR_70 = ( TYPE_18 ) METHOD_8 ( VAR_71 - VAR_72 ) ; if ( VAR_73 < 0 ) VAR_74 = 0 ; VAR_75 = ( TYPE_19 ) METHOD_9 ( VAR_76 + VAR_77 ) ; if ( VAR_78 > VAR_79 -> VAR_80 ) VAR_81 = VAR_82 -> VAR_83 ; for ( VAR_84 = VAR_85 ; VAR_86 < VAR_87 ; VAR_88 ++ ) { TYPE_20 VAR_89 = VAR_90 -> STRUCT_OR_UNION_3 ( ( VAR_91 - VAR_92 + 0.5 ) * VAR_93 ) * VAR_94 ; VAR_95 [ VAR_96 - VAR_97 ] = VAR_98 ; VAR_99 += VAR_100 ; } for ( VAR_101 = 0 ; VAR_102 < VAR_103 - VAR_104 ; VAR_105 ++ ) { if ( VAR_106 != 0.0 ) VAR_107 [ VAR_108 ] /= VAR_109 ; } VAR_110 [ VAR_111 * 2 + 0 ] = VAR_112 ; VAR_113 [ VAR_114 * 2 + 1 ] = VAR_115 ; } VAR_116 = METHOD_10 ( VAR_117 -> VAR_118 , VAR_119 , VAR_120 -> VAR_121 ) ; if ( ! VAR_122 ) { METHOD_11 ( VAR_123 ) ; METHOD_12 ( VAR_124 ) ; return VAR_125 ; } METHOD_13 ( & VAR_126 ) ; for ( VAR_127 = 0 ; VAR_128 < VAR_129 -> VAR_130 ; VAR_131 ++ ) { if ( VAR_132 -> VAR_133 ) { for ( VAR_134 = 0 ; VAR_135 < VAR_136 ; VAR_137 ++ ) { VAR_138 = VAR_139 [ VAR_140 * 2 + 0 ] ; VAR_141 = VAR_142 [ VAR_143 * 2 + 1 ] ; VAR_144 = & VAR_145 [ VAR_146 * VAR_147 ] ; VAR_148 = 0.5 ; for ( VAR_149 = VAR_150 ; VAR_151 < VAR_152 ; VAR_153 ++ ) VAR_154 += METHOD_14 ( VAR_155 -> VAR_156 [ VAR_157 ] [ VAR_158 ] ) * VAR_159 [ VAR_160 - VAR_161 ] ; VAR_162 -> VAR_163 [ VAR_164 ] [ VAR_165 ] = METHOD_15 ( VAR_166 ) ; } } else { switch ( VAR_167 -> VAR_168 ) { case VAR_169 : if ( VAR_170 -> VAR_171 == 2 ) { for ( VAR_172 = 0 ; VAR_173 < VAR_174 ; VAR_175 ++ ) { VAR_176 = VAR_177 [ VAR_178 * 2 + 0 ] ; VAR_179 = VAR_180 [ VAR_181 * 2 + 1 ] ; VAR_182 = & VAR_183 [ VAR_184 * VAR_185 ] ; VAR_186 = VAR_187 = 0.5 ; for ( VAR_188 = VAR_189 ; VAR_190 < VAR_191 ; VAR_192 ++ ) { VAR_193 += METHOD_16 ( ( TYPE_21 ) VAR_194 -> VAR_195 [ VAR_196 ] [ VAR_197 * 4 + 0 ] ) * VAR_198 [ VAR_199 - VAR_200 ] ; VAR_201 += METHOD_17 ( ( TYPE_22 ) VAR_202 -> VAR_203 [ VAR_204 ] [ VAR_205 * 4 + 3 ] ) * VAR_206 [ VAR_207 - VAR_208 ] ; } VAR_209 -> VAR_210 [ VAR_211 ] [ VAR_212 * 4 + 0 ] = METHOD_18 ( VAR_213 ) ; VAR_214 -> VAR_215 [ VAR_216 ] [ VAR_217 * 4 + 3 ] = METHOD_19 ( VAR_218 ) ; } } else if ( VAR_219 -> VAR_220 == 3 ) { for ( VAR_221 = 0 ; VAR_222 < VAR_223 ; VAR_224 ++ ) { VAR_225 = VAR_226 [ VAR_227 * 2 + 0 ] ; VAR_228 = VAR_229 [ VAR_230 * 2 + 1 ] ; VAR_231 = & VAR_232 [ VAR_233 * VAR_234 ] ; VAR_235 = VAR_236 = VAR_237 = 0.5 ; for ( VAR_238 = VAR_239 ; VAR_240 < VAR_241 ; VAR_242 ++ ) { VAR_243 += METHOD_20 ( ( TYPE_23 ) VAR_244 -> VAR_245 [ VAR_246 ] [ VAR_247 * 4 + 0 ] ) * VAR_248 [ VAR_249 - VAR_250 ] ; VAR_251 += METHOD_21 ( ( TYPE_24 ) VAR_252 -> VAR_253 [ VAR_254 ] [ VAR_255 * 4 + 1 ] ) * VAR_256 [ VAR_257 - VAR_258 ] ; VAR_259 += METHOD_22 ( ( TYPE_25 ) VAR_260 -> VAR_261 [ VAR_262 ] [ VAR_263 * 4 + 2 ] ) * VAR_264 [ VAR_265 - VAR_266 ] ; } VAR_267 -> VAR_268 [ VAR_269 ] [ VAR_270 * 4 + 0 ] = METHOD_23 ( VAR_271 ) ; VAR_272 -> VAR_273 [ VAR_274 ] [ VAR_275 * 4 + 1 ] = METHOD_24 ( VAR_276 ) ; VAR_277 -> VAR_278 [ VAR_279 ] [ VAR_280 * 4 + 2 ] = METHOD_25 ( VAR_281 ) ; } } else { for ( VAR_282 = 0 ; VAR_283 < VAR_284 ; VAR_285 ++ ) { VAR_286 = VAR_287 [ VAR_288 * 2 + 0 ] ; VAR_289 = VAR_290 [ VAR_291 * 2 + 1 ] ; VAR_292 = & VAR_293 [ VAR_294 * VAR_295 ] ; VAR_296 = VAR_297 = VAR_298 = VAR_299 = 0.5 ; for ( VAR_300 = VAR_301 ; VAR_302 < VAR_303 ; VAR_304 ++ ) { VAR_305 += METHOD_26 ( ( TYPE_26 ) VAR_306 -> VAR_307 [ VAR_308 ] [ VAR_309 * 4 + 0 ] ) * VAR_310 [ VAR_311 - VAR_312 ] ; VAR_313 += METHOD_27 ( ( TYPE_27 ) VAR_314 -> VAR_315 [ VAR_316 ] [ VAR_317 * 4 + 1 ] ) * VAR_318 [ VAR_319 - VAR_320 ] ; VAR_321 += METHOD_28 ( ( TYPE_28 ) VAR_322 -> VAR_323 [ VAR_324 ] [ VAR_325 * 4 + 2 ] ) * VAR_326 [ VAR_327 - VAR_328 ] ; VAR_329 += METHOD_29 ( ( TYPE_29 ) VAR_330 -> VAR_331 [ VAR_332 ] [ VAR_333 * 4 + 3 ] ) * VAR_334 [ VAR_335 - VAR_336 ] ; } VAR_337 -> VAR_338 [ VAR_339 ] [ VAR_340 * 4 + 0 ] = METHOD_30 ( VAR_341 ) ; VAR_342 -> VAR_343 [ VAR_344 ] [ VAR_345 * 4 + 1 ] = METHOD_31 ( VAR_346 ) ; VAR_347 -> VAR_348 [ VAR_349 ] [ VAR_350 * 4 + 2 ] = METHOD_32 ( VAR_351 ) ; VAR_352 -> VAR_353 [ VAR_354 ] [ VAR_355 * 4 + 3 ] = METHOD_33 ( VAR_356 ) ; } } break ; case VAR_357 : for ( VAR_358 = 0 ; VAR_359 < VAR_360 ; VAR_361 ++ ) { VAR_362 = VAR_363 [ VAR_364 * 2 + 0 ] ; VAR_365 = VAR_366 [ VAR_367 * 2 + 1 ] ; VAR_368 = & VAR_369 [ VAR_370 * VAR_371 ] ; VAR_372 = 0.0 ; for ( VAR_373 = VAR_374 ; VAR_375 < VAR_376 ; VAR_377 ++ ) VAR_378 += METHOD_34 ( METHOD_35 ( VAR_379 , VAR_380 , VAR_381 ) ) * VAR_382 [ VAR_383 - VAR_384 ] ; METHOD_36 ( VAR_385 , VAR_386 , VAR_387 ) = ( TYPE_30 ) VAR_388 ; } break ; case VAR_389 : for ( VAR_390 = 0 ; VAR_391 < VAR_392 ; VAR_393 ++ ) { VAR_394 = VAR_395 [ VAR_396 * 2 + 0 ] ; VAR_397 = VAR_398 [ VAR_399 * 2 + 1 ] ; VAR_400 = & VAR_401 [ VAR_402 * VAR_403 ] ; VAR_404 = 0.0 ; for ( VAR_405 = VAR_406 ; VAR_407 < VAR_408 ; VAR_409 ++ ) VAR_410 += METHOD_37 ( VAR_411 , VAR_412 , VAR_413 ) * VAR_414 [ VAR_415 - VAR_416 ] ; METHOD_38 ( VAR_417 , VAR_418 , VAR_419 ) = VAR_420 ; } break ; } } } METHOD_39 ( & VAR_421 ) ; METHOD_40 ( VAR_422 ) ; METHOD_41 ( VAR_423 ) ; return VAR_424 ; }",<S2SV_ModStart> + 1 ; if ( VAR_403 > 0 && VAR_392 > VAR_425 / VAR_403 ) return ( TYPE_17 ) METHOD_7 ( ) ; if ( VAR_392 * VAR_403 > VAR_425 / sizeof ( TYPE_20 ) ) return ( TYPE_17 ) METHOD_7 ( ) ; <S2SV_ModStart> ( ! VAR_422 ) return ( TYPE_17 ) METHOD_7 ( ) ; if ( VAR_392 > VAR_425 / ( 2 * sizeof ( TYPE_30 ) ),"CWE-119 Imaging ImagingResampleHorizontal ( Imaging imIn , int xsize , int filter ) { ImagingSectionCookie cookie ; Imaging imOut ; struct filter * filterp ; float support , scale , filterscale ; float center , ww , ss , ss0 , ss1 , ss2 , ss3 ; int xx , yy , x , kmax , xmin , xmax ; int * xbounds ; float * k , * kk ; switch ( filter ) { case IMAGING_TRANSFORM_LANCZOS : filterp = & LANCZOS ; break ; case IMAGING_TRANSFORM_BILINEAR : filterp = & BILINEAR ; break ; case IMAGING_TRANSFORM_BICUBIC : filterp = & BICUBIC ; break ; default : return ( Imaging ) ImagingError_ValueError ( ""unsupported<S2SV_blank>resampling<S2SV_blank>filter"" ) ; } filterscale = scale = ( float ) imIn -> xsize / xsize ; support = filterp -> support ; if ( filterscale < 1.0 ) { filterscale = 1.0 ; } support = support * filterscale ; kmax = ( int ) ceil ( support ) * 2 + 1 ; <S2SV_StartBug> kk = malloc ( xsize * kmax * sizeof ( float ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! kk ) <S2SV_EndBug> return ( Imaging ) ImagingError_MemoryError ( ) ; xbounds = malloc ( xsize * 2 * sizeof ( int ) ) ; if ( ! xbounds ) { free ( kk ) ; return ( Imaging ) ImagingError_MemoryError ( ) ; } for ( xx = 0 ; xx < xsize ; xx ++ ) { k = & kk [ xx * kmax ] ; center = ( xx + 0.5 ) * scale ; ww = 0.0 ; ss = 1.0 / filterscale ; xmin = ( int ) floor ( center - support ) ; if ( xmin < 0 ) xmin = 0 ; xmax = ( int ) ceil ( center + support ) ; if ( xmax > imIn -> xsize ) xmax = imIn -> xsize ; for ( x = xmin ; x < xmax ; x ++ ) { float w = filterp -> filter ( ( x - center + 0.5 ) * ss ) * ss ; k [ x - xmin ] = w ; ww += w ; } for ( x = 0 ; x < xmax - xmin ; x ++ ) { if ( ww != 0.0 ) k [ x ] /= ww ; } xbounds [ xx * 2 + 0 ] = xmin ; xbounds [ xx * 2 + 1 ] = xmax ; } imOut = ImagingNew ( imIn -> mode , xsize , imIn -> ysize ) ; if ( ! imOut ) { free ( kk ) ; free ( xbounds ) ; return NULL ; } ImagingSectionEnter ( & cookie ) ; for ( yy = 0 ; yy < imOut -> ysize ; yy ++ ) { if ( imIn -> image8 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( imIn -> image8 [ yy ] [ x ] ) * k [ x - xmin ] ; imOut -> image8 [ yy ] [ xx ] = clip8 ( ss ) ; } } else { switch ( imIn -> type ) { case IMAGING_TYPE_UINT8 : if ( imIn -> bands == 2 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss1 ) ; } } else if ( imIn -> bands == 3 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; } } else { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = ss3 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; ss3 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss3 ) ; } } break ; case IMAGING_TYPE_INT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( IMAGING_PIXEL_I ( imIn , x , yy ) ) * k [ x - xmin ] ; IMAGING_PIXEL_I ( imOut , xx , yy ) = ( int ) ss ; } break ; case IMAGING_TYPE_FLOAT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += IMAGING_PIXEL_F ( imIn , x , yy ) * k [ x - xmin ] ; IMAGING_PIXEL_F ( imOut , xx , yy ) = ss ; } break ; } } } ImagingSectionLeave ( & cookie ) ; free ( kk ) ; free ( xbounds ) ; return imOut ; }",<S2SV_ModStart> + 1 ; if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ; <S2SV_ModStart> ( ! kk ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) )
90,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , const TYPE_1 TYPE_2 * VAR_0 , unsigned TYPE_3 VAR_1 ) { TYPE_4 VAR_2 , VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 ; struct STRUCT_OR_UNION_3 VAR_5 ; if ( METHOD_1 ( & VAR_6 , VAR_7 , sizeof ( VAR_8 ) ) != 0 ) return - VAR_9 ; if ( VAR_10 != sizeof ( VAR_11 ) + VAR_12 . VAR_13 ) { METHOD_2 ( ""Wrong<S2SV_blank>len<S2SV_blank>argument\\n"" ) ; return - VAR_14 ; } if ( VAR_15 . VAR_16 == 0 ) { METHOD_3 ( ""Entries_size<S2SV_blank>never<S2SV_blank>zero\\n"" ) ; return - VAR_17 ; } if ( VAR_18 . VAR_19 >= ( ( VAR_20 - sizeof ( struct STRUCT_OR_UNION_4 ) ) / VAR_21 - VAR_22 ) / sizeof ( struct STRUCT_OR_UNION_5 ) ) return - VAR_23 ; if ( VAR_24 . VAR_25 >= VAR_26 / sizeof ( struct STRUCT_OR_UNION_6 ) ) return - VAR_27 ; <S2SV_StartBug> VAR_28 = METHOD_4 ( VAR_29 . VAR_30 ) * VAR_31 ; <S2SV_EndBug> VAR_32 = METHOD_5 ( sizeof ( * VAR_33 ) + VAR_34 ) ; if ( ! VAR_35 ) return - VAR_36 ; if ( VAR_37 ) METHOD_6 ( VAR_38 -> VAR_39 , 0 , VAR_40 ) ; VAR_41 -> VAR_42 = METHOD_7 ( VAR_43 . VAR_44 ) ; if ( ! VAR_45 -> VAR_46 ) { VAR_47 = - VAR_48 ; goto VAR_49 ; } if ( METHOD_8 ( VAR_50 -> VAR_51 , VAR_52 . VAR_53 , VAR_54 . VAR_55 ) != 0 ) { METHOD_9 ( ""Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n"" ) ; VAR_56 = - VAR_57 ; goto VAR_58 ; } VAR_59 = METHOD_10 ( STRUCT_OR_UNION_7 , & VAR_60 , VAR_61 ) ; if ( VAR_62 == 0 ) return VAR_63 ; VAR_64 : METHOD_11 ( VAR_65 -> VAR_66 ) ; VAR_67 : METHOD_12 ( VAR_68 ) ; return VAR_69 ; }",<S2SV_ModStart> - VAR_48 ; VAR_60 . VAR_70 [ sizeof ( VAR_60 . VAR_70 ) - 1 ] = 0 ;,"CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( ""Wrong<S2SV_blank>len<S2SV_blank>argument\\n"" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( ""Entries_size<S2SV_blank>never<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( ""Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n"" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }",<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
91,"CWE-189 struct STRUCT_OR_UNION_0 METHOD_0 ( const TYPE_0 VAR_0 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_1 VAR_1 ; <S2SV_EndBug> if ( ! VAR_2 ) return ( struct STRUCT_OR_UNION_2 ) { 0 , 0 } ; <S2SV_StartBug> VAR_3 . VAR_4 = METHOD_1 ( VAR_5 , VAR_6 , & VAR_7 . VAR_8 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( METHOD_2 ( VAR_9 < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> METHOD_3 ( & VAR_10 , VAR_11 . VAR_12 , VAR_13 . VAR_14 ) ; <S2SV_EndBug> return VAR_15 ; }","<S2SV_ModStart> struct STRUCT_OR_UNION_2 VAR_15 ; TYPE_1 VAR_16 <S2SV_ModStart> . VAR_12 = METHOD_4 <S2SV_ModEnd> ( VAR_9 , <S2SV_ModStart> VAR_6 , & VAR_16 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( METHOD_2 ( VAR_16 <S2SV_ModEnd> < 0 ) <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> VAR_15 . VAR_12 <S2SV_ModStart> VAR_15 . VAR_12 -- ; VAR_16 += VAR_6 ; } <S2SV_ModEnd> VAR_15 . VAR_14 <S2SV_ModStart> VAR_15 . VAR_14 = VAR_16 <S2SV_ModEnd> ; return VAR_15","CWE-189 struct timespec ns_to_timespec ( const s64 nsec ) { <S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ; <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> return ts ; }","<S2SV_ModStart> struct timespec ts ; s32 rem <S2SV_ModStart> . tv_sec = div_s64_rem <S2SV_ModEnd> ( nsec , <S2SV_ModStart> NSEC_PER_SEC , & rem <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( rem <S2SV_ModEnd> < 0 ) <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> ts . tv_sec <S2SV_ModStart> ts . tv_sec -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> ts . tv_nsec <S2SV_ModStart> ts . tv_nsec = rem <S2SV_ModEnd> ; return ts"
92,"CWE-770 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; if ( VAR_2 -> VAR_3 == - 1 ) VAR_4 -> VAR_5 -> VAR_6 = VAR_7 ; if ( ! METHOD_1 ( VAR_8 , ( TYPE_3 * ) & VAR_9 , 1 ) ) return VAR_10 ; switch ( VAR_11 . VAR_12 ) { case VAR_13 : { break ; } case VAR_14 : { TYPE_4 VAR_15 ; TYPE_5 VAR_16 ; TYPE_6 VAR_17 ; TYPE_7 VAR_18 ; if ( ! METHOD_2 ( VAR_19 , ( ( TYPE_8 * ) & VAR_20 . VAR_21 ) + 1 , VAR_22 - 1 ) ) return VAR_23 ; VAR_24 . VAR_25 . VAR_26 = METHOD_3 ( VAR_27 . VAR_28 . VAR_29 ) ; for ( VAR_30 = 0 ; VAR_31 < VAR_32 . VAR_33 . VAR_34 ; VAR_35 ++ ) { if ( ! METHOD_4 ( VAR_36 , ( TYPE_9 * ) & VAR_37 , VAR_38 ) ) return VAR_39 ; VAR_40 . VAR_41 = METHOD_5 ( VAR_42 . VAR_43 ) ; if ( VAR_44 . VAR_45 == VAR_46 ) break ; VAR_47 . VAR_48 . VAR_49 = METHOD_6 ( VAR_50 . VAR_51 . VAR_52 ) ; VAR_53 . VAR_54 . VAR_55 = METHOD_7 ( VAR_56 . VAR_57 . VAR_58 ) ; VAR_59 . VAR_60 . VAR_61 = METHOD_8 ( VAR_62 . VAR_63 . VAR_64 ) ; VAR_65 . VAR_66 . VAR_67 = METHOD_9 ( VAR_68 . VAR_69 . VAR_70 ) ; if ( VAR_71 . VAR_72 == VAR_73 || VAR_74 . VAR_75 == VAR_76 ) { if ( ! METHOD_10 ( VAR_77 , VAR_78 . VAR_79 . VAR_80 , VAR_81 . VAR_82 . VAR_83 , VAR_84 . VAR_85 . VAR_86 , VAR_87 . VAR_88 . VAR_89 , VAR_90 . VAR_91 ) ) { return VAR_92 ; } continue ; } if ( VAR_93 . VAR_94 == VAR_95 ) { if ( ! VAR_96 -> METHOD_11 ( VAR_97 , VAR_98 . VAR_99 . VAR_100 , VAR_101 . VAR_102 . VAR_103 ) ) { return VAR_104 ; } continue ; } if ( VAR_105 . VAR_106 == VAR_107 ) { VAR_108 -> VAR_109 = 1 ; if ( VAR_110 -> METHOD_12 != VAR_111 ) VAR_112 -> METHOD_13 ( VAR_113 , VAR_114 . VAR_115 . VAR_116 , 0 ) ; VAR_117 -> VAR_118 = VAR_119 . VAR_120 . VAR_121 ; continue ; } if ( VAR_122 . VAR_123 == VAR_124 ) { VAR_125 -> VAR_126 = VAR_127 . VAR_128 . VAR_129 ; VAR_130 -> VAR_131 = VAR_132 . VAR_133 . VAR_134 ; VAR_135 -> VAR_136 . VAR_137 = VAR_138 -> VAR_139 . VAR_140 = 0 ; VAR_141 -> VAR_142 . VAR_143 = VAR_144 -> VAR_145 ; VAR_146 -> VAR_147 . VAR_148 = VAR_149 -> VAR_150 ; if ( ! VAR_151 -> METHOD_14 ( VAR_152 ) ) return VAR_153 ; METHOD_15 ( VAR_154 , 0 , 0 , VAR_155 . VAR_156 . VAR_157 , VAR_158 . VAR_159 . VAR_160 , VAR_161 ) ; METHOD_16 ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , VAR_162 . VAR_163 . VAR_164 , VAR_165 . VAR_166 . VAR_167 ) ; continue ; } if ( VAR_168 . VAR_169 == VAR_170 ) { TYPE_10 VAR_171 ; if ( ! METHOD_17 ( VAR_172 , ( TYPE_11 * ) & VAR_173 -> VAR_174 , VAR_175 ) ) return VAR_176 ; METHOD_18 ( ""client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( VAR_177 = 0 ; VAR_178 < 32 ; VAR_179 += 8 ) METHOD_19 ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , VAR_180 , VAR_181 -> VAR_182 . VAR_183 [ VAR_184 ] , VAR_185 -> VAR_186 . VAR_187 [ VAR_188 + 1 ] , VAR_189 -> VAR_190 . VAR_191 [ VAR_192 + 2 ] , VAR_193 -> VAR_194 . VAR_195 [ VAR_196 + 3 ] , VAR_197 -> VAR_198 . VAR_199 [ VAR_200 + 4 ] , VAR_201 -> VAR_202 . VAR_203 [ VAR_204 + 5 ] , VAR_205 -> VAR_206 . VAR_207 [ VAR_208 + 6 ] , VAR_209 -> VAR_210 . VAR_211 [ VAR_212 + 7 ] ) ; METHOD_20 ( ""server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( VAR_213 = 0 ; VAR_214 < 32 ; VAR_215 += 8 ) METHOD_21 ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , VAR_216 , VAR_217 -> VAR_218 . VAR_219 [ VAR_220 ] , VAR_221 -> VAR_222 . VAR_223 [ VAR_224 + 1 ] , VAR_225 -> VAR_226 . VAR_227 [ VAR_228 + 2 ] , VAR_229 -> VAR_230 . VAR_231 [ VAR_232 + 3 ] , VAR_233 -> VAR_234 . VAR_235 [ VAR_236 + 4 ] , VAR_237 -> VAR_238 . VAR_239 [ VAR_240 + 5 ] , VAR_241 -> VAR_242 . VAR_243 [ VAR_244 + 6 ] , VAR_245 -> VAR_246 . VAR_247 [ VAR_248 + 7 ] ) ; continue ; } if ( VAR_249 . VAR_250 == VAR_251 ) { TYPE_12 * VAR_252 ; VAR_253 = METHOD_22 ( VAR_254 . VAR_255 . VAR_256 ) ; if ( ! METHOD_23 ( VAR_257 , VAR_258 , VAR_259 . VAR_260 . VAR_261 ) ) { METHOD_24 ( VAR_262 ) ; return VAR_263 ; } METHOD_25 ( VAR_264 ) ; continue ; } if ( VAR_265 . VAR_266 == VAR_267 ) { TYPE_13 * VAR_268 ; VAR_269 = METHOD_26 ( VAR_270 . VAR_271 . VAR_272 + 1 ) ; if ( ! METHOD_27 ( VAR_273 , VAR_274 , VAR_275 . VAR_276 . VAR_277 ) ) { METHOD_28 ( VAR_278 ) ; return VAR_279 ; } VAR_280 [ VAR_281 . VAR_282 . VAR_283 ] = 0 ; METHOD_29 ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\""%s\\""\\n"" , VAR_284 ) ; METHOD_30 ( VAR_285 ) ; continue ; } if ( VAR_286 . VAR_287 != VAR_288 ) { if ( ( VAR_289 . VAR_290 . VAR_291 + VAR_292 . VAR_293 . VAR_294 > VAR_295 -> VAR_296 ) || ( VAR_297 . VAR_298 . VAR_299 + VAR_300 . VAR_301 . VAR_302 > VAR_303 -> VAR_304 ) ) { METHOD_31 ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , VAR_305 . VAR_306 . VAR_307 , VAR_308 . VAR_309 . VAR_310 , VAR_311 . VAR_312 . VAR_313 , VAR_314 . VAR_315 . VAR_316 ) ; return VAR_317 ; } VAR_318 -> METHOD_32 ( VAR_319 , VAR_320 . VAR_321 . VAR_322 , VAR_323 . VAR_324 . VAR_325 , VAR_326 . VAR_327 . VAR_328 , VAR_329 . VAR_330 . VAR_331 ) ; } switch ( VAR_332 . VAR_333 ) { case VAR_334 : { TYPE_14 VAR_335 = VAR_336 . VAR_337 . VAR_338 , VAR_339 = VAR_340 . VAR_341 . VAR_342 ; VAR_343 = VAR_344 . VAR_345 . VAR_346 * VAR_347 -> VAR_348 . VAR_349 / 8 ; VAR_350 = VAR_351 ? ( VAR_352 / VAR_353 ) : 0 ; while ( VAR_354 && VAR_355 > 0 ) { if ( VAR_356 > VAR_357 ) VAR_358 = VAR_359 ; if ( ! METHOD_33 ( VAR_360 , VAR_361 -> VAR_362 , VAR_363 * VAR_364 ) ) return VAR_365 ; VAR_366 -> METHOD_34 ( VAR_367 , ( TYPE_15 * ) VAR_368 -> VAR_369 , VAR_370 . VAR_371 . VAR_372 , VAR_373 , VAR_374 . VAR_375 . VAR_376 , VAR_377 ) ; VAR_378 -= VAR_379 ; VAR_380 += VAR_381 ; } break ; } case VAR_382 : { TYPE_16 VAR_383 ; if ( ! METHOD_35 ( VAR_384 , ( TYPE_17 * ) & VAR_385 , VAR_386 ) ) return VAR_387 ; VAR_388 . VAR_389 = METHOD_36 ( VAR_390 . VAR_391 ) ; VAR_392 . VAR_393 = METHOD_37 ( VAR_394 . VAR_395 ) ; VAR_396 -> METHOD_38 ( VAR_397 , VAR_398 . VAR_399 , VAR_400 . VAR_401 , VAR_402 . VAR_403 . VAR_404 , VAR_405 . VAR_406 . VAR_407 ) ; VAR_408 -> METHOD_39 ( VAR_409 , VAR_410 . VAR_411 , VAR_412 . VAR_413 , VAR_414 . VAR_415 . VAR_416 , VAR_417 . VAR_418 . VAR_419 , VAR_420 . VAR_421 . VAR_422 , VAR_423 . VAR_424 . VAR_425 ) ; break ; } case VAR_426 : { switch ( VAR_427 -> VAR_428 . VAR_429 ) { case 8 : if ( ! METHOD_40 ( VAR_430 , VAR_431 . VAR_432 . VAR_433 , VAR_434 . VAR_435 . VAR_436 , VAR_437 . VAR_438 . VAR_439 , VAR_440 . VAR_441 . VAR_442 ) ) return VAR_443 ; break ; case 16 : if ( ! METHOD_41 ( VAR_444 , VAR_445 . VAR_446 . VAR_447 , VAR_448 . VAR_449 . VAR_450 , VAR_451 . VAR_452 . VAR_453 , VAR_454 . VAR_455 . VAR_456 ) ) return VAR_457 ; break ; case 32 : if ( ! METHOD_42 ( VAR_458 , VAR_459 . VAR_460 . VAR_461 , VAR_462 . VAR_463 . VAR_464 , VAR_465 . VAR_466 . VAR_467 , VAR_468 . VAR_469 . VAR_470 ) ) return VAR_471 ; break ; } break ; } case VAR_472 : { switch ( VAR_473 -> VAR_474 . VAR_475 ) { case 8 : if ( ! METHOD_43 ( VAR_476 , VAR_477 . VAR_478 . VAR_479 , VAR_480 . VAR_481 . VAR_482 , VAR_483 . VAR_484 . VAR_485 , VAR_486 . VAR_487 . VAR_488 ) ) return VAR_489 ; break ; case 16 : if ( ! METHOD_44 ( VAR_490 , VAR_491 . VAR_492 . VAR_493 , VAR_494 . VAR_495 . VAR_496 , VAR_497 . VAR_498 . VAR_499 , VAR_500 . VAR_501 . VAR_502 ) ) return VAR_503 ; break ; case 32 : if ( ! METHOD_45 ( VAR_504 , VAR_505 . VAR_506 . VAR_507 , VAR_508 . VAR_509 . VAR_510 , VAR_511 . VAR_512 . VAR_513 , VAR_514 . VAR_515 . VAR_516 ) ) return VAR_517 ; break ; } break ; } case VAR_518 : { switch ( VAR_519 -> VAR_520 . VAR_521 ) { case 8 : if ( ! METHOD_46 ( VAR_522 , VAR_523 . VAR_524 . VAR_525 , VAR_526 . VAR_527 . VAR_528 , VAR_529 . VAR_530 . VAR_531 , VAR_532 . VAR_533 . VAR_534 ) ) return VAR_535 ; break ; case 16 : if ( ! METHOD_47 ( VAR_536 , VAR_537 . VAR_538 . VAR_539 , VAR_540 . VAR_541 . VAR_542 , VAR_543 . VAR_544 . VAR_545 , VAR_546 . VAR_547 . VAR_548 ) ) return VAR_549 ; break ; case 32 : if ( ! METHOD_48 ( VAR_550 , VAR_551 . VAR_552 . VAR_553 , VAR_554 . VAR_555 . VAR_556 , VAR_557 . VAR_558 . VAR_559 , VAR_560 . VAR_561 . VAR_562 ) ) return VAR_563 ; break ; } break ; } case VAR_564 : { switch ( VAR_565 -> VAR_566 . VAR_567 ) { case 8 : if ( ! METHOD_49 ( VAR_568 , VAR_569 . VAR_570 . VAR_571 , VAR_572 . VAR_573 . VAR_574 , VAR_575 . VAR_576 . VAR_577 , VAR_578 . VAR_579 . VAR_580 ) ) return VAR_581 ; break ; case 16 : if ( ! METHOD_50 ( VAR_582 , VAR_583 . VAR_584 . VAR_585 , VAR_586 . VAR_587 . VAR_588 , VAR_589 . VAR_590 . VAR_591 , VAR_592 . VAR_593 . VAR_594 ) ) return VAR_595 ; break ; case 32 : if ( ! METHOD_51 ( VAR_596 , VAR_597 . VAR_598 . VAR_599 , VAR_600 . VAR_601 . VAR_602 , VAR_603 . VAR_604 . VAR_605 , VAR_606 . VAR_607 . VAR_608 ) ) return VAR_609 ; break ; } break ; } case VAR_610 : { switch ( VAR_611 -> VAR_612 . VAR_613 ) { case 8 : if ( ! METHOD_52 ( VAR_614 , VAR_615 . VAR_616 . VAR_617 , VAR_618 . VAR_619 . VAR_620 , VAR_621 . VAR_622 . VAR_623 , VAR_624 . VAR_625 . VAR_626 ) ) return VAR_627 ; break ; case 16 : if ( ! METHOD_53 ( VAR_628 , VAR_629 . VAR_630 . VAR_631 , VAR_632 . VAR_633 . VAR_634 , VAR_635 . VAR_636 . VAR_637 , VAR_638 . VAR_639 . VAR_640 ) ) return VAR_641 ; break ; case 32 : if ( ! METHOD_54 ( VAR_642 , VAR_643 . VAR_644 . VAR_645 , VAR_646 . VAR_647 . VAR_648 , VAR_649 . VAR_650 . VAR_651 , VAR_652 . VAR_653 . VAR_654 ) ) return VAR_655 ; break ; } break ; } case VAR_656 : { switch ( VAR_657 -> VAR_658 . VAR_659 ) { case 8 : if ( ! METHOD_55 ( VAR_660 , VAR_661 . VAR_662 . VAR_663 , VAR_664 . VAR_665 . VAR_666 , VAR_667 . VAR_668 . VAR_669 , VAR_670 . VAR_671 . VAR_672 ) ) return VAR_673 ; break ; case 16 : if ( VAR_674 -> VAR_675 . VAR_676 . VAR_677 > 0x1F ) { if ( ! METHOD_56 ( VAR_678 , VAR_679 . VAR_680 . VAR_681 , VAR_682 . VAR_683 . VAR_684 , VAR_685 . VAR_686 . VAR_687 , VAR_688 . VAR_689 . VAR_690 ) ) return VAR_691 ; } else { if ( ! METHOD_57 ( VAR_692 , VAR_693 . VAR_694 . VAR_695 , VAR_696 . VAR_697 . VAR_698 , VAR_699 . VAR_700 . VAR_701 , VAR_702 . VAR_703 . VAR_704 ) ) return VAR_705 ; } break ; case 32 : { TYPE_18 VAR_706 = ( VAR_707 -> VAR_708 . VAR_709 << VAR_710 -> VAR_711 . VAR_712 ) | ( VAR_713 -> VAR_714 . VAR_715 << VAR_716 -> VAR_717 . VAR_718 ) | ( VAR_719 -> VAR_720 . VAR_721 << VAR_722 -> VAR_723 . VAR_724 ) ; if ( ( VAR_725 -> VAR_726 . VAR_727 && ( VAR_728 & 0xff ) == 0 ) || ( ! VAR_729 -> VAR_730 . VAR_731 && ( VAR_732 & 0xff000000 ) == 0 ) ) { if ( ! METHOD_58 ( VAR_733 , VAR_734 . VAR_735 . VAR_736 , VAR_737 . VAR_738 . VAR_739 , VAR_740 . VAR_741 . VAR_742 , VAR_743 . VAR_744 . VAR_745 ) ) return VAR_746 ; } else if ( ! VAR_747 -> VAR_748 . VAR_749 && ( VAR_750 & 0xff ) == 0 ) { if ( ! METHOD_59 ( VAR_751 , VAR_752 . VAR_753 . VAR_754 , VAR_755 . VAR_756 . VAR_757 , VAR_758 . VAR_759 . VAR_760 , VAR_761 . VAR_762 . VAR_763 ) ) return VAR_764 ; } else if ( VAR_765 -> VAR_766 . VAR_767 && ( VAR_768 & 0xff000000 ) == 0 ) { if ( ! METHOD_60 ( VAR_769 , VAR_770 . VAR_771 . VAR_772 , VAR_773 . VAR_774 . VAR_775 , VAR_776 . VAR_777 . VAR_778 , VAR_779 . VAR_780 . VAR_781 ) ) return VAR_782 ; } else if ( ! METHOD_61 ( VAR_783 , VAR_784 . VAR_785 . VAR_786 , VAR_787 . VAR_788 . VAR_789 , VAR_790 . VAR_791 . VAR_792 , VAR_793 . VAR_794 . VAR_795 ) ) return VAR_796 ; break ; } } break ; } TYPE_19 TYPE_20 case VAR_797 : { switch ( VAR_798 -> VAR_799 . VAR_800 ) { case 8 : if ( ! METHOD_62 ( VAR_801 , VAR_802 . VAR_803 . VAR_804 , VAR_805 . VAR_806 . VAR_807 , VAR_808 . VAR_809 . VAR_810 , VAR_811 . VAR_812 . VAR_813 ) ) return VAR_814 ; break ; case 16 : if ( ! METHOD_63 ( VAR_815 , VAR_816 . VAR_817 . VAR_818 , VAR_819 . VAR_820 . VAR_821 , VAR_822 . VAR_823 . VAR_824 , VAR_825 . VAR_826 . VAR_827 ) ) return VAR_828 ; break ; case 32 : if ( ! METHOD_64 ( VAR_829 , VAR_830 . VAR_831 . VAR_832 , VAR_833 . VAR_834 . VAR_835 , VAR_836 . VAR_837 . VAR_838 , VAR_839 . VAR_840 . VAR_841 ) ) return VAR_842 ; break ; } break ; } TYPE_21 TYPE_22 case VAR_843 : { switch ( VAR_844 -> VAR_845 . VAR_846 ) { case 8 : if ( ! METHOD_65 ( VAR_847 , VAR_848 . VAR_849 . VAR_850 , VAR_851 . VAR_852 . VAR_853 , VAR_854 . VAR_855 . VAR_856 , VAR_857 . VAR_858 . VAR_859 ) ) return VAR_860 ; break ; case 16 : if ( ! METHOD_66 ( VAR_861 , VAR_862 . VAR_863 . VAR_864 , VAR_865 . VAR_866 . VAR_867 , VAR_868 . VAR_869 . VAR_870 , VAR_871 . VAR_872 . VAR_873 ) ) return VAR_874 ; break ; case 32 : if ( ! METHOD_67 ( VAR_875 , VAR_876 . VAR_877 . VAR_878 , VAR_879 . VAR_880 . VAR_881 , VAR_882 . VAR_883 . VAR_884 , VAR_885 . VAR_886 . VAR_887 ) ) return VAR_888 ; break ; } break ; } case VAR_889 : VAR_890 -> VAR_891 . VAR_892 = 9 ; case VAR_893 : { switch ( VAR_894 -> VAR_895 . VAR_896 ) { case 8 : if ( ! METHOD_68 ( VAR_897 , VAR_898 . VAR_899 . VAR_900 , VAR_901 . VAR_902 . VAR_903 , VAR_904 . VAR_905 . VAR_906 , VAR_907 . VAR_908 . VAR_909 ) ) return VAR_910 ; break ; case 16 : if ( VAR_911 -> VAR_912 . VAR_913 . VAR_914 > 0x1F ) { if ( ! METHOD_69 ( VAR_915 , VAR_916 . VAR_917 . VAR_918 , VAR_919 . VAR_920 . VAR_921 , VAR_922 . VAR_923 . VAR_924 , VAR_925 . VAR_926 . VAR_927 ) ) return VAR_928 ; } else { if ( ! METHOD_70 ( VAR_929 , VAR_930 . VAR_931 . VAR_932 , VAR_933 . VAR_934 . VAR_935 , VAR_936 . VAR_937 . VAR_938 , VAR_939 . VAR_940 . VAR_941 ) ) return VAR_942 ; } break ; case 32 : { TYPE_23 VAR_943 = ( VAR_944 -> VAR_945 . VAR_946 << VAR_947 -> VAR_948 . VAR_949 ) | ( VAR_950 -> VAR_951 . VAR_952 << VAR_953 -> VAR_954 . VAR_955 ) | ( VAR_956 -> VAR_957 . VAR_958 << VAR_959 -> VAR_960 . VAR_961 ) ; if ( ( VAR_962 -> VAR_963 . VAR_964 && ( VAR_965 & 0xff ) == 0 ) || ( ! VAR_966 -> VAR_967 . VAR_968 && ( VAR_969 & 0xff000000 ) == 0 ) ) { if ( ! METHOD_71 ( VAR_970 , VAR_971 . VAR_972 . VAR_973 , VAR_974 . VAR_975 . VAR_976 , VAR_977 . VAR_978 . VAR_979 , VAR_980 . VAR_981 . VAR_982 ) ) return VAR_983 ; } else if ( ! VAR_984 -> VAR_985 . VAR_986 && ( VAR_987 & 0xff ) == 0 ) { if ( ! METHOD_72 ( VAR_988 , VAR_989 . VAR_990 . VAR_991 , VAR_992 . VAR_993 . VAR_994 , VAR_995 . VAR_996 . VAR_997 , VAR_998 . VAR_999 . VAR_1000 ) ) return VAR_1001 ; } else if ( VAR_1002 -> VAR_1003 . VAR_1004 && ( VAR_1005 & 0xff000000 ) == 0 ) { if ( ! METHOD_73 ( VAR_1006 , VAR_1007 . VAR_1008 . VAR_1009 , VAR_1010 . VAR_1011 . VAR_1012 , VAR_1013 . VAR_1014 . VAR_1015 , VAR_1016 . VAR_1017 . VAR_1018 ) ) return VAR_1019 ; } else if ( ! METHOD_74 ( VAR_1020 , VAR_1021 . VAR_1022 . VAR_1023 , VAR_1024 . VAR_1025 . VAR_1026 , VAR_1027 . VAR_1028 . VAR_1029 , VAR_1030 . VAR_1031 . VAR_1032 ) ) return VAR_1033 ; break ; } } break ; } default : { TYPE_24 VAR_1034 = VAR_1035 ; VAR_1036 * VAR_1037 ; for ( VAR_1038 = VAR_1039 ; ! VAR_1040 && VAR_1041 ; VAR_1042 = VAR_1043 -> VAR_1044 ) if ( VAR_1045 -> METHOD_75 && VAR_1046 -> METHOD_76 ( VAR_1047 , & VAR_1048 ) ) VAR_1049 = VAR_1050 ; if ( ! VAR_1051 ) { METHOD_77 ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n"" , ( TYPE_25 ) VAR_1052 . VAR_1053 ) ; return VAR_1054 ; } } } VAR_1055 -> METHOD_78 ( VAR_1056 ) ; VAR_1057 -> METHOD_79 ( VAR_1058 , VAR_1059 . VAR_1060 . VAR_1061 , VAR_1062 . VAR_1063 . VAR_1064 , VAR_1065 . VAR_1066 . VAR_1067 , VAR_1068 . VAR_1069 . VAR_1070 ) ; } if ( ! METHOD_80 ( VAR_1071 ) ) return VAR_1072 ; if ( VAR_1073 -> METHOD_81 ) VAR_1074 -> METHOD_82 ( VAR_1075 ) ; break ; } case VAR_1076 : { VAR_1077 -> METHOD_83 ( VAR_1078 ) ; break ; } case VAR_1079 : { TYPE_26 * VAR_1080 ; if ( ! METHOD_84 ( VAR_1081 , ( ( TYPE_27 * ) & VAR_1082 ) + 1 , VAR_1083 - 1 ) ) return VAR_1084 ; VAR_1085 . VAR_1086 . VAR_1087 = METHOD_85 ( VAR_1088 . VAR_1089 . VAR_1090 ) ; if ( VAR_1091 . VAR_1092 . VAR_1093 > 1 << 20 ) { METHOD_86 ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned TYPE_28 ) VAR_1094 . VAR_1095 . VAR_1096 ) ; return VAR_1097 ; } VAR_1098 = METHOD_87 ( VAR_1099 . VAR_1100 . VAR_1101 + 1 ) ; if ( ! METHOD_88 ( VAR_1102 , VAR_1103 , VAR_1104 . VAR_1105 . VAR_1106 ) ) { METHOD_89 ( VAR_1107 ) ; return VAR_1108 ; } VAR_1109 [ VAR_1110 . VAR_1111 . VAR_1112 ] = 0 ; if ( VAR_1113 -> METHOD_90 ) VAR_1114 -> METHOD_91 ( VAR_1115 , VAR_1116 , VAR_1117 . VAR_1118 . VAR_1119 ) ; METHOD_92 ( VAR_1120 ) ; break ; } case VAR_1121 : { TYPE_29 * VAR_1122 = VAR_1123 ; if ( ! METHOD_93 ( VAR_1124 , ( ( TYPE_30 * ) & VAR_1125 ) + 1 , VAR_1126 - 1 ) ) return VAR_1127 ; VAR_1128 . VAR_1129 . VAR_1130 = METHOD_94 ( VAR_1131 . VAR_1132 . VAR_1133 ) ; switch ( VAR_1134 . VAR_1135 . VAR_1136 ) { case VAR_1137 : METHOD_95 ( ""Received<S2SV_blank>TextChat<S2SV_blank>Open\\n"" ) ; if ( VAR_1138 -> METHOD_96 != VAR_1139 ) VAR_1140 -> METHOD_97 ( VAR_1141 , ( TYPE_31 ) VAR_1142 , VAR_1143 ) ; break ; case VAR_1144 : METHOD_98 ( ""Received<S2SV_blank>TextChat<S2SV_blank>Close\\n"" ) ; if ( VAR_1145 -> METHOD_99 != VAR_1146 ) VAR_1147 -> METHOD_100 ( VAR_1148 , ( TYPE_32 ) VAR_1149 , VAR_1150 ) ; break ; case VAR_1151 : METHOD_101 ( ""Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n"" ) ; if ( VAR_1152 -> METHOD_102 != VAR_1153 ) VAR_1154 -> METHOD_103 ( VAR_1155 , ( TYPE_33 ) VAR_1156 , VAR_1157 ) ; break ; default : <S2SV_StartBug> VAR_1158 = METHOD_104 ( VAR_1159 . VAR_1160 . VAR_1161 + 1 ) ; <S2SV_EndBug> if ( ! METHOD_105 ( VAR_1162 , VAR_1163 , VAR_1164 . VAR_1165 . VAR_1166 ) ) { METHOD_106 ( VAR_1167 ) ; return VAR_1168 ; } VAR_1169 [ VAR_1170 . VAR_1171 . VAR_1172 ] = 0 ; METHOD_107 ( ""Received<S2SV_blank>TextChat<S2SV_blank>\\""%s\\""\\n"" , VAR_1173 ) ; if ( VAR_1174 -> METHOD_108 != VAR_1175 ) VAR_1176 -> METHOD_109 ( VAR_1177 , ( TYPE_34 ) VAR_1178 . VAR_1179 . VAR_1180 , VAR_1181 ) ; METHOD_110 ( VAR_1182 ) ; break ; } break ; } case VAR_1183 : { if ( ! METHOD_111 ( VAR_1184 , ( ( TYPE_35 * ) & VAR_1185 ) + 1 , VAR_1186 - 1 ) ) return VAR_1187 ; METHOD_112 ( VAR_1188 , VAR_1189 ) ; METHOD_113 ( VAR_1190 , VAR_1191 ) ; if ( VAR_1192 -> METHOD_114 ) VAR_1193 -> METHOD_115 ( VAR_1194 , VAR_1195 . VAR_1196 . VAR_1197 , VAR_1198 . VAR_1199 . VAR_1200 ) ; break ; } case VAR_1201 : { if ( ! METHOD_116 ( VAR_1202 , ( ( TYPE_36 * ) & VAR_1203 ) + 1 , VAR_1204 - 1 ) ) return VAR_1205 ; VAR_1206 -> VAR_1207 = METHOD_117 ( VAR_1208 . VAR_1209 . VAR_1210 ) ; VAR_1211 -> VAR_1212 = METHOD_118 ( VAR_1213 . VAR_1214 . VAR_1215 ) ; VAR_1216 -> VAR_1217 . VAR_1218 = VAR_1219 -> VAR_1220 . VAR_1221 = 0 ; VAR_1222 -> VAR_1223 . VAR_1224 = VAR_1225 -> VAR_1226 ; VAR_1227 -> VAR_1228 . VAR_1229 = VAR_1230 -> VAR_1231 ; if ( ! VAR_1232 -> METHOD_119 ( VAR_1233 ) ) return VAR_1234 ; METHOD_120 ( VAR_1235 , 0 , 0 , VAR_1236 -> VAR_1237 , VAR_1238 -> VAR_1239 , VAR_1240 ) ; METHOD_121 ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , VAR_1241 -> VAR_1242 , VAR_1243 -> VAR_1244 ) ; break ; } case VAR_1245 : { if ( ! METHOD_122 ( VAR_1246 , ( ( TYPE_37 * ) & VAR_1247 ) + 1 , VAR_1248 - 1 ) ) return VAR_1249 ; VAR_1250 -> VAR_1251 = METHOD_123 ( VAR_1252 . VAR_1253 . VAR_1254 ) ; VAR_1255 -> VAR_1256 = METHOD_124 ( VAR_1257 . VAR_1258 . VAR_1259 ) ; VAR_1260 -> VAR_1261 . VAR_1262 = VAR_1263 -> VAR_1264 . VAR_1265 = 0 ; VAR_1266 -> VAR_1267 . VAR_1268 = VAR_1269 -> VAR_1270 ; VAR_1271 -> VAR_1272 . VAR_1273 = VAR_1274 -> VAR_1275 ; if ( ! VAR_1276 -> METHOD_125 ( VAR_1277 ) ) return VAR_1278 ; METHOD_126 ( VAR_1279 , 0 , 0 , VAR_1280 -> VAR_1281 , VAR_1282 -> VAR_1283 , VAR_1284 ) ; METHOD_127 ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , VAR_1285 -> VAR_1286 , VAR_1287 -> VAR_1288 ) ; break ; } default : { TYPE_38 VAR_1289 = VAR_1290 ; VAR_1291 * VAR_1292 ; for ( VAR_1293 = VAR_1294 ; ! VAR_1295 && VAR_1296 ; VAR_1297 = VAR_1298 -> VAR_1299 ) if ( VAR_1300 -> METHOD_128 && VAR_1301 -> METHOD_129 ( VAR_1302 , & VAR_1303 ) ) VAR_1304 = VAR_1305 ; if ( ! VAR_1306 ) { TYPE_39 VAR_1307 [ 256 ] ; METHOD_130 ( ""Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n"" , VAR_1308 . VAR_1309 ) ; METHOD_131 ( VAR_1310 , VAR_1311 , 256 ) ; return VAR_1312 ; } } } return VAR_1313 ; }",<S2SV_ModStart> ; default : if ( VAR_1308 . VAR_1179 . VAR_1180 > VAR_1315 ) return VAR_1312 ;,"CWE-770 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( ""client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( ""server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; }  ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; }  ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; }   case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; }   default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n"" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } buffer = malloc ( msg . sct . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Open\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Close\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : <S2SV_StartBug> buffer = malloc ( msg . tc . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( ""Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n"" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }",<S2SV_ModStart> ; default : if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ;
93,"CWE-611 TYPE_0 METHOD_0 ( ) { TYPE_1 VAR_0 = METHOD_1 ( ""Nokogiri"" ) ; TYPE_2 VAR_1 = METHOD_2 ( VAR_2 , ""XML"" ) ; TYPE_3 VAR_3 = METHOD_3 ( VAR_4 , ""RelaxNG"" , VAR_5 ) ; VAR_6 = VAR_7 ; <S2SV_StartBug> METHOD_4 ( VAR_8 , ""read_memory"" , VAR_9 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_5 ( VAR_10 , ""from_document"" , VAR_11 , 1 ) ; <S2SV_EndBug> METHOD_6 ( VAR_12 , ""validate_document"" , VAR_13 , 1 ) ; }","<S2SV_ModStart> , VAR_9 , - <S2SV_ModStart> , VAR_11 , -","CWE-611 void init_xml_relax_ng ( ) { VALUE nokogiri = rb_define_module ( ""Nokogiri"" ) ; VALUE xml = rb_define_module_under ( nokogiri , ""XML"" ) ; VALUE klass = rb_define_class_under ( xml , ""RelaxNG"" , cNokogiriXmlSchema ) ; cNokogiriXmlRelaxNG = klass ; <S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ; }","<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -"
94,"CWE-787 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) <S2SV_EndBug> { TYPE_2 VAR_1 ; TYPE_3 VAR_2 ; <S2SV_StartBug> TYPE_4 * VAR_3 ; <S2SV_EndBug> TYPE_5 * VAR_4 ; TYPE_6 * VAR_5 ; TYPE_7 * VAR_6 ; TYPE_8 * VAR_7 ; TYPE_9 * VAR_8 ; TYPE_10 VAR_9 ; <S2SV_StartBug> TYPE_11 VAR_10 ; <S2SV_EndBug> VAR_11 = METHOD_1 ( VAR_12 -> VAR_13 , 8 ) ; VAR_14 = METHOD_2 ( VAR_15 -> VAR_16 , 2 ) ; <S2SV_StartBug> for ( VAR_17 = 0 ; VAR_18 < VAR_19 >> 1 ; VAR_20 ++ ) <S2SV_EndBug> { <S2SV_StartBug> VAR_21 = VAR_22 -> VAR_23 -> VAR_24 [ 1 ] + VAR_25 * ( VAR_26 >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_27 = VAR_28 -> VAR_29 -> VAR_30 [ 2 ] + VAR_31 * ( VAR_32 >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_33 = ( TYPE_12 * ) VAR_34 -> VAR_35 -> VAR_36 [ 1 ] + ( VAR_37 << 1 ) * VAR_38 ; <S2SV_EndBug> <S2SV_StartBug> VAR_39 = VAR_40 + VAR_41 ; <S2SV_EndBug> <S2SV_StartBug> VAR_42 = ( TYPE_13 * ) VAR_43 -> VAR_44 -> VAR_45 [ 2 ] + ( VAR_46 << 1 ) * VAR_47 ; <S2SV_EndBug> <S2SV_StartBug> VAR_48 = VAR_49 + VAR_50 ; <S2SV_EndBug> for ( VAR_51 = 0 ; VAR_52 < VAR_53 >> 1 ; VAR_54 ++ ) { * VAR_55 ++ = ( TYPE_14 ) ( ( ( TYPE_15 ) * VAR_56 + ( TYPE_16 ) * ( VAR_57 + 1 ) + ( TYPE_17 ) * VAR_58 + ( TYPE_18 ) * ( VAR_59 + 1 ) ) >> 2 ) ; * VAR_60 ++ = ( TYPE_19 ) ( ( ( TYPE_20 ) * VAR_61 + ( TYPE_21 ) * ( VAR_62 + 1 ) + ( TYPE_22 ) * VAR_63 + ( TYPE_23 ) * ( VAR_64 + 1 ) ) >> 2 ) ; VAR_65 += 2 ; VAR_66 += 2 ; VAR_67 += 2 ; VAR_68 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static TYPE_24 <S2SV_ModEnd> METHOD_0 ( TYPE_1 <S2SV_ModStart> TYPE_3 VAR_46 ; <S2SV_ModEnd> TYPE_11 VAR_53 ; <S2SV_ModStart> ; TYPE_11 VAR_19 ; if ( ! VAR_43 ) return VAR_69 <S2SV_ModStart> 2 ) ; if ( VAR_19 == 0 ) return VAR_69 ; if ( VAR_53 > VAR_43 -> VAR_44 -> VAR_70 / VAR_19 ) return VAR_69 ; <S2SV_ModStart> ++ ) { TYPE_19 * <S2SV_ModStart> 1 ) ; TYPE_19 * <S2SV_ModStart> 1 ) ; const TYPE_13 * <S2SV_ModStart> * VAR_53 ; const TYPE_13 * <S2SV_ModStart> + VAR_53 ; const TYPE_13 * <S2SV_ModStart> * VAR_53 ; const TYPE_13 * <S2SV_ModStart> ; } } return VAR_71 ;,"CWE-787 <S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ; <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ; <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> { <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT <S2SV_ModStart> UINT16 y ; <S2SV_ModEnd> UINT32 tempWidth ; <S2SV_ModStart> ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ++ ) { BYTE * <S2SV_ModStart> 1 ) ; BYTE * <S2SV_ModStart> 1 ) ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> + tempWidth ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> ; } } return TRUE ;
95,"CWE-125 static VAR_0 TYPE_0 * METHOD_0 ( unsigned TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 , TYPE_3 VAR_3 , const TYPE_4 VAR_4 ) { TYPE_5 VAR_5 ; TYPE_6 VAR_6 = 1.0 ; const TYPE_7 VAR_7 = VAR_8 ; TYPE_8 VAR_9 ; unsigned TYPE_9 VAR_10 ; TYPE_10 * VAR_11 ; if ( VAR_12 < 1.0 ) { VAR_13 = VAR_14 / VAR_15 ; VAR_16 = VAR_17 ; } else { VAR_18 = VAR_19 ; } VAR_20 = 2 * ( TYPE_11 ) METHOD_1 ( VAR_21 ) + 1 ; VAR_22 = METHOD_2 ( VAR_23 , VAR_24 ) ; for ( VAR_25 = 0 ; VAR_26 < VAR_27 ; VAR_28 ++ ) { const TYPE_12 VAR_29 = ( TYPE_13 ) VAR_30 / VAR_31 ; register TYPE_14 VAR_32 = METHOD_3 ( 0 , ( TYPE_15 ) METHOD_4 ( VAR_33 - VAR_34 ) ) ; TYPE_16 VAR_35 = METHOD_5 ( ( TYPE_17 ) METHOD_6 ( VAR_36 + VAR_37 ) , ( TYPE_18 ) VAR_38 - 1 ) ; TYPE_19 VAR_39 = 0.0 ; <S2SV_StartBug> TYPE_20 VAR_40 ; <S2SV_EndBug> VAR_41 -> VAR_42 [ VAR_43 ] . VAR_44 = VAR_45 ; VAR_46 -> VAR_47 [ VAR_48 ] . VAR_49 = VAR_50 ; if ( VAR_51 - VAR_52 + 1 > VAR_53 ) { if ( VAR_54 < ( ( TYPE_21 ) VAR_55 - 1 / 2 ) ) { VAR_56 ++ ; } else { VAR_57 -- ; } } <S2SV_StartBug> for ( VAR_58 = VAR_59 ; VAR_60 <= VAR_61 ; VAR_62 ++ ) { <S2SV_EndBug> <S2SV_StartBug> VAR_63 += ( VAR_64 -> VAR_65 [ VAR_66 ] . VAR_67 [ VAR_68 - VAR_69 ] = VAR_70 * ( * VAR_71 ) ( VAR_72 * ( VAR_73 - ( TYPE_22 ) VAR_74 ) ) ) ; <S2SV_EndBug> } if ( VAR_75 < 0.0 ) { METHOD_7 ( VAR_76 ) ; return VAR_77 ; } if ( VAR_78 > 0.0 ) { for ( VAR_79 = VAR_80 ; VAR_81 <= VAR_82 ; VAR_83 ++ ) { VAR_84 -> VAR_85 [ VAR_86 ] . VAR_87 [ VAR_88 - VAR_89 ] /= VAR_90 ; } } } return VAR_91 ; }",<S2SV_ModStart> ; TYPE_21 VAR_88 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> VAR_91 -> VAR_85 <S2SV_ModStart> VAR_86 ] . VAR_44 = VAR_89 ; VAR_91 -> VAR_85 [ VAR_86 ] . VAR_49 = VAR_82 ; for ( VAR_88 = VAR_89 ; VAR_88 <= VAR_82 ; VAR_88 ++ ) { VAR_90 += ( VAR_91 -> VAR_85 [ VAR_86 ] .,"CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }",<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
96,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 -> VAR_4 . VAR_5 ; struct STRUCT_OR_UNION_2 * VAR_6 ; if ( ! METHOD_1 ( VAR_7 ) || ! VAR_8 ) return ; VAR_9 = & VAR_10 -> VAR_11 . VAR_12 ; <S2SV_StartBug> if ( METHOD_2 ( VAR_13 ) ) <S2SV_EndBug> METHOD_3 ( VAR_14 , VAR_15 ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> . VAR_14 ; METHOD_4 ( & VAR_10 -> VAR_11 . VAR_16 ) ; <S2SV_ModStart> VAR_15 ) ; METHOD_5 ( & VAR_10 -> VAR_11 . VAR_16 ) ;,"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
97,"CWE-352 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_StartBug> TYPE_2 * VAR_1 = VAR_2 ; <S2SV_EndBug> METHOD_1 ( VAR_3 ) ; if ( ! METHOD_2 ( VAR_4 ) ) { <S2SV_StartBug> TYPE_3 VAR_5 ; <S2SV_EndBug> TYPE_4 VAR_6 [ VAR_7 ] ; TYPE_5 VAR_8 ; VAR_9 = METHOD_3 ( VAR_10 , ""w"" ) ; if ( ! VAR_11 ) { METHOD_4 ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , VAR_12 , VAR_13 ) ; return VAR_14 ; } <S2SV_StartBug> METHOD_5 ( VAR_15 , VAR_16 , ""%lu%d%lu"" , ( unsigned TYPE_6 ) METHOD_6 ( ) , METHOD_7 ( ) , METHOD_8 ( ) ) ; <S2SV_EndBug> METHOD_9 ( & VAR_17 ) ; METHOD_10 ( & VAR_18 , ( const TYPE_7 * ) VAR_19 , VAR_20 - 1 ) ; METHOD_11 ( & VAR_21 , ( TYPE_8 * ) VAR_22 ) ; METHOD_12 ( ( unsigned TYPE_9 * ) VAR_23 , 16 , VAR_24 . VAR_25 ) ; <S2SV_StartBug> METHOD_13 ( VAR_26 , ""%s"" , VAR_27 . VAR_28 ) ; <S2SV_EndBug> METHOD_14 ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\n<S2SV_blank>Stored<S2SV_blank>in<S2SV_blank>\'%s\'\\n"" , VAR_29 . VAR_30 , VAR_31 ) ; } else { if ( ! METHOD_15 ( VAR_32 ) ) { METHOD_16 ( ""idfile<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\n"" , VAR_33 ) ; return VAR_34 ; } if ( ( VAR_35 = METHOD_17 ( VAR_36 , ""r"" ) ) == ( TYPE_10 * ) VAR_37 ) { METHOD_18 ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , VAR_38 , VAR_39 ) ; return VAR_40 ; } if ( METHOD_19 ( VAR_41 , ""%64s"" , VAR_42 . VAR_43 ) != 1 ) { METHOD_20 ( ""Error<S2SV_blank>reading<S2SV_blank>id<S2SV_blank>from<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , VAR_44 ) ; if ( METHOD_21 ( VAR_45 ) ) METHOD_22 ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , VAR_46 , VAR_47 ) ; return VAR_48 ; } } if ( METHOD_23 ( VAR_49 ) ) METHOD_24 ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , VAR_50 , VAR_51 ) ; return VAR_52 . VAR_53 ; }","<S2SV_ModStart> VAR_50 ) { METHOD_1 ( VAR_50 ) ; <S2SV_ModStart> VAR_49 = VAR_48 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> VAR_49 = METHOD_17 <S2SV_ModStart> VAR_48 ; } <S2SV_ModEnd> METHOD_13 ( VAR_49 <S2SV_ModStart> , ""%s"" , Util_getToken ( VAR_52 . VAR_53 ) <S2SV_ModEnd> ) ; METHOD_14","CWE-352 char * Util_monitId ( char * idfile ) { <S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> ASSERT ( idfile ) ; if ( ! File_exist ( idfile ) ) { <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> char buf [ STRLEN ] ; MD_T digest ; file = fopen ( idfile , ""w"" ) ; if ( ! file ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> md5_init ( & ctx ) ; md5_append ( & ctx , ( const md5_byte_t * ) buf , STRLEN - 1 ) ; md5_finish ( & ctx , ( md5_byte_t * ) digest ) ; Util_digest2Bytes ( ( unsigned char * ) digest , 16 , Run . id ) ; <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug> LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\n<S2SV_blank>Stored<S2SV_blank>in<S2SV_blank>\'%s\'\\n"" , Run . id , idfile ) ; } else { if ( ! File_isFile ( idfile ) ) { LogError ( ""idfile<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\n"" , idfile ) ; return NULL ; } if ( ( file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } if ( fscanf ( file , ""%64s"" , Run . id ) != 1 ) { LogError ( ""Error<S2SV_blank>reading<S2SV_blank>id<S2SV_blank>from<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , idfile ) ; if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } } if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return Run . id ; }","<S2SV_ModStart> idfile ) { ASSERT ( idfile ) ; <S2SV_ModStart> file = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> file = fopen <S2SV_ModStart> NULL ; } <S2SV_ModEnd> fprintf ( file <S2SV_ModStart> , ""%s"" , Util_getToken ( Run . id ) <S2SV_ModEnd> ) ; LogInfo"
98,"CWE-125 TYPE_0 METHOD_0 ( const unsigned TYPE_1 * VAR_0 , TYPE_2 VAR_1 , struct STRUCT_OR_UNION_0 * * VAR_2 ) { unsigned TYPE_3 VAR_3 , VAR_4 ; TYPE_4 VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 ; TYPE_5 TYPE_6 VAR_11 ; TYPE_7 VAR_12 ; const unsigned TYPE_8 * VAR_13 ; TYPE_9 * VAR_14 , * VAR_15 , * VAR_16 , * * VAR_17 ; struct STRUCT_OR_UNION_1 * VAR_18 ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 ; * VAR_19 = VAR_20 ; if ( VAR_21 < VAR_22 ) return VAR_23 ; VAR_24 = METHOD_1 ( VAR_25 ) ; VAR_26 = METHOD_2 ( VAR_27 ) ; if ( VAR_28 != 1 ) return VAR_29 ; VAR_30 = VAR_31 + VAR_32 ; VAR_33 = METHOD_3 ( VAR_34 , VAR_35 , VAR_36 , & VAR_37 , & VAR_38 ) ; if ( VAR_39 != VAR_40 ) return VAR_41 ; if ( VAR_42 + VAR_43 + VAR_44 > VAR_45 + VAR_46 ) { METHOD_4 ( VAR_47 ) ; return VAR_48 ; } VAR_49 += VAR_50 + VAR_51 ; VAR_52 = METHOD_5 ( VAR_53 * sizeof ( struct STRUCT_OR_UNION_4 ) ) ; if ( ! VAR_54 ) { METHOD_6 ( VAR_55 ) ; return VAR_56 ; } VAR_57 = METHOD_7 ( ( VAR_58 + 1 ) * sizeof ( TYPE_10 * ) ) ; if ( ! VAR_59 ) { METHOD_8 ( VAR_60 ) ; METHOD_9 ( VAR_61 ) ; return VAR_62 ; } VAR_63 = 0 ; VAR_64 = 0 ; for ( VAR_65 = 0 ; VAR_66 < ( TYPE_11 ) VAR_67 ; VAR_68 ++ ) { VAR_69 = METHOD_10 ( VAR_70 , VAR_71 , VAR_72 , & VAR_73 , & VAR_74 ) ; if ( VAR_75 != VAR_76 ) break ; VAR_77 += VAR_78 ; if ( VAR_79 + VAR_80 > VAR_81 + VAR_82 ) { METHOD_11 ( VAR_83 ) ; VAR_84 = VAR_85 ; break ; } VAR_86 = METHOD_12 ( VAR_87 ) ; VAR_88 = METHOD_13 ( VAR_89 ) ; VAR_90 = METHOD_14 ( VAR_91 ) ; <S2SV_StartBug> VAR_92 += VAR_93 ; <S2SV_EndBug> if ( VAR_94 == VAR_95 && VAR_96 == VAR_97 && VAR_98 == sizeof ( struct STRUCT_OR_UNION_5 ) && METHOD_15 ( VAR_99 , VAR_100 ) == 0 ) { METHOD_16 ( & VAR_101 [ VAR_102 ] , VAR_103 , sizeof ( struct STRUCT_OR_UNION_6 ) ) ; VAR_104 ++ ; VAR_105 = VAR_106 ; } if ( VAR_107 == VAR_108 && VAR_109 == VAR_110 ) { VAR_111 [ VAR_112 ] = VAR_113 ; VAR_114 ++ ; VAR_115 = METHOD_17 ( VAR_116 , VAR_117 , VAR_118 , & VAR_119 , & VAR_120 ) ; if ( VAR_121 != VAR_122 ) break ; METHOD_18 ( VAR_123 ) ; VAR_124 = VAR_125 ; } else METHOD_19 ( VAR_126 ) ; VAR_127 += VAR_128 ; if ( VAR_129 > VAR_130 + VAR_131 ) { VAR_132 = VAR_133 ; break ; } } if ( VAR_134 == VAR_135 && VAR_136 == 0 ) VAR_137 = VAR_138 ; if ( VAR_139 == VAR_140 ) { VAR_141 [ VAR_142 ] = VAR_143 ; STRUCT_OR_UNION_7 = METHOD_20 ( sizeof ( struct STRUCT_OR_UNION_8 ) ) ; if ( STRUCT_OR_UNION_9 ) { STRUCT_OR_UNION_10 -> VAR_144 = METHOD_21 ( ( VAR_145 + 1 ) * sizeof ( TYPE_12 * ) ) ; if ( STRUCT_OR_UNION_11 -> VAR_146 ) { STRUCT_OR_UNION_12 -> VAR_147 = VAR_148 ; STRUCT_OR_UNION_13 -> VAR_149 = VAR_150 ; STRUCT_OR_UNION_14 -> VAR_151 = VAR_152 ; STRUCT_OR_UNION_15 -> VAR_153 = sizeof ( struct STRUCT_OR_UNION_16 ) ; for ( VAR_154 = 0 ; VAR_155 < VAR_156 ; VAR_157 ++ ) STRUCT_OR_UNION_17 -> VAR_158 [ VAR_159 ] = ( TYPE_13 * ) & VAR_160 [ VAR_161 ] ; STRUCT_OR_UNION_18 -> VAR_162 [ VAR_163 ] = VAR_164 ; * VAR_165 = STRUCT_OR_UNION_19 ; return VAR_166 ; } METHOD_22 ( STRUCT_OR_UNION_20 ) ; } VAR_167 = VAR_168 ; } for ( VAR_169 = 0 ; VAR_170 < VAR_171 ; VAR_172 ++ ) METHOD_23 ( VAR_173 [ VAR_174 ] ) ; METHOD_24 ( VAR_175 ) ; METHOD_25 ( VAR_176 ) ; METHOD_26 ( VAR_177 ) ; return VAR_178 ; }",<S2SV_ModStart> += VAR_93 ; if ( VAR_129 + VAR_128 > VAR_130 + VAR_131 ) { METHOD_26 ( VAR_126 ) ; VAR_178 = VAR_133 ; break ; },"CWE-125 int ares_parse_a_reply ( const unsigned char * abuf , int alen , struct hostent * * host ) { unsigned int qdcount , ancount ; int status , i , rr_type , rr_class , rr_len , naddrs ; long int len ; int naliases ; const unsigned char * aptr ; char * hostname , * rr_name , * rr_data , * * aliases ; struct in_addr * addrs ; struct hostent * hostent ; * host = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; addrs = malloc ( ancount * sizeof ( struct in_addr ) ) ; if ( ! addrs ) { free ( hostname ) ; return ARES_ENOMEM ; } aliases = malloc ( ( ancount + 1 ) * sizeof ( char * ) ) ; if ( ! aliases ) { free ( hostname ) ; free ( addrs ) ; return ARES_ENOMEM ; } naddrs = 0 ; naliases = 0 ; for ( i = 0 ; i < ( int ) ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) break ; aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; <S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) { memcpy ( & addrs [ naddrs ] , aptr , sizeof ( struct in_addr ) ) ; naddrs ++ ; status = ARES_SUCCESS ; } if ( rr_class == C_IN && rr_type == T_CNAME ) { aliases [ naliases ] = rr_name ; naliases ++ ; status = ares_expand_name ( aptr , abuf , alen , & rr_data , & len ) ; if ( status != ARES_SUCCESS ) break ; free ( hostname ) ; hostname = rr_data ; } else free ( rr_name ) ; aptr += rr_len ; if ( aptr > abuf + alen ) { status = ARES_EBADRESP ; break ; } } if ( status == ARES_SUCCESS && naddrs == 0 ) status = ARES_ENODATA ; if ( status == ARES_SUCCESS ) { aliases [ naliases ] = NULL ; hostent = malloc ( sizeof ( struct hostent ) ) ; if ( hostent ) { hostent -> h_addr_list = malloc ( ( naddrs + 1 ) * sizeof ( char * ) ) ; if ( hostent -> h_addr_list ) { hostent -> h_name = hostname ; hostent -> h_aliases = aliases ; hostent -> h_addrtype = AF_INET ; hostent -> h_length = sizeof ( struct in_addr ) ; for ( i = 0 ; i < naddrs ; i ++ ) hostent -> h_addr_list [ i ] = ( char * ) & addrs [ i ] ; hostent -> h_addr_list [ naddrs ] = NULL ; * host = hostent ; return ARES_SUCCESS ; } free ( hostent ) ; } status = ARES_ENOMEM ; } for ( i = 0 ; i < naliases ; i ++ ) free ( aliases [ i ] ) ; free ( aliases ) ; free ( addrs ) ; free ( hostname ) ; return status ; }",<S2SV_ModStart> += RRFIXEDSZ ; if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; }
99,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 ) { struct STRUCT_OR_UNION_1 * VAR_6 ; struct STRUCT_OR_UNION_2 * VAR_7 = VAR_8 -> VAR_9 ; struct STRUCT_OR_UNION_3 VAR_10 ; unsigned VAR_11 ; unsigned TYPE_6 VAR_12 ; struct STRUCT_OR_UNION_4 * VAR_13 ; struct STRUCT_OR_UNION_5 * VAR_14 ; TYPE_7 VAR_15 ; TYPE_8 VAR_16 ; TYPE_9 VAR_17 ; TYPE_10 VAR_18 ; TYPE_11 VAR_19 ; <S2SV_StartBug> VAR_20 . VAR_21 = METHOD_1 ( VAR_22 [ 0 ] ) ; <S2SV_EndBug> VAR_23 = METHOD_2 ( & VAR_24 ) ; if ( VAR_25 == VAR_26 ) { VAR_27 = METHOD_3 ( & VAR_28 ) ; VAR_29 ++ ; VAR_30 -= VAR_31 ; VAR_32 = METHOD_4 ( VAR_33 + METHOD_5 ( VAR_34 ) ) ; if ( METHOD_6 ( ! VAR_35 ) ) { VAR_36 -> VAR_37 . VAR_38 ++ ; return - VAR_39 ; } METHOD_7 ( VAR_40 , METHOD_8 ( VAR_41 ) ) ; METHOD_9 ( METHOD_10 ( VAR_42 , VAR_43 ) , VAR_44 , VAR_45 ) ; return METHOD_11 ( VAR_46 , VAR_47 , VAR_48 , VAR_49 , VAR_50 ) ; } <S2SV_StartBug> VAR_51 . VAR_52 = METHOD_12 ( VAR_53 [ 1 ] ) ; <S2SV_EndBug> VAR_54 += 2 ; VAR_55 -= VAR_56 ; if ( VAR_57 == VAR_58 ) { VAR_59 = METHOD_13 ( & VAR_60 ) ; VAR_61 = 0 ; } else { VAR_62 = 0 ; VAR_63 = METHOD_14 ( & VAR_64 ) ; } VAR_65 = METHOD_15 ( & VAR_66 ) ; VAR_67 = METHOD_16 ( & VAR_68 ) ; <S2SV_StartBug> METHOD_17 ( & VAR_69 -> VAR_70 , VAR_71 ) ; <S2SV_EndBug> VAR_72 = METHOD_18 ( VAR_73 , VAR_74 , VAR_75 ) ; if ( ! VAR_76 ) { VAR_77 = - VAR_78 ; goto VAR_79 ; } VAR_80 = METHOD_19 ( VAR_81 , VAR_82 ) ; if ( VAR_83 == VAR_84 ) { while ( VAR_85 -> VAR_86 >= VAR_87 ) { METHOD_20 ( list_first_entry ( & VAR_88 -> VAR_89 , struct STRUCT_OR_UNION_6 , VAR_90 ) ) ; VAR_91 -> VAR_92 -- ; } VAR_93 = METHOD_21 ( VAR_94 , VAR_95 , VAR_96 , VAR_97 , VAR_98 , VAR_99 , VAR_100 ) ; if ( VAR_101 == VAR_102 ) { VAR_103 = - VAR_104 ; goto VAR_105 ; } VAR_106 -> VAR_107 ++ ; } else { if ( METHOD_22 ( VAR_108 , VAR_109 , VAR_110 ) || VAR_111 -> VAR_112 != VAR_113 ) { METHOD_23 ( VAR_114 ) ; VAR_115 = METHOD_24 ( VAR_116 , VAR_117 , VAR_118 , VAR_119 , VAR_120 , VAR_121 , VAR_122 ) ; if ( VAR_123 == VAR_124 ) { VAR_125 -> VAR_126 -- ; VAR_127 = - VAR_128 ; goto VAR_129 ; } } else { if ( ! METHOD_25 ( VAR_130 , VAR_131 , VAR_132 , VAR_133 , VAR_134 ) ) { METHOD_26 ( VAR_135 ) ; VAR_136 -> VAR_137 -- ; VAR_138 = - VAR_139 ; goto VAR_140 ; } } } if ( VAR_141 == VAR_142 ) VAR_143 -> VAR_144 = VAR_145 ; if ( METHOD_27 ( VAR_146 ) ) { VAR_147 = VAR_148 -> VAR_149 ; VAR_150 -> VAR_151 -- ; VAR_152 = METHOD_28 ( VAR_153 -> VAR_154 ) ; METHOD_29 ( VAR_155 ) ; METHOD_30 ( & VAR_156 -> VAR_157 , VAR_158 ) ; return METHOD_31 ( VAR_159 , VAR_160 , VAR_161 , VAR_162 , VAR_163 ) ; } VAR_164 = 0 ; VAR_165 : METHOD_32 ( & VAR_166 -> VAR_167 , VAR_168 ) ; return VAR_169 ; }",<S2SV_ModStart> TYPE_11 VAR_163 ; if ( VAR_134 <= VAR_31 ) return 0 ; <S2SV_ModStart> ) ; } if ( VAR_134 <= VAR_56 ) return 0 ; <S2SV_ModStart> VAR_68 ) ; if ( VAR_133 + VAR_134 > VAR_119 ) return 0 ;,"CWE-119 static int fwnet_incoming_packet ( struct fwnet_device * dev , __be32 * buf , int len , int source_node_id , int generation , bool is_broadcast ) { struct sk_buff * skb ; struct net_device * net = dev -> netdev ; struct rfc2734_header hdr ; unsigned lf ; unsigned long flags ; struct fwnet_peer * peer ; struct fwnet_partial_datagram * pd ; int fg_off ; int dg_size ; u16 datagram_label ; int retval ; u16 ether_type ; <S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> lf = fwnet_get_hdr_lf ( & hdr ) ; if ( lf == RFC2374_HDR_UNFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; buf ++ ; len -= RFC2374_UNFRAG_HDR_SIZE ; skb = dev_alloc_skb ( len + LL_RESERVED_SPACE ( net ) ) ; if ( unlikely ( ! skb ) ) { net -> stats . rx_dropped ++ ; return - ENOMEM ; } skb_reserve ( skb , LL_RESERVED_SPACE ( net ) ) ; memcpy ( skb_put ( skb , len ) , buf , len ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , is_broadcast , ether_type ) ; } <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> buf += 2 ; len -= RFC2374_FRAG_HDR_SIZE ; if ( lf == RFC2374_HDR_FIRSTFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; fg_off = 0 ; } else { ether_type = 0 ; fg_off = fwnet_get_hdr_fg_off ( & hdr ) ; } datagram_label = fwnet_get_hdr_dgl ( & hdr ) ; dg_size = fwnet_get_hdr_dg_size ( & hdr ) ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ; if ( ! peer ) { retval = - ENOENT ; goto fail ; } pd = fwnet_pd_find ( peer , datagram_label ) ; if ( pd == NULL ) { while ( peer -> pdg_size >= FWNET_MAX_FRAGMENTS ) { fwnet_pd_delete ( list_first_entry ( & peer -> pd_list , struct fwnet_partial_datagram , pd_link ) ) ; peer -> pdg_size -- ; } pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { retval = - ENOMEM ; goto fail ; } peer -> pdg_size ++ ; } else { if ( fwnet_frag_overlap ( pd , fg_off , len ) || pd -> datagram_size != dg_size ) { fwnet_pd_delete ( pd ) ; pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } else { if ( ! fwnet_pd_update ( peer , pd , buf , fg_off , len ) ) { fwnet_pd_delete ( pd ) ; peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } } if ( lf == RFC2374_HDR_FIRSTFRAG ) pd -> ether_type = ether_type ; if ( fwnet_pd_is_complete ( pd ) ) { ether_type = pd -> ether_type ; peer -> pdg_size -- ; skb = skb_get ( pd -> skb ) ; fwnet_pd_delete ( pd ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , false , ether_type ) ; } retval = 0 ; fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ; return retval ; }",<S2SV_ModStart> u16 ether_type ; if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> ) ; } if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> hdr ) ; if ( fg_off + len > dg_size ) return 0 ;
100,"CWE-90 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { VAR_6 * VAR_7 ; TYPE_7 VAR_8 ; TYPE_8 VAR_9 ; TYPE_9 VAR_10 = VAR_11 ; TYPE_10 VAR_12 ; VAR_13 * VAR_14 ; unsigned TYPE_11 VAR_15 ; TYPE_12 VAR_16 = VAR_17 ; VAR_18 * VAR_19 ; TYPE_13 VAR_20 ; TYPE_14 VAR_21 = 0 ; TYPE_15 * VAR_22 = VAR_23 ; METHOD_1 ( VAR_24 ) ; METHOD_2 ( VAR_25 -> VAR_26 ) ; METHOD_3 ( VAR_27 , VAR_28 , VAR_29 , VAR_30 , & VAR_31 ) ; if ( VAR_32 == VAR_33 ) return VAR_34 ; if ( ! ( VAR_35 & VAR_36 ) || ( VAR_37 & VAR_38 ) || ( VAR_39 & VAR_40 ) || ( VAR_41 & VAR_42 ) || ( VAR_43 & VAR_44 ) || ( VAR_45 & VAR_46 ) || ( VAR_47 & VAR_48 ) || ( VAR_49 & VAR_50 ) || ( VAR_51 & VAR_52 ) ) return VAR_53 ; if ( ( VAR_54 & VAR_55 ) && VAR_56 -> VAR_57 != 0 ) return VAR_58 ; if ( ( VAR_59 & VAR_60 ) && VAR_61 -> VAR_62 == VAR_63 ) return VAR_64 ; if ( ( VAR_65 & VAR_66 ) && ( VAR_67 & VAR_68 ) ) return VAR_69 ; if ( ( VAR_70 & ~ VAR_71 ) ) <S2SV_StartBug> return VAR_72 ; <S2SV_EndBug> VAR_73 = METHOD_4 ( VAR_74 , VAR_75 -> VAR_76 , & VAR_77 , & VAR_78 ) ; switch ( VAR_79 ) { case VAR_80 : break ; case 0 : METHOD_5 ( VAR_81 , VAR_82 , & VAR_83 ) ; return VAR_84 ; default : return VAR_85 ; } VAR_86 = METHOD_6 ( 1 , sizeof ( * VAR_87 ) ) ; if ( VAR_88 == VAR_89 ) return VAR_90 ; METHOD_7 ( & VAR_91 , 0 , sizeof ( TYPE_16 ) ) ; if ( ( VAR_92 & VAR_93 ) ) { VAR_94 = METHOD_8 ( VAR_95 , VAR_96 -> VAR_97 , & VAR_98 , & VAR_99 ) ; if ( VAR_100 ) goto VAR_101 ; } if ( VAR_102 ) { VAR_103 = METHOD_9 ( VAR_104 , VAR_105 , VAR_106 ? & VAR_107 : VAR_108 , VAR_109 -> VAR_110 ) ; if ( VAR_111 ) goto VAR_112 ; } if ( ( VAR_113 = METHOD_10 ( VAR_114 -> VAR_115 , & VAR_116 ) ) ) goto VAR_117 ; VAR_118 -> VAR_119 = VAR_120 ; VAR_121 -> VAR_122 = VAR_123 ; if ( ( VAR_124 & VAR_125 ) ) VAR_126 -> VAR_127 = VAR_128 -> VAR_129 ; else VAR_130 -> VAR_131 = VAR_132 -> VAR_133 . VAR_134 ; if ( ( VAR_135 & VAR_136 ) ) VAR_137 -> VAR_138 = VAR_139 -> VAR_140 ; else VAR_141 -> VAR_142 = VAR_143 -> VAR_144 . VAR_145 ; if ( VAR_146 & VAR_147 ) VAR_148 -> VAR_149 = VAR_150 -> VAR_151 ; else VAR_152 -> VAR_153 = VAR_154 -> VAR_155 . VAR_156 ; if ( ( VAR_157 & VAR_158 ) ) VAR_159 -> VAR_160 = VAR_161 -> VAR_162 ; else VAR_163 -> VAR_164 = VAR_165 -> VAR_166 . VAR_167 ; VAR_168 -> VAR_169 = 0 ; if ( VAR_170 ) { if ( VAR_171 . VAR_172 ) VAR_173 -> VAR_174 = METHOD_11 ( VAR_175 , VAR_176 . VAR_177 ) ; else VAR_178 -> VAR_179 = 0 ; } if ( ( VAR_180 & VAR_181 ) ) VAR_182 -> VAR_183 = VAR_184 -> VAR_185 ; VAR_186 -> VAR_187 = 0 ; VAR_188 -> VAR_189 = 0 ; VAR_190 -> VAR_191 = 0 ; VAR_192 = METHOD_12 ( VAR_193 -> VAR_194 , VAR_195 -> VAR_196 , & VAR_197 -> VAR_198 ) ; if ( VAR_199 ) goto VAR_200 ; if ( ( VAR_201 = METHOD_13 ( VAR_202 -> VAR_203 , VAR_204 , VAR_205 ) ) ) goto VAR_206 ; if ( VAR_207 & VAR_208 ) { for ( VAR_209 = VAR_210 -> VAR_211 ; VAR_212 ; VAR_213 = VAR_214 -> VAR_215 ) { VAR_216 = METHOD_14 ( VAR_217 -> VAR_218 , VAR_219 , VAR_220 ) ; if ( VAR_221 ) goto VAR_222 ; } } VAR_223 = METHOD_15 ( VAR_224 , VAR_225 -> VAR_226 , VAR_227 , VAR_228 , & VAR_229 , & VAR_230 ) ; if ( VAR_231 ) goto VAR_232 ; VAR_233 = METHOD_16 ( VAR_234 , & VAR_235 , & VAR_236 ) ; if ( VAR_237 ) goto VAR_238 ; if ( VAR_239 & VAR_240 ) { METHOD_17 ( VAR_241 -> VAR_242 == 0 ) ; } else if ( VAR_243 ) { VAR_244 = METHOD_18 ( VAR_245 -> VAR_246 , VAR_247 , VAR_248 , VAR_249 , VAR_250 , ( VAR_251 & VAR_252 ) ? VAR_253 -> VAR_254 : 1 , VAR_255 , VAR_256 ) ; } else { VAR_257 = METHOD_19 ( VAR_258 -> VAR_259 , & VAR_260 , VAR_261 , VAR_262 , VAR_263 , VAR_264 ) ; } if ( VAR_265 ) goto VAR_266 ; VAR_267 = METHOD_20 ( VAR_268 -> VAR_269 , VAR_270 , VAR_271 ) ; if ( VAR_272 ) goto VAR_273 ; VAR_274 = METHOD_21 ( VAR_275 -> VAR_276 , VAR_277 -> VAR_278 , VAR_279 , VAR_280 , VAR_281 , VAR_282 , VAR_283 , VAR_284 ) ; if ( VAR_285 ) goto VAR_286 ; VAR_287 . VAR_288 = VAR_289 ; if ( VAR_290 & VAR_291 ) { VAR_292 . VAR_293 = VAR_294 ; VAR_295 . VAR_296 = VAR_297 -> VAR_298 ; } VAR_299 -> VAR_300 = VAR_301 | VAR_302 | VAR_303 ; VAR_304 = METHOD_22 ( VAR_305 , VAR_306 , & VAR_307 ) ; ( TYPE_17 ) METHOD_23 ( VAR_308 -> VAR_309 , VAR_310 -> VAR_311 , VAR_312 , VAR_313 , VAR_314 , VAR_315 , VAR_316 , VAR_317 ) ; VAR_318 : METHOD_24 ( VAR_319 ) ; METHOD_25 ( VAR_320 -> VAR_321 , VAR_322 ) ; if ( VAR_323 ) ( TYPE_18 ) METHOD_26 ( VAR_324 -> VAR_325 , & VAR_326 ) ; return VAR_327 ; }",<S2SV_ModStart> return VAR_72 ; if ( VAR_314 & VAR_208 ) { for ( VAR_220 = VAR_313 -> VAR_211 ; VAR_220 != VAR_108 ; VAR_220 = VAR_220 -> VAR_215 ) { if ( VAR_220 -> VAR_328 < 256 ) return VAR_329 ; } },"CWE-90 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }",<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
101,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) <S2SV_StartBug> { <S2SV_EndBug> if ( METHOD_1 ( VAR_1 , METHOD_2 ( VAR_2 , VAR_3 ) ) == 0 ) <S2SV_StartBug> METHOD_3 ( VAR_4 , VAR_5 -> VAR_6 . VAR_7 ) ; <S2SV_EndBug> <S2SV_StartBug> return VAR_8 ; <S2SV_EndBug> }",<S2SV_ModStart> VAR_5 ) { TYPE_0 VAR_9 = VAR_8 ; <S2SV_ModStart> == 0 ) VAR_9 = <S2SV_ModStart> ) ; return VAR_9 <S2SV_ModEnd> ; } <S2SV_null>,"CWE-000 static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }",<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> == 0 ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
102,"CWE-476 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { VAR_2 * VAR_3 ; TYPE_2 VAR_4 ; VAR_5 = METHOD_1 ( VAR_6 , ""w"" ) ; if ( ! VAR_7 ) { METHOD_2 ( ""open<S2SV_blank>%s:"" , VAR_8 ) ; return - 1 ; } VAR_9 = 0 ; <S2SV_StartBug> if ( METHOD_3 ( VAR_10 -> VAR_11 , 1 , VAR_12 -> VAR_13 , VAR_14 ) != VAR_15 -> VAR_16 || METHOD_4 ( VAR_17 ) != 0 ) { <S2SV_EndBug> METHOD_5 ( ""write<S2SV_blank>%s:"" , VAR_18 ) ; VAR_19 = - 1 ; } METHOD_6 ( VAR_20 ) ; return VAR_21 ; }",<S2SV_ModStart> ; if ( VAR_15 && ( <S2SV_ModStart> ) != 0 ),"CWE-476 int writefile ( const char * name , struct string * s ) { FILE * f ; int ret ; f = fopen ( name , ""w"" ) ; if ( ! f ) { warn ( ""open<S2SV_blank>%s:"" , name ) ; return - 1 ; } ret = 0 ; <S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> warn ( ""write<S2SV_blank>%s:"" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }",<S2SV_ModStart> ; if ( s && ( <S2SV_ModStart> ) != 0 )
103,"CWE-119 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { VAR_4 * VAR_5 ; if ( VAR_6 -> VAR_7 == VAR_8 || VAR_9 -> VAR_10 == VAR_11 || VAR_12 -> VAR_13 == VAR_14 ) { VAR_15 = VAR_16 ; METHOD_1 ( VAR_17 , sizeof ( VAR_18 ) , ""Bad<S2SV_blank>vio_get_filelen<S2SV_blank>/<S2SV_blank>vio_seek<S2SV_blank>/<S2SV_blank>vio_tell<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return VAR_19 ; } ; if ( ( VAR_20 == VAR_21 || VAR_22 == VAR_23 ) && VAR_24 -> VAR_25 == VAR_26 ) { VAR_27 = VAR_28 ; METHOD_2 ( VAR_29 , sizeof ( VAR_30 ) , ""Bad<S2SV_blank>vio_read<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return VAR_31 ; } ; if ( ( VAR_32 == VAR_33 || VAR_34 == VAR_35 ) && VAR_36 -> VAR_37 == VAR_38 ) { VAR_39 = VAR_40 ; METHOD_3 ( VAR_41 , sizeof ( VAR_42 ) , ""Bad<S2SV_blank>vio_write<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return VAR_43 ; } ; <S2SV_StartBug> if ( ( VAR_44 = METHOD_4 ( 1 , sizeof ( VAR_45 ) ) ) == VAR_46 ) <S2SV_EndBug> { VAR_47 = VAR_48 ; return VAR_49 ; } ; METHOD_5 ( VAR_50 ) ; VAR_51 -> VAR_52 = VAR_53 ; VAR_54 -> VAR_55 = * VAR_56 ; VAR_57 -> VAR_58 = VAR_59 ; VAR_60 -> VAR_61 . VAR_62 = VAR_63 ; return METHOD_6 ( VAR_64 , VAR_65 ) ; }",<S2SV_ModStart> ( VAR_64 = METHOD_7 ( <S2SV_ModEnd> ) ) ==,"CWE-119 SNDFILE * sf_open_virtual ( SF_VIRTUAL_IO * sfvirtual , int mode , SF_INFO * sfinfo , void * user_data ) { SF_PRIVATE * psf ; if ( sfvirtual -> get_filelen == NULL || sfvirtual -> seek == NULL || sfvirtual -> tell == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , ""Bad<S2SV_blank>vio_get_filelen<S2SV_blank>/<S2SV_blank>vio_seek<S2SV_blank>/<S2SV_blank>vio_tell<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return NULL ; } ; if ( ( mode == SFM_READ || mode == SFM_RDWR ) && sfvirtual -> read == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , ""Bad<S2SV_blank>vio_read<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return NULL ; } ; if ( ( mode == SFM_WRITE || mode == SFM_RDWR ) && sfvirtual -> write == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , ""Bad<S2SV_blank>vio_write<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n"" ) ; return NULL ; } ; <S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf -> virtual_io = SF_TRUE ; psf -> vio = * sfvirtual ; psf -> vio_user_data = user_data ; psf -> file . mode = mode ; return psf_open_file ( psf , sfinfo ) ; }",<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
104,"CWE-476 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; VAR_2 * VAR_3 ; TYPE_3 * VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; VAR_8 = 0 ; VAR_9 = 0 ; if ( ! ( VAR_10 = METHOD_1 ( sizeof ( TYPE_7 ) ) ) ) { goto VAR_11 ; } VAR_12 -> VAR_13 = & VAR_14 . VAR_15 ; if ( METHOD_2 ( VAR_16 , & VAR_17 ) || METHOD_3 ( VAR_18 , & VAR_19 -> VAR_20 ) ) { goto VAR_21 ; } VAR_22 = METHOD_4 ( VAR_23 -> VAR_24 ) ; VAR_25 -> VAR_26 = VAR_27 ; VAR_28 -> VAR_29 = & VAR_30 -> VAR_31 ; <S2SV_StartBug> VAR_32 -> VAR_33 = VAR_34 ; <S2SV_EndBug> if ( VAR_35 -> VAR_36 == 1 ) { if ( METHOD_5 ( VAR_37 , & VAR_38 ) ) { goto VAR_39 ; } if ( VAR_40 > 0xffffffffUL ) { METHOD_6 ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; VAR_41 = 0xffffffffUL ; } VAR_42 -> VAR_43 = VAR_44 ; VAR_45 -> VAR_46 = VAR_47 - METHOD_7 ( VAR_48 ) ; } else { VAR_49 -> VAR_50 = VAR_51 -> VAR_52 - METHOD_8 ( VAR_53 ) ; } if ( VAR_54 -> VAR_55 != 0 && VAR_56 -> VAR_57 < 8 ) { goto VAR_58 ; } VAR_59 = ! ( VAR_60 -> VAR_61 -> VAR_62 & ( VAR_63 | VAR_64 ) ) ; if ( VAR_65 ) { if ( ! ( VAR_66 = METHOD_9 ( 0 , 0 ) ) ) { goto VAR_67 ; } if ( METHOD_10 ( VAR_68 , VAR_69 , VAR_70 -> VAR_71 ) ) { <S2SV_StartBug> METHOD_11 ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; <S2SV_EndBug> goto VAR_72 ; } METHOD_12 ( VAR_73 ) ; if ( VAR_74 -> VAR_75 -> VAR_76 ) { if ( ( * VAR_77 -> VAR_78 -> VAR_79 ) ( VAR_80 , VAR_81 ) ) { METHOD_13 ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto VAR_82 ; } } METHOD_14 ( VAR_83 ) ; } if ( METHOD_15 ( ) >= 1 ) { METHOD_16 ( VAR_84 , VAR_85 ) ; } return VAR_86 ; VAR_87 : if ( VAR_88 ) { METHOD_17 ( VAR_89 ) ; } if ( VAR_90 ) { METHOD_18 ( VAR_91 ) ; } return 0 ; }","<S2SV_ModStart> VAR_57 = VAR_57 ; METHOD_20 ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , VAR_30 -> name , \'""\' , VAR_89 -> VAR_24 , VAR_89 -> VAR_57 ) ) <S2SV_ModStart> ) ) { VAR_89 -> VAR_78 = & VAR_14 . VAR_78 ;","CWE-476 jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; <S2SV_StartBug> box -> len = len ; <S2SV_EndBug> if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <S2SV_StartBug> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; <S2SV_EndBug> goto error ; } jas_stream_rewind ( tmpstream ) ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }","<S2SV_ModStart> len = len ; JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) <S2SV_ModStart> ) ) { box -> ops = & jp2_boxinfo_unk . ops ;"
105,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { VAR_3 * VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 ; METHOD_1 ( VAR_7 >= 0 ) ; METHOD_2 ( VAR_8 -> VAR_9 == VAR_10 ) ; VAR_11 = METHOD_3 ( VAR_12 ) ; if ( VAR_13 -> VAR_14 == VAR_15 ) { <S2SV_StartBug> VAR_16 = METHOD_4 ( 64 , ( VAR_17 + 1 ) * 2 ) ; <S2SV_EndBug> VAR_18 -> VAR_19 = ( TYPE_6 * ) METHOD_5 ( sizeof ( TYPE_7 ) + VAR_20 * sizeof ( TYPE_8 * ) ) ; if ( VAR_21 -> VAR_22 == VAR_23 ) return VAR_24 ; METHOD_6 ( VAR_25 -> VAR_26 -> VAR_27 , 0 , VAR_28 * sizeof ( TYPE_9 * ) ) ; VAR_29 -> VAR_30 -> VAR_31 = VAR_32 ; } else if ( VAR_33 >= VAR_34 -> VAR_35 -> VAR_36 ) { VAR_37 = VAR_38 -> VAR_39 -> VAR_40 * 2 ; <S2SV_StartBug> VAR_41 -> VAR_42 = ( TYPE_10 * ) METHOD_7 ( <S2SV_EndBug> VAR_43 -> VAR_44 , sizeof ( TYPE_11 ) + VAR_45 * sizeof ( TYPE_12 * ) ) ; if ( VAR_46 -> VAR_47 == VAR_48 ) return VAR_49 ; for ( VAR_50 = VAR_51 -> VAR_52 -> VAR_53 ; VAR_54 < VAR_55 ; VAR_56 ++ ) VAR_57 -> VAR_58 -> VAR_59 [ VAR_60 ] = VAR_61 ; VAR_62 -> VAR_63 -> VAR_64 = VAR_65 ; } VAR_66 -> VAR_67 = VAR_68 ; VAR_69 -> VAR_70 -> VAR_71 [ VAR_72 ] = VAR_73 ; return VAR_74 ; }",<S2SV_ModStart> { VAR_65 = 64 ; while ( VAR_65 <= VAR_72 ) VAR_65 *= 2 <S2SV_ModEnd> ; VAR_69 -> <S2SV_ModStart> * 2 ; while ( VAR_65 <= VAR_72 ) VAR_65 *= 2 ;,"CWE-119 int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }",<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
106,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 , VAR_7 , VAR_8 ; union { TYPE_8 VAR_9 ; TYPE_9 VAR_10 ; } VAR_11 ; TYPE_10 VAR_12 ; TYPE_11 VAR_13 ; const TYPE_12 * VAR_14 ; TYPE_13 VAR_15 [ VAR_16 + 100 ] ; TYPE_14 VAR_17 ; VAR_18 = VAR_19 ; VAR_20 = VAR_21 ; switch ( VAR_22 ) { case VAR_23 : if ( VAR_24 != 1 ) METHOD_1 ( ( VAR_25 , ""invalid<S2SV_blank>len"" ) ) ; else { METHOD_2 ( * VAR_26 ) ; METHOD_3 ( ( VAR_27 , ""%s"" , METHOD_4 ( VAR_28 , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , VAR_29 [ 0 ] ) ) ) ; } break ; case VAR_30 : case VAR_31 : if ( VAR_32 % 2 ) { METHOD_5 ( ( VAR_33 , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! VAR_34 ) { METHOD_6 ( ( VAR_35 , ""empty"" ) ) ; break ; } VAR_36 = METHOD_7 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; while ( VAR_41 < VAR_42 + VAR_43 ) { METHOD_8 ( VAR_44 [ 0 ] ) ; METHOD_9 ( ( VAR_45 , ""%s"" , METHOD_10 ( VAR_46 , ""?"" , VAR_47 [ 0 ] ) ) ) ; METHOD_11 ( VAR_48 [ 1 ] ) ; for ( VAR_49 = 0 ; VAR_50 < VAR_51 [ 1 ] * VAR_52 ; VAR_53 += VAR_54 ) { METHOD_12 ( VAR_55 [ 2 + VAR_56 ] , VAR_57 ) ; METHOD_13 ( ( VAR_58 , ""%s<S2SV_blank>"" , METHOD_14 ( VAR_59 , VAR_60 , sizeof ( VAR_61 ) , VAR_62 == 2 ? METHOD_15 ( & VAR_63 [ 2 + VAR_64 ] ) : METHOD_16 ( & VAR_65 [ 2 + VAR_66 ] ) ) ) ) ; } METHOD_17 ( VAR_67 [ 0 ] ) ; METHOD_18 ( ( VAR_68 , ""%s"" , METHOD_19 ( VAR_69 , ""?"" , VAR_70 [ 0 ] ) ) ) ; METHOD_20 ( VAR_71 [ 1 ] ) ; VAR_72 += 2 + VAR_73 [ 1 ] * VAR_74 ; } break ; case VAR_75 : if ( VAR_76 != 4 ) METHOD_21 ( ( VAR_77 , ""invalid<S2SV_blank>len"" ) ) ; else { METHOD_22 ( VAR_78 [ 0 ] , 4 ) ; METHOD_23 ( ( VAR_79 , ""%s"" , METHOD_24 ( VAR_80 , VAR_81 ) ) ) ; } break ; case VAR_82 : case VAR_83 : if ( VAR_84 != 4 ) METHOD_25 ( ( VAR_85 , ""invalid<S2SV_blank>len"" ) ) ; else { METHOD_26 ( VAR_86 [ 0 ] , 4 ) ; METHOD_27 ( ( VAR_87 , ""%u"" , METHOD_28 ( VAR_88 ) ) ) ; } break ; case VAR_89 : if ( VAR_90 != 0 ) METHOD_29 ( ( VAR_91 , ""invalid<S2SV_blank>len"" ) ) ; break ; case VAR_92 : if ( VAR_93 != 6 && VAR_94 != 8 ) { METHOD_30 ( ( VAR_95 , ""invalid<S2SV_blank>len"" ) ) ; break ; } METHOD_31 ( VAR_96 [ 0 ] , VAR_97 ) ; if ( VAR_98 == 6 ) { METHOD_32 ( ( VAR_99 , ""<S2SV_blank>AS<S2SV_blank>%s,<S2SV_blank>origin<S2SV_blank>%s"" , METHOD_33 ( VAR_100 , VAR_101 , sizeof ( VAR_102 ) , METHOD_34 ( VAR_103 ) ) , METHOD_35 ( VAR_104 , VAR_105 + 2 ) ) ) ; } else { METHOD_36 ( ( VAR_106 , ""<S2SV_blank>AS<S2SV_blank>%s,<S2SV_blank>origin<S2SV_blank>%s"" , METHOD_37 ( VAR_107 , VAR_108 , sizeof ( VAR_109 ) , METHOD_38 ( VAR_110 ) ) , METHOD_39 ( VAR_111 , VAR_112 + 4 ) ) ) ; } break ; case VAR_113 : if ( VAR_114 != 8 ) { METHOD_40 ( ( VAR_115 , ""invalid<S2SV_blank>len"" ) ) ; break ; } METHOD_41 ( VAR_116 [ 0 ] , 8 ) ; METHOD_42 ( ( VAR_117 , ""<S2SV_blank>AS<S2SV_blank>%s,<S2SV_blank>origin<S2SV_blank>%s"" , METHOD_43 ( VAR_118 , VAR_119 , sizeof ( VAR_120 ) , METHOD_44 ( VAR_121 ) ) , METHOD_45 ( VAR_122 , VAR_123 + 4 ) ) ) ; break ; case VAR_124 : if ( VAR_125 % 4 ) { METHOD_46 ( ( VAR_126 , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( VAR_127 > 0 ) { TYPE_15 VAR_128 ; METHOD_47 ( VAR_129 [ 0 ] , 4 ) ; VAR_130 = METHOD_48 ( VAR_131 ) ; switch ( VAR_132 ) { case VAR_133 : METHOD_49 ( ( VAR_134 , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case VAR_135 : METHOD_50 ( ( VAR_136 , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case VAR_137 : METHOD_51 ( ( VAR_138 , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : METHOD_52 ( ( VAR_139 , ""%u:%u%s"" , ( VAR_140 >> 16 ) & 0xffff , VAR_141 & 0xffff , ( VAR_142 > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } VAR_143 -= 4 ; VAR_144 += 4 ; } break ; case VAR_145 : if ( VAR_146 != 4 ) { METHOD_53 ( ( VAR_147 , ""invalid<S2SV_blank>len"" ) ) ; break ; } METHOD_54 ( VAR_148 [ 0 ] , 4 ) ; METHOD_55 ( ( VAR_149 , ""%s"" , METHOD_56 ( VAR_150 , VAR_151 ) ) ) ; break ; case VAR_152 : if ( VAR_153 % 4 ) { METHOD_57 ( ( VAR_154 , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( VAR_155 > 0 ) { METHOD_58 ( VAR_156 [ 0 ] , 4 ) ; METHOD_59 ( ( VAR_157 , ""%s%s"" , METHOD_60 ( VAR_158 , VAR_159 ) , ( VAR_160 > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; VAR_161 -= 4 ; VAR_162 += 4 ; } break ; case VAR_163 : METHOD_61 ( VAR_164 [ 0 ] , 3 ) ; VAR_165 = METHOD_62 ( VAR_166 ) ; VAR_167 = VAR_168 [ 2 ] ; METHOD_63 ( ( VAR_169 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , METHOD_64 ( VAR_170 , ""Unknown<S2SV_blank>AFI"" , VAR_171 ) , VAR_172 , ( VAR_173 > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , METHOD_65 ( VAR_174 , ""Unknown<S2SV_blank>SAFI"" , VAR_175 ) , VAR_176 ) ) ; switch ( VAR_177 << 8 | VAR_178 ) { case ( VAR_179 << 8 | VAR_180 ) : case ( VAR_181 << 8 | VAR_182 ) : case ( VAR_183 << 8 | VAR_184 ) : case ( VAR_185 << 8 | VAR_186 ) : case ( VAR_187 << 8 | VAR_188 ) : case ( VAR_189 << 8 | VAR_190 ) : case ( VAR_191 << 8 | VAR_192 ) : case ( VAR_193 << 8 | VAR_194 ) : case ( VAR_195 << 8 | VAR_196 ) : case ( VAR_197 << 8 | VAR_198 ) : case ( VAR_199 << 8 | VAR_200 ) : case ( VAR_201 << 8 | VAR_202 ) : case ( VAR_203 << 8 | VAR_204 ) : case ( VAR_205 << 8 | VAR_206 ) : case ( VAR_207 << 8 | VAR_208 ) : case ( VAR_209 << 8 | VAR_210 ) : case ( VAR_211 << 8 | VAR_212 ) : case ( VAR_213 << 8 | VAR_214 ) : case ( VAR_215 << 8 | VAR_216 ) : case ( VAR_217 << 8 | VAR_218 ) : case ( VAR_219 << 8 | VAR_220 ) : case ( VAR_221 << 8 | VAR_222 ) : case ( VAR_223 << 8 | VAR_224 ) : case ( VAR_225 << 8 | VAR_226 ) : case ( VAR_227 << 8 | VAR_228 ) : case ( VAR_229 << 8 | VAR_230 ) : case ( VAR_231 << 8 | VAR_232 ) : break ; default : METHOD_66 ( VAR_233 [ 0 ] , VAR_234 ) ; METHOD_67 ( ( VAR_235 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , VAR_236 , VAR_237 ) ) ; if ( VAR_238 -> VAR_239 <= 1 ) METHOD_68 ( VAR_240 , VAR_241 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_242 ) ; goto VAR_243 ; break ; } VAR_244 += 3 ; METHOD_69 ( VAR_245 [ 0 ] ) ; VAR_246 = VAR_247 [ 0 ] ; VAR_248 = VAR_249 ; VAR_250 ++ ; if ( VAR_251 ) { TYPE_16 VAR_252 = 0 ; METHOD_70 ( ( VAR_253 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( VAR_254 > 0 ) { if ( VAR_255 ++ > 0 ) { METHOD_71 ( ( VAR_256 , "",<S2SV_blank>"" ) ) ; } switch ( VAR_257 << 8 | VAR_258 ) { case ( VAR_259 << 8 | VAR_260 ) : case ( VAR_261 << 8 | VAR_262 ) : case ( VAR_263 << 8 | VAR_264 ) : case ( VAR_265 << 8 | VAR_266 ) : case ( VAR_267 << 8 | VAR_268 ) : case ( VAR_269 << 8 | VAR_270 ) : case ( VAR_271 << 8 | VAR_272 ) : if ( VAR_273 < ( TYPE_17 ) sizeof ( struct STRUCT_OR_UNION_0 ) ) { METHOD_72 ( ( VAR_274 , ""invalid<S2SV_blank>len"" ) ) ; VAR_275 = 0 ; } else { METHOD_73 ( VAR_276 [ 0 ] , sizeof ( struct STRUCT_OR_UNION_1 ) ) ; METHOD_74 ( ( VAR_277 , ""%s"" , METHOD_75 ( VAR_278 , VAR_279 ) ) ) ; VAR_280 -= sizeof ( struct STRUCT_OR_UNION_2 ) ; VAR_281 += sizeof ( struct STRUCT_OR_UNION_3 ) ; } break ; case ( VAR_282 << 8 | VAR_283 ) : case ( VAR_284 << 8 | VAR_285 ) : case ( VAR_286 << 8 | VAR_287 ) : if ( VAR_288 < ( TYPE_18 ) ( sizeof ( struct STRUCT_OR_UNION_4 ) + VAR_289 ) ) { METHOD_76 ( ( VAR_290 , ""invalid<S2SV_blank>len"" ) ) ; VAR_291 = 0 ; } else { METHOD_77 ( VAR_292 [ 0 ] , sizeof ( struct STRUCT_OR_UNION_5 ) + VAR_293 ) ; METHOD_78 ( ( VAR_294 , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , METHOD_79 ( VAR_295 , VAR_296 ) , METHOD_80 ( VAR_297 , VAR_298 + VAR_299 ) ) ) ; VAR_300 -= ( sizeof ( struct STRUCT_OR_UNION_6 ) + VAR_301 ) ; VAR_302 += ( sizeof ( struct STRUCT_OR_UNION_7 ) + VAR_303 ) ; } break ; case ( VAR_304 << 8 | VAR_305 ) : case ( VAR_306 << 8 | VAR_307 ) : case ( VAR_308 << 8 | VAR_309 ) : case ( VAR_310 << 8 | VAR_311 ) : if ( VAR_312 < ( TYPE_19 ) sizeof ( struct STRUCT_OR_UNION_8 ) ) { METHOD_81 ( ( VAR_313 , ""invalid<S2SV_blank>len"" ) ) ; VAR_314 = 0 ; } else { METHOD_82 ( VAR_315 [ 0 ] , sizeof ( struct STRUCT_OR_UNION_9 ) ) ; METHOD_83 ( ( VAR_316 , ""%s"" , METHOD_84 ( VAR_317 , VAR_318 ) ) ) ; VAR_319 -= sizeof ( struct STRUCT_OR_UNION_10 ) ; VAR_320 += sizeof ( struct STRUCT_OR_UNION_11 ) ; } break ; case ( VAR_321 << 8 | VAR_322 ) : case ( VAR_323 << 8 | VAR_324 ) : case ( VAR_325 << 8 | VAR_326 ) : if ( VAR_327 < ( TYPE_20 ) ( sizeof ( struct STRUCT_OR_UNION_12 ) + VAR_328 ) ) { METHOD_85 ( ( VAR_329 , ""invalid<S2SV_blank>len"" ) ) ; VAR_330 = 0 ; } else { METHOD_86 ( VAR_331 [ 0 ] , sizeof ( struct STRUCT_OR_UNION_13 ) + VAR_332 ) ; METHOD_87 ( ( VAR_333 , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , METHOD_88 ( VAR_334 , VAR_335 ) , METHOD_89 ( VAR_336 , VAR_337 + VAR_338 ) ) ) ; VAR_339 -= ( sizeof ( struct STRUCT_OR_UNION_14 ) + VAR_340 ) ; VAR_341 += ( sizeof ( struct STRUCT_OR_UNION_15 ) + VAR_342 ) ; } break ; case ( VAR_343 << 8 | VAR_344 ) : case ( VAR_345 << 8 | VAR_346 ) : case ( VAR_347 << 8 | VAR_348 ) : case ( VAR_349 << 8 | VAR_350 ) : if ( VAR_351 < ( TYPE_21 ) sizeof ( struct STRUCT_OR_UNION_16 ) ) { METHOD_90 ( ( VAR_352 , ""invalid<S2SV_blank>len"" ) ) ; VAR_353 = 0 ; } else { METHOD_91 ( VAR_354 [ 0 ] , sizeof ( struct STRUCT_OR_UNION_17 ) ) ; METHOD_92 ( ( VAR_355 , ""%s"" , METHOD_93 ( VAR_356 , VAR_357 ) ) ) ; VAR_358 -= ( sizeof ( struct STRUCT_OR_UNION_18 ) ) ; VAR_359 += ( sizeof ( struct STRUCT_OR_UNION_19 ) ) ; } break ; case ( VAR_360 << 8 | VAR_361 ) : case ( VAR_362 << 8 | VAR_363 ) : case ( VAR_364 << 8 | VAR_365 ) : METHOD_94 ( VAR_366 [ 0 ] , VAR_367 ) ; METHOD_95 ( ( VAR_368 , ""%s"" , METHOD_96 ( VAR_369 , VAR_370 , VAR_371 ) ) ) ; VAR_372 += VAR_373 ; VAR_374 = 0 ; break ; case ( VAR_375 << 8 | VAR_376 ) : case ( VAR_377 << 8 | VAR_378 ) : case ( VAR_379 << 8 | VAR_380 ) : if ( VAR_381 < VAR_382 + 1 ) { METHOD_97 ( ( VAR_383 , ""invalid<S2SV_blank>len"" ) ) ; VAR_384 = 0 ; } else { METHOD_98 ( VAR_385 [ 0 ] , VAR_386 ) ; METHOD_99 ( ( VAR_387 , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , METHOD_100 ( VAR_388 , VAR_389 ) , METHOD_101 ( VAR_390 , VAR_391 + VAR_392 , VAR_393 - VAR_394 ) ) ) ; <S2SV_StartBug> if ( METHOD_102 ( VAR_395 + VAR_396 ) == 0x47000601 ) <S2SV_EndBug> METHOD_103 ( ( VAR_397 , ""<S2SV_blank>=<S2SV_blank>%s"" , METHOD_104 ( VAR_398 , VAR_399 + VAR_400 + 4 ) ) ) ; <S2SV_StartBug> else if ( METHOD_105 ( VAR_401 + VAR_402 ) == 0x350000 ) <S2SV_EndBug> METHOD_106 ( ( VAR_403 , ""<S2SV_blank>=<S2SV_blank>%s"" , METHOD_107 ( VAR_404 , VAR_405 + VAR_406 + 3 ) ) ) ; VAR_407 += VAR_408 ; VAR_409 = 0 ; } break ; default : METHOD_108 ( VAR_410 [ 0 ] , VAR_411 ) ; METHOD_109 ( ( VAR_412 , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , VAR_413 , VAR_414 ) ) ; if ( VAR_415 -> VAR_416 <= 1 ) METHOD_110 ( VAR_417 , VAR_418 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_419 ) ; VAR_420 += VAR_421 ; VAR_422 = 0 ; goto VAR_423 ; break ; } } } METHOD_111 ( ( VAR_424 , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , VAR_425 ) ) ; VAR_426 += VAR_427 ; METHOD_112 ( VAR_428 [ 0 ] ) ; VAR_429 = VAR_430 [ 0 ] ; VAR_431 ++ ; if ( VAR_432 ) { METHOD_113 ( ( VAR_433 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , VAR_434 ) ) ; for ( ; VAR_435 > 0 ; VAR_436 -- ) { METHOD_114 ( VAR_437 [ 0 ] ) ; METHOD_115 ( ( VAR_438 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , VAR_439 [ 0 ] ) ) ; VAR_440 += VAR_441 [ 0 ] + 1 ; } } else { METHOD_116 ( ( VAR_442 , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( VAR_443 < VAR_444 + VAR_445 ) { switch ( VAR_446 << 8 | VAR_447 ) { case ( VAR_448 << 8 | VAR_449 ) : case ( VAR_450 << 8 | VAR_451 ) : case ( VAR_452 << 8 | VAR_453 ) : VAR_454 = METHOD_117 ( VAR_455 , VAR_456 , VAR_457 , VAR_458 , sizeof ( VAR_459 ) ) ; if ( VAR_460 == - 1 ) METHOD_118 ( ( VAR_461 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_462 == - 2 ) goto VAR_463 ; else if ( VAR_464 == - 3 ) break ; else METHOD_119 ( ( VAR_465 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_466 ) ) ; break ; case ( VAR_467 << 8 | VAR_468 ) : VAR_469 = METHOD_120 ( VAR_470 , VAR_471 , VAR_472 , VAR_473 , sizeof ( VAR_474 ) ) ; if ( VAR_475 == - 1 ) METHOD_121 ( ( VAR_476 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_477 == - 2 ) goto VAR_478 ; else if ( VAR_479 == - 3 ) break ; else METHOD_122 ( ( VAR_480 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_481 ) ) ; break ; case ( VAR_482 << 8 | VAR_483 ) : case ( VAR_484 << 8 | VAR_485 ) : case ( VAR_486 << 8 | VAR_487 ) : VAR_488 = METHOD_123 ( VAR_489 , VAR_490 , VAR_491 , sizeof ( VAR_492 ) ) ; if ( VAR_493 == - 1 ) METHOD_124 ( ( VAR_494 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_495 == - 2 ) goto VAR_496 ; else METHOD_125 ( ( VAR_497 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_498 ) ) ; break ; case ( VAR_499 << 8 | VAR_500 ) : VAR_501 = METHOD_126 ( VAR_502 , VAR_503 , VAR_504 , sizeof ( VAR_505 ) ) ; if ( VAR_506 == - 1 ) METHOD_127 ( ( VAR_507 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_508 == - 2 ) goto VAR_509 ; else METHOD_128 ( ( VAR_510 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_511 ) ) ; break ; case ( VAR_512 << 8 | VAR_513 ) : case ( VAR_514 << 8 | VAR_515 ) : VAR_516 = METHOD_129 ( VAR_517 , VAR_518 , VAR_519 , sizeof ( VAR_520 ) ) ; if ( VAR_521 == - 1 ) METHOD_130 ( ( VAR_522 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_523 == - 2 ) goto VAR_524 ; else METHOD_131 ( ( VAR_525 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_526 ) ) ; break ; case ( VAR_527 << 8 | VAR_528 ) : VAR_529 = METHOD_132 ( VAR_530 , VAR_531 , VAR_532 , sizeof ( VAR_533 ) ) ; if ( VAR_534 == - 1 ) METHOD_133 ( ( VAR_535 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_536 == - 2 ) goto VAR_537 ; else METHOD_134 ( ( VAR_538 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_539 ) ) ; break ; case ( VAR_540 << 8 | VAR_541 ) : case ( VAR_542 << 8 | VAR_543 ) : case ( VAR_544 << 8 | VAR_545 ) : VAR_546 = METHOD_135 ( VAR_547 , VAR_548 , VAR_549 , VAR_550 , sizeof ( VAR_551 ) ) ; if ( VAR_552 == - 1 ) METHOD_136 ( ( VAR_553 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_554 == - 2 ) goto VAR_555 ; else if ( VAR_556 == - 3 ) break ; else METHOD_137 ( ( VAR_557 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_558 ) ) ; break ; case ( VAR_559 << 8 | VAR_560 ) : VAR_561 = METHOD_138 ( VAR_562 , VAR_563 , VAR_564 , VAR_565 , sizeof ( VAR_566 ) ) ; if ( VAR_567 == - 1 ) METHOD_139 ( ( VAR_568 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_569 == - 2 ) goto VAR_570 ; else if ( VAR_571 == - 3 ) break ; else METHOD_140 ( ( VAR_572 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_573 ) ) ; break ; case ( VAR_574 << 8 | VAR_575 ) : case ( VAR_576 << 8 | VAR_577 ) : case ( VAR_578 << 8 | VAR_579 ) : VAR_580 = METHOD_141 ( VAR_581 , VAR_582 , VAR_583 , sizeof ( VAR_584 ) ) ; if ( VAR_585 == - 1 ) METHOD_142 ( ( VAR_586 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_587 == - 2 ) goto VAR_588 ; else METHOD_143 ( ( VAR_589 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_590 ) ) ; break ; case ( VAR_591 << 8 | VAR_592 ) : case ( VAR_593 << 8 | VAR_594 ) : case ( VAR_595 << 8 | VAR_596 ) : case ( VAR_597 << 8 | VAR_598 ) : VAR_599 = METHOD_144 ( VAR_600 , VAR_601 , VAR_602 , sizeof ( VAR_603 ) ) ; if ( VAR_604 == - 1 ) METHOD_145 ( ( VAR_605 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( VAR_606 == - 2 ) goto VAR_607 ; else METHOD_146 ( ( VAR_608 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_609 ) ) ; break ; case ( VAR_610 << 8 | VAR_611 ) : case ( VAR_612 << 8 | VAR_613 ) : case ( VAR_614 << 8 | VAR_615 ) : VAR_616 = METHOD_147 ( VAR_617 , VAR_618 , VAR_619 , sizeof ( VAR_620 ) ) ; if ( VAR_621 == - 1 ) METHOD_148 ( ( VAR_622 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_623 == - 2 ) goto VAR_624 ; else METHOD_149 ( ( VAR_625 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_626 ) ) ; break ; case ( VAR_627 << 8 | VAR_628 ) : case ( VAR_629 << 8 | VAR_630 ) : case ( VAR_631 << 8 | VAR_632 ) : VAR_633 = METHOD_150 ( VAR_634 , VAR_635 , VAR_636 , sizeof ( VAR_637 ) ) ; if ( VAR_638 == - 1 ) METHOD_151 ( ( VAR_639 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_640 == - 2 ) goto VAR_641 ; else METHOD_152 ( ( VAR_642 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_643 ) ) ; break ; default : METHOD_153 ( * VAR_644 , VAR_645 ) ; METHOD_154 ( ( VAR_646 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , VAR_647 , VAR_648 ) ) ; if ( VAR_649 -> VAR_650 <= 1 ) METHOD_155 ( VAR_651 , VAR_652 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_653 ) ; VAR_654 = 0 ; VAR_655 = VAR_656 + VAR_657 ; break ; } if ( VAR_658 < 0 ) break ; VAR_659 += VAR_660 ; } VAR_661 : break ; case VAR_662 : METHOD_156 ( VAR_663 [ 0 ] , VAR_664 ) ; VAR_665 = METHOD_157 ( VAR_666 ) ; VAR_667 = VAR_668 [ 2 ] ; METHOD_158 ( ( VAR_669 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , METHOD_159 ( VAR_670 , ""Unknown<S2SV_blank>AFI"" , VAR_671 ) , VAR_672 , ( VAR_673 > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , METHOD_160 ( VAR_674 , ""Unknown<S2SV_blank>SAFI"" , VAR_675 ) , VAR_676 ) ) ; if ( VAR_677 == VAR_678 ) METHOD_161 ( ( VAR_679 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; VAR_680 += 3 ; while ( VAR_681 < VAR_682 + VAR_683 ) { switch ( VAR_684 << 8 | VAR_685 ) { case ( VAR_686 << 8 | VAR_687 ) : case ( VAR_688 << 8 | VAR_689 ) : case ( VAR_690 << 8 | VAR_691 ) : VAR_692 = METHOD_162 ( VAR_693 , VAR_694 , VAR_695 , VAR_696 , sizeof ( VAR_697 ) ) ; if ( VAR_698 == - 1 ) METHOD_163 ( ( VAR_699 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_700 == - 2 ) goto VAR_701 ; else if ( VAR_702 == - 3 ) break ; else METHOD_164 ( ( VAR_703 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_704 ) ) ; break ; case ( VAR_705 << 8 | VAR_706 ) : VAR_707 = METHOD_165 ( VAR_708 , VAR_709 , VAR_710 , VAR_711 , sizeof ( VAR_712 ) ) ; if ( VAR_713 == - 1 ) METHOD_166 ( ( VAR_714 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_715 == - 2 ) goto VAR_716 ; else if ( VAR_717 == - 3 ) break ; else METHOD_167 ( ( VAR_718 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_719 ) ) ; break ; case ( VAR_720 << 8 | VAR_721 ) : case ( VAR_722 << 8 | VAR_723 ) : case ( VAR_724 << 8 | VAR_725 ) : VAR_726 = METHOD_168 ( VAR_727 , VAR_728 , VAR_729 , sizeof ( VAR_730 ) ) ; if ( VAR_731 == - 1 ) METHOD_169 ( ( VAR_732 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_733 == - 2 ) goto VAR_734 ; else METHOD_170 ( ( VAR_735 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_736 ) ) ; break ; case ( VAR_737 << 8 | VAR_738 ) : case ( VAR_739 << 8 | VAR_740 ) : case ( VAR_741 << 8 | VAR_742 ) : VAR_743 = METHOD_171 ( VAR_744 , VAR_745 , VAR_746 , VAR_747 , sizeof ( VAR_748 ) ) ; if ( VAR_749 == - 1 ) METHOD_172 ( ( VAR_750 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_751 == - 2 ) goto VAR_752 ; else if ( VAR_753 == - 3 ) break ; else METHOD_173 ( ( VAR_754 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_755 ) ) ; break ; case ( VAR_756 << 8 | VAR_757 ) : VAR_758 = METHOD_174 ( VAR_759 , VAR_760 , VAR_761 , VAR_762 , sizeof ( VAR_763 ) ) ; if ( VAR_764 == - 1 ) METHOD_175 ( ( VAR_765 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_766 == - 2 ) goto VAR_767 ; else if ( VAR_768 == - 3 ) break ; else METHOD_176 ( ( VAR_769 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_770 ) ) ; break ; case ( VAR_771 << 8 | VAR_772 ) : case ( VAR_773 << 8 | VAR_774 ) : case ( VAR_775 << 8 | VAR_776 ) : VAR_777 = METHOD_177 ( VAR_778 , VAR_779 , VAR_780 , sizeof ( VAR_781 ) ) ; if ( VAR_782 == - 1 ) METHOD_178 ( ( VAR_783 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_784 == - 2 ) goto VAR_785 ; else METHOD_179 ( ( VAR_786 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_787 ) ) ; break ; case ( VAR_788 << 8 | VAR_789 ) : case ( VAR_790 << 8 | VAR_791 ) : case ( VAR_792 << 8 | VAR_793 ) : case ( VAR_794 << 8 | VAR_795 ) : VAR_796 = METHOD_180 ( VAR_797 , VAR_798 , VAR_799 , sizeof ( VAR_800 ) ) ; if ( VAR_801 == - 1 ) METHOD_181 ( ( VAR_802 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( VAR_803 == - 2 ) goto VAR_804 ; else METHOD_182 ( ( VAR_805 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_806 ) ) ; break ; case ( VAR_807 << 8 | VAR_808 ) : case ( VAR_809 << 8 | VAR_810 ) : case ( VAR_811 << 8 | VAR_812 ) : VAR_813 = METHOD_183 ( VAR_814 , VAR_815 , VAR_816 , sizeof ( VAR_817 ) ) ; if ( VAR_818 == - 1 ) METHOD_184 ( ( VAR_819 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_820 == - 2 ) goto VAR_821 ; else METHOD_185 ( ( VAR_822 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_823 ) ) ; break ; case ( VAR_824 << 8 | VAR_825 ) : case ( VAR_826 << 8 | VAR_827 ) : case ( VAR_828 << 8 | VAR_829 ) : VAR_830 = METHOD_186 ( VAR_831 , VAR_832 , VAR_833 , sizeof ( VAR_834 ) ) ; if ( VAR_835 == - 1 ) METHOD_187 ( ( VAR_836 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_837 == - 2 ) goto VAR_838 ; else METHOD_188 ( ( VAR_839 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_840 ) ) ; break ; case ( VAR_841 << 8 | VAR_842 ) : VAR_843 = METHOD_189 ( VAR_844 , VAR_845 , VAR_846 , sizeof ( VAR_847 ) ) ; if ( VAR_848 == - 1 ) METHOD_190 ( ( VAR_849 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_850 == - 2 ) goto VAR_851 ; else METHOD_191 ( ( VAR_852 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_853 ) ) ; break ; case ( VAR_854 << 8 | VAR_855 ) : case ( VAR_856 << 8 | VAR_857 ) : VAR_858 = METHOD_192 ( VAR_859 , VAR_860 , VAR_861 , sizeof ( VAR_862 ) ) ; if ( VAR_863 == - 1 ) METHOD_193 ( ( VAR_864 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( VAR_865 == - 2 ) goto VAR_866 ; else METHOD_194 ( ( VAR_867 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , VAR_868 ) ) ; break ; default : METHOD_195 ( * ( VAR_869 - 3 ) , VAR_870 ) ; METHOD_196 ( ( VAR_871 , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , VAR_872 , VAR_873 ) ) ; if ( VAR_874 -> VAR_875 <= 1 ) METHOD_197 ( VAR_876 , VAR_877 - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_878 ) ; VAR_879 = 0 ; VAR_880 = VAR_881 + VAR_882 ; break ; } if ( VAR_883 < 0 ) break ; VAR_884 += VAR_885 ; } break ; case VAR_886 : if ( VAR_887 % 8 ) { METHOD_198 ( ( VAR_888 , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( VAR_889 > 0 ) { TYPE_22 VAR_890 ; METHOD_199 ( VAR_891 [ 0 ] , 2 ) ; VAR_892 = METHOD_200 ( VAR_893 ) ; METHOD_201 ( ( VAR_894 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , METHOD_202 ( VAR_895 , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , VAR_896 ) , VAR_897 , METHOD_203 ( VAR_898 , ""none"" , VAR_899 ) ) ) ; METHOD_204 ( * ( VAR_900 + 2 ) , 6 ) ; switch ( VAR_901 ) { case VAR_902 : case VAR_903 : case VAR_904 : METHOD_205 ( ( VAR_905 , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , METHOD_206 ( VAR_906 + 2 ) , METHOD_207 ( VAR_907 + 4 ) , METHOD_208 ( VAR_908 , VAR_909 + 4 ) ) ) ; break ; case VAR_910 : case VAR_911 : case VAR_912 : case VAR_913 : METHOD_209 ( ( VAR_914 , "":<S2SV_blank>%s:%u"" , METHOD_210 ( VAR_915 , VAR_916 + 2 ) , METHOD_211 ( VAR_917 + 6 ) ) ) ; break ; case VAR_918 : case VAR_919 : METHOD_212 ( ( VAR_920 , "":<S2SV_blank>%s:%u"" , METHOD_213 ( VAR_921 , VAR_922 , sizeof ( VAR_923 ) , METHOD_214 ( VAR_924 + 2 ) ) , METHOD_215 ( VAR_925 + 6 ) ) ) ; break ; case VAR_926 : VAR_927 . VAR_928 = METHOD_216 ( VAR_929 + 2 ) ; METHOD_217 ( ( VAR_930 , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , VAR_931 . VAR_932 * 8 / 1000000 ) ) ; break ; case VAR_933 : case VAR_934 : case VAR_935 : case VAR_936 : case VAR_937 : case VAR_938 : METHOD_218 ( ( VAR_939 , ""%s"" , METHOD_219 ( VAR_940 , VAR_941 + 2 ) ) ) ; break ; case VAR_942 : case VAR_943 : METHOD_220 ( ( VAR_944 , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , METHOD_221 ( VAR_945 , VAR_946 + 2 ) , METHOD_222 ( VAR_947 , ""unknown<S2SV_blank>(0x%02x)"" , * ( VAR_948 + 6 ) ) , ( * ( VAR_949 + 7 ) & VAR_950 ) ? ""E2"" : """" , ( ( * ( VAR_951 + 6 ) == VAR_952 ) || ( * ( VAR_953 + 6 ) == VAR_954 ) ) ? ""E1"" : """" ) ) ; break ; case VAR_955 : METHOD_223 ( ( VAR_956 , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , METHOD_224 ( VAR_957 , ""unknown<S2SV_blank>encaps"" , * ( VAR_958 + 2 ) ) , * ( VAR_959 + 3 ) , METHOD_225 ( VAR_960 + 4 ) ) ) ; break ; case VAR_961 : METHOD_226 ( ( VAR_962 , "":<S2SV_blank>AS<S2SV_blank>%u"" , METHOD_227 ( VAR_963 + 2 ) ) ) ; break ; default : METHOD_228 ( * VAR_964 , 8 ) ; METHOD_229 ( VAR_965 , VAR_966 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } VAR_967 -= 8 ; VAR_968 += 8 ; } break ; case VAR_969 : { TYPE_23 VAR_970 , VAR_971 ; METHOD_230 ( VAR_972 [ 0 ] , 5 ) ; VAR_973 = * ( VAR_974 + 1 ) ; VAR_975 = * VAR_976 ; VAR_977 = VAR_978 ; METHOD_231 ( ( VAR_979 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , METHOD_232 ( VAR_980 , ""Unknown"" , VAR_981 ) , VAR_982 , METHOD_233 ( VAR_983 , ""none"" , VAR_984 ) , METHOD_234 ( VAR_985 + 2 ) >> 4 ) ) ; VAR_986 += 5 ; VAR_987 -= 5 ; switch ( VAR_988 ) { case VAR_989 : case VAR_990 : METHOD_235 ( VAR_991 [ 0 ] , 8 ) ; METHOD_236 ( ( VAR_992 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , METHOD_237 ( VAR_993 , VAR_994 ) , METHOD_238 ( VAR_995 , VAR_996 + 4 ) ) ) ; break ; case VAR_997 : METHOD_239 ( VAR_998 [ 0 ] , 8 ) ; METHOD_240 ( ( VAR_999 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , METHOD_241 ( VAR_1000 , VAR_1001 ) , METHOD_242 ( VAR_1002 , VAR_1003 + 4 ) ) ) ; break ; case VAR_1004 : METHOD_243 ( VAR_1005 [ 0 ] , 4 ) ; METHOD_244 ( ( VAR_1006 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , METHOD_245 ( VAR_1007 , VAR_1008 ) ) ) ; break ; case VAR_1009 : case VAR_1010 : METHOD_246 ( VAR_1011 [ 0 ] , 8 ) ; METHOD_247 ( ( VAR_1012 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , METHOD_248 ( VAR_1013 , VAR_1014 ) , METHOD_249 ( VAR_1015 + 4 ) ) ) ; break ; case VAR_1016 : METHOD_250 ( VAR_1017 [ 0 ] , 8 ) ; METHOD_251 ( ( VAR_1018 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , METHOD_252 ( VAR_1019 , VAR_1020 ) , METHOD_253 ( VAR_1021 + 4 ) ) ) ; break ; default : if ( VAR_1022 -> VAR_1023 <= 1 ) { METHOD_254 ( VAR_1024 , VAR_1025 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_1026 ) ; } } break ; } case VAR_1027 : { TYPE_24 VAR_1028 ; TYPE_25 VAR_1029 ; VAR_1030 = VAR_1031 ; while ( VAR_1032 >= 3 ) { METHOD_255 ( VAR_1033 [ 0 ] , 3 ) ; VAR_1034 = * VAR_1035 ; VAR_1036 = METHOD_256 ( VAR_1037 + 1 ) ; VAR_1038 += 3 ; VAR_1039 -= 3 ; METHOD_257 ( ( VAR_1040 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , METHOD_258 ( VAR_1041 , ""Unknown"" , VAR_1042 ) , VAR_1043 , VAR_1044 ) ) ; if ( VAR_1045 < 3 ) goto VAR_1046 ; VAR_1047 -= 3 ; METHOD_259 ( VAR_1048 [ 3 ] , VAR_1049 ) ; switch ( VAR_1050 ) { case VAR_1051 : if ( VAR_1052 < 8 ) goto VAR_1053 ; METHOD_260 ( ( VAR_1054 , "",<S2SV_blank>metric<S2SV_blank>%"" VAR_1055 , METHOD_261 ( VAR_1056 ) ) ) ; break ; default : if ( VAR_1057 -> VAR_1058 <= 1 ) { METHOD_262 ( VAR_1059 , VAR_1060 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_1061 ) ; } } VAR_1062 += VAR_1063 ; VAR_1064 -= VAR_1065 ; } break ; } case VAR_1066 : METHOD_263 ( VAR_1067 [ 0 ] , 4 ) ; if ( VAR_1068 < 4 ) goto VAR_1069 ; METHOD_264 ( ( VAR_1070 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , METHOD_265 ( VAR_1071 , VAR_1072 , sizeof ( VAR_1073 ) , METHOD_266 ( VAR_1074 ) ) ) ) ; VAR_1075 += 4 ; VAR_1076 -= 4 ; while ( VAR_1077 ) { TYPE_26 VAR_1078 , VAR_1079 , VAR_1080 ; METHOD_267 ( VAR_1081 [ 0 ] , 2 ) ; if ( VAR_1082 < 2 ) goto VAR_1083 ; VAR_1084 = * VAR_1085 ; VAR_1086 = * ( VAR_1087 + 1 ) ; VAR_1088 += 2 ; VAR_1089 -= 2 ; VAR_1090 = METHOD_268 ( VAR_1091 , VAR_1092 ) ; METHOD_269 ( VAR_1093 [ 0 ] , VAR_1094 ) ; if ( VAR_1095 < VAR_1096 ) goto VAR_1097 ; VAR_1098 = METHOD_270 ( VAR_1099 , VAR_1100 ) ; VAR_1101 += VAR_1102 ; VAR_1103 -= VAR_1104 ; METHOD_271 ( ( VAR_1105 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , METHOD_272 ( VAR_1106 , ""Unknown<S2SV_blank>Attribute"" , VAR_1107 ) , VAR_1108 , VAR_1109 ) ) ; if ( VAR_1110 ) { METHOD_273 ( ( VAR_1111 , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , VAR_1112 & 0x80 ? ""O"" : """" , VAR_1113 & 0x40 ? ""T"" : """" , VAR_1114 & 0x20 ? ""P"" : """" , VAR_1115 & 0x10 ? ""E"" : """" ) ) ; if ( VAR_1116 & 0xf ) METHOD_274 ( ( VAR_1117 , ""+%x"" , VAR_1118 & 0xf ) ) ; METHOD_275 ( ( VAR_1119 , ""]:<S2SV_blank>"" ) ) ; } if ( ! METHOD_276 ( VAR_1120 , VAR_1121 , VAR_1122 , VAR_1123 ) ) return 0 ; VAR_1124 += VAR_1125 ; VAR_1126 -= VAR_1127 ; } break ; case VAR_1128 : if ( VAR_1129 == 0 || VAR_1130 % 12 ) { METHOD_277 ( ( VAR_1131 , ""invalid<S2SV_blank>len"" ) ) ; break ; } METHOD_278 ( ( VAR_1132 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( VAR_1133 > 0 ) { METHOD_279 ( * VAR_1134 , 12 ) ; METHOD_280 ( ( VAR_1135 , ""%u:%u:%u%s"" , METHOD_281 ( VAR_1136 ) , METHOD_282 ( VAR_1137 + 4 ) , METHOD_283 ( VAR_1138 + 8 ) , ( VAR_1139 > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; VAR_1140 += 12 ; VAR_1141 -= 12 ; } break ; default : METHOD_284 ( * VAR_1142 , VAR_1143 ) ; METHOD_285 ( ( VAR_1144 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , VAR_1145 ) ) ; if ( VAR_1146 -> VAR_1147 <= 1 ) METHOD_286 ( VAR_1148 , VAR_1149 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_1150 ) ; break ; } if ( VAR_1151 -> VAR_1152 > 1 && VAR_1153 ) { METHOD_287 ( * VAR_1154 , VAR_1155 ) ; METHOD_288 ( VAR_1156 , VAR_1157 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_1158 ) ; } return 1 ; VAR_1159 : return 0 ; }",<S2SV_ModStart> ; if ( VAR_1064 == VAR_406 + 4 + sizeof ( struct STRUCT_OR_UNION_19 ) && <S2SV_ModStart> else if ( VAR_1064 == VAR_406 + 3 + sizeof ( struct STRUCT_OR_UNION_15 ) &&,"CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }",<S2SV_ModStart> ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) &&
107,"CWE-125 static const TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , register const struct STRUCT_OR_UNION_0 * VAR_1 , register TYPE_2 VAR_2 ) { register const TYPE_3 * VAR_3 ; TYPE_4 VAR_4 ; enum VAR_5 VAR_6 ; VAR_7 = ( ( const TYPE_5 * ) & VAR_8 -> VAR_9 ) + 1 ; METHOD_1 ( VAR_10 [ 1 ] ) ; VAR_11 = METHOD_2 ( & VAR_12 [ 1 ] ) ; if ( VAR_13 >= VAR_14 ) return ( VAR_15 ) ; VAR_16 += ( VAR_17 + ( 2 * sizeof ( TYPE_6 ) + 3 ) ) / sizeof ( TYPE_7 ) ; <S2SV_StartBug> METHOD_3 ( VAR_18 [ 0 ] , 0 ) ; <S2SV_EndBug> VAR_19 = ( enum VAR_20 ) METHOD_4 ( VAR_21 ) ; if ( VAR_22 != VAR_23 ) { METHOD_5 ( ( VAR_24 , ""<S2SV_blank>%s"" , METHOD_6 ( VAR_25 , ""ar_stat<S2SV_blank>%d"" , VAR_26 ) ) ) ; VAR_27 = 1 ; return ( VAR_28 ) ; } METHOD_7 ( * VAR_29 , sizeof ( VAR_30 ) ) ; return ( ( const TYPE_8 * ) ( sizeof ( VAR_31 ) + ( ( const TYPE_9 * ) VAR_32 ) ) ) ; VAR_33 : return ( 0 ) ; }",<S2SV_ModStart> TYPE_8 ) ; METHOD_1 <S2SV_ModEnd> ( VAR_32 [ <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ) ; VAR_31,"CWE-125 static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( sunrpc_str , ""ar_stat<S2SV_blank>%d"" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }",<S2SV_ModStart> uint32_t ) ; ND_TCHECK <S2SV_ModEnd> ( dp [ <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ) ; astat
108,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { TYPE_3 VAR_4 = METHOD_1 ( VAR_5 , VAR_6 ) - VAR_7 ; TYPE_4 VAR_8 = METHOD_2 ( VAR_9 ) ; TYPE_5 VAR_10 , VAR_11 = 0 ; TYPE_6 VAR_12 = 0 ; while ( VAR_13 && ( VAR_14 >= VAR_15 -> VAR_16 ) ) { VAR_17 -= VAR_18 -> VAR_19 ; ++ VAR_20 ; -- VAR_21 ; } while ( VAR_22 && ( VAR_23 > 0 ) ) { VAR_24 = min_t ( unsigned TYPE_7 , VAR_25 , VAR_26 -> VAR_27 - VAR_28 ) ; if ( METHOD_3 ( VAR_29 -> VAR_30 + VAR_31 , VAR_32 -> VAR_33 + VAR_34 , VAR_35 ) ) return - VAR_36 ; if ( VAR_37 > VAR_38 ) { ++ VAR_39 ; -- VAR_40 ; VAR_41 = 0 ; } else VAR_42 += VAR_43 ; VAR_44 -= VAR_45 ; VAR_46 += VAR_47 ; } if ( VAR_48 == VAR_49 ) return 0 ; while ( VAR_50 -- ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 [ VAR_51 ] ; TYPE_8 VAR_52 ; unsigned TYPE_9 VAR_53 ; unsigned TYPE_10 VAR_54 ; VAR_55 = VAR_56 -> VAR_57 - VAR_58 ; if ( ! VAR_59 ) { VAR_60 = 0 ; ++ VAR_61 ; continue ; } VAR_62 = ( unsigned TYPE_11 ) VAR_63 -> VAR_64 + VAR_65 ; VAR_66 = ( ( VAR_67 & ~ VAR_68 ) + VAR_69 + ~ VAR_70 ) >> VAR_71 ; <S2SV_StartBug> VAR_72 = METHOD_4 ( VAR_73 , VAR_74 , 0 , & STRUCT_OR_UNION_4 [ VAR_75 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( VAR_76 != VAR_77 ) || <S2SV_EndBug> ( VAR_78 > VAR_79 - METHOD_5 ( VAR_80 ) -> VAR_81 ) ) { for ( VAR_82 = 0 ; VAR_83 < VAR_84 ; VAR_85 ++ ) METHOD_6 ( STRUCT_OR_UNION_5 [ VAR_86 ] ) ; return - VAR_87 ; } VAR_88 = VAR_89 * VAR_90 ; VAR_91 -> VAR_92 += VAR_93 ; VAR_94 -> VAR_95 += VAR_96 ; VAR_97 -> VAR_98 += VAR_99 ; METHOD_7 ( VAR_100 , & VAR_101 -> VAR_102 -> VAR_103 ) ; while ( VAR_104 ) { TYPE_12 VAR_105 = VAR_106 & ~ VAR_107 ; TYPE_13 VAR_108 = min_t ( TYPE_14 , VAR_109 , VAR_110 - VAR_111 ) ; METHOD_8 ( VAR_112 , VAR_113 , STRUCT_OR_UNION_6 [ VAR_114 ] , VAR_115 , VAR_116 ) ; METHOD_9 ( VAR_117 ) -> VAR_118 ++ ; VAR_119 += VAR_120 ; VAR_121 -= VAR_122 ; VAR_123 ++ ; } VAR_124 = 0 ; ++ VAR_125 ; } return 0 ; }",<S2SV_ModStart> >> VAR_71 ; if ( VAR_123 + VAR_122 > VAR_79 ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> VAR_84 != VAR_122 <S2SV_ModStart> VAR_84 != VAR_122 <S2SV_ModEnd> ) { for,"CWE-119 static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ MAX_SKB_FRAGS ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; <S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - EFAULT ; } truesize = size * PAGE_SIZE ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ PAGE_MASK ; int size = min_t ( int , len , PAGE_SIZE - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }",<S2SV_ModStart> >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
109,"CWE-552 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = - 1 ; TYPE_4 * VAR_4 = METHOD_1 ( VAR_5 ) ; TYPE_5 * VAR_6 = VAR_7 ; <S2SV_StartBug> TYPE_6 VAR_8 = 0 ; <S2SV_EndBug> if ( ! VAR_9 || ! VAR_10 || VAR_11 < 0 || VAR_12 > VAR_13 ) METHOD_2 ( VAR_14 ) ; <S2SV_StartBug> if ( METHOD_3 ( VAR_15 , VAR_16 , & VAR_17 , & VAR_18 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> METHOD_4 ( VAR_19 ) ; <S2SV_EndBug> if ( METHOD_5 ( & VAR_20 , VAR_21 -> VAR_22 , VAR_23 , VAR_24 , VAR_25 ) != VAR_26 ) { METHOD_6 ( VAR_27 ) ; } <S2SV_StartBug> VAR_28 : <S2SV_EndBug> if ( VAR_29 ) METHOD_7 ( VAR_30 ) ; return VAR_31 ; }","<S2SV_ModStart> ; TYPE_6 VAR_25 = 0 ; TYPE_6 VAR_32 <S2SV_ModStart> , & VAR_25 , & VAR_32 <S2SV_ModStart> METHOD_6 ( VAR_19 ) ; if ( VAR_32 > VAR_33 ) METHOD_6 ( VAR_27 <S2SV_ModStart> ) ; } if ( VAR_31 > ( TYPE_3 ) VAR_32 ) { VAR_31 = - 1 ; METHOD_6 ( VAR_27 ) ; }","CWE-552 static ssize_t _hostsock_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }"
110,"CWE-416 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = 0 ; TYPE_2 VAR_2 ; TYPE_3 * VAR_3 = VAR_4 ; METHOD_1 ( ""Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n"" , METHOD_2 ( VAR_5 -> VAR_6 . VAR_7 ) , VAR_8 [ VAR_9 -> VAR_10 . VAR_11 ] , VAR_12 [ VAR_13 -> VAR_14 . VAR_15 ] , VAR_16 -> VAR_17 . VAR_18 , VAR_19 -> VAR_20 . VAR_21 , VAR_22 -> VAR_23 . VAR_24 ) ; switch ( VAR_25 -> VAR_26 . VAR_27 ) { case VAR_28 : VAR_29 -> VAR_30 = & VAR_31 ; break ; case VAR_32 : VAR_33 -> VAR_34 = & VAR_35 ; break ; case VAR_36 : VAR_37 -> VAR_38 = & VAR_39 ; break ; default : VAR_40 = - VAR_41 ; goto VAR_42 ; } VAR_43 -> VAR_44 = VAR_45 ; if ( ! VAR_46 -> VAR_47 . VAR_48 ) { VAR_49 = METHOD_3 ( VAR_50 , ""ipmi_si.%d"" , VAR_51 -> VAR_52 ) ; VAR_53 -> VAR_54 = METHOD_4 ( ""ipmi_si"" , VAR_55 -> VAR_56 ) ; if ( ! VAR_57 -> VAR_58 ) { METHOD_5 ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n"" ) ; VAR_59 = - VAR_60 ; goto VAR_61 ; } VAR_62 -> VAR_63 . VAR_64 = & VAR_65 -> VAR_66 -> VAR_67 ; VAR_68 -> VAR_69 . VAR_70 -> VAR_71 = & VAR_72 . VAR_73 ; VAR_74 -> VAR_75 . VAR_76 -> VAR_77 = VAR_78 ; } VAR_79 -> VAR_80 = METHOD_6 ( VAR_81 -> VAR_82 -> METHOD_7 ( ) , VAR_83 ) ; if ( ! VAR_84 -> VAR_85 ) { VAR_86 = - VAR_87 ; goto VAR_88 ; } VAR_89 -> VAR_90 . VAR_91 = VAR_92 -> VAR_93 -> METHOD_8 ( VAR_94 -> VAR_95 , & VAR_96 -> VAR_97 ) ; VAR_98 = VAR_99 -> VAR_100 . METHOD_9 ( & VAR_101 -> VAR_102 ) ; if ( VAR_103 ) { METHOD_10 ( VAR_104 -> VAR_105 . VAR_106 , ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n"" ) ; goto VAR_107 ; } if ( VAR_108 -> VAR_109 -> METHOD_11 ( VAR_110 -> VAR_111 ) ) { if ( VAR_112 -> VAR_113 . VAR_114 ) METHOD_12 ( VAR_115 -> VAR_116 . VAR_117 , ""Interface<S2SV_blank>detection<S2SV_blank>failed\\n"" ) ; VAR_118 = - VAR_119 ; goto VAR_120 ; } VAR_121 = METHOD_13 ( VAR_122 ) ; if ( VAR_123 ) { if ( VAR_124 -> VAR_125 . VAR_126 ) METHOD_14 ( VAR_127 -> VAR_128 . VAR_129 , ""There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n"" ) ; goto VAR_130 ; } METHOD_15 ( VAR_131 ) ; METHOD_16 ( VAR_132 ) ; METHOD_17 ( VAR_133 ) ; VAR_134 -> VAR_135 = VAR_136 ; VAR_137 -> VAR_138 = VAR_139 ; METHOD_18 ( & VAR_140 -> VAR_141 , 0 ) ; VAR_142 -> VAR_143 = VAR_144 ; for ( VAR_145 = 0 ; VAR_146 < VAR_147 ; VAR_148 ++ ) METHOD_19 ( & VAR_149 -> VAR_150 [ VAR_151 ] , 0 ) ; VAR_152 -> VAR_153 = VAR_154 ; METHOD_20 ( & VAR_155 -> VAR_156 , 0 ) ; VAR_157 = METHOD_21 ( VAR_158 ) ; if ( VAR_159 == 0 ) VAR_160 -> VAR_161 = VAR_162 ; METHOD_22 ( VAR_163 ) ; if ( VAR_164 -> VAR_165 . VAR_166 ) { VAR_167 -> VAR_168 = VAR_169 ; METHOD_23 ( & VAR_170 -> VAR_171 , 1 ) ; } if ( VAR_172 -> VAR_173 && ! VAR_174 -> VAR_175 ) { VAR_176 = METHOD_24 ( VAR_177 -> VAR_178 ) ; if ( VAR_179 ) { METHOD_25 ( VAR_180 -> VAR_181 . VAR_182 , ""Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n"" , VAR_183 ) ; goto VAR_184 ; } VAR_185 -> VAR_186 = VAR_187 ; } METHOD_26 ( VAR_188 -> VAR_189 . VAR_190 , VAR_191 ) ; VAR_192 = METHOD_27 ( VAR_193 -> VAR_194 . VAR_195 , & VAR_196 ) ; if ( VAR_197 ) { METHOD_28 ( VAR_198 -> VAR_199 . VAR_200 , ""Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n"" , VAR_201 ) ; goto VAR_202 ; } VAR_203 -> VAR_204 = VAR_205 ; VAR_206 = METHOD_29 ( & VAR_207 , VAR_208 , VAR_209 -> VAR_210 . VAR_211 , VAR_212 -> VAR_213 . VAR_214 ) ; if ( VAR_215 ) { METHOD_30 ( VAR_216 -> VAR_217 . VAR_218 , ""Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n"" , VAR_219 ) ; goto VAR_220 ; } VAR_221 ++ ; METHOD_31 ( VAR_222 -> VAR_223 . VAR_224 , ""IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n"" , VAR_225 [ VAR_226 -> VAR_227 . VAR_228 ] ) ; METHOD_32 ( VAR_229 -> VAR_230 . VAR_231 -> VAR_232 != VAR_233 ) ; VAR_234 : <S2SV_StartBug> METHOD_33 ( VAR_235 ) ; <S2SV_EndBug> return VAR_236 ; }",<S2SV_ModStart> ; VAR_234 : if ( VAR_236 && VAR_229 -> VAR_230 . METHOD_34 ) { VAR_229 -> VAR_230 . METHOD_34 ( & VAR_229 -> VAR_230 ) ; VAR_229 -> VAR_230 . METHOD_34 = VAR_233 ; },"CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( ""Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n"" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , ""ipmi_si.%d"" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( ""ipmi_si"" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n"" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n"" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , ""Interface<S2SV_blank>detection<S2SV_blank>failed\\n"" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , ""There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n"" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , ""Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n"" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , ""Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n"" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , ""Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n"" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , ""IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n"" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }",<S2SV_ModStart> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }
111,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { unsigned TYPE_2 VAR_3 , VAR_4 , VAR_5 , VAR_6 ; TYPE_3 VAR_7 = METHOD_1 ( VAR_8 ) ; struct STRUCT_OR_UNION_2 * VAR_9 = VAR_10 -> VAR_11 . VAR_12 ; struct STRUCT_OR_UNION_3 * VAR_13 = VAR_14 -> VAR_15 . VAR_16 ; VAR_17 = METHOD_2 ( VAR_18 , & VAR_19 -> VAR_20 ) ; if ( ! VAR_21 ) return 0 ; VAR_22 = METHOD_3 ( VAR_23 , & VAR_24 -> VAR_25 ) ; VAR_26 -> VAR_27 = METHOD_4 ( * VAR_28 ++ ) ; VAR_29 -> VAR_30 = METHOD_5 ( * VAR_31 ++ ) ; <S2SV_StartBug> VAR_32 = VAR_33 -> VAR_34 = METHOD_6 ( * VAR_35 ++ ) ; <S2SV_EndBug> if ( VAR_36 -> VAR_37 != VAR_38 -> VAR_39 ) return 0 ; VAR_40 = ( TYPE_4 * ) VAR_41 - VAR_42 -> VAR_43 ; VAR_44 = VAR_45 -> VAR_46 + VAR_47 -> VAR_48 . VAR_49 + VAR_50 -> VAR_51 - VAR_52 ; if ( VAR_53 < METHOD_7 ( VAR_54 ) * 4 ) return 0 ; if ( VAR_55 -> VAR_56 > VAR_57 ) { VAR_58 -> VAR_59 = VAR_60 ; VAR_61 = VAR_62 -> VAR_63 = VAR_64 ; } VAR_65 -> VAR_66 [ 0 ] . VAR_67 = ( TYPE_5 * ) VAR_68 ; VAR_69 -> VAR_70 [ 0 ] . VAR_71 = VAR_72 -> VAR_73 - VAR_74 ; VAR_75 = 0 ; while ( VAR_76 > VAR_77 -> VAR_78 [ VAR_79 ] . VAR_80 ) { VAR_81 -= VAR_82 -> VAR_83 [ VAR_84 ] . VAR_85 ; VAR_86 ++ ; VAR_87 -> VAR_88 [ VAR_89 ] . VAR_90 = METHOD_8 ( VAR_91 -> VAR_92 [ VAR_93 ] ) ; VAR_94 -> VAR_95 [ VAR_96 ] . VAR_97 = VAR_98 ; } VAR_99 -> VAR_100 [ VAR_101 ] . VAR_102 = VAR_103 ; VAR_104 -> VAR_105 = VAR_106 + 1 ; return 1 ; }",<S2SV_ModStart> VAR_68 ++ ) ; if ( ( TYPE_5 * ) VAR_68 > VAR_72 -> VAR_90 + VAR_72 -> VAR_102 ) return 0,"CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }",<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
112,"CWE-476 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; VAR_4 * VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 [ 3 ] ; TYPE_7 * VAR_8 ; TYPE_8 VAR_9 ; TYPE_9 VAR_10 ; if ( VAR_11 ) { METHOD_1 ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } METHOD_2 ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( METHOD_3 ( VAR_12 , & VAR_13 ) ) { METHOD_4 ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; return 0 ; } <S2SV_StartBug> if ( ! ( VAR_14 = METHOD_5 ( VAR_15 ) ) ) { <S2SV_EndBug> METHOD_6 ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! METHOD_7 ( & VAR_16 , VAR_17 ) ) { METHOD_8 ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; METHOD_9 ( VAR_18 ) ; return 0 ; } if ( ( VAR_19 = VAR_20 . VAR_21 - ( VAR_22 + VAR_23 + METHOD_10 ( VAR_24 ) ) ) < 0 ) { METHOD_11 ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; return 0 ; } if ( VAR_25 > 0 ) { METHOD_12 ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( METHOD_13 ( VAR_26 , VAR_27 ) ) { METHOD_14 ( VAR_28 ) ; return 0 ; } } VAR_29 = METHOD_15 ( VAR_30 ) ; for ( VAR_31 = 0 , VAR_32 = VAR_33 ; VAR_34 < VAR_35 ; ++ VAR_36 , ++ VAR_37 ) { VAR_38 -> VAR_39 = 0 ; VAR_40 -> VAR_41 = 0 ; VAR_42 -> VAR_43 = 1 ; VAR_44 -> VAR_45 = 1 ; VAR_46 -> VAR_47 = VAR_48 -> VAR_49 ; VAR_50 -> VAR_51 = VAR_52 -> VAR_53 ; VAR_54 -> VAR_55 = 8 ; VAR_56 -> VAR_57 = VAR_58 ; } if ( ! ( VAR_59 = METHOD_16 ( VAR_60 , VAR_61 , VAR_62 ) ) ) { METHOD_17 ( VAR_63 ) ; return 0 ; } if ( VAR_64 == 3 ) { METHOD_18 ( VAR_65 , VAR_66 ) ; METHOD_19 ( VAR_67 , 0 , METHOD_20 ( VAR_68 ) ) ; METHOD_21 ( VAR_69 , 1 , METHOD_22 ( VAR_70 ) ) ; METHOD_23 ( VAR_71 , 2 , METHOD_24 ( VAR_72 ) ) ; } else { METHOD_25 ( VAR_73 , VAR_74 ) ; METHOD_26 ( VAR_75 , 0 , METHOD_27 ( VAR_76 ) ) ; } if ( METHOD_28 ( VAR_77 , VAR_78 , VAR_79 ) ) { METHOD_29 ( VAR_80 ) ; METHOD_30 ( VAR_81 ) ; return 0 ; } METHOD_31 ( VAR_82 ) ; return VAR_83 ; }","<S2SV_ModStart> 0 ; } METHOD_32 ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , VAR_20 . VAR_84 , VAR_20 . VAR_85 , VAR_20 . VAR_86 , VAR_20 . VAR_87 , VAR_20 . VAR_21 ) ) ; <S2SV_ModStart> 0 ; } METHOD_32 ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\n"" , VAR_82 -> VAR_88 , VAR_82 -> VAR_49 , VAR_82 -> VAR_53 , VAR_82 -> VAR_89 , VAR_82 -> VAR_90 , VAR_82 -> VAR_91 , VAR_82 -> VAR_85 , VAR_82 -> VAR_92 , VAR_82 -> VAR_93 , VAR_82 -> VAR_94 , VAR_82 -> VAR_95 ) ) ;","CWE-476 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; if ( optstr ) { jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } jas_eprintf ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; return 0 ; } <S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; bmp_info_destroy ( info ) ; return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; return 0 ; } if ( n > 0 ) { jas_eprintf ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( bmp_gobble ( in , n ) ) { bmp_info_destroy ( info ) ; return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { bmp_info_destroy ( info ) ; return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { bmp_info_destroy ( info ) ; jas_image_destroy ( image ) ; return 0 ; } bmp_info_destroy ( info ) ; return image ; }","<S2SV_ModStart> 0 ; } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> 0 ; } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ;"
113,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , register const TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { register TYPE_4 VAR_3 ; const TYPE_5 * VAR_4 = """" ; for ( ; VAR_5 > 0 ; VAR_6 += VAR_7 , VAR_8 -= VAR_9 ) { TYPE_6 VAR_10 ; METHOD_1 ( ( VAR_11 , ""%s"" , VAR_12 ) ) ; VAR_13 = "","" ; METHOD_2 ( * VAR_14 ) ; VAR_15 = * VAR_16 ; METHOD_3 ( ( VAR_17 , ""%s"" , METHOD_4 ( VAR_18 , ""unknown<S2SV_blank>%u"" , VAR_19 ) ) ) ; if ( VAR_20 == VAR_21 || VAR_22 == VAR_23 ) VAR_24 = 1 ; else { METHOD_5 ( VAR_25 [ 1 ] ) ; VAR_26 = VAR_27 [ 1 ] ; if ( VAR_28 < 2 ) { METHOD_6 ( ( VAR_29 , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , VAR_30 ) ) ; return ; } } if ( VAR_31 > VAR_32 ) { METHOD_7 ( ( VAR_33 , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , VAR_34 ) ) ; return ; } METHOD_8 ( * VAR_35 , VAR_36 ) ; switch ( VAR_37 ) { case VAR_38 : return ; case VAR_39 : <S2SV_StartBug> METHOD_9 ( VAR_40 , VAR_41 , VAR_42 ) ; <S2SV_EndBug> break ; case VAR_43 : case VAR_44 : case VAR_45 : if ( METHOD_10 ( VAR_46 , VAR_47 , VAR_48 ) == - 1 ) goto VAR_49 ; break ; <S2SV_StartBug> case VAR_50 : <S2SV_EndBug> if ( VAR_51 < 4 ) { METHOD_11 ( ( VAR_52 , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , VAR_53 ) ) ; break ; } METHOD_12 ( VAR_54 [ 3 ] ) ; if ( METHOD_13 ( & VAR_55 [ 2 ] ) != 0 ) METHOD_14 ( ( VAR_56 , ""<S2SV_blank>value<S2SV_blank>%u"" , METHOD_15 ( & VAR_57 [ 2 ] ) ) ) ; break ; case VAR_58 : case VAR_59 : default : break ; } } return ; VAR_60 : METHOD_16 ( ( VAR_61 , ""%s"" , VAR_62 ) ) ; }","<S2SV_ModStart> case VAR_39 : if ( METHOD_9 <S2SV_ModEnd> ( VAR_61 , <S2SV_ModStart> break ; case VAR_43 : case VAR_44 : case VAR_45 : if ( METHOD_10 ( VAR_61 , VAR_57 , VAR_53 ) == - 1 ) goto VAR_60 ; break ; case","CWE-125 static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = """" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , ""%s"" , sep ) ) ; sep = "","" ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( ip_option_values , ""unknown<S2SV_blank>%u"" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : <S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> if ( option_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>value<S2SV_blank>%u"" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","<S2SV_ModStart> case IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo , <S2SV_ModStart> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case"
114,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; <S2SV_StartBug> VAR_8 = VAR_9 -> VAR_10 ; <S2SV_EndBug> VAR_11 = VAR_12 -> VAR_13 ; VAR_14 = VAR_15 -> VAR_16 . VAR_17 ; VAR_18 = ( TYPE_9 ) ( VAR_19 -> VAR_20 ) >> 18 ; VAR_21 = ( TYPE_10 ) ( VAR_22 -> VAR_23 ) >> 18 ; while ( VAR_24 -- ) { VAR_25 = METHOD_1 ( VAR_26 , ( VAR_27 - VAR_28 -> VAR_29 ) ) ; VAR_30 += METHOD_2 ( VAR_31 , VAR_32 -> VAR_33 ) ; * VAR_34 ++ = ( TYPE_11 ) VAR_35 ; VAR_36 -> VAR_37 += ( TYPE_12 ) VAR_38 ; if ( METHOD_3 ( VAR_39 -> VAR_40 ) ) { VAR_41 = VAR_42 ; VAR_43 -> VAR_44 = VAR_45 -> VAR_46 ; VAR_47 -> VAR_48 = ( 5 * VAR_49 -> VAR_50 + 1 ) ; VAR_51 = ( TYPE_13 ) ( VAR_52 -> VAR_53 ) >> 18 ; VAR_54 -> VAR_55 = METHOD_4 ( VAR_56 -> VAR_57 ) ; } } }","<S2SV_ModStart> -> VAR_24 ; if ( VAR_24 <= 0 ) { METHOD_5 ( ""b/26366256"" ) ; return ; }","CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }","<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; }"
115,"CWE-200 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 ) { static TYPE_2 TYPE_3 VAR_2 ; <S2SV_StartBug> TYPE_4 VAR_3 , VAR_4 ; <S2SV_EndBug> <S2SV_StartBug> METHOD_1 ( & TYPE_5 , sizeof ( TYPE_6 ) ) ; <S2SV_EndBug> VAR_5 = METHOD_2 ( ( TYPE_7 TYPE_8 ) VAR_6 -> VAR_7 , ( TYPE_9 TYPE_10 ) VAR_8 -> VAR_9 , <S2SV_StartBug> VAR_10 -> VAR_11 , <S2SV_EndBug> TYPE_11 ) ; VAR_12 = METHOD_3 ( VAR_13 , VAR_14 ) ; VAR_15 -> VAR_16 = METHOD_4 ( VAR_17 ) ; }","<S2SV_ModStart> TYPE_11 VAR_2 ; static TYPE_10 TYPE_12 VAR_2 ; <S2SV_ModStart> sizeof ( TYPE_11 ) ) ; METHOD_1 ( & TYPE_12 , sizeof ( TYPE_12 <S2SV_ModStart> VAR_15 -> VAR_11 ^ TYPE_12","CWE-200 void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }","<S2SV_ModStart> ip_idents_hashrnd __read_mostly ; static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip_idents_hashrnd ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> iph -> protocol ^ ip_idents_hashrnd_extra"
116,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , struct STRUCT_OR_UNION_0 * VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 ; if ( METHOD_1 ( VAR_4 ) > VAR_5 ) { METHOD_2 ( ""Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\""%s\\""<S2SV_blank>exceeds<S2SV_blank>%d,"" ""<S2SV_blank>protocol<S2SV_blank>error.\\n"" , VAR_6 , VAR_7 ) ; return - 1 ; } VAR_8 = METHOD_3 ( sizeof ( struct STRUCT_OR_UNION_2 ) , VAR_9 ) ; if ( ! VAR_10 ) { METHOD_4 ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for"" ""<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\n"" ) ; return - 1 ; } METHOD_5 ( & VAR_11 -> VAR_12 ) ; <S2SV_StartBug> METHOD_6 ( VAR_13 -> VAR_14 , VAR_15 , METHOD_7 ( VAR_16 ) + 1 ) ; <S2SV_EndBug> METHOD_8 ( VAR_17 -> VAR_18 , VAR_19 , <S2SV_StartBug> METHOD_9 ( VAR_20 ) + 1 ) ; <S2SV_EndBug> METHOD_10 ( & VAR_21 -> VAR_22 , & VAR_23 -> VAR_24 ) ; return 0 ; }","<S2SV_ModStart> VAR_22 ) ; METHOD_11 <S2SV_ModEnd> ( VAR_21 -> <S2SV_ModStart> , VAR_16 , sizeof ( VAR_21 -> VAR_16 ) ) ; METHOD_11 <S2SV_ModEnd> ( VAR_21 -> <S2SV_ModStart> , VAR_20 , sizeof ( VAR_21 -> VAR_18 ) <S2SV_ModEnd> ) ; METHOD_10","CWE-119 static int iscsi_add_notunderstood_response ( char * key , char * value , struct iscsi_param_list * param_list ) { struct iscsi_extra_response * extra_response ; if ( strlen ( value ) > VALUE_MAXLEN ) { pr_err ( ""Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\""%s\\""<S2SV_blank>exceeds<S2SV_blank>%d,"" ""<S2SV_blank>protocol<S2SV_blank>error.\\n"" , key , VALUE_MAXLEN ) ; return - 1 ; } extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ) ; if ( ! extra_response ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for"" ""<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\n"" ) ; return - 1 ; } INIT_LIST_HEAD ( & extra_response -> er_list ) ; <S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> strncpy ( extra_response -> value , NOTUNDERSTOOD , <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ; return 0 ; }","<S2SV_ModStart> er_list ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , key , sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail"
117,"CWE-16 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 TYPE_2 * VAR_0 , TYPE_3 VAR_1 ) <S2SV_EndBug> { <S2SV_StartBug> TYPE_4 VAR_2 = 0 ; <S2SV_EndBug> TYPE_5 VAR_3 [ 65 ] ; if ( VAR_4 -> VAR_5 & VAR_6 ) { <S2SV_StartBug> TYPE_6 * VAR_7 = VAR_8 ; <S2SV_EndBug> TYPE_7 VAR_9 = 0 ; <S2SV_StartBug> unsigned VAR_10 ; <S2SV_EndBug> while ( * VAR_11 ) { if ( * VAR_12 == '.' && ++ VAR_13 >= 3 ) break ; if ( ! METHOD_1 ( * VAR_14 ) && * VAR_15 != '.' ) break ; VAR_16 ++ ; } VAR_17 = ( ( VAR_18 >> 8 ) & 0xff ) + 40 ; <S2SV_StartBug> METHOD_2 ( VAR_19 , VAR_20 , ""2.6.%u%s"" , VAR_21 , VAR_22 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_23 = METHOD_3 ( VAR_24 , VAR_25 , VAR_26 ) ; <S2SV_EndBug> } return VAR_27 ; }","<S2SV_ModStart> * VAR_24 , TYPE_8 <S2SV_ModEnd> VAR_26 ) { <S2SV_ModStart> VAR_27 = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> VAR_6 ) { const <S2SV_ModStart> VAR_22 = VAR_8 ; TYPE_6 VAR_25 [ 65 ] = { 0 } <S2SV_ModStart> ; unsigned VAR_21 ; TYPE_8 VAR_28 <S2SV_ModStart> + 40 ; VAR_28 = METHOD_5 ( sizeof ( VAR_25 ) , METHOD_4 ( TYPE_8 , 1 , VAR_26 ) ) ; VAR_28 = METHOD_6 <S2SV_ModEnd> ( VAR_25 , <S2SV_ModStart> ( VAR_25 , VAR_28 <S2SV_ModEnd> , ""2.6.%u%s"" , <S2SV_ModStart> , VAR_25 , VAR_28 + 1 <S2SV_ModEnd> ) ; }","CWE-16 <S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> char buf [ 65 ] ; if ( current -> personality & UNAME26 ) { <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> int ndots = 0 ; <S2SV_StartBug> unsigned v ; <S2SV_EndBug> while ( * rest ) { if ( * rest == '.' && ++ ndots >= 3 ) break ; if ( ! isdigit ( * rest ) && * rest != '.' ) break ; rest ++ ; } v = ( ( LINUX_VERSION_CODE >> 8 ) & 0xff ) + 40 ; <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> } return ret ; }","<S2SV_ModStart> * release , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> UNAME26 ) { const <S2SV_ModStart> rest = UTS_RELEASE ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; unsigned v ; size_t copy <S2SV_ModStart> + 40 ; copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , copy <S2SV_ModEnd> , ""2.6.%u%s"" , <S2SV_ModStart> , buf , copy + 1 <S2SV_ModEnd> ) ; }"
118,CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) { <S2SV_StartBug> if ( VAR_1 == VAR_2 ) <S2SV_EndBug> return METHOD_1 ( VAR_3 ) ; return 0 ; },<S2SV_ModStart> VAR_1 == VAR_2 || VAR_1 == VAR_4,CWE-119 static int hns_gmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ; },<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
119,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 VAR_5 , TYPE_7 VAR_6 , TYPE_8 VAR_7 , TYPE_9 VAR_8 , TYPE_10 VAR_9 ) { TYPE_11 * const VAR_10 = & VAR_11 -> VAR_12 ; const struct STRUCT_OR_UNION_0 * const VAR_13 = & VAR_14 -> VAR_15 [ VAR_16 ] ; <S2SV_StartBug> struct STRUCT_OR_UNION_1 VAR_17 = { 0 } ; <S2SV_EndBug> VAR_18 . VAR_19 = VAR_20 ; VAR_21 . VAR_22 = VAR_23 ; <S2SV_StartBug> VAR_24 . VAR_25 = VAR_26 ; <S2SV_EndBug> if ( VAR_27 == 0 ) VAR_28 -> VAR_29 [ 0 ] -> VAR_30 . VAR_31 = VAR_32 ; METHOD_1 ( VAR_33 , VAR_34 , VAR_35 , VAR_36 . VAR_37 , VAR_38 . VAR_39 ) ; VAR_40 . VAR_41 = METHOD_2 ( VAR_42 , VAR_43 , VAR_44 -> VAR_45 , 0 ) ; METHOD_3 ( VAR_46 , VAR_47 , VAR_48 , VAR_49 , & VAR_50 ) ; <S2SV_StartBug> if ( VAR_51 . VAR_52 ) { <S2SV_EndBug> * VAR_53 = VAR_54 ; * VAR_55 = VAR_56 ; * VAR_57 = VAR_58 ; * VAR_59 = 0 ; } else { * VAR_60 = VAR_61 . VAR_62 ; * VAR_63 = VAR_64 . VAR_65 ; * VAR_66 = VAR_67 . VAR_68 ; <S2SV_StartBug> * VAR_69 = METHOD_4 ( VAR_70 , VAR_71 , VAR_72 ) ; <S2SV_EndBug> } }",<S2SV_ModStart> struct STRUCT_OR_UNION_1 VAR_67 ; METHOD_5 ( VAR_67 ) <S2SV_ModEnd> ; VAR_67 . <S2SV_ModStart> VAR_25 = VAR_26 ; VAR_67 . VAR_69 = 1 <S2SV_ModStart> ( VAR_67 . VAR_73 <S2SV_ModEnd> ) { * <S2SV_ModStart> * VAR_69 = VAR_67 . VAR_69 <S2SV_ModEnd> ; } },"CWE-119 static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> args . x = x ; args . best_rd = ref_best_rd ; <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ; vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ; args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ; vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ; <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } else { * distortion = args . this_dist ; * rate = args . this_rate ; * sse = args . this_sse ; <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> } }",<S2SV_ModStart> struct rdcost_block_args args ; vp9_zero ( args ) <S2SV_ModEnd> ; args . <S2SV_ModStart> use_fast_coef_costing = use_fast_coef_casting ; args . skippable = 1 <S2SV_ModStart> ( args . exit_early <S2SV_ModEnd> ) { * <S2SV_ModStart> * skippable = args . skippable <S2SV_ModEnd> ; } }
120,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; struct STRUCT_OR_UNION_2 * VAR_2 ; struct STRUCT_OR_UNION_3 * VAR_3 = METHOD_1 ( VAR_4 ) ; struct STRUCT_OR_UNION_4 * VAR_5 = METHOD_2 ( VAR_6 ) ; <S2SV_StartBug> struct STRUCT_OR_UNION_5 * VAR_7 = & VAR_8 -> VAR_9 . VAR_10 . VAR_11 . VAR_12 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_1 VAR_13 = 0 ; <S2SV_EndBug> TYPE_2 VAR_14 = METHOD_3 ( VAR_15 ) ; TYPE_3 VAR_16 = 0 ; if ( ( VAR_17 = METHOD_4 ( & VAR_18 -> VAR_19 ) ) == VAR_20 ) goto VAR_21 ; VAR_22 = METHOD_5 ( VAR_23 ) ; VAR_24 -> VAR_25 = VAR_26 -> VAR_27 ; VAR_28 -> VAR_29 = VAR_30 -> VAR_31 ; VAR_32 -> VAR_33 = METHOD_6 ( VAR_34 -> VAR_35 ) ; VAR_36 -> VAR_37 = 0 ; if ( VAR_38 ) VAR_39 = METHOD_7 ( VAR_40 , VAR_41 ) ; else if ( VAR_42 -> VAR_43 == VAR_44 ) { METHOD_8 ( VAR_45 , VAR_46 , & VAR_47 -> VAR_48 , & VAR_49 -> VAR_50 , VAR_51 -> VAR_52 ) ; goto VAR_53 ; } else VAR_54 = METHOD_9 ( VAR_55 , VAR_56 ) ; VAR_57 -> VAR_58 = METHOD_10 ( & VAR_59 -> VAR_60 , & VAR_61 -> VAR_62 , VAR_63 -> VAR_64 , VAR_65 -> VAR_66 , VAR_67 ) ; if ( VAR_68 -> VAR_69 == 0 ) VAR_70 -> VAR_71 = VAR_72 ; VAR_73 : VAR_74 = METHOD_11 ( VAR_75 ) ; if ( VAR_76 ) { if ( VAR_77 == - VAR_78 && ! METHOD_12 ( VAR_79 ) -> VAR_80 ) { METHOD_13 ( METHOD_14 ( VAR_81 ) , VAR_82 , VAR_83 ) ; VAR_84 = 0 ; } } else METHOD_15 ( METHOD_16 ( VAR_85 ) , VAR_86 , VAR_87 ) ; VAR_88 : VAR_89 -> VAR_90 = 0 ; VAR_91 -> VAR_92 = 0 ; return VAR_93 ; }",<S2SV_ModStart> struct STRUCT_OR_UNION_5 * VAR_65 ; TYPE_2 VAR_93 = 0 ; TYPE_2 VAR_87 = METHOD_3 ( VAR_85 ) ; TYPE_3 VAR_67 = 0 ; if ( VAR_91 -> VAR_92 == VAR_94 ) return METHOD_17 ( VAR_85 ) ; <S2SV_ModStart> . VAR_12 ; <S2SV_ModEnd> if ( (,"CWE-399 static int udp_v6_push_pending_frames ( struct sock * sk ) { struct sk_buff * skb ; struct udphdr * uh ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; <S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( ( skb = skb_peek ( & sk -> sk_write_queue ) ) == NULL ) goto out ; uh = udp_hdr ( skb ) ; uh -> source = fl6 -> fl6_sport ; uh -> dest = fl6 -> fl6_dport ; uh -> len = htons ( up -> len ) ; uh -> check = 0 ; if ( is_udplite ) csum = udplite_csum_outgoing ( sk , skb ) ; else if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { udp6_hwcsum_outgoing ( sk , skb , & fl6 -> saddr , & fl6 -> daddr , up -> len ) ; goto send ; } else csum = udp_csum_outgoing ( sk , skb ) ; uh -> check = csum_ipv6_magic ( & fl6 -> saddr , & fl6 -> daddr , up -> len , fl6 -> flowi6_proto , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; send : err = ip6_push_pending_frames ( sk ) ; if ( err ) { if ( err == - ENOBUFS && ! inet6_sk ( sk ) -> recverr ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; err = 0 ; } } else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_OUTDATAGRAMS , is_udplite ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }",<S2SV_ModStart> struct flowi6 * fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart> . ip6 ; <S2SV_ModEnd> if ( (
121,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = METHOD_1 ( VAR_3 ) ; struct STRUCT_OR_UNION_3 * VAR_4 ; struct STRUCT_OR_UNION_4 * STRUCT_OR_UNION_5 ; struct STRUCT_OR_UNION_6 * VAR_5 ; TYPE_1 VAR_6 ; TYPE_2 VAR_7 [ ] = { 0 , VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 } ; TYPE_3 VAR_14 = - VAR_15 ; VAR_16 [ 0 ] = VAR_17 ; STRUCT_OR_UNION_7 = METHOD_2 ( sizeof ( struct STRUCT_OR_UNION_8 ) , VAR_18 ) ; VAR_19 = METHOD_3 ( ) ; if ( ! STRUCT_OR_UNION_9 || ! VAR_20 ) { METHOD_4 ( & VAR_21 -> VAR_22 , ""cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\n"" ) ; goto VAR_23 ; } STRUCT_OR_UNION_10 -> VAR_24 = METHOD_5 ( VAR_25 , VAR_26 , VAR_27 , & STRUCT_OR_UNION_11 -> VAR_28 ) ; if ( ! STRUCT_OR_UNION_12 -> VAR_29 ) { METHOD_6 ( & VAR_30 -> VAR_31 , ""cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\n"" ) ; goto VAR_32 ; } STRUCT_OR_UNION_13 -> VAR_33 = METHOD_7 ( 0 , VAR_34 ) ; if ( ! STRUCT_OR_UNION_14 -> VAR_35 ) { METHOD_8 ( & VAR_36 -> VAR_37 , ""cannot<S2SV_blank>allocate<S2SV_blank>urb\\n"" ) ; goto VAR_38 ; } STRUCT_OR_UNION_15 -> VAR_39 = VAR_40 ; STRUCT_OR_UNION_16 -> VAR_41 = VAR_42 ; STRUCT_OR_UNION_17 -> VAR_43 = VAR_44 ; STRUCT_OR_UNION_18 -> VAR_45 = VAR_46 -> VAR_47 [ 0 ] . VAR_48 . VAR_49 ; STRUCT_OR_UNION_19 -> VAR_50 = 0 ; STRUCT_OR_UNION_20 -> VAR_51 = 0 ; STRUCT_OR_UNION_21 -> VAR_52 = 0 ; STRUCT_OR_UNION_22 -> VAR_53 = - 1 ; STRUCT_OR_UNION_23 -> VAR_54 . VAR_55 = VAR_56 ; STRUCT_OR_UNION_24 -> VAR_57 . VAR_58 = VAR_59 ; STRUCT_OR_UNION_25 -> VAR_60 . VAR_61 = VAR_62 ; STRUCT_OR_UNION_26 -> VAR_63 . VAR_64 = VAR_65 ; STRUCT_OR_UNION_27 -> VAR_66 . VAR_67 = VAR_68 ; STRUCT_OR_UNION_28 -> VAR_69 . VAR_70 = VAR_71 ; STRUCT_OR_UNION_29 -> VAR_72 . VAR_73 = VAR_74 ; STRUCT_OR_UNION_30 -> VAR_75 . VAR_76 = VAR_77 ; STRUCT_OR_UNION_31 -> VAR_78 . VAR_79 = VAR_80 ; STRUCT_OR_UNION_32 -> VAR_81 . VAR_82 = VAR_83 ; STRUCT_OR_UNION_33 -> VAR_84 . VAR_85 = VAR_86 ; STRUCT_OR_UNION_34 -> VAR_87 . VAR_88 = VAR_89 ; STRUCT_OR_UNION_35 -> VAR_90 = STRUCT_OR_UNION_36 -> VAR_91 ; METHOD_9 ( VAR_92 , STRUCT_OR_UNION_37 -> VAR_93 . VAR_94 , sizeof ( STRUCT_OR_UNION_38 -> VAR_95 . VAR_96 ) ) ; METHOD_10 ( STRUCT_OR_UNION_39 -> VAR_97 . VAR_98 , ""/input0"" , sizeof ( STRUCT_OR_UNION_40 -> VAR_99 . VAR_100 ) ) ; VAR_101 -> VAR_102 = ""Aiptek"" ; VAR_103 -> VAR_104 = STRUCT_OR_UNION_41 -> VAR_105 . VAR_106 ; METHOD_11 ( VAR_107 , & VAR_108 -> VAR_109 ) ; VAR_110 -> VAR_111 . VAR_112 = & VAR_113 -> VAR_114 ; METHOD_12 ( VAR_115 , STRUCT_OR_UNION_42 ) ; VAR_116 -> VAR_117 = VAR_118 ; VAR_119 -> VAR_120 = VAR_121 ; for ( VAR_122 = 0 ; VAR_123 < METHOD_13 ( VAR_124 ) ; ++ VAR_125 ) METHOD_14 ( VAR_126 [ VAR_127 ] , VAR_128 -> VAR_129 ) ; for ( VAR_130 = 0 ; VAR_131 < METHOD_15 ( VAR_132 ) ; ++ VAR_133 ) METHOD_16 ( VAR_134 [ VAR_135 ] , VAR_136 -> VAR_137 ) ; for ( VAR_138 = 0 ; VAR_139 < METHOD_17 ( VAR_140 ) ; ++ VAR_141 ) METHOD_18 ( VAR_142 [ VAR_143 ] , VAR_144 -> VAR_145 ) ; METHOD_19 ( VAR_146 , VAR_147 -> VAR_148 ) ; for ( VAR_149 = 0 ; VAR_150 < METHOD_20 ( VAR_151 ) ; ++ VAR_152 ) METHOD_21 ( VAR_153 [ VAR_154 ] , VAR_155 -> VAR_156 ) ; for ( VAR_157 = 0 ; VAR_158 < METHOD_22 ( VAR_159 ) ; ++ VAR_160 ) METHOD_23 ( VAR_161 [ VAR_162 ] , VAR_163 -> VAR_164 ) ; METHOD_24 ( VAR_165 , VAR_166 , 0 , 2999 , 0 , 0 ) ; METHOD_25 ( VAR_167 , VAR_168 , 0 , 2249 , 0 , 0 ) ; METHOD_26 ( VAR_169 , VAR_170 , 0 , 511 , 0 , 0 ) ; METHOD_27 ( VAR_171 , VAR_172 , VAR_173 , VAR_174 , 0 , 0 ) ; METHOD_28 ( VAR_175 , VAR_176 , VAR_177 , VAR_178 , 0 , 0 ) ; METHOD_29 ( VAR_179 , VAR_180 , VAR_181 , VAR_182 - 1 , 0 , 0 ) ; <S2SV_StartBug> VAR_183 = & VAR_184 -> VAR_185 [ 0 ] . VAR_186 [ 0 ] . VAR_187 ; <S2SV_EndBug> METHOD_30 ( STRUCT_OR_UNION_43 -> VAR_188 , STRUCT_OR_UNION_44 -> VAR_189 , METHOD_31 ( STRUCT_OR_UNION_45 -> VAR_190 , VAR_191 -> VAR_192 ) , STRUCT_OR_UNION_46 -> VAR_193 , 8 , VAR_194 , STRUCT_OR_UNION_47 , VAR_195 -> VAR_196 ) ; STRUCT_OR_UNION_48 -> VAR_197 -> VAR_198 = STRUCT_OR_UNION_49 -> VAR_199 ; STRUCT_OR_UNION_50 -> VAR_200 -> VAR_201 |= VAR_202 ; for ( VAR_203 = 0 ; VAR_204 < METHOD_32 ( VAR_205 ) ; ++ VAR_206 ) { STRUCT_OR_UNION_51 -> VAR_207 . VAR_208 = VAR_209 [ VAR_210 ] ; ( TYPE_4 ) METHOD_33 ( STRUCT_OR_UNION_52 ) ; if ( METHOD_34 ( STRUCT_OR_UNION_53 -> VAR_211 , VAR_212 ) > 0 ) { METHOD_35 ( & VAR_213 -> VAR_214 , ""Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\n"" , STRUCT_OR_UNION_54 -> VAR_215 . VAR_216 ) ; break ; } } if ( VAR_217 == METHOD_36 ( VAR_218 ) ) { METHOD_37 ( & VAR_219 -> VAR_220 , ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; <S2SV_StartBug> goto VAR_221 ; <S2SV_EndBug> } METHOD_38 ( VAR_222 , STRUCT_OR_UNION_55 ) ; VAR_223 = METHOD_39 ( & VAR_224 -> VAR_225 . VAR_226 , & VAR_227 ) ; if ( VAR_228 ) { METHOD_40 ( & VAR_229 -> VAR_230 , ""cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\n"" , VAR_231 ) ; goto VAR_232 ; } VAR_233 = METHOD_41 ( STRUCT_OR_UNION_56 -> VAR_234 ) ; if ( VAR_235 ) { METHOD_42 ( & VAR_236 -> VAR_237 , ""input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\n"" , VAR_238 ) ; goto VAR_239 ; } return 0 ; VAR_240 : METHOD_43 ( & VAR_241 -> VAR_242 . VAR_243 , & VAR_244 ) ; VAR_245 : METHOD_44 ( STRUCT_OR_UNION_57 -> VAR_246 ) ; VAR_247 : METHOD_45 ( VAR_248 , VAR_249 , STRUCT_OR_UNION_58 -> VAR_250 , STRUCT_OR_UNION_59 -> VAR_251 ) ; VAR_252 : METHOD_46 ( VAR_253 , VAR_254 ) ; METHOD_47 ( VAR_255 ) ; METHOD_48 ( STRUCT_OR_UNION_60 ) ; return VAR_256 ; }","<S2SV_ModStart> 0 ) ; if ( VAR_253 -> VAR_185 [ 0 ] . VAR_187 . VAR_257 < 1 ) { METHOD_49 ( & VAR_253 -> VAR_242 , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , VAR_253 -> VAR_185 [ 0 ] . VAR_187 . VAR_257 ) ; VAR_256 = - VAR_258 ; goto VAR_245 ; } <S2SV_ModStart> ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; VAR_256 = - VAR_258 ;","CWE-000 static int aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct usb_endpoint_descriptor * endpoint ; struct aiptek * aiptek ; struct input_dev * inputdev ; int i ; int speeds [ ] = { 0 , AIPTEK_PROGRAMMABLE_DELAY_50 , AIPTEK_PROGRAMMABLE_DELAY_400 , AIPTEK_PROGRAMMABLE_DELAY_25 , AIPTEK_PROGRAMMABLE_DELAY_100 , AIPTEK_PROGRAMMABLE_DELAY_200 , AIPTEK_PROGRAMMABLE_DELAY_300 } ; int err = - ENOMEM ; speeds [ 0 ] = programmableDelay ; aiptek = kzalloc ( sizeof ( struct aiptek ) , GFP_KERNEL ) ; inputdev = input_allocate_device ( ) ; if ( ! aiptek || ! inputdev ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\n"" ) ; goto fail1 ; } aiptek -> data = usb_alloc_coherent ( usbdev , AIPTEK_PACKET_LENGTH , GFP_ATOMIC , & aiptek -> data_dma ) ; if ( ! aiptek -> data ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\n"" ) ; goto fail1 ; } aiptek -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! aiptek -> urb ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>allocate<S2SV_blank>urb\\n"" ) ; goto fail2 ; } aiptek -> inputdev = inputdev ; aiptek -> usbdev = usbdev ; aiptek -> intf = intf ; aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; aiptek -> inDelay = 0 ; aiptek -> endDelay = 0 ; aiptek -> previousJitterable = 0 ; aiptek -> lastMacro = - 1 ; aiptek -> curSetting . pointerMode = AIPTEK_POINTER_EITHER_MODE ; aiptek -> curSetting . coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE ; aiptek -> curSetting . toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE ; aiptek -> curSetting . xTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . yTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON ; aiptek -> curSetting . mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON ; aiptek -> curSetting . mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON ; aiptek -> curSetting . stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON ; aiptek -> curSetting . stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON ; aiptek -> curSetting . jitterDelay = jitterDelay ; aiptek -> curSetting . programmableDelay = programmableDelay ; aiptek -> newSetting = aiptek -> curSetting ; usb_make_path ( usbdev , aiptek -> features . usbPath , sizeof ( aiptek -> features . usbPath ) ) ; strlcat ( aiptek -> features . usbPath , ""/input0"" , sizeof ( aiptek -> features . usbPath ) ) ; inputdev -> name = ""Aiptek"" ; inputdev -> phys = aiptek -> features . usbPath ; usb_to_input_id ( usbdev , & inputdev -> id ) ; inputdev -> dev . parent = & intf -> dev ; input_set_drvdata ( inputdev , aiptek ) ; inputdev -> open = aiptek_open ; inputdev -> close = aiptek_close ; for ( i = 0 ; i < ARRAY_SIZE ( eventTypes ) ; ++ i ) __set_bit ( eventTypes [ i ] , inputdev -> evbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( absEvents ) ; ++ i ) __set_bit ( absEvents [ i ] , inputdev -> absbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( relEvents ) ; ++ i ) __set_bit ( relEvents [ i ] , inputdev -> relbit ) ; __set_bit ( MSC_SERIAL , inputdev -> mscbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( buttonEvents ) ; ++ i ) __set_bit ( buttonEvents [ i ] , inputdev -> keybit ) ; for ( i = 0 ; i < ARRAY_SIZE ( macroKeyEvents ) ; ++ i ) __set_bit ( macroKeyEvents [ i ] , inputdev -> keybit ) ; input_set_abs_params ( inputdev , ABS_X , 0 , 2999 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_Y , 0 , 2249 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_PRESSURE , 0 , 511 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_X , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_Y , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_WHEEL , AIPTEK_WHEEL_MIN , AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; <S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ; aiptek -> urb -> transfer_dma = aiptek -> data_dma ; aiptek -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; for ( i = 0 ; i < ARRAY_SIZE ( speeds ) ; ++ i ) { aiptek -> curSetting . programmableDelay = speeds [ i ] ; ( void ) aiptek_program_tablet ( aiptek ) ; if ( input_abs_get_max ( aiptek -> inputdev , ABS_X ) > 0 ) { dev_info ( & intf -> dev , ""Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\n"" , aiptek -> curSetting . programmableDelay ) ; break ; } } if ( i == ARRAY_SIZE ( speeds ) ) { dev_info ( & intf -> dev , ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> } usb_set_intfdata ( intf , aiptek ) ; err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; if ( err ) { dev_warn ( & intf -> dev , ""cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\n"" , err ) ; goto fail3 ; } err = input_register_device ( aiptek -> inputdev ) ; if ( err ) { dev_warn ( & intf -> dev , ""input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\n"" , err ) ; goto fail4 ; } return 0 ; fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; fail3 : usb_free_urb ( aiptek -> urb ) ; fail2 : usb_free_coherent ( usbdev , AIPTEK_PACKET_LENGTH , aiptek -> data , aiptek -> data_dma ) ; fail1 : usb_set_intfdata ( intf , NULL ) ; input_free_device ( inputdev ) ; kfree ( aiptek ) ; return err ; }","<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; err = - EINVAL ;"
122,"CWE-416 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 * VAR_3 ; TYPE_5 VAR_4 , VAR_5 , VAR_6 , VAR_7 ; TYPE_6 VAR_8 , VAR_9 , VAR_10 , VAR_11 ; TYPE_7 VAR_12 ; TYPE_8 VAR_13 , VAR_14 ; VAR_15 = ( TYPE_9 * ) VAR_16 ; VAR_17 = METHOD_1 ( VAR_18 ) ; METHOD_2 ( VAR_19 , VAR_20 + 8 ) ; VAR_21 = METHOD_3 ( VAR_22 ) ; if ( VAR_23 ) VAR_24 -> VAR_25 = 1 ; if ( VAR_26 == 1 ) { METHOD_4 ( VAR_27 , VAR_28 + 8 + 20 + 4 ) ; VAR_29 = METHOD_5 ( VAR_30 ) ; VAR_31 = METHOD_6 ( VAR_32 ) ; VAR_33 = METHOD_7 ( VAR_34 ) ; VAR_35 = METHOD_8 ( VAR_36 ) ; VAR_37 = 0 ; if ( METHOD_9 ( VAR_38 ) ) VAR_39 ++ ; if ( METHOD_10 ( VAR_40 ) ) VAR_41 ++ ; if ( METHOD_11 ( VAR_42 ) ) VAR_43 ++ ; if ( METHOD_12 ( VAR_44 ) ) VAR_45 ++ ; if ( VAR_46 > 2 ) VAR_47 -> VAR_48 = 0 ; } METHOD_13 ( VAR_49 , VAR_50 ) ; VAR_51 = METHOD_14 ( ( TYPE_10 * ) VAR_52 , VAR_53 ) ; if ( VAR_54 ) return VAR_55 ; VAR_56 = METHOD_15 ( VAR_57 ) ; VAR_58 = ( TYPE_11 ) VAR_59 -> VAR_60 ; if ( METHOD_16 ( VAR_61 ) ) { VAR_62 -> VAR_63 |= 1 << 16 ; } VAR_64 = METHOD_17 ( VAR_65 , VAR_66 , VAR_67 ) ; if ( ! VAR_68 ) return VAR_69 ; if ( VAR_70 < 8 ) return VAR_71 ; METHOD_18 ( VAR_72 , VAR_73 ) ; VAR_74 = ( TYPE_12 * ) METHOD_19 ( sizeof ( TYPE_13 ) * VAR_75 ) ; METHOD_20 ( VAR_76 , VAR_77 , VAR_78 ) ; for ( VAR_79 = 0 ; VAR_80 < VAR_81 - 8 ; VAR_82 ++ ) { if ( METHOD_21 ( ( TYPE_14 ) VAR_83 [ VAR_84 + 4 ] , ( TYPE_15 ) VAR_85 [ VAR_86 + 5 ] , ( TYPE_16 ) VAR_87 [ VAR_88 + 6 ] , ( TYPE_17 ) VAR_89 [ VAR_90 + 7 ] ) == VAR_91 ) { <S2SV_StartBug> TYPE_18 * VAR_92 = METHOD_22 ( VAR_93 + VAR_94 , VAR_95 - VAR_96 , VAR_97 ) ; <S2SV_EndBug> if ( VAR_98 -> VAR_99 ) { <S2SV_StartBug> METHOD_23 ( ( TYPE_19 * ) VAR_100 -> VAR_101 ) ; <S2SV_EndBug> VAR_102 -> VAR_103 = VAR_104 ; } VAR_105 = METHOD_24 ( ( TYPE_20 * * ) & VAR_106 -> VAR_107 , VAR_108 ) ; if ( VAR_109 == VAR_110 ) { METHOD_25 ( ( TYPE_21 * ) VAR_111 , ( TYPE_22 * ) VAR_112 -> VAR_113 ) ; } else if ( VAR_114 -> VAR_115 ) { METHOD_26 ( ( TYPE_23 * ) VAR_116 -> VAR_117 ) ; VAR_118 -> VAR_119 = VAR_120 ; } METHOD_27 ( VAR_121 ) ; break ; } } METHOD_28 ( VAR_122 ) ; return VAR_123 ; }",<S2SV_ModStart> VAR_91 ) { extern TYPE_24 VAR_124 ; <S2SV_ModStart> VAR_119 ) { if ( ! VAR_124 ),"CWE-416 GF_Err audio_sample_entry_Read ( GF_Box * s , GF_BitStream * bs ) { GF_MPEGAudioSampleEntryBox * ptr ; char * data ; u8 a , b , c , d ; u32 i , size , v , nb_alnum ; GF_Err e ; u64 pos , start ; ptr = ( GF_MPEGAudioSampleEntryBox * ) s ; start = gf_bs_get_position ( bs ) ; gf_bs_seek ( bs , start + 8 ) ; v = gf_bs_read_u16 ( bs ) ; if ( v ) ptr -> is_qtff = 1 ; if ( v == 1 ) { gf_bs_seek ( bs , start + 8 + 20 + 4 ) ; a = gf_bs_read_u8 ( bs ) ; b = gf_bs_read_u8 ( bs ) ; c = gf_bs_read_u8 ( bs ) ; d = gf_bs_read_u8 ( bs ) ; nb_alnum = 0 ; if ( isalnum ( a ) ) nb_alnum ++ ; if ( isalnum ( b ) ) nb_alnum ++ ; if ( isalnum ( c ) ) nb_alnum ++ ; if ( isalnum ( d ) ) nb_alnum ++ ; if ( nb_alnum > 2 ) ptr -> is_qtff = 0 ; } gf_bs_seek ( bs , start ) ; e = gf_isom_audio_sample_entry_read ( ( GF_AudioSampleEntryBox * ) s , bs ) ; if ( e ) return e ; pos = gf_bs_get_position ( bs ) ; size = ( u32 ) s -> size ; if ( gf_bs_get_cookie ( bs ) ) { ptr -> is_qtff |= 1 << 16 ; } e = gf_isom_box_array_read ( s , bs , audio_sample_entry_AddBox ) ; if ( ! e ) return GF_OK ; if ( size < 8 ) return GF_ISOM_INVALID_FILE ; gf_bs_seek ( bs , pos ) ; data = ( char * ) gf_malloc ( sizeof ( char ) * size ) ; gf_bs_read_data ( bs , data , size ) ; for ( i = 0 ; i < size - 8 ; i ++ ) { if ( GF_4CC ( ( u32 ) data [ i + 4 ] , ( u8 ) data [ i + 5 ] , ( u8 ) data [ i + 6 ] , ( u8 ) data [ i + 7 ] ) == GF_ISOM_BOX_TYPE_ESDS ) { <S2SV_StartBug> GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ; <S2SV_EndBug> if ( ptr -> esd ) { <S2SV_StartBug> gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; <S2SV_EndBug> ptr -> esd = NULL ; } e = gf_isom_box_parse ( ( GF_Box * * ) & ptr -> esd , mybs ) ; if ( e == GF_OK ) { gf_isom_box_add_for_dump_mode ( ( GF_Box * ) ptr , ( GF_Box * ) ptr -> esd ) ; } else if ( ptr -> esd ) { gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; ptr -> esd = NULL ; } gf_bs_del ( mybs ) ; break ; } } gf_free ( data ) ; return e ; }",<S2SV_ModStart> GF_ISOM_BOX_TYPE_ESDS ) { extern Bool use_dump_mode ; <S2SV_ModStart> esd ) { if ( ! use_dump_mode )
123,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { <S2SV_StartBug> if ( * VAR_3 >= VAR_4 ) <S2SV_EndBug> <S2SV_StartBug> return VAR_5 ; <S2SV_EndBug> * VAR_6 = * VAR_7 + 1 ; VAR_8 [ * VAR_9 ] = VAR_10 ; return VAR_11 ; }","<S2SV_ModStart> * VAR_9 >= ( VAR_4 - 1 ) ) { METHOD_1 ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * VAR_9 ) ; METHOD_2 ( 0x534e4554 , ""34031018"" ) ; <S2SV_ModEnd> return VAR_5 ; <S2SV_ModStart> return VAR_5 ; }","CWE-119 static EAS_RESULT PushcdlStack ( EAS_U32 * pStack , EAS_INT * pStackPtr , EAS_U32 value ) { <S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> * pStackPtr = * pStackPtr + 1 ; pStack [ * pStackPtr ] = value ; return EAS_SUCCESS ; }","<S2SV_ModStart> * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ; <S2SV_ModEnd> return EAS_ERROR_FILE_FORMAT ; <S2SV_ModStart> return EAS_ERROR_FILE_FORMAT ; }"
124,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 ; while ( ( VAR_5 = METHOD_1 ( & VAR_6 -> VAR_7 ) ) != VAR_8 ) { struct STRUCT_OR_UNION_3 * VAR_9 ; struct STRUCT_OR_UNION_4 * VAR_10 ; TYPE_1 VAR_11 ; unsigned VAR_12 ; VAR_13 = * ( ( TYPE_2 * ) VAR_14 -> VAR_15 ) ; VAR_16 = VAR_17 -> VAR_18 [ VAR_19 ] . VAR_20 ; VAR_21 = & VAR_22 -> VAR_23 [ VAR_24 ] . VAR_25 ; if ( METHOD_2 ( METHOD_3 ( VAR_26 , VAR_27 , & VAR_28 ) ) ) { METHOD_4 ( VAR_29 -> VAR_30 , ""netback<S2SV_blank>grant<S2SV_blank>failed.\\n"" ) ; METHOD_5 ( VAR_31 ) -> VAR_32 = 0 ; METHOD_6 ( VAR_33 ) ; continue ; } VAR_34 = VAR_35 -> VAR_36 ; METHOD_7 ( VAR_37 -> VAR_38 , ( TYPE_3 * ) ( METHOD_8 ( VAR_39 , VAR_40 ) | VAR_41 -> VAR_42 ) , VAR_43 ) ; if ( VAR_44 < VAR_45 -> VAR_46 ) { VAR_47 -> VAR_48 += VAR_49 ; VAR_50 -> VAR_51 -= VAR_52 ; } else { <S2SV_StartBug> METHOD_9 ( VAR_53 , VAR_54 ) ; <S2SV_EndBug> } if ( VAR_55 -> VAR_56 & VAR_57 ) VAR_58 -> VAR_59 = VAR_60 ; else if ( VAR_61 -> VAR_62 & VAR_63 ) VAR_64 -> VAR_65 = VAR_66 ; METHOD_10 ( VAR_67 , VAR_68 ) ; if ( METHOD_11 ( VAR_69 ) < VAR_70 && METHOD_12 ( VAR_71 ) ) { TYPE_4 VAR_72 = min_t ( TYPE_5 , VAR_73 -> VAR_74 , VAR_75 ) ; METHOD_13 ( VAR_76 , VAR_77 - METHOD_14 ( VAR_78 ) ) ; } VAR_79 -> VAR_80 = VAR_81 -> VAR_82 ; VAR_83 -> VAR_84 = METHOD_15 ( VAR_85 , VAR_86 -> VAR_87 ) ; if ( METHOD_16 ( VAR_88 , VAR_89 ) ) { METHOD_17 ( VAR_90 -> VAR_91 , ""Can\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\n"" ) ; METHOD_18 ( VAR_92 ) ; continue ; } VAR_93 -> VAR_94 -> VAR_95 . VAR_96 += VAR_97 -> VAR_98 ; VAR_99 -> VAR_100 -> VAR_101 . VAR_102 ++ ; METHOD_19 ( VAR_103 , VAR_104 ) ; } }","<S2SV_ModStart> VAR_67 , VAR_54 , VAR_105","CWE-399 static void xen_netbk_tx_submit ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops ; struct sk_buff * skb ; while ( ( skb = __skb_dequeue ( & netbk -> tx_queue ) ) != NULL ) { struct xen_netif_tx_request * txp ; struct xenvif * vif ; u16 pending_idx ; unsigned data_len ; pending_idx = * ( ( u16 * ) skb -> data ) ; vif = netbk -> pending_tx_info [ pending_idx ] . vif ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; if ( unlikely ( xen_netbk_tx_check_gop ( netbk , skb , & gop ) ) ) { netdev_dbg ( vif -> dev , ""netback<S2SV_blank>grant<S2SV_blank>failed.\\n"" ) ; skb_shinfo ( skb ) -> nr_frags = 0 ; kfree_skb ( skb ) ; continue ; } data_len = skb -> len ; memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ; if ( data_len < txp -> size ) { txp -> offset += data_len ; txp -> size -= data_len ; } else { <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } if ( txp -> flags & XEN_NETTXF_csum_blank ) skb -> ip_summed = CHECKSUM_PARTIAL ; else if ( txp -> flags & XEN_NETTXF_data_validated ) skb -> ip_summed = CHECKSUM_UNNECESSARY ; xen_netbk_fill_frags ( netbk , skb ) ; if ( skb_headlen ( skb ) < PKT_PROT_LEN && skb_is_nonlinear ( skb ) ) { int target = min_t ( int , skb -> len , PKT_PROT_LEN ) ; __pskb_pull_tail ( skb , target - skb_headlen ( skb ) ) ; } skb -> dev = vif -> dev ; skb -> protocol = eth_type_trans ( skb , skb -> dev ) ; if ( checksum_setup ( vif , skb ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\n"" ) ; kfree_skb ( skb ) ; continue ; } vif -> dev -> stats . rx_bytes += skb -> len ; vif -> dev -> stats . rx_packets ++ ; xenvif_receive_skb ( vif , skb ) ; } }","<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY"
125,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 = VAR_5 -> VAR_6 ; const TYPE_6 * VAR_7 = VAR_8 -> VAR_9 & VAR_10 ? ""POST"" : ""GET"" ; TYPE_7 * VAR_11 , * VAR_12 , * VAR_13 , * VAR_14 , * VAR_15 , * VAR_16 ; TYPE_8 VAR_17 ; if ( VAR_18 [ 0 ] == '\\0' ) { VAR_19 -> VAR_20 = 1 ; return 0 ; } VAR_21 = VAR_22 ; if ( VAR_23 == 0 ) { if ( VAR_24 -> VAR_25 ) { VAR_26 = VAR_27 ; while ( * VAR_28 && ! METHOD_1 ( * VAR_29 ) ) VAR_30 ++ ; * ( VAR_31 ++ ) = '\\0' ; METHOD_2 ( VAR_32 , VAR_33 , ""Received<S2SV_blank>method:<S2SV_blank>%s\\n"" , VAR_34 ) ; if ( VAR_35 -> VAR_36 ) { if ( METHOD_3 ( VAR_37 -> VAR_38 , VAR_39 ) ) { METHOD_4 ( VAR_40 , VAR_41 , ""Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\n"" , VAR_42 -> VAR_43 , VAR_44 ) ; return METHOD_5 ( 400 , METHOD_6 ( VAR_45 ) ) ; } } else { METHOD_7 ( VAR_46 , VAR_47 , ""Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\n"" , VAR_48 ) ; if ( METHOD_8 ( VAR_49 , VAR_50 ) ) { METHOD_9 ( VAR_51 , VAR_52 , ""Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\n"" , VAR_53 , VAR_54 ) ; return METHOD_10 ( 400 , METHOD_11 ( VAR_55 ) ) ; } if ( ! ( VAR_56 -> VAR_57 = METHOD_12 ( VAR_58 ) ) ) return METHOD_13 ( VAR_59 ) ; } while ( METHOD_14 ( * VAR_60 ) ) VAR_61 ++ ; VAR_62 = VAR_63 ; while ( ! METHOD_15 ( * VAR_64 ) ) VAR_65 ++ ; * ( VAR_66 ++ ) = '\\0' ; METHOD_16 ( VAR_67 , VAR_68 , ""Requested<S2SV_blank>resource:<S2SV_blank>%s\\n"" , VAR_69 ) ; if ( ! ( VAR_70 -> VAR_71 = METHOD_17 ( VAR_72 ) ) ) return METHOD_18 ( VAR_73 ) ; while ( METHOD_19 ( * VAR_74 ) ) VAR_75 ++ ; VAR_76 = VAR_77 ; while ( * VAR_78 && ! METHOD_20 ( * VAR_79 ) ) VAR_80 ++ ; * VAR_81 = '\\0' ; if ( METHOD_21 ( VAR_82 , ""HTTP/"" , 5 ) ) { METHOD_22 ( VAR_83 , VAR_84 , ""Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\n"" ) ; return METHOD_23 ( 400 , METHOD_24 ( VAR_85 ) ) ; } METHOD_25 ( VAR_86 , VAR_87 , ""HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\n"" , VAR_88 ) ; } else { while ( ! METHOD_26 ( * VAR_89 ) && * VAR_90 != '\\0' ) VAR_91 ++ ; while ( METHOD_27 ( * VAR_92 ) ) VAR_93 ++ ; VAR_94 -> VAR_95 = METHOD_28 ( VAR_96 , & VAR_97 , 10 ) ; METHOD_29 ( VAR_98 , VAR_99 , ""http_code=%d\\n"" , VAR_100 -> VAR_101 ) ; if ( ( VAR_102 = METHOD_30 ( VAR_103 , VAR_104 -> VAR_105 , VAR_106 ) ) < 0 ) return VAR_107 ; } } else { while ( * VAR_108 != '\\0' && * VAR_109 != ':' ) VAR_110 ++ ; if ( * VAR_111 != ':' ) return 1 ; * VAR_112 = '\\0' ; VAR_113 = VAR_114 ; VAR_115 ++ ; while ( METHOD_31 ( * VAR_116 ) ) VAR_117 ++ ; if ( ! METHOD_32 ( VAR_118 , ""Location"" ) ) { if ( ( VAR_119 = METHOD_33 ( VAR_120 , VAR_121 ) ) < 0 ) return VAR_122 ; * VAR_123 = 1 ; <S2SV_StartBug> } else if ( ! METHOD_34 ( VAR_124 , ""Content-Length"" ) && VAR_125 -> VAR_126 == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> VAR_127 -> VAR_128 = METHOD_35 ( VAR_129 , VAR_130 , 10 ) ; <S2SV_EndBug> } else if ( ! METHOD_36 ( VAR_131 , ""Content-Range"" ) ) { METHOD_37 ( VAR_132 , VAR_133 ) ; } else if ( ! METHOD_38 ( VAR_134 , ""Accept-Ranges"" ) && ! METHOD_39 ( VAR_135 , ""bytes"" , 5 ) && VAR_136 -> VAR_137 == - 1 ) { VAR_138 -> VAR_139 = 0 ; } else if ( ! METHOD_40 ( VAR_140 , ""Transfer-Encoding"" ) && ! METHOD_41 ( VAR_141 , ""chunked"" , 7 ) ) { <S2SV_StartBug> VAR_142 -> VAR_143 = - 1 ; <S2SV_EndBug> VAR_144 -> VAR_145 = 0 ; } else if ( ! METHOD_42 ( VAR_146 , ""WWW-Authenticate"" ) ) { <S2SV_StartBug> METHOD_43 ( & VAR_147 -> VAR_148 , VAR_149 , VAR_150 ) ; <S2SV_EndBug> } else if ( ! METHOD_44 ( VAR_151 , ""Authentication-Info"" ) ) { METHOD_45 ( & VAR_152 -> VAR_153 , VAR_154 , VAR_155 ) ; } else if ( ! METHOD_46 ( VAR_156 , ""Proxy-Authenticate"" ) ) { METHOD_47 ( & VAR_157 -> VAR_158 , VAR_159 , VAR_160 ) ; } else if ( ! METHOD_48 ( VAR_161 , ""Connection"" ) ) { if ( ! METHOD_49 ( VAR_162 , ""close"" ) ) VAR_163 -> VAR_164 = 1 ; } else if ( ! METHOD_50 ( VAR_165 , ""Server"" ) ) { if ( ! METHOD_51 ( VAR_166 , ""AkamaiGHost"" ) ) { VAR_167 -> VAR_168 = 1 ; } else if ( ! METHOD_52 ( VAR_169 , ""MediaGateway"" , 12 ) ) { VAR_170 -> VAR_171 = 1 ; } } else if ( ! METHOD_53 ( VAR_172 , ""Content-Type"" ) ) { METHOD_54 ( VAR_173 -> VAR_174 ) ; VAR_175 -> VAR_176 = METHOD_55 ( VAR_177 ) ; } else if ( ! METHOD_56 ( VAR_178 , ""Set-Cookie"" ) ) { if ( METHOD_57 ( VAR_179 , VAR_180 , & VAR_181 -> VAR_182 ) ) METHOD_58 ( VAR_183 , VAR_184 , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'%s\'\\n"" , VAR_185 ) ; } else if ( ! METHOD_59 ( VAR_186 , ""Icy-MetaInt"" ) ) { <S2SV_StartBug> VAR_187 -> VAR_188 = METHOD_60 ( VAR_189 , VAR_190 , 10 ) ; <S2SV_EndBug> } else if ( ! METHOD_61 ( VAR_191 , ""Icy-"" , 4 ) ) { if ( ( VAR_192 = METHOD_62 ( VAR_193 , VAR_194 , VAR_195 ) ) < 0 ) return VAR_196 ; } else if ( ! METHOD_63 ( VAR_197 , ""Content-Encoding"" ) ) { if ( ( VAR_198 = METHOD_64 ( VAR_199 , VAR_200 ) ) < 0 ) return VAR_201 ; } } return 1 ; }","<S2SV_ModStart> -> VAR_143 == VAR_202 <S2SV_ModEnd> ) { VAR_193 <S2SV_ModStart> -> VAR_143 = METHOD_65 <S2SV_ModEnd> ( VAR_200 , <S2SV_ModStart> -> VAR_143 = VAR_202 ; VAR_193 -> VAR_145 = 0 ; } else if ( ! METHOD_63 ( VAR_197 , ""WWW-Authenticate"" ) ) { METHOD_47 ( & VAR_193 -> VAR_153 , VAR_197 , VAR_200 ) ; } else if ( ! METHOD_63 ( VAR_197 , ""Authentication-Info"" ) ) { METHOD_47 ( & VAR_193 -> VAR_153 , VAR_197 , VAR_200 ) ; } else if ( ! METHOD_63 ( VAR_197 , ""Proxy-Authenticate"" ) ) { METHOD_47 ( & VAR_193 -> VAR_158 , VAR_197 , VAR_200 ) ; } else if ( ! METHOD_63 ( VAR_197 , ""Connection"" ) ) { if ( ! METHOD_49 ( VAR_200 , ""close"" ) ) VAR_193 -> VAR_164 = 1 ; } else if ( ! METHOD_63 ( VAR_197 , ""Server"" ) ) { if ( ! METHOD_63 ( VAR_200 , ""AkamaiGHost"" ) ) { VAR_193 -> VAR_168 = 1 ; } else if ( ! METHOD_61 ( VAR_200 , ""MediaGateway"" , 12 ) ) { VAR_193 -> VAR_171 = 1 ; } } else if ( ! METHOD_63 ( VAR_197 , ""Content-Type"" ) ) { METHOD_54 ( VAR_193 -> VAR_176 ) ; VAR_193 -> VAR_176 = METHOD_55 ( VAR_200 ) ; } else if ( ! METHOD_63 ( VAR_197 , ""Set-Cookie"" ) ) { if ( METHOD_57 ( VAR_193 , VAR_200 , <S2SV_ModEnd> & VAR_193 -> <S2SV_ModStart> & VAR_193 -> <S2SV_ModEnd> VAR_182 ) ) <S2SV_ModStart> -> VAR_188 = METHOD_65 <S2SV_ModEnd> ( VAR_200 ,","CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? ""POST"" : ""GET"" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , ""Received<S2SV_blank>method:<S2SV_blank>%s\\n"" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , ""Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\n"" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , ""Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\n"" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , ""Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\n"" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , ""Requested<S2SV_blank>resource:<S2SV_blank>%s\\n"" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\0' ; if ( av_strncasecmp ( version , ""HTTP/"" , 5 ) ) { av_log ( h , AV_LOG_ERROR , ""Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\n"" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , ""HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\n"" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , ""http_code=%d\\n"" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , ""Location"" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , ""Content-Range"" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , ""Accept-Ranges"" ) && ! strncmp ( p , ""bytes"" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , ""Transfer-Encoding"" ) && ! av_strncasecmp ( p , ""chunked"" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'%s\'\\n"" , p ) ; } else if ( ! av_strcasecmp ( tag , ""Icy-MetaInt"" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , ""Icy-"" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , ""Content-Encoding"" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }","<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,"
126,"CWE-74 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 ; TYPE_1 VAR_4 [ 256 ] ; TYPE_2 VAR_5 ; TYPE_3 VAR_6 = VAR_7 , VAR_8 = VAR_9 ; if ( VAR_10 -> VAR_11 == VAR_12 ) return 0 ; if ( VAR_13 -> VAR_14 == VAR_15 ) return - 1 ; VAR_16 -> VAR_17 = VAR_18 ; if ( METHOD_1 ( VAR_19 ) < 0 ) return - 1 ; if ( METHOD_2 ( VAR_20 , sizeof ( VAR_21 ) , VAR_22 ) < 0 ) return METHOD_3 ( VAR_23 ) ; if ( METHOD_4 ( VAR_24 , ""200"" , VAR_25 ) ) VAR_26 = VAR_27 ; else if ( ! METHOD_5 ( VAR_28 , ""201"" , VAR_29 ) ) { METHOD_6 ( VAR_30 ) ; METHOD_7 ( VAR_31 ) ; METHOD_8 ( ""%s"" , VAR_32 ) ; return - 1 ; } VAR_33 = METHOD_9 ( VAR_34 ) ; if ( VAR_35 < 0 ) return - 1 ; if ( VAR_36 > 0 ) { if ( ( METHOD_10 ( VAR_37 , ""MODE<S2SV_blank>READER\\r\\n"" ) < 0 ) || ( METHOD_11 ( VAR_38 , sizeof ( VAR_39 ) , VAR_40 ) < 0 ) ) { return METHOD_12 ( VAR_41 ) ; } if ( METHOD_13 ( VAR_42 , ""200"" , VAR_43 ) ) VAR_44 = VAR_45 ; else if ( METHOD_14 ( VAR_46 , ""201"" , VAR_47 ) ) VAR_48 = VAR_49 ; else if ( VAR_50 -> VAR_51 ) { METHOD_15 ( VAR_52 ) ; METHOD_16 ( METHOD_17 ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } if ( VAR_53 -> VAR_54 ) { VAR_55 = METHOD_18 ( VAR_56 ) ; if ( VAR_57 < 0 ) return - 1 ; } } METHOD_19 ( METHOD_20 ( ""Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s"" ) , VAR_58 -> VAR_59 . VAR_60 , VAR_61 ? METHOD_21 ( ""Posting<S2SV_blank>is<S2SV_blank>ok"" ) : METHOD_22 ( ""Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok"" ) ) ; METHOD_23 ( 1 ) ; TYPE_4 TYPE_5 if ( ( VAR_62 -> VAR_63 != 1 ) && ( VAR_64 -> VAR_65 || VAR_66 ) ) { if ( VAR_67 -> VAR_68 == 0 ) { VAR_69 -> VAR_70 = VAR_71 || METHOD_24 ( VAR_72 , METHOD_25 ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) == VAR_73 ? 2 : 1 ; } if ( VAR_74 -> VAR_75 == 2 ) { if ( ( METHOD_26 ( VAR_76 , ""STARTTLS\\r\\n"" ) < 0 ) || ( METHOD_27 ( VAR_77 , sizeof ( VAR_78 ) , VAR_79 ) < 0 ) ) { return METHOD_28 ( VAR_80 ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! METHOD_29 ( VAR_81 , ""382"" , VAR_82 ) ) { VAR_83 -> VAR_84 = 0 ; METHOD_30 ( ""STARTTLS:<S2SV_blank>%s"" , VAR_85 ) ; } else if ( METHOD_31 ( VAR_86 ) ) { VAR_87 -> VAR_88 = 0 ; VAR_89 -> VAR_90 = VAR_91 ; METHOD_32 ( VAR_92 -> VAR_93 ) ; METHOD_33 ( METHOD_34 ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 1 ; } else { VAR_94 = METHOD_35 ( VAR_95 ) ; if ( VAR_96 < 0 ) return - 1 ; } } } if ( VAR_97 -> VAR_98 . VAR_99 & VAR_100 ) { if ( ! VAR_101 -> VAR_102 . VAR_103 [ 0 ] ) VAR_104 = VAR_105 ; } else { if ( ( METHOD_36 ( VAR_106 , ""STAT\\r\\n"" ) < 0 ) || ( METHOD_37 ( VAR_107 , sizeof ( VAR_108 ) , VAR_109 ) < 0 ) ) { return METHOD_38 ( VAR_110 ) ; } if ( ! METHOD_39 ( VAR_111 , ""480"" , VAR_112 ) ) VAR_113 = VAR_114 ; } if ( VAR_115 && ( METHOD_40 ( VAR_116 ) < 0 ) ) return - 1 ; if ( VAR_117 -> VAR_118 && ( VAR_119 || ( VAR_120 > 0 ) ) ) { VAR_121 = METHOD_41 ( VAR_122 ) ; if ( VAR_123 < 0 ) return - 1 ; if ( VAR_124 > 0 ) { METHOD_42 ( VAR_125 ) ; METHOD_43 ( METHOD_44 ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } } if ( METHOD_45 ( VAR_126 ) < 0 ) return - 1 ; VAR_127 -> VAR_128 = VAR_129 ; return 0 ; }",<S2SV_ModStart> ) ; } METHOD_46 ( VAR_125 ) ;,"CWE-74 int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , ""200"" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , ""201"" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( ""%s"" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , ""MODE<S2SV_blank>READER\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , ""200"" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , ""201"" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( ""Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s"" ) , conn -> account . host , posting ? _ ( ""Posting<S2SV_blank>is<S2SV_blank>ok"" ) : _ ( ""Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok"" ) ) ; mutt_sleep ( 1 ) ;  ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , ""STARTTLS\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( ""STARTTLS:<S2SV_blank>%s"" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } }   if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , ""STAT\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , ""480"" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode"" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }",<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;
127,"CWE-20 TYPE_0 METHOD_0 ( ) { TYPE_1 VAR_0 ; TYPE_2 VAR_1 ; VAR_2 ; if ( VAR_3 ) VAR_4 = - VAR_5 . VAR_6 ; else VAR_7 = VAR_8 . VAR_9 ; METHOD_1 ( 0 , 0 ) ; if ( VAR_10 . VAR_11 ) { METHOD_2 ( VAR_12 . VAR_13 ) ; for ( VAR_14 = 1 ; VAR_15 <= 2 ; VAR_16 ++ ) { VAR_17 ; METHOD_3 ( VAR_18 * 0.5 , 0 ) ; METHOD_4 ( - VAR_19 * 0.5 , VAR_20 . VAR_21 ) ; METHOD_5 ( - VAR_22 * 0.5 + VAR_23 * VAR_24 . VAR_25 , 0 ) ; METHOD_6 ( - VAR_26 * 0.5 , - VAR_27 . VAR_28 ) ; if ( VAR_29 == 1 ) { METHOD_7 ( VAR_30 ) ; <S2SV_StartBug> VAR_31 += METHOD_8 ( VAR_32 , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } else { <S2SV_StartBug> VAR_33 += METHOD_9 ( VAR_34 , ""<S2SV_blank>s"" ) ; <S2SV_EndBug> } VAR_35 ; } } else { METHOD_10 ( VAR_36 * 0.5 , 0 ) ; METHOD_11 ( - VAR_37 * 0.5 , VAR_38 . VAR_39 ) ; METHOD_12 ( - VAR_40 * 0.5 + VAR_41 * VAR_42 . VAR_43 , 0 ) ; METHOD_13 ( - VAR_44 * 0.5 , - VAR_45 . VAR_46 ) ; <S2SV_StartBug> VAR_47 += METHOD_14 ( VAR_48 , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } VAR_49 ; }","<S2SV_ModStart> VAR_30 ) ; METHOD_15 ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_ModStart> } else { METHOD_15 ( <S2SV_ModEnd> ""<S2SV_blank>s"" ) ; <S2SV_ModStart> VAR_46 ) ; METHOD_15 ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ;","CWE-20 void ArrowHead ( ) { int k ; double length ; SaveGraphicsState ; if ( flip ) length = - arrow . length ; else length = arrow . length ; SetDashSize ( 0 , 0 ) ; if ( arrow . stroke ) { SetLineWidth ( arrow . stroke ) ; for ( k = 1 ; k <= 2 ; k ++ ) { SaveGraphicsState ; MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; if ( k == 1 ) { SetBackgroundColor ( NONSTROKING ) ; <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ; <S2SV_EndBug> } RestoreGraphicsState ; } } else { MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } RestoreGraphicsState ; }","<S2SV_ModStart> NONSTROKING ) ; send ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_ModStart> } else { send ( <S2SV_ModEnd> ""<S2SV_blank>s"" ) ; <S2SV_ModStart> width ) ; send ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ;"
128,"CWE-416 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 , * VAR_3 ; VAR_4 * VAR_5 ; struct STRUCT_OR_UNION_0 { TYPE_4 * VAR_6 ; TYPE_5 * VAR_7 ; <S2SV_StartBug> TYPE_6 VAR_8 ; <S2SV_EndBug> } * VAR_9 , * VAR_10 ; VAR_11 = METHOD_1 ( sizeof ( struct STRUCT_OR_UNION_1 ) ) ; VAR_12 -> VAR_13 = VAR_14 -> VAR_15 ; VAR_16 -> VAR_17 = VAR_18 ; VAR_19 = METHOD_2 ( ) ; METHOD_3 ( VAR_20 , VAR_21 , VAR_22 , & METHOD_4 ) ; METHOD_5 ( VAR_23 , VAR_24 , 0 ) ; while ( VAR_25 -> VAR_26 != VAR_27 ) { VAR_28 = VAR_29 -> VAR_30 ; METHOD_6 ( VAR_31 , VAR_32 -> VAR_33 ) ; VAR_34 = ( ( struct STRUCT_OR_UNION_2 * ) VAR_35 -> VAR_36 ) -> VAR_37 ; VAR_38 = ( struct STRUCT_OR_UNION_3 * ) VAR_39 -> VAR_40 ; METHOD_7 ( VAR_41 ) ; for ( VAR_42 = VAR_43 -> VAR_44 ; VAR_45 != VAR_46 ; VAR_47 = VAR_48 -> VAR_49 ) { VAR_50 = METHOD_8 ( sizeof ( struct STRUCT_OR_UNION_4 ) ) ; VAR_51 -> VAR_52 = ( ( TYPE_7 * ) VAR_53 -> VAR_54 ) -> VAR_55 ; if ( VAR_56 -> VAR_57 != VAR_58 ) { VAR_59 -> VAR_60 = METHOD_9 ( sizeof ( TYPE_8 ) * ( METHOD_10 ( ( ( TYPE_9 * ) VAR_61 -> VAR_62 ) -> VAR_63 ) + METHOD_11 ( VAR_64 -> VAR_65 ) + 1 ) ) ; METHOD_12 ( VAR_66 -> VAR_67 , VAR_68 -> VAR_69 , sizeof ( TYPE_10 ) * METHOD_13 ( VAR_70 -> VAR_71 ) ) ; METHOD_14 ( VAR_72 -> VAR_73 + METHOD_15 ( VAR_74 -> VAR_75 ) , ( ( TYPE_11 * ) VAR_76 -> VAR_77 ) -> VAR_78 , sizeof ( TYPE_12 ) * ( METHOD_16 ( ( ( TYPE_13 * ) VAR_79 -> VAR_80 ) -> VAR_81 ) + 1 ) ) ; } else { VAR_82 -> VAR_83 = METHOD_17 ( sizeof ( TYPE_14 ) * ( METHOD_18 ( ( ( TYPE_15 * ) VAR_84 -> VAR_85 ) -> VAR_86 ) + 1 ) ) ; METHOD_19 ( VAR_87 -> VAR_88 , ( ( TYPE_16 * ) VAR_89 -> VAR_90 ) -> VAR_91 , sizeof ( TYPE_17 ) * ( METHOD_20 ( ( ( TYPE_18 * ) VAR_92 -> VAR_93 ) -> VAR_94 ) + 1 ) ) ; } if ( ( ( TYPE_19 * ) VAR_95 -> VAR_96 ) -> VAR_97 != VAR_98 ) { METHOD_21 ( VAR_99 , VAR_100 -> VAR_101 , VAR_102 -> METHOD_22 ( ( ( TYPE_20 * ) VAR_103 -> VAR_104 ) -> VAR_105 ) ) ; } if ( ( ( TYPE_21 * ) VAR_106 -> VAR_107 ) -> VAR_108 -> VAR_109 ) { METHOD_23 ( VAR_110 , VAR_111 , 0 ) ; } else { METHOD_24 ( VAR_112 -> VAR_113 ) ; METHOD_25 ( VAR_114 ) ; } } METHOD_26 ( VAR_115 -> VAR_116 ) ; METHOD_27 ( VAR_117 ) ; } METHOD_28 ( & VAR_118 ) ; }",<S2SV_ModStart> * VAR_116 ; <S2SV_ModEnd> } * VAR_114,"CWE-416 void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }",<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
129,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = METHOD_1 ( VAR_2 ) ; <S2SV_StartBug> const TYPE_1 * VAR_3 = VAR_4 -> VAR_5 ; <S2SV_EndBug> <S2SV_StartBug> struct STRUCT_OR_UNION_2 VAR_6 = VAR_7 -> VAR_8 -> VAR_9 ; <S2SV_EndBug> METHOD_2 ( & VAR_10 -> VAR_11 -> VAR_12 , ""%s:<S2SV_blank>bInterfaceNumber=%d\\n"" , VAR_13 , VAR_14 -> VAR_15 -> VAR_16 . VAR_17 ) ; if ( VAR_18 -> VAR_19 -> METHOD_3 ) VAR_20 -> VAR_21 -> METHOD_4 ( VAR_22 ) ; METHOD_5 ( VAR_23 ) ; <S2SV_StartBug> METHOD_6 ( & VAR_24 , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> VAR_25 , VAR_26 ) ; <S2SV_EndBug> }","<S2SV_ModStart> const TYPE_1 * VAR_27 = METHOD_8 ( METHOD_7 ( & <S2SV_ModEnd> VAR_23 -> VAR_11 <S2SV_ModStart> VAR_11 -> VAR_24 ) , VAR_28 ) ; const TYPE_1 * VAR_29 = VAR_23 -> VAR_26 <S2SV_ModStart> VAR_23 ) ; METHOD_9 ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> , VAR_25 , <S2SV_ModStart> , VAR_25 , VAR_29 , VAR_27 ) ; kfree ( VAR_27 <S2SV_ModEnd> ) ; }","CWE-119 void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\n"" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> }","<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }"
130,"CWE-20 static TYPE_0 TYPE_1 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { while ( ! METHOD_1 ( VAR_1 ) ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = list_entry ( VAR_2 -> VAR_3 , struct STRUCT_OR_UNION_3 , VAR_4 ) ; <S2SV_StartBug> METHOD_2 ( & STRUCT_OR_UNION_4 -> VAR_5 ) ; <S2SV_EndBug> METHOD_3 ( ""-<S2SV_blank>%u"" , STRUCT_OR_UNION_5 -> VAR_6 ) ; METHOD_4 ( STRUCT_OR_UNION_6 ) ; <S2SV_StartBug> if ( METHOD_5 ( VAR_7 , & STRUCT_OR_UNION_7 -> VAR_8 ) && <S2SV_EndBug> ! METHOD_6 ( VAR_9 , & STRUCT_OR_UNION_8 -> VAR_10 ) && STRUCT_OR_UNION_9 -> VAR_11 -> METHOD_7 ) STRUCT_OR_UNION_10 -> VAR_12 -> METHOD_8 ( STRUCT_OR_UNION_11 ) ; METHOD_9 ( STRUCT_OR_UNION_12 ) ; if ( METHOD_10 ( VAR_13 , & STRUCT_OR_UNION_13 -> VAR_14 ) ) { METHOD_11 ( & STRUCT_OR_UNION_14 -> VAR_15 -> VAR_16 ) ; STRUCT_OR_UNION_15 -> VAR_17 -> VAR_18 -- ; STRUCT_OR_UNION_16 -> VAR_19 -> VAR_20 -= STRUCT_OR_UNION_17 -> VAR_21 ; METHOD_12 ( & STRUCT_OR_UNION_18 -> VAR_22 -> VAR_23 ) ; } METHOD_13 ( & STRUCT_OR_UNION_19 -> VAR_24 -> VAR_25 ) ; <S2SV_StartBug> if ( METHOD_14 ( VAR_26 , & STRUCT_OR_UNION_20 -> VAR_27 ) ) <S2SV_EndBug> METHOD_15 ( & STRUCT_OR_UNION_21 -> VAR_28 -> VAR_29 ) ; METHOD_16 ( STRUCT_OR_UNION_22 -> VAR_30 ) ; METHOD_17 ( STRUCT_OR_UNION_23 -> VAR_31 ) ; METHOD_18 ( STRUCT_OR_UNION_24 , sizeof ( * STRUCT_OR_UNION_25 ) ) ; METHOD_19 ( VAR_32 , STRUCT_OR_UNION_26 ) ; } }",<S2SV_ModStart> VAR_5 ) ; TYPE_2 VAR_33 = STRUCT_OR_UNION_26 -> VAR_33 ; <S2SV_ModStart> ; if ( VAR_33 == VAR_34 && <S2SV_ModEnd> STRUCT_OR_UNION_26 -> VAR_12 <S2SV_ModStart> ; if ( VAR_33 != VAR_35 <S2SV_ModEnd> ) METHOD_15 (,"CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; <S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ; key_check ( key ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }",<S2SV_ModStart> graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ; if ( state == KEY_IS_POSITIVE && <S2SV_ModEnd> key -> type <S2SV_ModStart> ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec (
131,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { const TYPE_3 * const VAR_3 = VAR_4 ? METHOD_1 ( VAR_5 , 1 ) : VAR_6 ; VAR_7 * VAR_8 , * VAR_9 = VAR_10 , * VAR_11 ; TYPE_4 VAR_12 ; TYPE_5 VAR_13 , VAR_14 ; const TYPE_6 * VAR_15 ; TYPE_7 VAR_16 , VAR_17 ; <S2SV_StartBug> METHOD_2 ( VAR_18 , VAR_19 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( METHOD_3 ( VAR_20 ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> VAR_21 = METHOD_4 ( VAR_22 , METHOD_5 ( VAR_23 , 8 ) ) ; <S2SV_EndBug> if ( ! VAR_24 ) return VAR_25 ; } VAR_26 = METHOD_6 ( VAR_27 , 1 ) ; VAR_28 = METHOD_7 ( VAR_29 , VAR_30 , VAR_31 ) ; if ( ! VAR_32 ) return VAR_33 ; VAR_34 = ( TYPE_8 ) METHOD_8 ( VAR_35 , 0 ) ; if ( METHOD_9 ( VAR_36 ) == 1 ) VAR_37 = VAR_38 ; else VAR_39 = METHOD_10 ( VAR_40 , VAR_41 , VAR_42 -> VAR_43 , VAR_44 -> VAR_45 , VAR_46 -> VAR_47 , VAR_48 -> VAR_49 , VAR_50 -> VAR_51 ) ; VAR_52 = METHOD_11 ( VAR_53 , METHOD_12 ( VAR_54 , 3 ) ) ; if ( ! VAR_55 ) return VAR_56 ; <S2SV_StartBug> VAR_57 = METHOD_13 ( VAR_58 , METHOD_14 ( VAR_59 , 5 ) ) ; <S2SV_EndBug> if ( ! VAR_60 ) return VAR_61 ; if ( VAR_62 != VAR_63 ) { METHOD_15 ( VAR_64 , & VAR_65 , & VAR_66 ) ; } else { METHOD_16 ( VAR_67 , & VAR_68 , & VAR_69 ) ; } <S2SV_StartBug> if ( VAR_70 ) <S2SV_EndBug> <S2SV_StartBug> return METHOD_17 ( VAR_71 , VAR_72 , VAR_73 , VAR_74 , <S2SV_EndBug> METHOD_18 ( VAR_75 ) , VAR_76 -> VAR_77 , VAR_78 , VAR_79 , VAR_80 -> VAR_81 ) ; else <S2SV_StartBug> return METHOD_19 ( VAR_82 , VAR_83 , VAR_84 , VAR_85 , <S2SV_EndBug> METHOD_20 ( VAR_86 ) , VAR_87 -> VAR_88 , VAR_89 , VAR_90 , VAR_91 -> VAR_92 ) ; }","<S2SV_ModStart> , VAR_90 ; TYPE_7 VAR_93 ; TYPE_9 VAR_94 ; <S2SV_ModStart> , VAR_19 ) ; VAR_93 = METHOD_21 ( METHOD_14 ( VAR_87 , 5 ) ) == VAR_95 <S2SV_ModStart> ) == 9 + VAR_93 <S2SV_ModStart> VAR_87 , 8 + VAR_93 <S2SV_ModStart> VAR_87 , 5 + VAR_93 <S2SV_ModStart> } if ( VAR_93 ) { VAR_94 = METHOD_22 ( METHOD_14 ( VAR_87 , 5 ) ) ; if ( ! VAR_94 ) return VAR_63 ; } else VAR_94 = VAR_63 ; if ( <S2SV_ModStart> , VAR_85 , VAR_94 , <S2SV_ModStart> VAR_84 , VAR_85 , VAR_94","CWE-125 static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; asdl_seq * _target , * seq = NULL , * suite_seq ; expr_ty expression ; expr_ty target , first ; const node * node_target ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> if ( ! seq ) return NULL ; } node_target = CHILD ( n , 1 ) ; _target = ast_for_exprlist ( c , node_target , Store ) ; if ( ! _target ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( _target , 0 ) ; if ( NCH ( node_target ) == 1 ) target = first ; else target = Tuple ( _target , Store , first -> lineno , first -> col_offset , node_target -> n_end_lineno , node_target -> n_end_col_offset , c -> c_arena ) ; expression = ast_for_testlist ( c , CHILD ( n , 3 ) ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> if ( ! suite_seq ) return NULL ; if ( seq != NULL ) { get_last_end_pos ( seq , & end_lineno , & end_col_offset ) ; } else { get_last_end_pos ( suite_seq , & end_lineno , & end_col_offset ) ; } <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }","<S2SV_ModStart> , end_col_offset ; int has_type_comment ; string type_comment ; <S2SV_ModStart> , for_stmt ) ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> ) == 9 + has_type_comment <S2SV_ModStart> n , 8 + has_type_comment <S2SV_ModStart> n , 5 + has_type_comment <S2SV_ModStart> } if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , seq , type_comment , <S2SV_ModStart> suite_seq , seq , type_comment"
132,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = container_of ( VAR_2 -> VAR_3 , struct STRUCT_OR_UNION_4 , VAR_4 ) ; TYPE_1 VAR_5 = METHOD_1 ( STRUCT_OR_UNION_5 -> VAR_6 , 0 ) ; TYPE_2 VAR_7 = METHOD_2 ( STRUCT_OR_UNION_6 -> VAR_8 , 0 ) ; if ( METHOD_3 ( STRUCT_OR_UNION_7 -> VAR_9 , VAR_10 ) || <S2SV_StartBug> METHOD_4 ( VAR_11 , METHOD_5 ( ) ) ) { <S2SV_EndBug> TYPE_3 VAR_12 = ( VAR_13 -> VAR_14 >> 6 ) & 7 ; return ( VAR_15 << 6 ) | ( VAR_16 << 3 ) | VAR_17 ; } <S2SV_StartBug> if ( METHOD_6 ( VAR_18 , METHOD_7 ( ) ) ) { <S2SV_EndBug> TYPE_4 VAR_19 = ( VAR_20 -> VAR_21 >> 3 ) & 7 ; return ( VAR_22 << 3 ) | VAR_23 ; } return VAR_24 -> VAR_25 ; }","<S2SV_ModStart> ( VAR_11 , METHOD_8 <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( METHOD_9 ( VAR_18 <S2SV_ModEnd> ) ) {","CWE-20 static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || <S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }","<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {"
133,"CWE-200 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 , * VAR_3 = VAR_4 , * VAR_5 ; register TYPE_4 * VAR_6 ; unsigned TYPE_5 VAR_7 ; TYPE_6 VAR_8 ; TYPE_7 VAR_9 ; TYPE_8 VAR_10 ; TYPE_9 * VAR_11 ; TYPE_10 * VAR_12 ; TYPE_11 VAR_13 ; TYPE_12 VAR_14 ; unsigned TYPE_13 * VAR_15 = VAR_16 ; TYPE_14 VAR_17 , VAR_18 ; unsigned VAR_19 , VAR_20 ; unsigned VAR_21 ; TYPE_15 VAR_22 ; TYPE_16 VAR_23 ; TYPE_17 VAR_24 = 0x80 ; VAR_25 * VAR_26 ; TYPE_18 VAR_27 ; unsigned TYPE_19 ( * METHOD_1 ) ( TYPE_20 * VAR_28 ) ; unsigned TYPE_21 ( * METHOD_2 ) ( TYPE_22 * VAR_29 ) ; TYPE_23 ( * METHOD_3 ) ( TYPE_24 * VAR_30 , TYPE_25 VAR_31 , TYPE_26 * VAR_32 ) ; TYPE_27 ( * METHOD_4 ) ( TYPE_28 * VAR_33 , TYPE_29 VAR_34 , TYPE_30 * VAR_35 ) ; METHOD_5 ( VAR_36 != ( const TYPE_31 * ) VAR_37 ) ; METHOD_6 ( VAR_38 -> VAR_39 == VAR_40 ) ; METHOD_7 ( VAR_41 != ( TYPE_32 * ) VAR_42 ) ; METHOD_8 ( VAR_43 -> VAR_44 == VAR_45 ) ; VAR_46 = METHOD_9 ( VAR_47 , METHOD_10 ( ) , ""enter"" ) ; VAR_48 = METHOD_11 ( VAR_49 , VAR_50 ) ; VAR_51 = METHOD_12 ( VAR_52 , VAR_53 , VAR_54 , VAR_55 ) ; if ( VAR_56 == VAR_57 ) { VAR_58 = METHOD_13 ( VAR_59 ) ; return ( ( TYPE_33 * ) VAR_60 ) ; } VAR_61 = METHOD_14 ( VAR_62 ) ; if ( METHOD_15 ( VAR_63 , 124 , ( unsigned TYPE_34 * ) & VAR_64 . VAR_65 ) != 124 ) METHOD_16 ( VAR_66 , ""ImproperImageHeader"" ) ; if ( METHOD_17 ( VAR_67 . VAR_68 , ""MATLAB"" , 6 ) != 0 ) { VAR_69 = METHOD_18 ( VAR_70 , VAR_71 , VAR_72 ) ; if ( VAR_73 == VAR_74 ) goto VAR_75 ; VAR_76 = VAR_77 ; goto VAR_78 ; } VAR_79 . VAR_80 = METHOD_19 ( VAR_81 ) ; if ( METHOD_20 ( VAR_82 , 2 , ( unsigned TYPE_35 * ) & VAR_83 . VAR_84 ) != 2 ) METHOD_21 ( VAR_85 , ""ImproperImageHeader"" ) ; if ( VAR_86 ) ( TYPE_36 ) METHOD_22 ( VAR_87 , METHOD_23 ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , VAR_88 . VAR_89 [ 0 ] , VAR_90 . VAR_91 [ 1 ] ) ; if ( ! METHOD_24 ( VAR_92 . VAR_93 , ""IM"" , 2 ) ) { METHOD_25 = VAR_94 ; METHOD_26 = METHOD_27 ; METHOD_28 = VAR_95 ; METHOD_29 = VAR_96 ; VAR_97 -> VAR_98 = VAR_99 ; } else if ( ! METHOD_30 ( VAR_100 . VAR_101 , ""MI"" , 2 ) ) { METHOD_31 = VAR_102 ; METHOD_32 = VAR_103 ; METHOD_33 = VAR_104 ; METHOD_34 = VAR_105 ; VAR_106 -> VAR_107 = VAR_108 ; } else goto VAR_109 ; if ( METHOD_35 ( VAR_110 . VAR_111 , ""MATLAB"" , 6 ) ) VAR_112 : METHOD_36 ( VAR_113 , ""ImproperImageHeader"" ) ; VAR_114 = METHOD_37 ( VAR_115 ) ; while ( ! METHOD_38 ( VAR_116 ) ) { VAR_117 = 1 ; ( TYPE_37 ) METHOD_39 ( VAR_118 , VAR_119 , VAR_120 ) ; VAR_121 . VAR_122 = METHOD_40 ( VAR_123 ) ; if ( METHOD_41 ( VAR_124 ) ) break ; VAR_125 . VAR_126 = METHOD_42 ( VAR_127 ) ; if ( METHOD_43 ( VAR_128 ) ) break ; VAR_129 += VAR_130 . VAR_131 + 4 + 4 ; VAR_132 = VAR_133 ; if d ( VAR_134 ) if ( VAR_135 . VAR_136 == VAR_137 ) { VAR_138 = METHOD_44 ( VAR_139 , VAR_140 . VAR_141 , VAR_142 , VAR_143 ) ; if ( VAR_144 == VAR_145 ) continue ; VAR_146 . VAR_147 = METHOD_45 ( VAR_148 ) ; } if ( VAR_149 . VAR_150 != VAR_151 ) continue ; VAR_152 . VAR_153 = METHOD_46 ( VAR_154 ) ; VAR_155 . VAR_156 = METHOD_47 ( VAR_157 ) ; VAR_158 . VAR_159 = METHOD_48 ( VAR_160 ) ; VAR_161 . VAR_162 = VAR_163 . VAR_164 & 0xFF ; VAR_165 . VAR_166 = ( VAR_167 . VAR_168 >> 8 ) & 0xFF ; VAR_169 . VAR_170 = METHOD_49 ( VAR_171 ) ; if ( VAR_172 != VAR_173 ) VAR_174 . VAR_175 = METHOD_50 ( VAR_176 ) ; VAR_177 . VAR_178 = METHOD_51 ( VAR_179 ) ; VAR_180 . VAR_181 = METHOD_52 ( VAR_182 ) ; VAR_183 . VAR_184 = METHOD_53 ( VAR_185 ) ; VAR_186 . VAR_187 = METHOD_54 ( VAR_188 ) ; switch ( VAR_189 . VAR_190 ) { case 8 : VAR_191 = VAR_192 = 1 ; break ; case 12 : VAR_193 = VAR_194 = METHOD_55 ( VAR_195 ) ; ( TYPE_38 ) METHOD_56 ( VAR_196 ) ; if ( VAR_197 != 3 ) METHOD_57 ( VAR_198 , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : VAR_199 = VAR_200 = METHOD_58 ( VAR_201 ) ; if ( VAR_202 != 3 && VAR_203 != 1 ) METHOD_59 ( VAR_204 , ""MultidimensionalMatricesAreNotSupported"" ) ; VAR_205 = METHOD_60 ( VAR_206 ) ; if ( VAR_207 == 0 ) METHOD_61 ( VAR_208 , ""ImproperImageHeader"" ) ; break ; default : METHOD_62 ( VAR_209 , ""MultidimensionalMatricesAreNotSupported"" ) ; } VAR_210 . VAR_211 = METHOD_63 ( VAR_212 ) ; VAR_213 . VAR_214 = METHOD_64 ( VAR_215 ) ; if ( VAR_216 ) ( TYPE_39 ) METHOD_65 ( VAR_217 , METHOD_66 ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , VAR_218 . VAR_219 ) ; if ( VAR_220 . VAR_221 != VAR_222 && VAR_223 . VAR_224 != VAR_225 && VAR_226 . VAR_227 != VAR_228 && VAR_229 . VAR_230 != VAR_231 && VAR_232 . VAR_233 != VAR_234 && VAR_235 . VAR_236 != VAR_237 && VAR_238 . VAR_239 != VAR_240 && VAR_241 . VAR_242 != VAR_243 && VAR_244 . VAR_245 != VAR_246 && VAR_247 . VAR_248 != VAR_249 && VAR_250 . VAR_251 != VAR_252 ) METHOD_67 ( VAR_253 , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( VAR_254 . VAR_255 ) { case 0 : VAR_256 = METHOD_68 ( VAR_257 ) ; VAR_258 = 4 * ( TYPE_40 ) ( ( VAR_259 + 3 + 1 ) / 4 ) ; ( TYPE_41 ) METHOD_69 ( VAR_260 , VAR_261 , VAR_262 ) ; break ; case 1 : case 2 : case 3 : case 4 : ( TYPE_42 ) METHOD_70 ( VAR_263 , 4 , ( unsigned TYPE_43 * ) & VAR_264 ) ; break ; default : goto VAR_265 ; } VAR_266 = METHOD_71 ( VAR_267 ) ; if ( VAR_268 ) ( TYPE_44 ) METHOD_72 ( VAR_269 , METHOD_73 ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( TYPE_45 ) VAR_270 ) ; ( TYPE_46 ) METHOD_74 ( VAR_271 , 4 , ( unsigned TYPE_47 * ) & VAR_272 ) ; VAR_273 : switch ( VAR_274 ) { case VAR_275 : case VAR_276 : VAR_277 = 8 ; if ( VAR_278 . VAR_279 & VAR_280 ) VAR_281 -> VAR_282 = 1 ; else VAR_283 -> VAR_284 = 8 ; VAR_285 = ( TYPE_48 ) VAR_286 . VAR_287 ; break ; case VAR_288 : case VAR_289 : VAR_290 = 16 ; VAR_291 -> VAR_292 = 16 ; VAR_293 = ( TYPE_49 ) ( 2 * VAR_294 . VAR_295 ) ; break ; case VAR_296 : case VAR_297 : VAR_298 = 32 ; VAR_299 -> VAR_300 = 32 ; VAR_301 = ( TYPE_50 ) ( 4 * VAR_302 . VAR_303 ) ; break ; case VAR_304 : case VAR_305 : VAR_306 = 64 ; VAR_307 -> VAR_308 = 64 ; VAR_309 = ( TYPE_51 ) ( 8 * VAR_310 . VAR_311 ) ; break ; case VAR_312 : VAR_313 = 32 ; VAR_314 -> VAR_315 = 32 ; ( TYPE_52 ) METHOD_75 ( VAR_316 , ""quantum:format"" , ""floating-point"" ) ; if ( VAR_317 . VAR_318 & VAR_319 ) { } VAR_320 = ( TYPE_53 ) ( 4 * VAR_321 . VAR_322 ) ; break ; case VAR_323 : VAR_324 = 64 ; VAR_325 -> VAR_326 = 64 ; ( TYPE_54 ) METHOD_76 ( VAR_327 , ""quantum:format"" , ""floating-point"" ) ; METHOD_77 ( 4127 ) if ( sizeof ( TYPE_55 ) != 8 ) TYPE_56 METHOD_78 ( VAR_328 , ""IncompatibleSizeOfDouble"" ) ; if ( VAR_329 . VAR_330 & VAR_331 ) { } VAR_332 = ( TYPE_57 ) ( 8 * VAR_333 . VAR_334 ) ; break ; default : METHOD_79 ( VAR_335 , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( TYPE_58 ) VAR_336 ; VAR_337 -> VAR_338 = VAR_339 . VAR_340 ; VAR_341 -> VAR_342 = VAR_343 . VAR_344 ; VAR_345 = METHOD_80 ( VAR_346 , VAR_347 ) ; if ( VAR_348 == ( TYPE_59 * ) VAR_349 ) METHOD_81 ( VAR_350 , ""MemoryAllocationFailed"" ) ; VAR_351 = 1 ; VAR_352 -> VAR_353 = VAR_354 << VAR_355 -> VAR_356 ; if ( VAR_357 -> VAR_358 == 0 || VAR_359 -> VAR_360 == 0 ) goto VAR_361 ; if ( ( VAR_362 . VAR_363 == 8 ) && ( ( VAR_364 . VAR_365 & VAR_366 ) == 0 ) ) { VAR_367 -> VAR_368 = VAR_369 ; METHOD_82 ( VAR_370 , VAR_371 , VAR_372 ) ; } if ( VAR_373 -> VAR_374 ) { TYPE_60 VAR_375 = VAR_376 -> VAR_377 ; VAR_378 -> VAR_379 = VAR_380 -> VAR_381 ; VAR_382 -> VAR_383 = VAR_384 ; goto VAR_385 ; } VAR_386 = METHOD_83 ( VAR_387 , VAR_388 -> VAR_389 , VAR_390 -> VAR_391 , VAR_392 ) ; if ( VAR_393 == VAR_394 ) return ( METHOD_84 ( VAR_395 ) ) ; VAR_396 = ( unsigned TYPE_61 * ) METHOD_85 ( ( TYPE_62 ) ( VAR_397 ) , sizeof ( TYPE_63 ) ) ; if ( VAR_398 == VAR_399 ) METHOD_86 ( VAR_400 , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> VAR_401 = 0 ; <S2SV_EndBug> VAR_402 = 0 ; if ( VAR_403 == VAR_404 || VAR_405 == VAR_406 ) { METHOD_87 ( VAR_407 , VAR_408 -> VAR_409 , VAR_410 . VAR_411 , VAR_412 . VAR_413 , VAR_414 , VAR_415 , VAR_416 , & VAR_417 -> VAR_418 , & VAR_419 -> VAR_420 ) ; } if ( VAR_421 == 1 ) VAR_422 = 0 ; do { for ( VAR_423 = 0 ; VAR_424 < ( TYPE_64 ) VAR_425 . VAR_426 ; VAR_427 ++ ) { VAR_428 = METHOD_88 ( VAR_429 , 0 , VAR_430 . VAR_431 - VAR_432 - 1 , VAR_433 -> VAR_434 , 1 , VAR_435 ) ; if ( VAR_436 == ( TYPE_65 * ) VAR_437 ) { if ( VAR_438 ) ( TYPE_66 ) METHOD_89 ( VAR_439 , METHOD_90 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( VAR_440 . VAR_441 - VAR_442 - 1 ) ) ; goto VAR_443 ; } if ( METHOD_91 ( VAR_444 , VAR_445 , ( unsigned TYPE_67 * ) VAR_446 ) != ( TYPE_68 ) VAR_447 ) { if ( VAR_448 ) ( TYPE_69 ) METHOD_92 ( VAR_449 , METHOD_93 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( VAR_450 . VAR_451 - VAR_452 - 1 ) ) ; goto VAR_453 ; } if ( ( VAR_454 == VAR_455 || VAR_456 == VAR_457 ) && ( VAR_458 . VAR_459 & VAR_460 ) ) { METHOD_94 ( ( unsigned TYPE_70 * ) VAR_461 , VAR_462 ) ; if ( METHOD_95 ( VAR_463 , ( TYPE_71 * ) VAR_464 , VAR_465 , VAR_466 [ VAR_467 ] , VAR_468 , VAR_469 ) <= 0 ) { VAR_470 : if ( VAR_471 ) ( TYPE_72 ) METHOD_96 ( VAR_472 , METHOD_97 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( VAR_473 . VAR_474 - VAR_475 - 1 ) ) ; break ; } } else { if ( METHOD_98 ( VAR_476 , ( TYPE_73 * ) VAR_477 , VAR_478 , VAR_479 [ VAR_480 ] , VAR_481 , VAR_482 ) <= 0 ) goto VAR_483 ; if ( VAR_484 <= 1 && ( VAR_485 == VAR_486 || VAR_487 == VAR_488 || VAR_489 == VAR_490 || VAR_491 == VAR_492 ) ) METHOD_99 ( VAR_493 , VAR_494 , VAR_495 . VAR_496 ) ; } if ( ! METHOD_100 ( VAR_497 , VAR_498 ) ) { if ( VAR_499 ) ( TYPE_74 ) METHOD_101 ( VAR_500 , METHOD_102 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( VAR_501 . VAR_502 - VAR_503 - 1 ) ) ; goto VAR_504 ; } } } while ( VAR_505 -- >= 2 ) ; VAR_506 = METHOD_103 ( VAR_507 ) ; VAR_508 : if ( VAR_509 . VAR_510 & VAR_511 ) { VAR_512 = METHOD_104 ( VAR_513 ) ; VAR_514 = METHOD_105 ( VAR_515 ) ; if ( VAR_516 == VAR_517 || VAR_518 == VAR_519 ) { METHOD_106 ( VAR_520 , VAR_521 -> VAR_522 , VAR_523 . VAR_524 , VAR_525 . VAR_526 , VAR_527 , VAR_528 , VAR_529 , & VAR_530 , & VAR_531 ) ; } if ( VAR_532 == VAR_533 ) for ( VAR_534 = 0 ; VAR_535 < ( TYPE_75 ) VAR_536 . VAR_537 ; VAR_538 ++ ) { METHOD_107 ( VAR_539 , VAR_540 , ( TYPE_76 * ) VAR_541 ) ; METHOD_108 ( VAR_542 , ( TYPE_77 * ) VAR_543 , VAR_544 , VAR_545 , VAR_546 , VAR_547 ) ; } if ( VAR_548 == VAR_549 ) for ( VAR_550 = 0 ; VAR_551 < ( TYPE_78 ) VAR_552 . VAR_553 ; VAR_554 ++ ) { METHOD_109 ( VAR_555 , VAR_556 , ( TYPE_79 * ) VAR_557 ) ; METHOD_110 ( VAR_558 , ( TYPE_80 * ) VAR_559 , VAR_560 , VAR_561 , VAR_562 , VAR_563 ) ; } } if ( ( VAR_564 . VAR_565 == 8 ) && ( ( VAR_566 . VAR_567 & VAR_568 ) == 0 ) ) VAR_569 -> VAR_570 = VAR_571 ; if ( VAR_572 -> VAR_573 == 1 ) VAR_574 -> VAR_575 = VAR_576 ; if ( VAR_577 == VAR_578 ) VAR_579 = VAR_580 ; VAR_581 = METHOD_111 ( VAR_582 , 90.0 , VAR_583 ) ; if ( VAR_584 != ( TYPE_81 * ) VAR_585 ) { VAR_586 -> VAR_587 . VAR_588 = 0 ; VAR_589 -> VAR_590 . VAR_591 = 0 ; VAR_592 = VAR_593 -> VAR_594 ; VAR_595 -> VAR_596 = VAR_597 -> VAR_598 ; VAR_599 -> VAR_600 = VAR_601 -> VAR_602 ; VAR_603 -> VAR_604 = VAR_605 ; METHOD_112 ( & VAR_606 , VAR_607 ) ; METHOD_113 ( & VAR_608 ) ; } VAR_609 : if ( VAR_610 != VAR_611 ) if ( VAR_612 != VAR_613 ) { METHOD_114 ( & VAR_614 ) ; if ( VAR_615 ) { if ( VAR_616 -> VAR_617 ) { METHOD_115 ( VAR_618 -> VAR_619 ) ; VAR_620 -> VAR_621 = VAR_622 ; ( TYPE_82 ) METHOD_116 ( VAR_623 -> VAR_624 ) ; } } } METHOD_117 ( VAR_625 , VAR_626 , VAR_627 ) ; if ( VAR_628 -> VAR_629 == ( TYPE_83 * ) VAR_630 ) break ; VAR_631 = METHOD_118 ( VAR_632 ) ; VAR_633 -> VAR_634 = VAR_635 -> VAR_636 = 0 ; VAR_637 -> VAR_638 = 0 ; METHOD_119 ( VAR_639 ) ; VAR_640 = VAR_641 ; if ( -- VAR_642 > 0 ) { VAR_643 = VAR_644 ; if ( VAR_645 == VAR_646 ) VAR_647 = VAR_648 ; goto VAR_649 ; } if ( ( VAR_650 != VAR_651 ) && ( VAR_652 != VAR_653 ) ) { METHOD_120 ( & VAR_654 ) ; if ( VAR_655 ) { if ( VAR_656 -> VAR_657 ) { METHOD_121 ( VAR_658 -> VAR_659 ) ; VAR_660 -> VAR_661 = VAR_662 ; ( TYPE_84 ) METHOD_122 ( VAR_663 -> VAR_664 ) ; } } } } METHOD_123 ( VAR_665 ) ; VAR_666 : VAR_667 = METHOD_124 ( VAR_668 ) ; METHOD_125 ( VAR_669 ) ; { TYPE_85 * VAR_670 ; TYPE_86 VAR_671 = 0 ; VAR_672 = VAR_673 ; VAR_674 = VAR_675 ; while ( VAR_676 != ( TYPE_87 * ) VAR_677 ) { TYPE_88 * VAR_678 = VAR_679 ; if ( ( VAR_680 -> VAR_681 == 0 ) || ( VAR_682 -> VAR_683 == 0 ) ) { VAR_684 = VAR_685 -> VAR_686 ; METHOD_126 ( & VAR_687 ) ; } else { VAR_688 = VAR_689 ; VAR_690 = VAR_691 -> VAR_692 ; } } for ( VAR_693 = VAR_694 ; VAR_695 != ( TYPE_89 * ) VAR_696 ; VAR_697 = VAR_698 -> VAR_699 ) VAR_700 -> VAR_701 = VAR_702 ++ ; } if ( VAR_703 != VAR_704 ) { if ( VAR_705 -> VAR_706 ) { METHOD_127 ( VAR_707 -> VAR_708 ) ; VAR_709 -> VAR_710 = VAR_711 ; ( TYPE_90 ) METHOD_128 ( VAR_712 -> VAR_713 ) ; } METHOD_129 ( VAR_714 ) ; VAR_715 = VAR_716 ; } if ( VAR_717 ) ( TYPE_91 ) METHOD_130 ( VAR_718 , METHOD_131 ( ) , ""return"" ) ; if ( VAR_719 == VAR_720 ) METHOD_132 ( VAR_721 , ""ImproperImageHeader"" ) ; return ( VAR_722 ) ; }","<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; ( TYPE_91 ) METHOD_133 ( VAR_665 , 0 , VAR_556 * sizeof ( TYPE_77 ) ) ;","CWE-200 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ;  if d ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; }   if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;"
134,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_2 * VAR_6 = VAR_7 -> VAR_8 ; TYPE_3 TYPE_4 * VAR_9 = ( TYPE_5 TYPE_6 * ) VAR_10 ; TYPE_7 VAR_11 ; switch ( VAR_12 ) { case VAR_13 : { struct STRUCT_OR_UNION_3 VAR_14 , * VAR_15 ; if ( METHOD_1 ( & VAR_16 , VAR_17 , sizeof ( VAR_18 ) ) ) return - VAR_19 ; if ( METHOD_2 ( & VAR_20 ) > VAR_21 || VAR_22 . VAR_23 > VAR_24 ) return - VAR_25 ; VAR_26 = METHOD_3 ( METHOD_4 ( & VAR_27 ) , VAR_28 ) ; if ( ! VAR_29 ) return - VAR_30 ; if ( METHOD_5 ( VAR_31 , VAR_32 , METHOD_6 ( & VAR_33 ) ) ) { VAR_34 = - VAR_35 ; goto VAR_36 ; } <S2SV_StartBug> METHOD_7 ( & VAR_37 -> VAR_38 ) ; <S2SV_EndBug> METHOD_8 ( & VAR_39 -> VAR_40 ) ; VAR_41 = METHOD_9 ( VAR_42 , VAR_43 ) ; if ( VAR_44 ) goto VAR_45 ; METHOD_10 ( & VAR_46 -> VAR_47 , & VAR_48 -> VAR_49 ) ; VAR_50 : METHOD_11 ( & VAR_51 -> VAR_52 ) ; METHOD_12 ( & VAR_53 -> VAR_54 ) ; VAR_55 : METHOD_13 ( VAR_56 ) ; return VAR_57 ; } case VAR_58 : { struct STRUCT_OR_UNION_4 VAR_59 ; METHOD_14 ( & VAR_60 -> VAR_61 ) ; VAR_62 = METHOD_15 ( VAR_63 ) ; if ( VAR_64 ) goto VAR_65 ; if ( METHOD_16 ( & VAR_66 , VAR_67 , sizeof ( VAR_68 ) ) ) { VAR_69 = - VAR_70 ; goto VAR_71 ; } VAR_72 = METHOD_17 ( VAR_73 , & VAR_74 ) ; if ( VAR_75 < 0 ) goto VAR_76 ; if ( METHOD_18 ( & ( ( struct STRUCT_OR_UNION_5 TYPE_8 * ) VAR_77 ) -> VAR_78 , & VAR_79 . VAR_80 , sizeof ( VAR_81 . VAR_82 ) ) ) VAR_83 = - VAR_84 ; VAR_85 : METHOD_19 ( & VAR_86 -> VAR_87 ) ; return VAR_88 ; } case VAR_89 : { TYPE_9 * VAR_90 ; METHOD_20 ( & VAR_91 -> VAR_92 ) ; VAR_93 = METHOD_21 ( VAR_94 ) ; if ( VAR_95 ) goto VAR_96 ; VAR_97 = METHOD_22 ( VAR_98 -> VAR_99 -> VAR_100 , VAR_101 ) ; if ( ! VAR_102 ) { VAR_103 = - VAR_104 ; goto VAR_105 ; } if ( METHOD_23 ( VAR_106 , VAR_107 , VAR_108 -> VAR_109 -> VAR_110 ) ) { VAR_111 = - VAR_112 ; goto VAR_113 ; } VAR_114 = METHOD_24 ( VAR_115 , VAR_116 ) ; VAR_117 : METHOD_25 ( VAR_118 ) ; VAR_119 : METHOD_26 ( & VAR_120 -> VAR_121 ) ; return VAR_122 ; } default : return - VAR_123 ; } ; return 0 ; }","<S2SV_ModStart> VAR_55 ; } if ( METHOD_27 ( & VAR_109 , VAR_56 , sizeof ( VAR_109 ) ) ) { VAR_122 = - VAR_25 ; goto VAR_55 ; }","CWE-119 static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case MIC_VIRTIO_ADD_DEVICE : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - EFAULT ; if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || dd . num_vq > MIC_MAX_VRINGS ) return - EINVAL ; dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; if ( ! dd_config ) return - ENOMEM ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - EFAULT ; goto free_ret ; } <S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case MIC_VIRTIO_COPY_DESC : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - EFAULT ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - EFAULT ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case MIC_VIRTIO_CONFIG_CHANGE : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - EFAULT ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - ENOIOCTLCMD ; } ; return 0 ; }","<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }"
135,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 = VAR_3 -> VAR_4 ; unsigned TYPE_4 * VAR_5 = VAR_6 -> VAR_7 ; VAR_8 -> VAR_9 = 1 ; VAR_10 -> VAR_11 = VAR_12 -> VAR_13 . VAR_14 = VAR_15 -> VAR_16 = 0 ; if ( VAR_17 -> VAR_18 ) { METHOD_1 ( VAR_19 -> VAR_20 ) ; VAR_21 -> VAR_22 = VAR_23 ; } <S2SV_StartBug> if ( VAR_24 ) { <S2SV_EndBug> VAR_25 -> VAR_26 = * VAR_27 ++ ; VAR_28 -> VAR_29 . VAR_30 = ( VAR_31 -> VAR_32 . VAR_33 & ~ 0xff ) | * VAR_34 ++ ; VAR_35 -= 2 ; if ( VAR_36 ) { TYPE_5 VAR_37 , VAR_38 ; VAR_39 -> VAR_40 = ( TYPE_6 ) * VAR_41 ++ << 16 ; VAR_42 -- ; if ( VAR_43 ) { VAR_44 -> VAR_45 += VAR_46 = * VAR_47 ++ ; VAR_48 -- ; if ( VAR_49 ) { if ( VAR_50 > VAR_51 ) return VAR_52 ; VAR_53 -> VAR_54 = METHOD_2 ( VAR_55 ) ; if ( VAR_56 -> VAR_57 ) { for ( VAR_58 = 0 ; VAR_59 < VAR_60 ; ++ VAR_61 ) if ( VAR_62 ) { VAR_63 -> VAR_64 [ VAR_65 ] = * VAR_66 ++ ; <S2SV_StartBug> VAR_67 -- ; <S2SV_EndBug> } else VAR_68 -> VAR_69 [ VAR_70 ] = VAR_71 ; } } } else VAR_72 -> VAR_73 += VAR_74 -> VAR_75 . VAR_76 ; } } return VAR_77 ; }",<S2SV_ModStart> if ( VAR_67 >= 2 <S2SV_ModStart> VAR_66 ++ ; if ( VAR_74 -> VAR_69 [ VAR_71 ] >= VAR_60 ) VAR_74 -> VAR_69 [ VAR_71 ] = 0 ;,"CWE-125 static int read_new_config_info ( WavpackContext * wpc , WavpackMetadata * wpmd ) { int bytecnt = wpmd -> byte_length ; unsigned char * byteptr = wpmd -> data ; wpc -> version_five = 1 ; wpc -> file_format = wpc -> config . qmode = wpc -> channel_layout = 0 ; if ( wpc -> channel_reordering ) { free ( wpc -> channel_reordering ) ; wpc -> channel_reordering = NULL ; } <S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> wpc -> file_format = * byteptr ++ ; wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; bytecnt -= 2 ; if ( bytecnt ) { int nchans , i ; wpc -> channel_layout = ( int32_t ) * byteptr ++ << 16 ; bytecnt -- ; if ( bytecnt ) { wpc -> channel_layout += nchans = * byteptr ++ ; bytecnt -- ; if ( bytecnt ) { if ( bytecnt > nchans ) return FALSE ; wpc -> channel_reordering = malloc ( nchans ) ; if ( wpc -> channel_reordering ) { for ( i = 0 ; i < nchans ; ++ i ) if ( bytecnt ) { wpc -> channel_reordering [ i ] = * byteptr ++ ; <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> } else wpc -> channel_reordering [ i ] = i ; } } } else wpc -> channel_layout += wpc -> config . num_channels ; } } return TRUE ; }",<S2SV_ModStart> if ( bytecnt >= 2 <S2SV_ModStart> byteptr ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
136,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> if ( VAR_1 -> VAR_2 ) { <S2SV_EndBug> struct STRUCT_OR_UNION_1 * VAR_3 = VAR_4 -> VAR_5 -> VAR_6 ; VAR_7 -> VAR_8 -> METHOD_1 ( VAR_9 ) ; VAR_10 -> VAR_11 = VAR_12 ; METHOD_2 ( VAR_13 ) ; } <S2SV_StartBug> if ( METHOD_3 ( VAR_14 -> VAR_15 , 1 ) -> VAR_16 ) <S2SV_EndBug> METHOD_4 ( ""%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\n"" , VAR_17 ) ; if ( ! VAR_18 -> VAR_19 ) { METHOD_5 ( METHOD_6 ( VAR_20 ) ) ; return ; } VAR_21 -> VAR_22 = VAR_23 ; }","<S2SV_ModStart> VAR_21 ) { METHOD_7 ( VAR_21 , VAR_23 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>","CWE-362 void sock_release ( struct socket * sock ) { <S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> pr_err ( ""%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\n"" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }","<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
137,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_7 * VAR_8 = VAR_9 -> VAR_10 ; unsigned VAR_11 = METHOD_2 ( METHOD_3 ( & VAR_12 -> VAR_13 ) ) ; TYPE_3 VAR_14 ; if ( VAR_15 > VAR_16 ) VAR_17 = VAR_18 ; else if ( VAR_19 < VAR_20 ) VAR_21 -> VAR_22 |= VAR_23 ; <S2SV_StartBug> METHOD_4 ( VAR_24 ) ; <S2SV_EndBug> if ( VAR_25 -> VAR_26 ) { VAR_27 -> VAR_28 = 0 ; METHOD_5 ( & VAR_29 -> VAR_30 , VAR_31 , VAR_32 -> VAR_33 , 0 ) ; VAR_34 = METHOD_6 ( METHOD_7 ( & VAR_35 -> VAR_36 ) , & VAR_37 -> VAR_38 ) ; if ( VAR_39 ) goto VAR_40 ; } VAR_41 = METHOD_8 ( VAR_42 -> VAR_43 , VAR_44 -> VAR_45 , VAR_46 ) ; VAR_47 : METHOD_9 ( VAR_48 ) ; return VAR_49 ? : VAR_50 ; }",<S2SV_ModStart> |= VAR_23 ; VAR_42 -> VAR_51 = 0 ;,"CWE-200 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",<S2SV_ModStart> |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
138,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { if ( VAR_2 -> VAR_3 . VAR_4 . VAR_5 == VAR_6 ) { VAR_7 -> VAR_8 . VAR_9 = 0 ; VAR_10 -> VAR_11 . VAR_12 = 0 ; VAR_13 -> VAR_14 . VAR_15 = 0 ; VAR_16 -> VAR_17 . VAR_18 = 0 ; return ; } <S2SV_StartBug> METHOD_1 ( VAR_19 -> VAR_20 , VAR_21 -> VAR_22 . VAR_23 . VAR_24 * VAR_25 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_2 ( VAR_26 -> VAR_27 , ( VAR_28 -> VAR_29 . VAR_30 . VAR_31 - METHOD_3 ( ) ) * VAR_32 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }",<S2SV_ModStart> return ; } <S2SV_ModEnd> VAR_26 -> VAR_20 <S2SV_ModStart> VAR_26 -> VAR_20 = METHOD_2 ( <S2SV_ModEnd> VAR_28 -> VAR_29 <S2SV_ModStart> VAR_32 ) ; <S2SV_ModEnd> VAR_26 -> VAR_27 <S2SV_ModStart> VAR_26 -> VAR_27 = METHOD_2 ( <S2SV_ModEnd> ( VAR_28 -> <S2SV_ModStart> VAR_32 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,"CWE-189 static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }",<S2SV_ModStart> return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
139,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = 0 ; VAR_2 * VAR_3 ; VAR_4 * VAR_5 ; VAR_6 * VAR_7 ; VAR_8 * VAR_9 ; VAR_10 * VAR_11 ; TYPE_2 VAR_12 ; VAR_13 * VAR_14 ; TYPE_3 VAR_15 , VAR_16 ; VAR_17 * VAR_18 ; VAR_19 * VAR_20 ; VAR_21 * VAR_22 ; VAR_23 * VAR_24 ; VAR_25 * VAR_26 ; VAR_27 * VAR_28 ; VAR_29 * VAR_30 ; VAR_31 * VAR_32 ; TYPE_4 VAR_33 , VAR_34 , VAR_35 ; TYPE_5 VAR_36 ; TYPE_6 VAR_37 ; TYPE_7 VAR_38 ; struct STRUCT_OR_UNION_1 * VAR_39 ; VAR_40 = METHOD_1 ( VAR_41 -> VAR_42 ) ; if ( VAR_43 == VAR_44 ) { VAR_45 = VAR_46 ; VAR_47 = - 1 ; } else { VAR_48 = METHOD_2 ( VAR_49 , ""cpu_util_total"" ) ; VAR_50 = METHOD_3 ( VAR_51 , ""cpu_util_user"" ) ; VAR_52 = METHOD_4 ( VAR_53 , ""cpu_util_system"" ) ; VAR_54 = METHOD_5 ( VAR_55 , ""sender_has_retransmits"" ) ; if ( VAR_56 == VAR_57 || VAR_58 == VAR_59 || VAR_60 == VAR_61 || VAR_62 == VAR_63 ) { VAR_64 = VAR_65 ; VAR_66 = - 1 ; } else { if ( VAR_67 -> VAR_68 ) { METHOD_6 ( ""get_results\\n%s\\n"" , METHOD_7 ( VAR_69 ) ) ; } <S2SV_StartBug> VAR_70 -> VAR_71 [ 0 ] = VAR_72 -> VAR_73 ; <S2SV_EndBug> <S2SV_StartBug> VAR_74 -> VAR_75 [ 1 ] = VAR_76 -> VAR_77 ; <S2SV_EndBug> <S2SV_StartBug> VAR_78 -> VAR_79 [ 2 ] = VAR_80 -> VAR_81 ; <S2SV_EndBug> VAR_82 = VAR_83 -> VAR_84 ; if ( ! VAR_85 -> VAR_86 ) VAR_87 -> VAR_88 = VAR_89 ; VAR_90 = METHOD_8 ( VAR_91 , ""streams"" ) ; if ( VAR_92 == VAR_93 ) { VAR_94 = VAR_95 ; VAR_96 = - 1 ; } else { VAR_97 = METHOD_9 ( VAR_98 ) ; for ( VAR_99 = 0 ; VAR_100 < VAR_101 ; ++ VAR_102 ) { VAR_103 = METHOD_10 ( VAR_104 , VAR_105 ) ; if ( VAR_106 == VAR_107 ) { VAR_108 = VAR_109 ; VAR_110 = - 1 ; } else { VAR_111 = METHOD_11 ( VAR_112 , ""id"" ) ; VAR_113 = METHOD_12 ( VAR_114 , ""bytes"" ) ; VAR_115 = METHOD_13 ( VAR_116 , ""retransmits"" ) ; VAR_117 = METHOD_14 ( VAR_118 , ""jitter"" ) ; VAR_119 = METHOD_15 ( VAR_120 , ""errors"" ) ; VAR_121 = METHOD_16 ( VAR_122 , ""packets"" ) ; if ( VAR_123 == VAR_124 || VAR_125 == VAR_126 || VAR_127 == VAR_128 || VAR_129 == VAR_130 || VAR_131 == VAR_132 || VAR_133 == VAR_134 ) { VAR_135 = VAR_136 ; VAR_137 = - 1 ; } else { VAR_138 = VAR_139 -> VAR_140 ; VAR_141 = VAR_142 -> VAR_143 ; VAR_144 = VAR_145 -> VAR_146 ; <S2SV_StartBug> VAR_147 = VAR_148 -> VAR_149 ; <S2SV_EndBug> VAR_150 = VAR_151 -> VAR_152 ; VAR_153 = VAR_154 -> VAR_155 ; METHOD_17 ( VAR_156 , & VAR_157 -> VAR_158 , VAR_159 ) if ( VAR_160 -> VAR_161 == VAR_162 ) break ; if ( VAR_163 == VAR_164 ) { VAR_165 = VAR_166 ; VAR_167 = - 1 ; } else { if ( VAR_168 -> VAR_169 ) { VAR_170 -> VAR_171 = VAR_172 ; VAR_173 -> VAR_174 = VAR_175 ; VAR_176 -> VAR_177 = VAR_178 ; VAR_179 -> VAR_180 -> VAR_181 = VAR_182 ; } else { VAR_183 -> VAR_184 -> VAR_185 = VAR_186 ; VAR_187 -> VAR_188 -> VAR_189 = VAR_190 ; } } } } } if ( VAR_191 -> VAR_192 == 'c' && METHOD_18 ( VAR_193 ) ) { VAR_194 = METHOD_19 ( VAR_195 , ""server_output_json"" ) ; if ( VAR_196 != VAR_197 ) { VAR_198 -> VAR_199 = VAR_200 ; } else { VAR_201 = METHOD_20 ( VAR_202 , ""server_output_text"" ) ; if ( VAR_203 != VAR_204 ) { VAR_205 -> VAR_206 = METHOD_21 ( VAR_207 -> VAR_208 ) ; } } } } } METHOD_22 ( VAR_209 ) ; } return VAR_210 ; }",<S2SV_ModStart> = VAR_72 -> VAR_211 <S2SV_ModEnd> ; VAR_205 -> <S2SV_ModStart> = VAR_76 -> VAR_211 <S2SV_ModEnd> ; VAR_205 -> <S2SV_ModStart> = VAR_80 -> VAR_211 <S2SV_ModEnd> ; VAR_89 = <S2SV_ModStart> = VAR_148 -> VAR_211 <S2SV_ModEnd> ; VAR_175 =,"CWE-119 static int get_results ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; cJSON * j_cpu_util_total ; cJSON * j_cpu_util_user ; cJSON * j_cpu_util_system ; cJSON * j_sender_has_retransmits ; int result_has_retransmits ; cJSON * j_streams ; int n , i ; cJSON * j_stream ; cJSON * j_id ; cJSON * j_bytes ; cJSON * j_retransmits ; cJSON * j_jitter ; cJSON * j_errors ; cJSON * j_packets ; cJSON * j_server_output ; int sid , cerror , pcount ; double jitter ; iperf_size_t bytes_transferred ; int retransmits ; struct iperf_stream * sp ; j = JSON_read ( test -> ctrl_sck ) ; if ( j == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_cpu_util_total = cJSON_GetObjectItem ( j , ""cpu_util_total"" ) ; j_cpu_util_user = cJSON_GetObjectItem ( j , ""cpu_util_user"" ) ; j_cpu_util_system = cJSON_GetObjectItem ( j , ""cpu_util_system"" ) ; j_sender_has_retransmits = cJSON_GetObjectItem ( j , ""sender_has_retransmits"" ) ; if ( j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { if ( test -> debug ) { printf ( ""get_results\\n%s\\n"" , cJSON_Print ( j ) ) ; } <S2SV_StartBug> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <S2SV_EndBug> result_has_retransmits = j_sender_has_retransmits -> valueint ; if ( ! test -> sender ) test -> sender_has_retransmits = result_has_retransmits ; j_streams = cJSON_GetObjectItem ( j , ""streams"" ) ; if ( j_streams == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { n = cJSON_GetArraySize ( j_streams ) ; for ( i = 0 ; i < n ; ++ i ) { j_stream = cJSON_GetArrayItem ( j_streams , i ) ; if ( j_stream == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_id = cJSON_GetObjectItem ( j_stream , ""id"" ) ; j_bytes = cJSON_GetObjectItem ( j_stream , ""bytes"" ) ; j_retransmits = cJSON_GetObjectItem ( j_stream , ""retransmits"" ) ; j_jitter = cJSON_GetObjectItem ( j_stream , ""jitter"" ) ; j_errors = cJSON_GetObjectItem ( j_stream , ""errors"" ) ; j_packets = cJSON_GetObjectItem ( j_stream , ""packets"" ) ; if ( j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { sid = j_id -> valueint ; bytes_transferred = j_bytes -> valueint ; retransmits = j_retransmits -> valueint ; <S2SV_StartBug> jitter = j_jitter -> valuefloat ; <S2SV_EndBug> cerror = j_errors -> valueint ; pcount = j_packets -> valueint ; SLIST_FOREACH ( sp , & test -> streams , streams ) if ( sp -> id == sid ) break ; if ( sp == NULL ) { i_errno = IESTREAMID ; r = - 1 ; } else { if ( test -> sender ) { sp -> jitter = jitter ; sp -> cnt_error = cerror ; sp -> packet_count = pcount ; sp -> result -> bytes_received = bytes_transferred ; } else { sp -> result -> bytes_sent = bytes_transferred ; sp -> result -> stream_retrans = retransmits ; } } } } } if ( test -> role == 'c' && iperf_get_test_get_server_output ( test ) ) { j_server_output = cJSON_DetachItemFromObject ( j , ""server_output_json"" ) ; if ( j_server_output != NULL ) { test -> json_server_output = j_server_output ; } else { j_server_output = cJSON_GetObjectItem ( j , ""server_output_text"" ) ; if ( j_server_output != NULL ) { test -> server_output_text = strdup ( j_server_output -> valuestring ) ; } } } } } cJSON_Delete ( j ) ; } return r ; }",<S2SV_ModStart> = j_cpu_util_total -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_user -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_system -> valuedouble <S2SV_ModEnd> ; result_has_retransmits = <S2SV_ModStart> = j_jitter -> valuedouble <S2SV_ModEnd> ; cerror =
140,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 ; TYPE_3 VAR_7 ; TYPE_4 VAR_8 ; VAR_9 = - VAR_10 ; if ( VAR_11 -> VAR_12 & VAR_13 ) goto VAR_14 ; <S2SV_StartBug> VAR_15 = METHOD_1 ( VAR_16 , VAR_17 , 0 , & VAR_18 ) ; <S2SV_EndBug> if ( ! VAR_19 ) goto VAR_20 ; VAR_21 = VAR_22 -> VAR_23 ; if ( VAR_24 < VAR_25 ) { VAR_26 -> VAR_27 |= VAR_28 ; VAR_29 = VAR_30 ; } VAR_31 = METHOD_2 ( VAR_32 , 0 , VAR_33 -> VAR_34 , VAR_35 ) ; if ( VAR_36 ) goto VAR_37 ; VAR_38 = ( VAR_39 & VAR_40 ) ? VAR_41 -> VAR_42 : VAR_43 ; VAR_44 : METHOD_3 ( VAR_45 , VAR_46 ) ; METHOD_4 ( VAR_47 ) ; return VAR_48 ; VAR_49 : return VAR_50 ; }",<S2SV_ModStart> goto VAR_49 ; VAR_33 -> VAR_51 = 0 ;,"CWE-200 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }",<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
141,"CWE-000 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { VAR_3 * VAR_4 ; TYPE_4 * VAR_5 , * VAR_6 , * VAR_7 , * VAR_8 , * VAR_9 , * VAR_10 ; TYPE_5 VAR_11 ; TYPE_6 VAR_12 , VAR_13 , VAR_14 ; VAR_15 = VAR_16 -> VAR_17 ; VAR_18 = VAR_19 ; VAR_20 = 0 ; VAR_21 = 0 ; VAR_22 = 0 ; VAR_23 = VAR_24 ; VAR_25 = ""detail"" ; VAR_26 = 0 ; if ( VAR_27 -> VAR_28 -> VAR_29 & VAR_30 ) { METHOD_1 ( ""info<S2SV_blank>appweb<S2SV_blank>config"" , 4 , ""Already<S2SV_blank>tracing.<S2SV_blank>Ignoring<S2SV_blank>TraceLog<S2SV_blank>directive"" ) ; return 0 ; } for ( VAR_31 = METHOD_2 ( METHOD_3 ( VAR_32 ) , & VAR_33 ) ; VAR_34 ; VAR_35 = METHOD_4 ( VAR_36 , & VAR_37 ) ) { if ( ! VAR_38 ) { VAR_39 = METHOD_5 ( VAR_40 ) ; } else { <S2SV_StartBug> VAR_41 = METHOD_6 ( VAR_42 , ""<S2SV_blank>=\\t,"" , & VAR_43 ) ; <S2SV_EndBug> VAR_44 = strim ( VAR_45 , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( VAR_46 , ""anew"" ) ) { VAR_47 |= MPR_LOG_ANEW ; } else if ( smatch ( VAR_48 , ""backup"" ) ) { VAR_49 = atoi ( VAR_50 ) ; } else if ( smatch ( VAR_51 , ""format"" ) ) { VAR_52 = VAR_53 ; } else if ( smatch ( VAR_54 , ""level"" ) ) { VAR_55 = ( TYPE_7 ) stoi ( VAR_56 ) ; } else if ( smatch ( VAR_57 , ""size"" ) ) { VAR_58 = ( TYPE_8 ) getnum ( VAR_59 ) ; } else if ( smatch ( VAR_60 , ""formatter"" ) ) { VAR_61 = VAR_62 ; } else { METHOD_7 ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>TraceLog<S2SV_blank>option<S2SV_blank>%s"" , VAR_63 ) ; } } } if ( VAR_64 < HTTP_TRACE_MIN_LOG_SIZE ) { VAR_65 = HTTP_TRACE_MIN_LOG_SIZE ; } if ( VAR_66 == 0 ) { METHOD_8 ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Missing<S2SV_blank>TraceLog<S2SV_blank>filename"" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( VAR_67 ) { httpSetTraceFormatterName ( VAR_68 -> VAR_69 , VAR_70 ) ; } if ( ! smatch ( VAR_71 , ""stdout"" ) && ! smatch ( VAR_72 , ""stderr"" ) ) { VAR_73 = httpMakePath ( VAR_74 , VAR_75 -> configDir , VAR_76 ) ; } VAR_77 -> VAR_78 = httpCreateTrace ( VAR_79 -> VAR_80 ) ; if ( httpSetTraceLogFile ( VAR_81 -> VAR_82 , VAR_83 , VAR_84 , VAR_85 , VAR_86 , VAR_87 ) < 0 ) { return MPR_ERR_CANT_OPEN ; } httpSetTraceLevel ( VAR_88 ) ; return 0 ; }","<S2SV_ModStart> { VAR_63 = METHOD_9 <S2SV_ModEnd> ( VAR_63 ,","CWE-000 static int traceLogDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * format , * option , * ovalue , * tok , * path , * formatter ; ssize size ; int flags , backup , level ; route = state -> route ; size = MAXINT ; backup = 0 ; flags = 0 ; path = 0 ; format = ME_HTTP_LOG_FORMAT ; formatter = ""detail"" ; level = 0 ; if ( route -> trace -> flags & MPR_LOG_CMDLINE ) { mprLog ( ""info<S2SV_blank>appweb<S2SV_blank>config"" , 4 , ""Already<S2SV_blank>tracing.<S2SV_blank>Ignoring<S2SV_blank>TraceLog<S2SV_blank>directive"" ) ; return 0 ; } for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = sclone ( option ) ; } else { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""anew"" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , ""backup"" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , ""format"" ) ) { format = ovalue ; } else if ( smatch ( option , ""level"" ) ) { level = ( int ) stoi ( ovalue ) ; } else if ( smatch ( option , ""size"" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , ""formatter"" ) ) { formatter = ovalue ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>TraceLog<S2SV_blank>option<S2SV_blank>%s"" , option ) ; } } } if ( size < HTTP_TRACE_MIN_LOG_SIZE ) { size = HTTP_TRACE_MIN_LOG_SIZE ; } if ( path == 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Missing<S2SV_blank>TraceLog<S2SV_blank>filename"" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( formatter ) { httpSetTraceFormatterName ( route -> trace , formatter ) ; } if ( ! smatch ( path , ""stdout"" ) && ! smatch ( path , ""stderr"" ) ) { path = httpMakePath ( route , state -> configDir , path ) ; } route -> trace = httpCreateTrace ( route -> trace ) ; if ( httpSetTraceLogFile ( route -> trace , path , size , backup , format , flags ) < 0 ) { return MPR_ERR_CANT_OPEN ; } httpSetTraceLevel ( level ) ; return 0 ; }","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,"
142,"CWE-264 TYPE_0 METHOD_0 ( TYPE_1 ) { TYPE_2 * VAR_0 = METHOD_1 ( """" ) ; METHOD_2 ( ""js<S2SV_blank>(\'x\'<S2SV_blank>+<S2SV_blank>345).toUpperCase()"" , VAR_1 ) ; g_assert_cmpstr ( ""X345"" , == , VAR_2 -> VAR_3 ) ; <S2SV_StartBug> VAR_4 . VAR_5 . VAR_6 = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> METHOD_3 ( ""js<S2SV_blank>Uzbl.run(\'print<S2SV_blank>@useragent\').toUpperCase();"" , VAR_7 ) ; g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , VAR_8 -> VAR_9 ) ; METHOD_4 ( VAR_10 , VAR_11 ) ; }",<S2SV_ModStart> VAR_9 ) ; <S2SV_ModEnd> METHOD_4 ( VAR_10,"CWE-264 void test_js ( void ) { GString * result = g_string_new ( """" ) ; parse_cmd_line ( ""js<S2SV_blank>(\'x\'<S2SV_blank>+<S2SV_blank>345).toUpperCase()"" , result ) ; g_assert_cmpstr ( ""X345"" , == , result -> str ) ; <S2SV_StartBug> uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> parse_cmd_line ( ""js<S2SV_blank>Uzbl.run(\'print<S2SV_blank>@useragent\').toUpperCase();"" , result ) ; g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , result -> str ) ; g_string_free ( result , TRUE ) ; }",<S2SV_ModStart> str ) ; <S2SV_ModEnd> g_string_free ( result
143,"CWE-200 TYPE_0 STRUCT_OR_UNION_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_4 VAR_3 ; TYPE_3 VAR_4 ; TYPE_4 VAR_5 = 0 ; TYPE_5 TYPE_6 struct STRUCT_OR_UNION_5 VAR_6 ; METHOD_0 ( & VAR_7 , VAR_8 , sizeof ( * VAR_9 ) ) ; VAR_10 -> VAR_11 = 0 ; METHOD_1 ( ""ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u,"" ""logical<S2SV_blank>block<S2SV_blank>%lu\\n"" , STRUCT_OR_UNION_6 -> VAR_12 , VAR_13 , VAR_14 -> VAR_15 , ( unsigned TYPE_7 ) VAR_16 -> VAR_17 ) ; if ( METHOD_2 ( VAR_18 -> VAR_19 > VAR_20 ) ) VAR_21 -> VAR_22 = VAR_23 ; if ( METHOD_3 ( VAR_24 -> VAR_25 >= VAR_26 ) ) return - VAR_27 ; if ( METHOD_4 ( STRUCT_OR_UNION_7 , VAR_28 -> VAR_29 , & VAR_30 ) ) { if ( METHOD_5 ( & VAR_31 ) || METHOD_6 ( & VAR_32 ) ) { VAR_33 -> VAR_34 = METHOD_7 ( & VAR_35 ) + VAR_36 -> VAR_37 - VAR_38 . VAR_39 ; VAR_40 -> VAR_41 |= METHOD_8 ( & VAR_42 ) ? VAR_43 : VAR_44 ; VAR_45 = VAR_46 . VAR_47 - ( VAR_48 -> VAR_49 - VAR_50 . VAR_51 ) ; if ( VAR_52 > VAR_53 -> VAR_54 ) VAR_55 = VAR_56 -> VAR_57 ; VAR_58 -> VAR_59 = VAR_60 ; } else if ( METHOD_9 ( & VAR_61 ) || METHOD_10 ( & VAR_62 ) ) { VAR_63 -> VAR_64 = 0 ; VAR_65 = VAR_66 . VAR_67 - ( VAR_68 -> VAR_69 - VAR_70 . VAR_71 ) ; if ( VAR_72 > VAR_73 -> VAR_74 ) VAR_75 = VAR_76 -> VAR_77 ; VAR_78 -> VAR_79 = VAR_80 ; VAR_81 = 0 ; } else { METHOD_11 ( 1 ) ; } TYPE_8 TYPE_9 VAR_82 ( VAR_83 , STRUCT_OR_UNION_8 , VAR_84 , & VAR_85 , VAR_86 ) ; goto VAR_87 ; } METHOD_12 ( & METHOD_13 ( STRUCT_OR_UNION_9 ) -> VAR_88 ) ; if ( METHOD_14 ( STRUCT_OR_UNION_10 , VAR_89 ) ) { VAR_90 = METHOD_15 ( VAR_91 , STRUCT_OR_UNION_11 , VAR_92 , VAR_93 & VAR_94 ) ; } else { VAR_95 = METHOD_16 ( VAR_96 , STRUCT_OR_UNION_12 , VAR_97 , VAR_98 & VAR_99 ) ; } if ( VAR_100 > 0 ) { unsigned TYPE_10 VAR_101 ; if ( METHOD_17 ( VAR_102 != VAR_103 -> VAR_104 ) ) { METHOD_18 ( STRUCT_OR_UNION_13 -> VAR_105 , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , STRUCT_OR_UNION_14 -> VAR_106 , VAR_107 , VAR_108 -> VAR_109 ) ; METHOD_19 ( 1 ) ; } VAR_110 = VAR_111 -> VAR_112 & VAR_113 ? VAR_114 : VAR_115 ; if ( ! ( VAR_116 & VAR_117 ) && ! ( VAR_118 & VAR_119 ) && METHOD_20 ( STRUCT_OR_UNION_15 , VAR_120 -> VAR_121 , VAR_122 -> VAR_123 + VAR_124 -> VAR_125 - 1 ) ) VAR_126 |= VAR_127 ; VAR_128 = METHOD_21 ( STRUCT_OR_UNION_16 , VAR_129 -> VAR_130 , VAR_131 -> VAR_132 , VAR_133 -> VAR_134 , VAR_135 ) ; if ( VAR_136 < 0 ) VAR_137 = VAR_138 ; } METHOD_22 ( ( & METHOD_23 ( STRUCT_OR_UNION_17 ) -> VAR_139 ) ) ; VAR_140 : if ( VAR_141 > 0 && VAR_142 -> VAR_143 & VAR_144 ) { VAR_145 = METHOD_24 ( STRUCT_OR_UNION_18 , VAR_146 ) ; if ( VAR_147 != 0 ) return VAR_148 ; } if ( ( VAR_149 & VAR_150 ) == 0 ) return VAR_151 ; if ( VAR_152 > 0 && VAR_153 -> VAR_154 & VAR_155 ) if ( ! ( VAR_156 & VAR_157 ) ) return VAR_158 ; VAR_159 -> VAR_160 &= ~ VAR_161 ; METHOD_25 ( & METHOD_26 ( STRUCT_OR_UNION_19 ) -> VAR_162 ) ; if ( METHOD_27 ( STRUCT_OR_UNION_20 , VAR_163 ) ) { VAR_164 = METHOD_28 ( VAR_165 , STRUCT_OR_UNION_21 , VAR_166 , VAR_167 ) ; } else { VAR_168 = METHOD_29 ( VAR_169 , STRUCT_OR_UNION_22 , VAR_170 , VAR_171 ) ; if ( VAR_172 > 0 && VAR_173 -> VAR_174 & VAR_175 ) { METHOD_30 ( STRUCT_OR_UNION_23 , VAR_176 ) ; } if ( ( VAR_177 > 0 ) && ( VAR_178 & VAR_179 ) ) METHOD_31 ( STRUCT_OR_UNION_24 , VAR_180 , 1 ) ; } if ( VAR_181 > 0 ) { unsigned TYPE_11 VAR_182 ; if ( METHOD_32 ( VAR_183 != VAR_184 -> VAR_185 ) ) { METHOD_33 ( STRUCT_OR_UNION_25 -> VAR_186 , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , STRUCT_OR_UNION_26 -> VAR_187 , VAR_188 , VAR_189 -> VAR_190 ) ; METHOD_34 ( 1 ) ; } if ( VAR_191 & VAR_192 && VAR_193 -> VAR_194 & VAR_195 && VAR_196 -> VAR_197 & VAR_198 ) { VAR_199 = METHOD_35 ( STRUCT_OR_UNION_27 , VAR_200 -> VAR_201 , VAR_202 -> VAR_203 , VAR_204 -> VAR_205 ) ; if ( VAR_206 ) { VAR_207 = VAR_208 ; goto VAR_209 ; } } if ( ( VAR_210 & VAR_211 ) && METHOD_36 ( STRUCT_OR_UNION_28 , VAR_212 -> VAR_213 , & VAR_214 ) ) { if ( METHOD_37 ( & VAR_215 ) ) goto VAR_216 ; } VAR_217 = VAR_218 -> VAR_219 & VAR_220 ? VAR_221 : VAR_222 ; if ( ! ( VAR_223 & VAR_224 ) && ! ( VAR_225 & VAR_226 ) && METHOD_38 ( STRUCT_OR_UNION_29 , VAR_227 -> VAR_228 , VAR_229 -> VAR_230 + VAR_231 -> VAR_232 - 1 ) ) VAR_233 |= VAR_234 ; VAR_235 = METHOD_39 ( STRUCT_OR_UNION_30 , VAR_236 -> VAR_237 , VAR_238 -> VAR_239 , VAR_240 -> VAR_241 , VAR_242 ) ; if ( VAR_243 < 0 ) { VAR_244 = VAR_245 ; goto VAR_246 ; } } VAR_247 : METHOD_40 ( ( & METHOD_41 ( STRUCT_OR_UNION_31 ) -> VAR_248 ) ) ; if ( VAR_249 > 0 && VAR_250 -> VAR_251 & VAR_252 ) { VAR_253 = METHOD_42 ( STRUCT_OR_UNION_32 , VAR_254 ) ; if ( VAR_255 != 0 ) return VAR_256 ; <S2SV_StartBug> } <S2SV_EndBug> return VAR_257 ; }","<S2SV_ModStart> return VAR_256 ; if ( VAR_254 -> VAR_251 & VAR_198 && ! ( VAR_254 -> VAR_251 & VAR_220 ) && ! ( VAR_223 & VAR_192 ) && ! METHOD_43 ( STRUCT_OR_UNION_32 ) && METHOD_44 ( STRUCT_OR_UNION_32 ) ) { VAR_256 = METHOD_45 ( VAR_169 , STRUCT_OR_UNION_32 ) ; if ( VAR_256 ) return VAR_256 ; } } return <S2SV_ModEnd> VAR_257 ; }","CWE-200 int ext4_map_blocks ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , int flags ) { struct extent_status es ; int retval ; int ret = 0 ;  ifdef ES_AGGRESSIVE_TEST struct ext4_map_blocks orig_map ; memcpy ( & orig_map , map , sizeof ( * map ) ) ;   map -> m_flags = 0 ; ext_debug ( ""ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u,"" ""logical<S2SV_blank>block<S2SV_blank>%lu\\n"" , inode -> i_ino , flags , map -> m_len , ( unsigned long ) map -> m_lblk ) ; if ( unlikely ( map -> m_len > INT_MAX ) ) map -> m_len = INT_MAX ; if ( unlikely ( map -> m_lblk >= EXT_MAX_BLOCKS ) ) return - EFSCORRUPTED ; if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { map -> m_pblk = ext4_es_pblock ( & es ) + map -> m_lblk - es . es_lblk ; map -> m_flags |= ext4_es_is_written ( & es ) ? EXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { map -> m_pblk = 0 ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; retval = 0 ; } else { BUG_ON ( 1 ) ; }  ifdef ES_AGGRESSIVE_TEST ext4_map_blocks_es_recheck ( handle , inode , map , & orig_map , flags ) ;   goto found ; } down_read ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) retval = ret ; } up_read ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; found : if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ; map -> m_flags &= ~ EXT4_MAP_FLAGS ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) { ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ; } if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) { ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ; if ( ret ) { retval = ret ; goto out_sem ; } } if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) ) goto out_sem ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) { retval = ret ; goto out_sem ; } } out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; <S2SV_StartBug> } <S2SV_EndBug> return retval ; }","<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }"
144,"CWE-369 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 VAR_2 ; TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; struct STRUCT_OR_UNION_0 { unsigned TYPE_7 VAR_6 , VAR_7 , VAR_8 , VAR_9 ; } * VAR_10 = ( struct STRUCT_OR_UNION_1 * ) VAR_11 ; VAR_12 = & VAR_13 ; VAR_14 -> VAR_15 = VAR_16 ; VAR_17 -> VAR_18 = ( VAR_19 | VAR_20 | VAR_21 | VAR_22 | VAR_23 ) ; VAR_24 -> VAR_25 = VAR_26 -> VAR_27 & 0x43 ; VAR_28 -> VAR_29 = VAR_30 ; VAR_31 = METHOD_1 ( VAR_32 , VAR_33 ) ; VAR_34 = METHOD_2 ( VAR_35 ) + METHOD_3 ( VAR_36 , VAR_37 . VAR_38 ) ; VAR_39 = METHOD_4 ( VAR_40 ) ; VAR_41 = VAR_42 -> VAR_43 << 2 >> VAR_44 ; VAR_45 = VAR_46 -> VAR_47 ; VAR_48 = VAR_49 ; VAR_50 -> VAR_51 = VAR_52 ; VAR_53 -> VAR_54 = 4 * VAR_55 ; <S2SV_StartBug> VAR_56 = ( VAR_57 + 5 ) / 6 ; <S2SV_EndBug> VAR_58 = 2 * VAR_59 + 3 ; VAR_60 = ( VAR_61 * VAR_62 . VAR_63 + VAR_64 * VAR_65 . VAR_66 ) % VAR_67 ; VAR_68 = 1 ; if ( VAR_69 -> VAR_70 < 0x22 ) VAR_71 ++ ; for ( VAR_72 = 0 ; VAR_73 < VAR_74 ; ++ VAR_75 ) { VAR_76 [ VAR_77 ] . VAR_78 = VAR_79 . VAR_80 ; VAR_81 [ VAR_82 ] . VAR_83 = VAR_84 . VAR_85 ; VAR_86 [ VAR_87 ] . VAR_88 = 0 ; VAR_89 [ VAR_90 ] . VAR_91 = VAR_92 ; } for ( VAR_93 = 1 ; VAR_94 <= VAR_95 ; ++ VAR_96 ) { VAR_97 [ VAR_98 ] . VAR_99 = VAR_100 ; VAR_101 = ( VAR_102 + VAR_103 ) % VAR_104 ; if ( VAR_105 [ VAR_106 ] . VAR_107 ) { ++ VAR_108 ; if ( VAR_109 >= VAR_110 ) { VAR_111 -= VAR_112 ; while ( VAR_113 [ VAR_114 ] . VAR_115 ) ++ VAR_116 ; } } } if ( VAR_117 -> VAR_118 & VAR_119 ) { for ( VAR_120 = 0 ; VAR_121 < VAR_122 ; VAR_123 ++ ) VAR_124 [ VAR_125 ] . VAR_126 += METHOD_5 ( VAR_127 ) - 1 ; } }",<S2SV_ModStart> * VAR_122 ; if ( ! VAR_122 ) return ;,"CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }",<S2SV_ModStart> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
145,"CWE-476 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; <S2SV_StartBug> if ( VAR_11 == 0 && VAR_12 == 0 ) { <S2SV_EndBug> return ; } VAR_13 = 1 << VAR_14 ; VAR_15 = VAR_16 ; for ( VAR_17 = 0 ; VAR_18 < METHOD_1 ( VAR_19 ) ; ++ VAR_20 ) { for ( VAR_21 = 0 ; VAR_22 < METHOD_2 ( VAR_23 ) ; ++ VAR_24 ) { VAR_25 = METHOD_3 ( VAR_26 , VAR_27 , VAR_28 ) ; VAR_29 = METHOD_4 ( VAR_30 ) ; if ( VAR_31 >= VAR_32 ) { VAR_33 >>= VAR_34 ; VAR_35 = ( VAR_36 < 0 ) ? ( - VAR_37 ) : VAR_38 ; METHOD_5 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; } else { VAR_43 <<= VAR_44 ; <S2SV_StartBug> VAR_45 = ( 1 << VAR_46 ) - 1 ; <S2SV_EndBug> if ( VAR_47 & ( ~ VAR_48 ) ) { if ( ! VAR_49 ) { METHOD_6 ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; VAR_50 = VAR_51 ; } VAR_52 &= VAR_53 ; } VAR_54 = ( VAR_55 < 0 ) ? ( - VAR_56 ) : VAR_57 ; METHOD_7 ( VAR_58 , VAR_59 , VAR_60 , VAR_61 ) ; } } } }","<S2SV_ModStart> if ( VAR_34 < 0 ) { METHOD_6 ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; VAR_34 = 0 ; } if ( VAR_34 <S2SV_ModStart> VAR_53 = ( METHOD_8 ( TYPE_11 , 1 ) <S2SV_ModEnd> << VAR_46 )","CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }","<S2SV_ModStart> if ( roishift < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )"
146,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = METHOD_1 ( VAR_2 ) ; struct STRUCT_OR_UNION_1 * VAR_3 = METHOD_2 ( VAR_4 ) ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = METHOD_3 ( VAR_5 ) ; TYPE_2 VAR_6 = VAR_7 -> VAR_8 ; METHOD_4 ( METHOD_5 ( VAR_9 ) , VAR_10 , METHOD_6 ( VAR_11 ) , VAR_12 -> VAR_13 , VAR_14 , METHOD_7 ( VAR_15 ) , VAR_16 ) ; if ( VAR_17 -> VAR_18 . VAR_19 ) return 0 ; if ( METHOD_8 ( VAR_20 -> VAR_21 ) ) { METHOD_9 ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , VAR_22 , METHOD_10 ( VAR_23 ) ) ; return 1 ; } switch ( VAR_24 ) { case VAR_25 : if ( ! METHOD_11 ( VAR_26 ) ) return 0 ; else if ( METHOD_12 ( VAR_27 ) ) return VAR_28 ; else if ( METHOD_13 ( VAR_29 ) && ! ( STRUCT_OR_UNION_4 -> VAR_30 & VAR_31 ) ) return 0 ; return STRUCT_OR_UNION_5 -> VAR_32 & ( 1u << ( VAR_33 & VAR_34 ) ) ; case VAR_35 : return 0 ; case VAR_36 : return 1 ; case VAR_37 : return METHOD_14 ( STRUCT_OR_UNION_6 , VAR_38 ) ; case VAR_39 : return METHOD_15 ( STRUCT_OR_UNION_7 , VAR_40 ) ; case VAR_41 : return 1 ; case VAR_42 : if ( METHOD_16 ( VAR_43 , VAR_44 ) == 0xa ) return 0 ; return 1 ; case VAR_45 : return METHOD_17 ( STRUCT_OR_UNION_8 , VAR_46 ) ; case VAR_47 : return 1 ; case VAR_48 : return METHOD_18 ( STRUCT_OR_UNION_9 , VAR_49 ) ; case VAR_50 : return METHOD_19 ( STRUCT_OR_UNION_10 , VAR_51 ) ; case VAR_52 : return METHOD_20 ( STRUCT_OR_UNION_11 , VAR_53 ) ; case VAR_54 : case VAR_55 : case VAR_56 : case VAR_57 : case VAR_58 : case VAR_59 : case VAR_60 : case VAR_61 : case VAR_62 : case VAR_63 : <S2SV_StartBug> case VAR_64 : <S2SV_EndBug> return 1 ; case VAR_65 : return METHOD_21 ( VAR_66 , STRUCT_OR_UNION_12 ) ; case VAR_67 : return METHOD_22 ( STRUCT_OR_UNION_13 , VAR_68 ) ; case VAR_69 : return METHOD_23 ( VAR_70 , STRUCT_OR_UNION_14 ) ; case VAR_71 : case VAR_72 : return METHOD_24 ( VAR_73 , STRUCT_OR_UNION_15 , VAR_74 ) ; case VAR_75 : return 1 ; case VAR_76 : return METHOD_25 ( STRUCT_OR_UNION_16 , VAR_77 ) ; case VAR_78 : return METHOD_26 ( STRUCT_OR_UNION_17 , VAR_79 ) ; case VAR_80 : return METHOD_27 ( STRUCT_OR_UNION_18 , VAR_81 ) || METHOD_28 ( STRUCT_OR_UNION_19 , VAR_82 ) ; case VAR_83 : return 0 ; case VAR_84 : return METHOD_29 ( STRUCT_OR_UNION_20 , VAR_85 ) ; case VAR_86 : return METHOD_30 ( STRUCT_OR_UNION_21 , VAR_87 ) ; case VAR_88 : return 0 ; case VAR_89 : return 0 ; case VAR_90 : return METHOD_31 ( STRUCT_OR_UNION_22 , VAR_91 ) ; case VAR_92 : return 1 ; default : return 1 ; } }",<S2SV_ModStart> case VAR_64 : case VAR_93 :,"CWE-264 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }",<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
147,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = METHOD_1 ( VAR_3 -> STRUCT_OR_UNION_3 ) ; <S2SV_StartBug> struct STRUCT_OR_UNION_4 * VAR_4 = VAR_5 -> VAR_6 -> STRUCT_OR_UNION_5 ; <S2SV_EndBug> if ( VAR_7 -> STRUCT_OR_UNION_6 != VAR_8 || VAR_9 -> VAR_10 < VAR_11 ) return 1 ; if ( VAR_12 -> VAR_13 == VAR_14 && ! VAR_15 -> VAR_16 . VAR_17 ) return 1 ; return VAR_18 -> METHOD_2 ( VAR_19 , VAR_20 ) >= 0 ; }",<S2SV_ModStart> VAR_6 -> STRUCT_OR_UNION_6 ; if ( METHOD_3 ( VAR_20 ) ) return 1,"CWE-20 static int validate_event ( struct pmu_hw_events * hw_events , struct perf_event * event ) { struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; return armpmu -> get_event_idx ( hw_events , event ) >= 0 ; }",<S2SV_ModStart> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
148,"CWE-20 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { VAR_1 * VAR_2 ; TYPE_2 VAR_3 ; <S2SV_StartBug> TYPE_3 VAR_4 = 0 ; <S2SV_EndBug> TYPE_4 VAR_5 = 1 ; TYPE_5 VAR_6 = 0 ; unsigned TYPE_6 VAR_7 = 0 ; TYPE_7 VAR_8 = 0 ; unsigned TYPE_8 * VAR_9 ; TYPE_9 VAR_10 ; TYPE_10 VAR_11 ; TYPE_11 * VAR_12 = METHOD_1 ( VAR_13 , 1 ) ; VAR_14 = METHOD_2 ( VAR_15 -> VAR_16 ) ? 0 : 1 ; VAR_17 = METHOD_3 ( VAR_18 -> VAR_19 , 4 ) ; <S2SV_StartBug> VAR_20 = METHOD_4 ( VAR_21 -> VAR_22 ) ; <S2SV_EndBug> if ( VAR_23 ) { VAR_24 = METHOD_5 ( VAR_25 , & VAR_26 , & VAR_27 ) ; } else { VAR_28 = METHOD_6 ( VAR_29 -> VAR_30 , & VAR_31 , 1 ) ; } if ( VAR_32 == VAR_33 ) { unsigned TYPE_12 VAR_34 , VAR_35 , VAR_36 , VAR_37 , VAR_38 ; VAR_39 = ( unsigned TYPE_13 ) VAR_40 ; VAR_41 = VAR_42 >> ( VAR_43 - 1 ) ; VAR_44 = VAR_45 & 0xf ; if ( VAR_46 ) { VAR_47 = METHOD_7 ( VAR_48 , & VAR_49 , & VAR_50 ) ; } else { VAR_51 = METHOD_8 ( VAR_52 -> VAR_53 , & VAR_54 , 1 ) ; } if ( VAR_55 == VAR_56 ) { VAR_57 = ( unsigned TYPE_14 ) VAR_58 ; VAR_59 = VAR_60 >> ( VAR_61 - 1 ) ; VAR_62 = VAR_63 & 0x7f ; VAR_64 = VAR_65 ; if ( VAR_66 == 126 ) { VAR_67 = 2 ; if ( VAR_68 ) { VAR_69 = METHOD_9 ( VAR_70 , ( TYPE_15 * ) & VAR_71 , & VAR_72 ) ; } else { VAR_73 = METHOD_10 ( VAR_74 -> VAR_75 , ( TYPE_16 * ) & VAR_76 , 2 ) ; } VAR_77 = METHOD_11 ( VAR_78 ) ; if ( VAR_79 == VAR_80 ) { VAR_81 = VAR_82 ; } else { return 0 ; } } if ( VAR_83 == 127 ) { VAR_84 = 8 ; if ( VAR_85 ) { VAR_86 = METHOD_12 ( VAR_87 , ( TYPE_17 * ) & VAR_88 , & VAR_89 ) ; } else { VAR_90 = METHOD_13 ( VAR_91 -> VAR_92 , ( TYPE_18 * ) & VAR_93 , 8 ) ; } if ( VAR_94 == VAR_95 ) { VAR_96 = METHOD_14 ( & VAR_97 ) ; } else { return 0 ; } } ap_log_rerror ( VAR_98 , VAR_99 , 0 , VAR_100 , ""Websocket:<S2SV_blank>Reading<S2SV_blank>%"" APR_SIZE_T_FMT ""<S2SV_blank>(%s)<S2SV_blank>bytes,<S2SV_blank>masking<S2SV_blank>is<S2SV_blank>%s.<S2SV_blank>%s"" , VAR_101 , ( VAR_102 >= 126 ) ? ""extra<S2SV_blank>payload"" : ""no<S2SV_blank>extra<S2SV_blank>payload"" , VAR_103 ? ""on"" : ""off"" , VAR_104 ? ""This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>final<S2SV_blank>frame"" : ""more<S2SV_blank>to<S2SV_blank>follow"" ) ; if ( VAR_105 ) { VAR_106 = 4 ; if ( VAR_107 ) { VAR_108 = METHOD_15 ( VAR_109 , ( TYPE_19 * ) VAR_110 , & VAR_111 ) ; } else { VAR_112 = METHOD_16 ( VAR_113 -> VAR_114 , ( TYPE_20 * ) VAR_115 , 4 ) ; } if ( VAR_116 != VAR_117 ) { return 0 ; } } if ( VAR_118 < ( VAR_119 * 1024 ) && VAR_120 > 0 ) { TYPE_21 VAR_121 = VAR_122 ; TYPE_22 VAR_123 ; TYPE_23 VAR_124 = 0 ; TYPE_24 * VAR_125 = METHOD_17 ( VAR_126 -> VAR_127 , VAR_128 + 1 ) ; VAR_129 [ VAR_130 ] = 0 ; if ( VAR_131 ) { while ( VAR_132 > 0 ) { VAR_133 = VAR_134 ; VAR_135 = METHOD_18 ( VAR_136 , VAR_137 + VAR_138 , & VAR_139 ) ; if ( VAR_140 > 0 ) { VAR_141 -= VAR_142 ; VAR_143 += VAR_144 ; } } ap_log_rerror ( VAR_145 , VAR_146 , 0 , VAR_147 , ""Websocket:<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%"" APR_OFF_T_FMT ""<S2SV_blank>bytes,<S2SV_blank>pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack"" , VAR_148 ) ; } else { VAR_149 = METHOD_19 ( VAR_150 -> VAR_151 , VAR_152 , VAR_153 ) ; ap_log_rerror ( VAR_154 , VAR_155 , 0 , VAR_156 , ""Websocket:<S2SV_blank>SSL<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%"" APR_SIZE_T_FMT ""<S2SV_blank>bytes,<S2SV_blank>"" ""pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack"" , VAR_157 ) ; } if ( VAR_158 ) { for ( VAR_159 = 0 ; VAR_160 < VAR_161 ; VAR_162 ++ ) { VAR_163 [ VAR_164 ] ^= VAR_165 [ VAR_166 % 4 ] ; } } METHOD_20 ( VAR_167 , VAR_168 , ( TYPE_25 ) VAR_169 ) ; METHOD_21 ( VAR_170 , VAR_171 ) ; return 2 ; } if ( VAR_172 == 0x09 ) { TYPE_26 VAR_173 [ 2 ] ; VAR_174 = 2 ; VAR_175 [ 0 ] = 0x8A ; VAR_176 [ 1 ] = 0 ; METHOD_22 ( VAR_177 , VAR_178 , & VAR_179 ) ; <S2SV_StartBug> METHOD_23 ( VAR_180 ) ; <S2SV_EndBug> } } } return 0 ; }",<S2SV_ModStart> VAR_149 ; TYPE_10 VAR_181 = 1 ; TYPE_10 <S2SV_ModStart> -> VAR_151 ) ; while ( VAR_181 ) { VAR_181 = 0 <S2SV_ModStart> VAR_179 ) ; VAR_181 = 1 ; } <S2SV_ModEnd> } } },"CWE-20 static int lua_websocket_read ( lua_State * L ) { apr_socket_t * sock ; apr_status_t rv ; <S2SV_StartBug> int n = 0 ; <S2SV_EndBug> apr_size_t len = 1 ; apr_size_t plen = 0 ; unsigned short payload_short = 0 ; apr_uint64_t payload_long = 0 ; unsigned char * mask_bytes ; char byte ; int plaintext ; request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ; mask_bytes = apr_pcalloc ( r -> pool , 4 ) ; <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { unsigned char ubyte , fin , opcode , mask , payload ; ubyte = ( unsigned char ) byte ; fin = ubyte >> ( CHAR_BIT - 1 ) ; opcode = ubyte & 0xf ; if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { ubyte = ( unsigned char ) byte ; mask = ubyte >> ( CHAR_BIT - 1 ) ; payload = ubyte & 0x7f ; plen = payload ; if ( payload == 126 ) { len = 2 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ) ; } payload_short = ntohs ( payload_short ) ; if ( rv == APR_SUCCESS ) { plen = payload_short ; } else { return 0 ; } } if ( payload == 127 ) { len = 8 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ) ; } if ( rv == APR_SUCCESS ) { plen = ap_ntoh64 ( & payload_long ) ; } else { return 0 ; } } ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , ""Websocket:<S2SV_blank>Reading<S2SV_blank>%"" APR_SIZE_T_FMT ""<S2SV_blank>(%s)<S2SV_blank>bytes,<S2SV_blank>masking<S2SV_blank>is<S2SV_blank>%s.<S2SV_blank>%s"" , plen , ( payload >= 126 ) ? ""extra<S2SV_blank>payload"" : ""no<S2SV_blank>extra<S2SV_blank>payload"" , mask ? ""on"" : ""off"" , fin ? ""This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>final<S2SV_blank>frame"" : ""more<S2SV_blank>to<S2SV_blank>follow"" ) ; if ( mask ) { len = 4 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ) ; } if ( rv != APR_SUCCESS ) { return 0 ; } } if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 ) { apr_size_t remaining = plen ; apr_size_t received ; apr_off_t at = 0 ; char * buffer = apr_palloc ( r -> pool , plen + 1 ) ; buffer [ plen ] = 0 ; if ( plaintext ) { while ( remaining > 0 ) { received = remaining ; rv = apr_socket_recv ( sock , buffer + at , & received ) ; if ( received > 0 ) { remaining -= received ; at += received ; } } ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , ""Websocket:<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%"" APR_OFF_T_FMT ""<S2SV_blank>bytes,<S2SV_blank>pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack"" , at ) ; } else { rv = lua_websocket_readbytes ( r -> connection , buffer , remaining ) ; ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , ""Websocket:<S2SV_blank>SSL<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%"" APR_SIZE_T_FMT ""<S2SV_blank>bytes,<S2SV_blank>"" ""pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack"" , remaining ) ; } if ( mask ) { for ( n = 0 ; n < plen ; n ++ ) { buffer [ n ] ^= mask_bytes [ n % 4 ] ; } } lua_pushlstring ( L , buffer , ( size_t ) plen ) ; lua_pushboolean ( L , fin ) ; return 2 ; } if ( opcode == 0x09 ) { char frame [ 2 ] ; plen = 2 ; frame [ 0 ] = 0x8A ; frame [ 1 ] = 0 ; apr_socket_send ( sock , frame , & plen ) ; <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> } } } return 0 ; }",<S2SV_ModStart> rv ; int do_read = 1 ; int <S2SV_ModStart> -> connection ) ; while ( do_read ) { do_read = 0 <S2SV_ModStart> plen ) ; do_read = 1 ; } <S2SV_ModEnd> } } }
149,"CWE-264 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 ) { struct STRUCT_OR_UNION_4 * VAR_3 ; struct STRUCT_OR_UNION_5 * VAR_4 = VAR_5 , * VAR_6 = VAR_7 ; struct STRUCT_OR_UNION_6 * VAR_8 , * VAR_9 ; struct STRUCT_OR_UNION_7 * VAR_10 = VAR_11 -> VAR_12 ; struct STRUCT_OR_UNION_8 * VAR_13 ; TYPE_0 VAR_14 ; VAR_15 = METHOD_1 ( VAR_16 ) ; if ( METHOD_2 ( VAR_17 ) ) return VAR_18 ; METHOD_3 ( & VAR_19 ) ; VAR_20 = VAR_21 | VAR_22 ; if ( VAR_23 != VAR_24 -> VAR_25 ) <S2SV_StartBug> VAR_26 |= VAR_27 ; <S2SV_EndBug> VAR_28 = METHOD_4 ( VAR_29 , VAR_30 -> VAR_31 . VAR_32 , VAR_33 ) ; if ( METHOD_5 ( VAR_34 ) ) { METHOD_6 ( & VAR_35 ) ; METHOD_7 ( VAR_36 ) ; return METHOD_8 ( VAR_37 ) ; } VAR_38 -> VAR_39 = VAR_40 ; METHOD_9 ( & VAR_41 ) ; METHOD_10 ( & VAR_42 -> VAR_43 , & VAR_44 -> VAR_45 ) ; METHOD_11 ( & VAR_46 ) ; VAR_47 = VAR_48 ; VAR_49 = VAR_50 ; while ( VAR_51 ) { VAR_52 -> VAR_53 = VAR_54 ; if ( VAR_55 ) { if ( & VAR_56 -> VAR_57 == VAR_58 -> VAR_59 . VAR_60 ) { VAR_61 -> VAR_62 . VAR_63 = METHOD_12 ( & VAR_64 -> VAR_65 ) ; VAR_66 = & VAR_67 -> VAR_68 ; } if ( & VAR_69 -> VAR_70 == VAR_71 -> VAR_72 . VAR_73 ) { VAR_74 -> VAR_75 . VAR_76 = METHOD_13 ( & VAR_77 -> VAR_78 ) ; VAR_79 = & VAR_80 -> VAR_81 ; } } VAR_82 = METHOD_14 ( VAR_83 , VAR_84 ) ; VAR_85 = METHOD_15 ( VAR_86 , VAR_87 ) ; } METHOD_16 ( & VAR_88 ) ; if ( VAR_89 ) METHOD_17 ( VAR_90 ) ; if ( VAR_91 ) METHOD_18 ( VAR_92 ) ; return VAR_93 ; }",<S2SV_ModStart> VAR_33 |= VAR_27 | VAR_94,"CWE-264 static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , struct user_namespace * user_ns , struct fs_struct * fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old = mnt_ns -> root ; struct mount * new ; int copy_flags ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; down_write ( & namespace_sem ) ; copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns -> user_ns ) <S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; br_write_unlock ( & vfsmount_lock ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; if ( fs ) { if ( & p -> mnt == fs -> root . mnt ) { fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == fs -> pwd . mnt ) { fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; } up_write ( & namespace_sem ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }",<S2SV_ModStart> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED
150,CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) <S2SV_StartBug> { <S2SV_EndBug> METHOD_1 ( VAR_1 -> VAR_2 . VAR_3 ) ; METHOD_2 ( VAR_4 ) ; },<S2SV_ModStart> VAR_4 ) { if ( VAR_4 -> VAR_2 . VAR_3 ),CWE-119 void uwbd_stop ( struct uwb_rc * rc ) <S2SV_StartBug> { <S2SV_EndBug> kthread_stop ( rc -> uwbd . task ) ; uwbd_flush ( rc ) ; },<S2SV_ModStart> rc ) { if ( rc -> uwbd . task )
151,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; struct STRUCT_OR_UNION_1 * VAR_2 = & METHOD_1 ( STRUCT_OR_UNION_2 ) ; struct STRUCT_OR_UNION_3 * VAR_3 ; unsigned TYPE_2 VAR_4 ; TYPE_3 VAR_5 = 0 ; TYPE_4 VAR_6 ; VAR_7 = METHOD_2 ( VAR_8 ) ; if ( VAR_9 ) METHOD_3 ( ) ; else METHOD_4 ( ) ; for ( VAR_10 = 0 ; VAR_11 < VAR_12 -> VAR_13 ; ++ VAR_14 ) { VAR_15 = VAR_16 -> VAR_17 [ VAR_18 ] ; VAR_19 = METHOD_5 ( VAR_20 ) ; if ( ( TYPE_5 ) VAR_21 < 0 ) { if ( VAR_22 ) { VAR_23 = 1 ; <S2SV_StartBug> METHOD_6 ( VAR_24 , VAR_25 , VAR_26 , VAR_27 ) ; <S2SV_EndBug> } else { METHOD_7 ( VAR_28 , 0 ) ; } } } METHOD_8 ( METHOD_9 ( ) | VAR_29 ) ; METHOD_10 ( VAR_30 , VAR_31 | VAR_32 ) ; METHOD_11 ( ) ; if ( VAR_33 ) METHOD_12 ( ) ; else METHOD_13 ( ) ; }","<S2SV_ModStart> VAR_25 , VAR_26 <S2SV_ModEnd> ) ; }","CWE-399 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }"
152,"CWE-119 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 , * VAR_3 ; TYPE_4 VAR_4 ; TYPE_5 VAR_5 ; TYPE_6 * VAR_6 ; TYPE_7 VAR_7 ; TYPE_8 VAR_8 ; TYPE_9 VAR_9 , VAR_10 ; unsigned TYPE_10 * VAR_11 ; METHOD_1 ( VAR_12 != ( const TYPE_11 * ) VAR_13 ) ; METHOD_2 ( VAR_14 -> VAR_15 == VAR_16 ) ; if ( VAR_17 -> VAR_18 != VAR_19 ) ( TYPE_12 ) METHOD_3 ( VAR_20 , METHOD_4 ( ) , ""%s"" , VAR_21 -> VAR_22 ) ; METHOD_5 ( VAR_23 != ( TYPE_13 * ) VAR_24 ) ; METHOD_6 ( VAR_25 -> VAR_26 == VAR_27 ) ; VAR_28 = METHOD_7 ( VAR_29 ) ; if ( ( VAR_30 -> VAR_31 == 0 ) || ( VAR_32 -> VAR_33 == 0 ) ) METHOD_8 ( VAR_34 , ""MustSpecifyImageSize"" ) ; VAR_35 = METHOD_9 ( VAR_36 , VAR_37 , VAR_38 , VAR_39 ) ; if ( VAR_40 == VAR_41 ) { VAR_42 = METHOD_10 ( VAR_43 ) ; return ( ( TYPE_14 * ) VAR_44 ) ; } if ( METHOD_11 ( VAR_45 , ( TYPE_15 ) VAR_46 -> VAR_47 ) == VAR_48 ) METHOD_12 ( VAR_49 , VAR_50 , ""UnexpectedEndOfFile"" , VAR_51 -> VAR_52 ) ; METHOD_13 ( VAR_53 , VAR_54 ) ; VAR_55 = METHOD_14 ( VAR_56 , VAR_57 -> VAR_58 . VAR_59 , 1 , VAR_60 , VAR_61 ) ; ( TYPE_16 ) METHOD_15 ( VAR_62 , VAR_63 ) ; VAR_64 = VAR_65 ; VAR_66 = METHOD_16 ( VAR_67 , VAR_68 ) ; if ( VAR_69 == ( TYPE_17 * ) VAR_70 ) METHOD_17 ( VAR_71 , ""MemoryAllocationFailed"" ) ; VAR_72 = METHOD_18 ( VAR_73 ) ; if ( VAR_74 -> VAR_75 != 0 ) while ( VAR_76 -> VAR_77 < VAR_78 -> VAR_79 ) { VAR_80 -> VAR_81 ++ ; VAR_82 = METHOD_19 ( VAR_83 , VAR_84 , VAR_85 ) ; for ( VAR_86 = 0 ; VAR_87 < ( TYPE_18 ) VAR_88 -> VAR_89 ; VAR_90 ++ ) { VAR_91 = METHOD_20 ( VAR_92 , VAR_93 , VAR_94 ) ; if ( VAR_95 != ( TYPE_19 ) VAR_96 ) break ; } } VAR_97 = 0 ; VAR_98 = 0 ; VAR_99 = 0 ; do { if ( ( VAR_100 -> VAR_101 != VAR_102 ) && ( VAR_103 -> VAR_104 != 0 ) ) if ( VAR_105 -> VAR_106 >= ( VAR_107 -> VAR_108 + VAR_109 -> VAR_110 - 1 ) ) break ; <S2SV_StartBug> METHOD_21 ( VAR_111 , VAR_112 ) ; <S2SV_EndBug> if ( VAR_113 == 0 ) { VAR_114 = METHOD_22 ( VAR_115 , VAR_116 , VAR_117 ) ; VAR_118 = METHOD_23 ( VAR_119 , VAR_120 , VAR_121 ) ; } for ( VAR_122 = 0 ; VAR_123 < ( TYPE_20 ) VAR_124 -> VAR_125 . VAR_126 ; VAR_127 ++ ) { register const TYPE_21 * VAR_128 VAR_129 ; register TYPE_22 VAR_130 ; register TYPE_23 * VAR_131 VAR_132 ; if ( VAR_133 != ( TYPE_24 ) VAR_134 ) { METHOD_24 ( VAR_135 , VAR_136 , ""UnexpectedEndOfFile"" , VAR_137 -> VAR_138 ) ; break ; } VAR_139 = METHOD_25 ( VAR_140 , 0 , 0 , VAR_141 -> VAR_142 , 1 , VAR_143 ) ; if ( VAR_144 == ( TYPE_25 * ) VAR_145 ) break ; VAR_146 = METHOD_26 ( VAR_147 , ( TYPE_26 * ) VAR_148 , VAR_149 , VAR_150 , VAR_151 , VAR_152 ) ; if ( METHOD_27 ( VAR_153 , VAR_154 ) == VAR_155 ) break ; if ( ( ( VAR_156 - VAR_157 -> VAR_158 . VAR_159 ) >= 0 ) && ( ( VAR_160 - VAR_161 -> VAR_162 . VAR_163 ) < ( TYPE_27 ) VAR_164 -> VAR_165 ) ) { VAR_166 = METHOD_28 ( VAR_167 , VAR_168 -> VAR_169 . VAR_170 , 0 , VAR_171 -> VAR_172 , 1 , VAR_173 ) ; VAR_174 = METHOD_29 ( VAR_175 , 0 , VAR_176 - VAR_177 -> VAR_178 . VAR_179 , VAR_180 -> VAR_181 , 1 , VAR_182 ) ; if ( ( VAR_183 == ( const TYPE_28 * ) VAR_184 ) || ( VAR_185 == ( TYPE_29 * ) VAR_186 ) ) break ; for ( VAR_187 = 0 ; VAR_188 < ( TYPE_30 ) VAR_189 -> VAR_190 ; VAR_191 ++ ) { METHOD_30 ( VAR_192 , METHOD_31 ( VAR_193 ) ) ; METHOD_32 ( VAR_194 , METHOD_33 ( VAR_195 ) ) ; METHOD_34 ( VAR_196 , METHOD_35 ( VAR_197 ) ) ; VAR_198 ++ ; VAR_199 ++ ; } if ( METHOD_36 ( VAR_200 , VAR_201 ) == VAR_202 ) break ; } if ( VAR_203 -> VAR_204 == ( TYPE_31 * ) VAR_205 ) { VAR_206 = METHOD_37 ( VAR_207 , VAR_208 , ( TYPE_32 ) VAR_209 , VAR_210 -> VAR_211 ) ; if ( VAR_212 == VAR_213 ) break ; } VAR_214 = METHOD_38 ( VAR_215 , VAR_216 , VAR_217 ) ; } METHOD_39 ( VAR_218 , VAR_219 ) ; if ( VAR_220 -> VAR_221 != 0 ) if ( VAR_222 -> VAR_223 >= ( VAR_224 -> VAR_225 + VAR_226 -> VAR_227 - 1 ) ) break ; if ( VAR_228 == ( TYPE_33 ) VAR_229 ) { METHOD_40 ( VAR_230 , VAR_231 ) ; if ( METHOD_41 ( VAR_232 ) == ( TYPE_34 * ) VAR_233 ) { VAR_234 = METHOD_42 ( VAR_235 ) ; return ( ( TYPE_35 * ) VAR_236 ) ; } VAR_237 = METHOD_43 ( VAR_238 ) ; VAR_239 = METHOD_44 ( VAR_240 , VAR_241 , METHOD_45 ( VAR_242 ) , METHOD_46 ( VAR_243 ) ) ; if ( VAR_244 == VAR_245 ) break ; } VAR_246 ++ ; } while ( VAR_247 == ( TYPE_36 ) VAR_248 ) ; VAR_249 = METHOD_47 ( VAR_250 ) ; METHOD_48 ( & VAR_251 -> VAR_252 , & VAR_253 -> VAR_254 ) ; VAR_255 = METHOD_49 ( VAR_256 ) ; ( TYPE_37 ) METHOD_50 ( VAR_257 ) ; return ( METHOD_51 ( VAR_258 ) ) ; }","<S2SV_ModStart> ) break ; VAR_244 = METHOD_52 ( VAR_258 , VAR_258 -> VAR_190 , VAR_258 -> VAR_211 ) ; if ( VAR_244 == VAR_245 ) { METHOD_48 ( VAR_254 , & VAR_258 -> VAR_254 ) ; return ( METHOD_42 ( VAR_258 ) ) ; }","CWE-119 static Image * ReadGRAYImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( size_t ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , GRAYColorspace ) ; canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_type = GrayQuantum ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } scene = 0 ; count = 0 ; length = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register ssize_t x ; register PixelPacket * restrict q ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
153,"CWE-000 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> const TYPE_3 * VAR_2 ; <S2SV_EndBug> TYPE_4 VAR_3 ; <S2SV_StartBug> TYPE_5 VAR_4 = 0 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_6 * VAR_5 = """" ; <S2SV_EndBug> if ( METHOD_1 ( VAR_6 , VAR_7 , & VAR_8 , & VAR_9 ) ) { VAR_10 = ""Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size"" ; <S2SV_StartBug> METHOD_2 ( ""error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , <S2SV_EndBug> <S2SV_StartBug> VAR_11 , METHOD_3 ( VAR_12 , VAR_13 , VAR_14 ) , <S2SV_EndBug> METHOD_4 ( VAR_15 , VAR_16 , VAR_17 ) ) ; return 0 ; } <S2SV_StartBug> return METHOD_5 ( VAR_18 , VAR_19 , VAR_20 , VAR_21 ) ; <S2SV_EndBug> }","<S2SV_ModStart> ) { const TYPE_6 * VAR_22 = METHOD_4 ( VAR_18 , VAR_19 , VAR_17 ) ; const <S2SV_ModStart> TYPE_4 VAR_21 ; <S2SV_ModEnd> TYPE_6 * VAR_11 <S2SV_ModStart> = """" ; if ( METHOD_6 ( VAR_22 , '@' ) ) { VAR_11 = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto VAR_23 ; } <S2SV_ModStart> = ""Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size"" ; goto VAR_23 ; } return METHOD_5 <S2SV_ModEnd> ( VAR_18 , <S2SV_ModStart> ( VAR_18 , VAR_19 , VAR_20 , VAR_21 ) ; VAR_23 : METHOD_2 ( ""error!\\n%s<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , VAR_11 <S2SV_ModEnd> , METHOD_4 ( <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>","CWE-000 int fit_image_verify ( const void * fit , int image_noffset ) { <S2SV_StartBug> const void * data ; <S2SV_EndBug> size_t size ; <S2SV_StartBug> int noffset = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * err_msg = """" ; <S2SV_EndBug> if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) { err_msg = ""Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size"" ; <S2SV_StartBug> printf ( ""error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , <S2SV_EndBug> <S2SV_StartBug> err_msg , fit_get_name ( fit , noffset , NULL ) , <S2SV_EndBug> fit_get_name ( fit , image_noffset , NULL ) ) ; return 0 ; } <S2SV_StartBug> return fit_image_verify_with_data ( fit , image_noffset , data , size ) ; <S2SV_EndBug> }","<S2SV_ModStart> ) { const char * name = fit_get_name ( fit , image_noffset , NULL ) ; const <S2SV_ModStart> size_t size ; <S2SV_ModEnd> char * err_msg <S2SV_ModStart> = """" ; if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto err ; } <S2SV_ModStart> = ""Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size"" ; goto err ; } return fit_image_verify_with_data <S2SV_ModEnd> ( fit , <S2SV_ModStart> ( fit , image_noffset , data , size ) ; err : printf ( ""error!\\n%s<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg <S2SV_ModEnd> , fit_get_name ( <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
154,"CWE-401 static TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * * VAR_1 , TYPE_2 * VAR_2 ) { TYPE_3 * VAR_3 , * VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; VAR_8 = ( TYPE_7 * ) VAR_9 -> VAR_10 . VAR_11 . VAR_12 . VAR_13 ; VAR_14 = VAR_15 -> VAR_16 . VAR_17 . VAR_18 ; VAR_19 = VAR_20 -> VAR_21 != VAR_22 ; if ( VAR_23 > VAR_24 ) return - VAR_25 ; VAR_26 = METHOD_1 ( VAR_27 , VAR_28 ) ; if ( ! VAR_29 ) return - VAR_30 ; <S2SV_StartBug> if ( VAR_31 ) { <S2SV_EndBug> VAR_32 = METHOD_2 ( VAR_33 , ( TYPE_8 TYPE_9 * ) VAR_34 , VAR_35 ) ; if ( VAR_36 ) return - VAR_37 ; } else { METHOD_3 ( VAR_38 , 0 , VAR_39 ) ; } <S2SV_StartBug> * VAR_40 = VAR_41 ; <S2SV_EndBug> METHOD_4 ( VAR_42 , VAR_43 , VAR_44 ) ; return 0 ; }",<S2SV_ModStart> - VAR_30 ; * VAR_40 = VAR_42 ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> METHOD_4 ( VAR_42,"CWE-401 static int hgcm_call_preprocess_linaddr ( const struct vmmdev_hgcm_function_parameter * src_parm , void * * bounce_buf_ret , size_t * extra ) { void * buf , * bounce_buf ; bool copy_in ; u32 len ; int ret ; buf = ( void * ) src_parm -> u . pointer . u . linear_addr ; len = src_parm -> u . pointer . size ; copy_in = src_parm -> type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT ; if ( len > VBG_MAX_HGCM_USER_PARM ) return - E2BIG ; bounce_buf = kvmalloc ( len , GFP_KERNEL ) ; if ( ! bounce_buf ) return - ENOMEM ; <S2SV_StartBug> if ( copy_in ) { <S2SV_EndBug> ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ; if ( ret ) return - EFAULT ; } else { memset ( bounce_buf , 0 , len ) ; } <S2SV_StartBug> * bounce_buf_ret = bounce_buf ; <S2SV_EndBug> hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ; return 0 ; }",<S2SV_ModStart> - ENOMEM ; * bounce_buf_ret = bounce_buf ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> hgcm_call_add_pagelist_size ( bounce_buf
155,"CWE-119 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , <S2SV_StartBug> const TYPE_2 * VAR_1 ) { <S2SV_EndBug> <S2SV_StartBug> const struct STRUCT_OR_UNION_0 * VAR_2 = & VAR_3 -> VAR_4 ; <S2SV_EndBug> const TYPE_3 * const VAR_5 = & VAR_6 -> VAR_7 ; const TYPE_4 * VAR_8 ; TYPE_5 VAR_9 ; TYPE_6 VAR_10 ; if ( VAR_11 -> VAR_12 > 1 && VAR_13 -> VAR_14 == 1 ) { VAR_15 = & VAR_16 -> VAR_17 [ VAR_18 -> VAR_19 ] . VAR_20 ; } VAR_21 = & VAR_22 -> VAR_23 ; <S2SV_StartBug> VAR_24 = VAR_25 -> VAR_26 / VAR_27 -> VAR_28 ; <S2SV_EndBug> <S2SV_StartBug> VAR_29 = VAR_30 * METHOD_1 ( VAR_31 -> VAR_32 / <S2SV_EndBug> METHOD_2 ( VAR_33 ) , <S2SV_StartBug> VAR_34 -> VAR_35 . VAR_36 / 100.0 ) ; <S2SV_EndBug> return METHOD_3 ( VAR_37 , VAR_38 -> VAR_39 , VAR_40 -> VAR_41 ) ; }","<S2SV_ModStart> VAR_34 , const TYPE_7 * VAR_40 , const TYPE_8 * VAR_35 , const <S2SV_ModStart> ) { const TYPE_4 * const <S2SV_ModEnd> VAR_27 = & <S2SV_ModStart> -> VAR_23 ; const TYPE_6 VAR_43 <S2SV_ModEnd> = VAR_27 -> <S2SV_ModStart> = VAR_27 -> weight <S2SV_ModEnd> / VAR_27 -> <S2SV_ModStart> -> VAR_28 ; const TYPE_6 VAR_33 = ( VAR_27 -> VAR_42 * VAR_43 ) / VAR_27 -> VAR_28 ; TYPE_6 <S2SV_ModStart> ( VAR_31 -> VAR_42 * VAR_31 -> weight <S2SV_ModEnd> / METHOD_2 ( <S2SV_ModStart> VAR_33 ) , VAR_35 -> <S2SV_ModEnd> VAR_36 / 100.0 <S2SV_ModStart> VAR_36 / 100.0 ) ; VAR_37 *= METHOD_1 ( METHOD_4 ( VAR_34 , VAR_31 ) , VAR_44","CWE-119 static double calculate_modified_err ( const VP9_COMP * cpi , <S2SV_StartBug> const FIRSTPASS_STATS * this_frame ) { <S2SV_EndBug> <S2SV_StartBug> const struct twopass_rc * twopass = & cpi -> twopass ; <S2SV_EndBug> const SVC * const svc = & cpi -> svc ; const FIRSTPASS_STATS * stats ; double av_err ; double modified_error ; if ( svc -> number_spatial_layers > 1 && svc -> number_temporal_layers == 1 ) { twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; } stats = & twopass -> total_stats ; <S2SV_StartBug> av_err = stats -> ssim_weighted_pred_err / stats -> count ; <S2SV_EndBug> <S2SV_StartBug> modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / <S2SV_EndBug> DOUBLE_DIVIDE_CHECK ( av_err ) , <S2SV_StartBug> cpi -> oxcf . two_pass_vbrbias / 100.0 ) ; <S2SV_EndBug> return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ; }","<S2SV_ModStart> cpi , const TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const <S2SV_ModStart> ) { const FIRSTPASS_STATS * const <S2SV_ModEnd> stats = & <S2SV_ModStart> -> total_stats ; const double av_weight <S2SV_ModEnd> = stats -> <S2SV_ModStart> = stats -> weight <S2SV_ModEnd> / stats -> <S2SV_ModStart> -> count ; const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ; double <S2SV_ModStart> ( this_frame -> coded_error * this_frame -> weight <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK ( <S2SV_ModStart> av_err ) , oxcf -> <S2SV_ModEnd> two_pass_vbrbias / 100.0 <S2SV_ModStart> two_pass_vbrbias / 100.0 ) ; modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION"
156,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 ) { if ( METHOD_1 ( VAR_2 -> VAR_3 == 1 ) ) { VAR_4 -> VAR_5 += VAR_6 ; } else { const struct STRUCT_OR_UNION_1 * VAR_7 = VAR_8 -> VAR_9 ; TYPE_2 VAR_10 = VAR_11 -> VAR_12 ; <S2SV_StartBug> while ( VAR_13 ) { <S2SV_EndBug> TYPE_3 VAR_14 = METHOD_2 ( VAR_15 , VAR_16 -> VAR_17 - VAR_18 ) ; VAR_19 -= VAR_20 ; VAR_21 += VAR_22 ; if ( VAR_23 -> VAR_24 == VAR_25 ) { VAR_26 ++ ; VAR_27 = 0 ; } } VAR_28 -> VAR_29 = VAR_30 ; VAR_31 -> VAR_32 = VAR_33 ; } }",<S2SV_ModStart> while ( VAR_19 || ! VAR_30 -> VAR_24,"CWE-20 static void __iov_iter_advance_iov ( struct iov_iter * i , size_t bytes ) { if ( likely ( i -> nr_segs == 1 ) ) { i -> iov_offset += bytes ; } else { const struct iovec * iov = i -> iov ; size_t base = i -> iov_offset ; <S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> int copy = min ( bytes , iov -> iov_len - base ) ; bytes -= copy ; base += copy ; if ( iov -> iov_len == base ) { iov ++ ; base = 0 ; } } i -> iov = iov ; i -> iov_offset = base ; } }",<S2SV_ModStart> while ( bytes || ! iov -> iov_len
157,"CWE-476 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; VAR_2 * VAR_3 ; if ( VAR_4 -> VAR_5 == VAR_6 ) VAR_7 -> VAR_8 = METHOD_1 ( VAR_9 -> VAR_10 ) ; if ( VAR_11 -> VAR_12 == VAR_13 ) VAR_14 -> VAR_15 = VAR_16 -> VAR_17 ; VAR_18 -> VAR_19 = VAR_20 ; VAR_21 -> VAR_22 -> VAR_23 = VAR_24 -> VAR_25 -> VAR_26 ; if ( METHOD_2 ( VAR_27 -> VAR_28 , VAR_29 -> VAR_30 -> VAR_31 , VAR_32 -> VAR_33 -> VAR_34 ) != VAR_35 ) return VAR_36 ; if ( VAR_37 -> VAR_38 -> VAR_39 != VAR_40 ) return VAR_41 ; VAR_42 = VAR_43 -> VAR_44 ; VAR_45 = ( TYPE_3 * ) VAR_46 -> VAR_47 ; if ( VAR_48 -> VAR_49 == VAR_50 ) VAR_51 -> VAR_52 = METHOD_3 ( VAR_53 , VAR_54 , VAR_55 ) ; if ( METHOD_4 ( VAR_56 -> VAR_57 ) < 0 ) { METHOD_5 ( VAR_58 , ""client<S2SV_blank>authentication<S2SV_blank>failure\\n"" ) ; METHOD_6 ( VAR_59 -> VAR_60 ) ; <S2SV_StartBug> return VAR_61 ; <S2SV_EndBug> } return VAR_62 ; }",<S2SV_ModStart> VAR_60 ) ; VAR_59 -> VAR_60 = VAR_50 ;,"CWE-476 BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , ""client<S2SV_blank>authentication<S2SV_blank>failure\\n"" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }",<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
158,"CWE-476 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , const TYPE_2 * * VAR_2 , const TYPE_3 * * VAR_3 , TYPE_4 * * VAR_4 ) { switch ( VAR_5 -> VAR_6 . VAR_7 ) { case VAR_8 : * VAR_9 = VAR_10 ; * VAR_11 = METHOD_1 ( VAR_12 , VAR_13 -> VAR_14 . VAR_15 ) ; * VAR_16 = VAR_17 ; <S2SV_StartBug> return VAR_18 ; <S2SV_EndBug> case VAR_19 : * VAR_20 = METHOD_2 ( VAR_21 , VAR_22 -> VAR_23 . VAR_24 ) ; * VAR_25 = METHOD_3 ( VAR_26 , VAR_27 -> VAR_28 . VAR_29 ) ; * VAR_30 = VAR_31 ; return VAR_32 ; case VAR_33 : * VAR_34 = METHOD_4 ( VAR_35 , VAR_36 -> VAR_37 . VAR_38 ) ; * VAR_39 = METHOD_5 ( VAR_40 , VAR_41 -> VAR_42 . VAR_43 ) ; * VAR_44 = VAR_45 -> VAR_46 . VAR_47 ; return VAR_48 ; default : break ; } METHOD_6 ( VAR_49 , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , VAR_50 -> VAR_51 . VAR_52 ) ; return VAR_53 ; }",<S2SV_ModStart> VAR_31 ; return ( * VAR_39 != VAR_31 ) <S2SV_ModEnd> ; case VAR_19,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }",<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
159,"CWE-190 static TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 , const TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; <S2SV_StartBug> TYPE_4 VAR_3 = sizeof ( VAR_4 ) * ( 2 * VAR_5 + 1 ) + sizeof ( TYPE_5 ) ; <S2SV_EndBug> <S2SV_StartBug> TYPE_6 VAR_6 = ( TYPE_7 ) METHOD_1 ( VAR_7 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_8 = METHOD_2 ( VAR_9 + VAR_10 + 1 ) ; <S2SV_EndBug> if ( VAR_11 ) { METHOD_3 ( VAR_12 , 0 , VAR_13 ) ; VAR_14 -> VAR_15 [ 0 ] = ( TYPE_8 * ) ( & VAR_16 -> VAR_17 [ 1 ] ) - ( TYPE_9 * ) VAR_18 ; VAR_19 -> VAR_20 [ 1 + VAR_21 ] = VAR_22 -> VAR_23 [ 0 ] + sizeof ( VAR_24 ) * ( VAR_25 + 1 ) ; VAR_26 -> VAR_27 = VAR_28 ; VAR_29 -> VAR_30 = ( ( TYPE_10 * ) VAR_31 ) + VAR_32 ; METHOD_4 ( VAR_33 -> VAR_34 , VAR_35 , VAR_36 + 1 ) ; VAR_37 -> VAR_38 [ 0 ] = 1 ; } return VAR_39 ; }",<S2SV_ModStart> * VAR_39 ; TYPE_11 <S2SV_ModEnd> VAR_32 = sizeof <S2SV_ModStart> ( 2 * ( TYPE_11 ) <S2SV_ModStart> TYPE_5 ) ; TYPE_11 VAR_36 = <S2SV_ModEnd> METHOD_1 ( VAR_35 <S2SV_ModStart> ; VAR_39 = sqlite3_malloc64 <S2SV_ModEnd> ( VAR_32 +,"CWE-190 static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }",<S2SV_ModStart> * pRet ; sqlite3_int64 <S2SV_ModEnd> nByte = sizeof <S2SV_ModStart> ( 2 * ( sqlite3_int64 ) <S2SV_ModStart> MatchinfoBuffer ) ; sqlite3_int64 nStr = <S2SV_ModEnd> strlen ( zMatchinfo <S2SV_ModStart> ; pRet = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
160,"CWE-400 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { unsigned TYPE_2 VAR_2 = METHOD_1 ( VAR_3 , VAR_4 , 0 ) ; TYPE_3 VAR_5 = ( ( VAR_6 >> 25 ) & 0x1e ) | ( ( VAR_7 >> 20 ) & 0x20 ) ; struct STRUCT_OR_UNION_1 * VAR_8 = VAR_9 ; TYPE_4 VAR_10 = METHOD_2 ( VAR_11 , VAR_12 ) ; TYPE_5 VAR_13 = ( VAR_14 < 32 ) ? VAR_15 : VAR_16 ; <S2SV_StartBug> METHOD_3 ( VAR_17 , 1 , 0 , VAR_18 , 0 ) ; <S2SV_EndBug> METHOD_4 ( ) ; METHOD_5 ( ) -> VAR_19 [ 0 ] &= ~ 0x1c000 ; if ( VAR_20 & 3 ) { METHOD_6 ( ) -> VAR_21 [ 0 ] |= ( 6 << 14 ) ; METHOD_7 ( VAR_22 ) ; return 0 ; } if ( VAR_23 & 0x200000 ) { TYPE_6 VAR_24 = 0 , VAR_25 = 0 ; if ( METHOD_8 ( ) -> VAR_26 [ 0 ] & VAR_27 ) { VAR_28 = * ( TYPE_7 * ) & VAR_29 -> VAR_30 [ VAR_31 ] ; VAR_32 = * ( TYPE_8 * ) & VAR_33 -> VAR_34 [ VAR_35 + 2 ] ; } if ( VAR_36 < 0x80 ) { METHOD_9 ( VAR_37 ) ; return 1 ; } switch ( VAR_38 ) { case VAR_39 : case VAR_40 : break ; case VAR_41 : case VAR_42 : { TYPE_9 VAR_43 = METHOD_10 ( & VAR_44 ) ; VAR_45 = METHOD_11 ( & VAR_46 ) ; VAR_47 = VAR_48 ; break ; } default : if ( VAR_49 == VAR_50 ) METHOD_12 ( VAR_51 , VAR_52 , 0 ) ; else METHOD_13 ( VAR_53 , 0 , VAR_54 ) ; return 1 ; } if ( METHOD_14 ( VAR_55 >> 32 , ( TYPE_10 TYPE_11 * ) VAR_56 ) || METHOD_15 ( ( TYPE_12 ) VAR_57 , ( TYPE_13 TYPE_14 * ) ( VAR_58 + 4 ) ) || METHOD_16 ( VAR_59 >> 32 , ( TYPE_15 TYPE_16 * ) ( VAR_60 + 8 ) ) || METHOD_17 ( ( TYPE_17 ) VAR_61 , ( TYPE_18 TYPE_19 * ) ( VAR_62 + 12 ) ) ) { if ( VAR_63 == VAR_64 ) METHOD_18 ( VAR_65 , VAR_66 , 0 ) ; else METHOD_19 ( VAR_67 , 0 , VAR_68 ) ; return 1 ; } } else { TYPE_20 VAR_69 [ 4 ] VAR_70 ( ( VAR_71 ( 8 ) ) ) ; TYPE_21 VAR_72 , VAR_73 ; TYPE_22 VAR_74 ; if ( VAR_75 < 0x80 ) { METHOD_20 ( VAR_76 ) ; return 1 ; } else if ( VAR_77 > VAR_78 ) { if ( VAR_79 == VAR_80 ) METHOD_21 ( VAR_81 , VAR_82 , 0 ) ; else METHOD_22 ( VAR_83 , 0 , VAR_84 ) ; return 1 ; } switch ( VAR_85 & 0x180000 ) { case 0x000000 : VAR_86 = 1 ; break ; case 0x100000 : VAR_87 = 4 ; break ; default : VAR_88 = 2 ; break ; } for ( VAR_89 = 0 ; VAR_90 < VAR_91 ; VAR_92 ++ ) VAR_93 [ VAR_94 ] = 0 ; VAR_95 = METHOD_23 ( VAR_96 [ 0 ] , ( TYPE_23 TYPE_24 * ) VAR_97 ) ; if ( ! VAR_98 ) { for ( VAR_99 = 1 ; VAR_100 < VAR_101 ; VAR_102 ++ ) VAR_103 |= METHOD_24 ( VAR_104 [ VAR_105 ] , ( TYPE_25 TYPE_26 * ) ( VAR_106 + 4 * VAR_107 ) ) ; } if ( VAR_108 && ! ( VAR_109 & 0x2 ) ) { if ( VAR_110 == VAR_111 ) METHOD_25 ( VAR_112 , VAR_113 , 0 ) ; else METHOD_26 ( VAR_114 , 0 , VAR_115 ) ; return 1 ; } if ( VAR_116 & 0x8 ) { TYPE_27 VAR_117 ; switch ( VAR_118 ) { case 1 : VAR_119 [ 0 ] = METHOD_27 ( VAR_120 + 0 ) ; break ; default : * ( TYPE_28 * ) ( VAR_121 + 0 ) = METHOD_28 ( ( TYPE_29 * ) ( VAR_122 + 0 ) ) ; break ; case 4 : VAR_123 = METHOD_29 ( ( TYPE_30 * ) ( VAR_124 + 0 ) ) ; * ( TYPE_31 * ) ( VAR_125 + 0 ) = METHOD_30 ( ( TYPE_32 * ) ( VAR_126 + 2 ) ) ; * ( TYPE_33 * ) ( VAR_127 + 2 ) = VAR_128 ; break ; } } if ( ! ( METHOD_31 ( ) -> VAR_129 [ 0 ] & VAR_130 ) ) { METHOD_32 ( ) -> VAR_131 [ 0 ] = VAR_132 ; METHOD_33 ( ) -> VAR_133 [ 0 ] = 0 ; } if ( ! ( METHOD_34 ( ) -> VAR_134 [ 0 ] & VAR_135 ) ) { if ( VAR_136 < 32 ) METHOD_35 ( VAR_137 -> VAR_138 , 0 , 32 * sizeof ( TYPE_34 ) ) ; else METHOD_36 ( VAR_139 -> VAR_140 + 32 , 0 , 32 * sizeof ( TYPE_35 ) ) ; } METHOD_37 ( VAR_141 -> VAR_142 + VAR_143 , VAR_144 , VAR_145 * 4 ) ; METHOD_38 ( ) -> VAR_146 [ 0 ] |= VAR_147 ; } METHOD_39 ( VAR_148 ) ; return 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> VAR_148 , 0","CWE-400 int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = FPUSTATE ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > ASI_SNFL ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0"
161,"CWE-284 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 VAR_3 [ 20 + VAR_4 ] ; METHOD_1 ( ""connect_to_db"" ) ; METHOD_2 ( ""--<S2SV_blank>Connecting<S2SV_blank>to<S2SV_blank>%s...\\n"" , VAR_5 ? VAR_6 : ""localhost"" ) ; METHOD_3 ( & VAR_7 ) ; if ( VAR_8 ) METHOD_4 ( & VAR_9 , VAR_10 , VAR_11 ) ; <S2SV_StartBug> TYPE_5 TYPE_6 <S2SV_EndBug> if ( VAR_12 ) { METHOD_5 ( & VAR_13 , VAR_14 , VAR_15 , VAR_16 , VAR_17 , VAR_18 ) ; METHOD_6 ( & VAR_19 , VAR_20 , VAR_21 ) ; METHOD_7 ( & VAR_22 , VAR_23 , VAR_24 ) ; } METHOD_8 ( & VAR_25 , VAR_26 , ( TYPE_7 * ) & VAR_27 ) ; if ( VAR_28 ) METHOD_9 ( & VAR_29 , VAR_30 , ( TYPE_8 * ) & VAR_31 ) ; if ( VAR_32 ) METHOD_10 ( & VAR_33 , VAR_34 , VAR_35 ) ; if METHOD_11 ( VAR_36 ) && ! METHOD_12 ( VAR_37 ) if ( VAR_38 ) METHOD_13 ( & VAR_39 , VAR_40 , VAR_41 ) ; METHOD_14 ( & VAR_42 , VAR_43 , VAR_44 ) ; if ( VAR_45 && * VAR_46 ) METHOD_15 ( & VAR_47 , VAR_48 , VAR_49 ) ; if ( VAR_50 && * VAR_51 ) METHOD_16 ( & VAR_52 , VAR_53 , VAR_54 ) ; METHOD_17 ( & VAR_55 , VAR_56 , 0 ) ; METHOD_18 ( & VAR_57 , VAR_58 , ""program_name"" , ""mysqldump"" ) ; if ( ! ( VAR_59 = METHOD_19 ( & VAR_60 , VAR_61 , VAR_62 , VAR_63 , VAR_64 , VAR_65 , VAR_66 , 0 ) ) ) { METHOD_20 ( & VAR_67 , ""when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>connect"" ) ; METHOD_21 ( 1 ) ; } if ( ( METHOD_22 ( & VAR_68 ) < 40100 ) || ( VAR_69 & 3 ) ) { VAR_70 = 0 ; VAR_71 = VAR_72 ; } VAR_73 -> VAR_74 = 0 ; METHOD_23 ( VAR_75 , sizeof ( VAR_76 ) , ""/*!40100<S2SV_blank>SET<S2SV_blank>@@SQL_MODE=\'%s\'<S2SV_blank>*/"" , VAR_77 ) ; if ( METHOD_24 ( VAR_78 , 0 , VAR_79 ) ) METHOD_25 ( 1 ) ; if ( VAR_80 ) { METHOD_26 ( VAR_81 , sizeof ( VAR_82 ) , ""/*!40103<S2SV_blank>SET<S2SV_blank>TIME_ZONE=\'+00:00\'<S2SV_blank>*/"" ) ; if ( METHOD_27 ( VAR_83 , 0 , VAR_84 ) ) METHOD_28 ( 1 ) ; } METHOD_29 ( 0 ) ; }",<S2SV_ModStart> VAR_11 ) ; METHOD_30 ( & VAR_68 ) ; <S2SV_ModEnd> if ( VAR_31,"CWE-284 static int connect_to_db ( char * host , char * user , char * passwd ) { char buff [ 20 + FN_REFLEN ] ; DBUG_ENTER ( ""connect_to_db"" ) ; verbose_msg ( ""--<S2SV_blank>Connecting<S2SV_blank>to<S2SV_blank>%s...\\n"" , host ? host : ""localhost"" ) ; mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug>  ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;   if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ;  if d ( _WIN32 ) && ! d ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ;   mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqldump"" ) ; if ( ! ( mysql = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { DB_error ( & mysql_connection , ""when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>connect"" ) ; DBUG_RETURN ( 1 ) ; } if ( ( mysql_get_server_version ( & mysql_connection ) < 40100 ) || ( opt_compatible_mode & 3 ) ) { opt_set_charset = 0 ; server_supports_switching_charsets = FALSE ; } mysql -> reconnect = 0 ; my_snprintf ( buff , sizeof ( buff ) , ""/*!40100<S2SV_blank>SET<S2SV_blank>@@SQL_MODE=\'%s\'<S2SV_blank>*/"" , compatible_mode_normal_str ) ; if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ; if ( opt_tz_utc ) { my_snprintf ( buff , sizeof ( buff ) , ""/*!40103<S2SV_blank>SET<S2SV_blank>TIME_ZONE=\'+00:00\'<S2SV_blank>*/"" ) ; if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ; } DBUG_RETURN ( 0 ) ; }",<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> if ( opt_protocol
162,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 ) { struct STRUCT_OR_UNION_4 VAR_2 ; const unsigned VAR_3 = METHOD_1 ( STRUCT_OR_UNION_5 -> VAR_4 -> VAR_5 ) ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_2 ( VAR_7 ) ; struct STRUCT_OR_UNION_7 * VAR_8 = METHOD_3 ( VAR_9 ) ; struct STRUCT_OR_UNION_8 * VAR_10 = METHOD_4 ( VAR_11 ) ; METHOD_5 ( & VAR_12 , 0 , sizeof ( VAR_13 ) ) ; VAR_14 . VAR_15 = VAR_16 ; VAR_17 . VAR_18 = VAR_19 -> VAR_20 ; <S2SV_StartBug> METHOD_6 ( VAR_21 . VAR_22 , VAR_23 -> VAR_24 -> VAR_25 , VAR_26 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_7 ( VAR_27 . VAR_28 , VAR_29 -> VAR_30 , VAR_31 ) ; <S2SV_EndBug> if ( VAR_32 ) VAR_33 . VAR_34 = VAR_35 - VAR_36 -> VAR_37 ; else VAR_38 . VAR_39 = - 1 ; if ( VAR_40 ) VAR_41 . VAR_42 = VAR_43 - VAR_44 -> VAR_45 ; else VAR_46 . VAR_47 = - 1 ; if ( METHOD_8 ( VAR_48 , & VAR_49 , sizeof ( struct STRUCT_OR_UNION_9 ) ) ) return - VAR_50 ; return 0 ; }",<S2SV_ModStart> -> VAR_20 ; METHOD_9 <S2SV_ModEnd> ( VAR_49 . <S2SV_ModStart> VAR_31 ) ; METHOD_9 <S2SV_ModEnd> ( VAR_49 .,"CWE-200 static int do_devinfo_ioctl ( struct comedi_device * dev , struct comedi_devinfo __user * arg , struct file * file ) { struct comedi_devinfo devinfo ; const unsigned minor = iminor ( file -> f_dentry -> d_inode ) ; struct comedi_device_file_info * dev_file_info = comedi_get_device_file_info ( minor ) ; struct comedi_subdevice * read_subdev = comedi_get_read_subdevice ( dev_file_info ) ; struct comedi_subdevice * write_subdev = comedi_get_write_subdevice ( dev_file_info ) ; memset ( & devinfo , 0 , sizeof ( devinfo ) ) ; devinfo . version_code = COMEDI_VERSION_CODE ; devinfo . n_subdevs = dev -> n_subdevices ; <S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ; else devinfo . read_subdevice = - 1 ; if ( write_subdev ) devinfo . write_subdevice = write_subdev - dev -> subdevices ; else devinfo . write_subdevice = - 1 ; if ( copy_to_user ( arg , & devinfo , sizeof ( struct comedi_devinfo ) ) ) return - EFAULT ; return 0 ; }",<S2SV_ModStart> -> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . <S2SV_ModStart> COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo .
163,"CWE-190 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , <S2SV_EndBug> TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 ) { <S2SV_StartBug> TYPE_7 VAR_6 ; <S2SV_EndBug> if ( VAR_7 -> VAR_8 ) { if ( ! ( VAR_9 -> VAR_10 & VAR_11 ) ) { METHOD_1 ( VAR_12 -> VAR_13 ) ; } VAR_14 -> VAR_15 = 0 ; VAR_16 -> VAR_17 = 0 ; } if ( VAR_18 -> VAR_19 ) { METHOD_2 ( VAR_20 -> VAR_21 ) ; VAR_22 -> VAR_23 = 0 ; } VAR_24 -> VAR_25 |= VAR_26 ; VAR_27 -> VAR_28 = VAR_29 - VAR_30 + 1 ; VAR_31 -> VAR_32 = VAR_33 - VAR_34 + 1 ; VAR_35 -> VAR_36 = VAR_37 -> VAR_38 ; if ( ! ( VAR_39 -> VAR_40 = METHOD_3 ( VAR_41 -> VAR_42 , sizeof ( TYPE_8 * ) ) ) ) { METHOD_4 ( ) ; } for ( VAR_43 = 0 ; VAR_44 < VAR_45 -> VAR_46 ; ++ VAR_47 ) { VAR_48 -> VAR_49 [ VAR_50 ] = VAR_51 -> VAR_52 [ VAR_53 + VAR_54 ] + VAR_55 ; } VAR_56 -> VAR_57 = VAR_58 -> VAR_59 + VAR_60 ; VAR_61 -> VAR_62 = VAR_63 -> VAR_64 + VAR_65 ; VAR_66 -> VAR_67 = VAR_68 -> VAR_69 + VAR_70 -> VAR_71 ; VAR_72 -> VAR_73 = VAR_74 -> VAR_75 + VAR_76 -> VAR_77 ; }","<S2SV_ModStart> * VAR_63 , TYPE_9 VAR_65 , TYPE_9 VAR_60 , TYPE_9 VAR_29 , TYPE_9 <S2SV_ModEnd> VAR_33 ) { <S2SV_ModStart> VAR_33 ) { TYPE_9 <S2SV_ModEnd> VAR_54 ; if","CWE-190 <S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> int c0 , int r1 , int c1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> if ( mat0 -> data_ ) { if ( ! ( mat0 -> flags_ & JAS_MATRIX_REF ) ) { jas_free ( mat0 -> data_ ) ; } mat0 -> data_ = 0 ; mat0 -> datasize_ = 0 ; } if ( mat0 -> rows_ ) { jas_free ( mat0 -> rows_ ) ; mat0 -> rows_ = 0 ; } mat0 -> flags_ |= JAS_MATRIX_REF ; mat0 -> numrows_ = r1 - r0 + 1 ; mat0 -> numcols_ = c1 - c0 + 1 ; mat0 -> maxrows_ = mat0 -> numrows_ ; if ( ! ( mat0 -> rows_ = jas_alloc2 ( mat0 -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { abort ( ) ; } for ( i = 0 ; i < mat0 -> numrows_ ; ++ i ) { mat0 -> rows_ [ i ] = mat1 -> rows_ [ r0 + i ] + c0 ; } mat0 -> xstart_ = mat1 -> xstart_ + c0 ; mat0 -> ystart_ = mat1 -> ystart_ + r0 ; mat0 -> xend_ = mat0 -> xstart_ + mat0 -> numcols_ ; mat0 -> yend_ = mat0 -> ystart_ + mat0 -> numrows_ ; }","<S2SV_ModStart> * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> c1 ) { <S2SV_ModStart> c1 ) { jas_matind_t <S2SV_ModEnd> i ; if"
164,"CWE-19 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 = VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; TYPE_5 VAR_7 ; TYPE_6 VAR_8 ; <S2SV_StartBug> struct STRUCT_OR_UNION_4 * VAR_9 = METHOD_1 ( STRUCT_OR_UNION_5 ) ; <S2SV_EndBug> METHOD_2 ( STRUCT_OR_UNION_6 , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , VAR_10 , VAR_11 , VAR_12 , ( TYPE_7 ) VAR_13 ) ; VAR_14 = - VAR_15 ; if ( ! METHOD_3 ( STRUCT_OR_UNION_7 ) -> VAR_16 ) goto VAR_17 ; METHOD_4 ( STRUCT_OR_UNION_8 , ""reading<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned TYPE_8 TYPE_9 ) METHOD_5 ( STRUCT_OR_UNION_9 ) -> VAR_18 ) ; VAR_19 = METHOD_6 ( STRUCT_OR_UNION_10 -> VAR_20 , METHOD_7 ( STRUCT_OR_UNION_11 ) -> VAR_21 ) ; if ( ! VAR_22 ) goto VAR_23 ; METHOD_8 ( VAR_24 , ""b_count=%d,<S2SV_blank>refcount=%d"" , METHOD_9 ( & ( VAR_25 -> VAR_26 ) ) , METHOD_10 ( METHOD_11 ( VAR_27 ) -> VAR_28 ) ) ; if ( METHOD_12 ( STRUCT_OR_UNION_12 , VAR_29 ) ) { VAR_30 : METHOD_13 ( STRUCT_OR_UNION_13 , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , METHOD_14 ( STRUCT_OR_UNION_14 ) -> VAR_31 ) ; VAR_32 = - VAR_33 ; goto VAR_34 ; } METHOD_15 ( VAR_35 , VAR_36 ) ; VAR_37 = METHOD_16 ( VAR_38 ) ; VAR_39 = METHOD_17 ( & VAR_40 , VAR_41 , VAR_42 , VAR_43 -> VAR_44 , 1 ) ; if ( VAR_45 == - VAR_46 ) goto VAR_47 ; if ( VAR_48 ) goto VAR_49 ; VAR_50 = METHOD_18 ( VAR_51 -> VAR_52 ) ; if ( VAR_53 ) { VAR_54 = - VAR_55 ; if ( VAR_56 > VAR_57 ) goto VAR_58 ; METHOD_19 ( VAR_59 , VAR_60 -> VAR_61 + METHOD_20 ( VAR_62 -> VAR_63 ) , VAR_64 ) ; } VAR_65 = VAR_66 ; VAR_67 : METHOD_21 ( VAR_68 ) ; return VAR_69 ; }",<S2SV_ModStart> VAR_69 ; struct STRUCT_OR_UNION_15 <S2SV_ModEnd> * VAR_35 =,"CWE-19 static int ext4_xattr_block_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext4_xattr_entry * entry ; size_t size ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ; error = - ENODATA ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; entry = BFIRST ( bh ) ; error = ext4_xattr_find_entry ( & entry , name_index , name , bh -> b_size , 1 ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; return error ; }",<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
165,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , <S2SV_EndBug> TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = va_arg ( VAR_4 , TYPE_5 ) ; METHOD_1 ( VAR_5 -> VAR_6 , VAR_7 ) ; return VAR_8 ; }","<S2SV_ModStart> TYPE_1 * VAR_5 <S2SV_ModEnd> , TYPE_3 VAR_4","CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args"
166,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 , struct STRUCT_OR_UNION_2 * VAR_3 ) { unsigned TYPE_2 VAR_4 , VAR_5 , VAR_6 ; TYPE_3 VAR_7 = 0 ; TYPE_4 VAR_8 ; struct STRUCT_OR_UNION_3 * VAR_9 ; struct STRUCT_OR_UNION_4 * VAR_10 ; if ( VAR_11 ) METHOD_1 ( VAR_12 , VAR_13 ) ; METHOD_2 ( VAR_14 ) ; <S2SV_StartBug> VAR_15 = METHOD_3 ( VAR_16 -> VAR_17 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_18 = METHOD_4 ( VAR_19 -> VAR_20 ) ; <S2SV_EndBug> if ( VAR_21 == 0 ) return 0 ; VAR_22 = METHOD_5 ( sizeof ( struct STRUCT_OR_UNION_5 ) , VAR_23 ) ; if ( VAR_24 == VAR_25 ) return - VAR_26 ; if ( VAR_27 & VAR_28 ) { struct STRUCT_OR_UNION_6 VAR_29 ; unsigned TYPE_5 VAR_30 ; METHOD_6 ( & VAR_31 ) ; <S2SV_StartBug> VAR_32 = METHOD_7 ( VAR_33 ) ; <S2SV_EndBug> if ( VAR_34 > VAR_35 ) VAR_36 -= VAR_37 ; else VAR_38 = 0 ; } VAR_39 = ( VAR_40 + VAR_41 - 1 ) / VAR_42 + METHOD_8 ( ) ; VAR_43 = ( VAR_44 + VAR_45 - 1 ) / VAR_46 ; METHOD_9 ( ) ; VAR_47 = METHOD_10 ( METHOD_11 ( ) ) ; METHOD_12 ( & VAR_48 [ VAR_49 ] . VAR_50 , VAR_51 ) ; VAR_52 -> VAR_53 = VAR_54 ; VAR_55 -> VAR_56 = METHOD_13 ( ) ; VAR_57 -> VAR_58 . STRUCT_OR_UNION_7 . VAR_59 = VAR_60 ; VAR_61 -> VAR_62 . STRUCT_OR_UNION_8 . VAR_63 = VAR_64 ; VAR_65 -> VAR_66 . STRUCT_OR_UNION_9 . VAR_67 = VAR_68 ; VAR_69 -> VAR_70 . STRUCT_OR_UNION_10 . VAR_71 = VAR_72 ; VAR_73 = VAR_74 [ VAR_75 ] . VAR_76 ; METHOD_14 ( VAR_77 ) ; if ( VAR_78 [ VAR_79 ] . VAR_80 == VAR_81 ) { METHOD_15 ( & VAR_82 [ VAR_83 ] . VAR_84 , VAR_85 ) ; METHOD_16 ( ) ; return VAR_86 ; } if ( VAR_87 ) METHOD_17 ( METHOD_18 ( VAR_88 ) , VAR_89 ) ; METHOD_19 ( VAR_90 ) ; METHOD_20 ( & VAR_91 [ VAR_92 ] . VAR_93 , VAR_94 ) ; METHOD_21 ( ) ; return VAR_95 ; }",<S2SV_ModStart> = METHOD_7 ( & <S2SV_ModStart> = METHOD_7 ( & <S2SV_ModStart> = METHOD_7 ( &,"CWE-189 static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }",<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
167,"CWE-254 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = VAR_1 -> STRUCT_OR_UNION_3 ; if ( ! VAR_2 -> VAR_3 . VAR_4 ) METHOD_1 ( VAR_5 ) ; while ( 1 ) { if ( METHOD_2 ( & VAR_6 -> VAR_7 , & VAR_8 -> VAR_9 ) ) break ; if ( VAR_10 -> VAR_11 . STRUCT_OR_UNION_4 != VAR_12 -> VAR_13 . VAR_14 -> VAR_15 ) { struct STRUCT_OR_UNION_5 * VAR_16 = VAR_17 -> VAR_18 . STRUCT_OR_UNION_6 ; struct STRUCT_OR_UNION_7 * VAR_19 = VAR_20 -> VAR_21 ; unsigned VAR_22 ; STRUCT_OR_UNION_8 = VAR_23 -> VAR_24 ; VAR_25 = METHOD_3 ( & VAR_26 -> VAR_27 ) ; if ( METHOD_4 ( METHOD_5 ( & VAR_28 -> VAR_29 , VAR_30 -> VAR_31 ) ) ) return - VAR_32 ; VAR_33 -> VAR_34 . STRUCT_OR_UNION_9 = VAR_35 ; VAR_36 -> VAR_37 = VAR_38 ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct STRUCT_OR_UNION_10 * VAR_39 = METHOD_6 ( VAR_40 -> VAR_41 . VAR_42 ) ; struct STRUCT_OR_UNION_11 * VAR_43 = VAR_44 -> VAR_45 ; struct STRUCT_OR_UNION_12 * VAR_46 = VAR_47 -> VAR_48 ; struct STRUCT_OR_UNION_13 * VAR_49 = VAR_50 -> VAR_51 ; unsigned VAR_52 = METHOD_7 ( & VAR_53 -> VAR_54 ) ; if ( METHOD_8 ( METHOD_9 ( & VAR_55 , VAR_56 -> VAR_57 ) ) ) return - VAR_58 ; if ( & VAR_59 -> VAR_60 == VAR_61 -> VAR_62 . VAR_63 ) break ; VAR_64 -> VAR_65 . STRUCT_OR_UNION_14 = VAR_66 ; VAR_67 -> VAR_68 . VAR_69 = & VAR_70 -> VAR_71 ; STRUCT_OR_UNION_15 = VAR_72 ; VAR_73 -> VAR_74 = VAR_75 ; } } while ( METHOD_10 ( METHOD_11 ( VAR_76 -> VAR_77 . STRUCT_OR_UNION_16 ) ) ) { struct STRUCT_OR_UNION_17 * VAR_78 ; VAR_79 = METHOD_12 ( VAR_80 -> VAR_81 . VAR_82 , VAR_83 -> VAR_84 . STRUCT_OR_UNION_18 ) ; if ( METHOD_13 ( METHOD_14 ( & VAR_85 , VAR_86 -> VAR_87 ) ) ) return - VAR_88 ; if ( ! VAR_89 ) break ; VAR_90 -> VAR_91 . VAR_92 = & VAR_93 -> VAR_94 ; VAR_95 -> VAR_96 . STRUCT_OR_UNION_19 = VAR_97 -> VAR_98 . VAR_99 ; STRUCT_OR_UNION_20 = VAR_100 -> VAR_101 . STRUCT_OR_UNION_21 -> VAR_102 ; VAR_103 -> VAR_104 = METHOD_15 ( & VAR_105 -> VAR_106 . STRUCT_OR_UNION_22 -> VAR_107 ) ; } VAR_108 -> STRUCT_OR_UNION_23 = STRUCT_OR_UNION_24 ; return 0 ; }",<S2SV_ModStart> = VAR_104 ; if ( METHOD_13 ( ! METHOD_16 ( & VAR_108 -> VAR_106 ) ) ) return - VAR_109 ;,"CWE-254 static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }",<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
168,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { TYPE_6 VAR_5 = ( TYPE_7 ) VAR_6 ; TYPE_8 VAR_7 ; TYPE_9 VAR_8 [ 100 + VAR_9 ] ; TYPE_10 VAR_10 = 0 ; if ( ! METHOD_1 ( VAR_11 ) ) { METHOD_2 ( VAR_12 , VAR_13 , VAR_14 , VAR_15 , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; return VAR_16 ; } METHOD_3 ( VAR_17 ) ; if ( VAR_18 . VAR_19 ) { <S2SV_StartBug> METHOD_4 ( VAR_20 -> VAR_21 , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> VAR_22 , VAR_23 , METHOD_5 ( VAR_24 , VAR_25 ) , VAR_26 , ( TYPE_11 ) VAR_27 ) ; METHOD_6 ( VAR_28 , VAR_29 , VAR_30 , VAR_31 , VAR_32 -> VAR_33 ) ; } METHOD_7 ( VAR_34 , VAR_35 ) ; if ( VAR_36 -> VAR_37 -> VAR_38 < VAR_39 ) { METHOD_8 ( VAR_40 , VAR_41 , VAR_42 , VAR_43 , ""Error:<S2SV_blank>HY010"" ) ; METHOD_9 ( & VAR_44 -> VAR_45 , VAR_46 , VAR_47 , VAR_48 -> VAR_49 -> VAR_50 -> VAR_51 ) ; return METHOD_10 ( VAR_52 , VAR_53 , VAR_54 ) ; } if ( METHOD_11 ( VAR_55 , VAR_56 ) || METHOD_12 ( VAR_57 , VAR_58 ) || METHOD_13 ( VAR_59 , VAR_60 ) || METHOD_14 ( VAR_61 , VAR_62 ) || METHOD_15 ( VAR_63 , VAR_64 ) || METHOD_16 ( VAR_65 , VAR_66 ) || METHOD_17 ( VAR_67 , VAR_68 ) || METHOD_18 ( VAR_69 , VAR_70 ) ) { METHOD_19 ( VAR_71 , VAR_72 , VAR_73 , VAR_74 , ""Error:<S2SV_blank>HY010"" ) ; METHOD_20 ( & VAR_75 -> VAR_76 , VAR_77 , VAR_78 , VAR_79 -> VAR_80 -> VAR_81 -> VAR_82 ) ; return METHOD_21 ( VAR_83 , VAR_84 , VAR_85 ) ; } if ( VAR_86 < 0 ) { METHOD_22 ( & VAR_87 -> VAR_88 , VAR_89 , VAR_90 , VAR_91 -> VAR_92 -> VAR_93 -> VAR_94 ) ; return METHOD_23 ( VAR_95 , VAR_96 , VAR_97 ) ; } switch ( VAR_98 ) { case VAR_99 : case VAR_100 : case VAR_101 : case VAR_102 : case VAR_103 : case VAR_104 : case VAR_105 : case VAR_106 : case VAR_107 : case VAR_108 : case VAR_109 : case VAR_110 : case VAR_111 : case VAR_112 : case VAR_113 : case VAR_114 : case VAR_115 : case VAR_116 : case VAR_117 : case VAR_118 : case VAR_119 : case VAR_120 : case VAR_121 : case VAR_122 : case VAR_123 : case VAR_124 : case VAR_125 : case VAR_126 : case VAR_127 : case VAR_128 : VAR_129 = 0 ; break ; case VAR_130 : case VAR_131 : case VAR_132 : case VAR_133 : case VAR_134 : case VAR_135 : case VAR_136 : case VAR_137 : case VAR_138 : case VAR_139 : case VAR_140 : VAR_141 = 1 ; break ; default : VAR_142 = VAR_143 != VAR_144 && VAR_145 != VAR_146 && VAR_147 != VAR_148 && VAR_149 != VAR_150 && VAR_151 != VAR_152 ; } if ( VAR_153 && VAR_154 < 0 && VAR_155 != VAR_156 ) { METHOD_24 ( & VAR_157 -> VAR_158 , VAR_159 , VAR_160 , VAR_161 -> VAR_162 -> VAR_163 -> VAR_164 ) ; return METHOD_25 ( VAR_165 , VAR_166 , VAR_167 ) ; } <S2SV_StartBug> if ( VAR_168 == VAR_169 && ( TYPE_12 ) VAR_170 < 0 ) <S2SV_EndBug> { METHOD_26 ( & VAR_171 -> VAR_172 , VAR_173 , VAR_174 , VAR_175 -> VAR_176 -> VAR_177 -> VAR_178 ) ; return METHOD_27 ( VAR_179 , VAR_180 , VAR_181 ) ; } <S2SV_StartBug> if ( VAR_182 == VAR_183 && VAR_184 != VAR_185 <S2SV_EndBug> <S2SV_StartBug> && VAR_186 != VAR_187 && VAR_188 != VAR_189 && <S2SV_EndBug> <S2SV_StartBug> VAR_190 != VAR_191 && VAR_192 != VAR_193 ) <S2SV_EndBug> { METHOD_28 ( & VAR_194 -> VAR_195 , VAR_196 , VAR_197 , VAR_198 -> VAR_199 -> VAR_200 -> VAR_201 ) ; return METHOD_29 ( VAR_202 , VAR_203 , VAR_204 ) ; } if ( METHOD_30 ( VAR_205 -> VAR_206 ) ) { VAR_207 = METHOD_31 ( VAR_208 -> VAR_209 , VAR_210 -> VAR_211 , VAR_212 , VAR_213 , VAR_214 , VAR_215 ) ; } else if ( METHOD_32 ( VAR_216 -> VAR_217 ) ) { TYPE_13 * VAR_218 = VAR_219 ; if ( VAR_220 ) { VAR_221 = METHOD_33 ( VAR_222 , VAR_223 , VAR_224 -> VAR_225 , VAR_226 ) ; if ( VAR_227 != VAR_228 ) { VAR_229 *= sizeof ( TYPE_14 ) ; } } else { VAR_230 = VAR_231 ; } VAR_232 = METHOD_34 ( VAR_233 -> VAR_234 , VAR_235 -> VAR_236 , VAR_237 , VAR_238 , VAR_239 , VAR_240 ) ; if ( VAR_241 ) { if ( VAR_242 ) METHOD_35 ( VAR_243 ) ; } } else { METHOD_36 ( VAR_244 , VAR_245 , VAR_246 , VAR_247 , ""Error:<S2SV_blank>IM001"" ) ; METHOD_37 ( & VAR_248 -> VAR_249 , VAR_250 , VAR_251 , VAR_252 -> VAR_253 -> VAR_254 -> VAR_255 ) ; return METHOD_38 ( VAR_256 , VAR_257 , VAR_258 ) ; } if ( VAR_259 . VAR_260 ) { METHOD_39 ( VAR_261 -> VAR_262 , ""\\n\\t\\tExit:[%s]"" , METHOD_40 ( VAR_263 , VAR_264 ) ) ; METHOD_41 ( VAR_265 , VAR_266 , VAR_267 , VAR_268 , VAR_269 -> VAR_270 ) ; } return METHOD_42 ( VAR_271 , VAR_272 , VAR_273 ) ; }","<S2SV_ModStart> -> VAR_270 , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , VAR_272 , <S2SV_ModStart> VAR_169 && ( TYPE_15 <S2SV_ModEnd> ) VAR_231 < <S2SV_ModStart> == VAR_183 && ( TYPE_15 ) <S2SV_ModStart> != VAR_185 && ( TYPE_15 ) <S2SV_ModStart> != VAR_187 && ( TYPE_15 ) <S2SV_ModStart> != VAR_189 && ( TYPE_15 ) <S2SV_ModStart> != VAR_191 && ( TYPE_15 )","CWE-119 SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }","<S2SV_ModStart> -> msg , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )"
169,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 ; struct STRUCT_OR_UNION_5 * VAR_5 , * VAR_6 ; struct STRUCT_OR_UNION_6 * VAR_7 ; struct STRUCT_OR_UNION_7 * VAR_8 = VAR_9 ; TYPE_3 VAR_10 , VAR_11 , VAR_12 ; TYPE_4 VAR_13 ; unsigned VAR_14 = 0 ; METHOD_1 ( METHOD_2 ( VAR_15 ) == 0 ) ; VAR_16 = METHOD_3 ( STRUCT_OR_UNION_8 ) ; VAR_17 = VAR_18 [ VAR_19 ] . VAR_20 ; METHOD_4 ( VAR_21 [ VAR_22 ] . VAR_23 == VAR_24 ) ; <S2SV_StartBug> if ( VAR_25 && ( VAR_26 != VAR_27 ) <S2SV_EndBug> && METHOD_5 ( STRUCT_OR_UNION_9 , VAR_28 , VAR_29 ) ) { METHOD_6 ( ""append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n"" , METHOD_7 ( VAR_30 ) , METHOD_8 ( VAR_31 ) , METHOD_9 ( VAR_32 -> VAR_33 ) , METHOD_10 ( VAR_34 ) , METHOD_11 ( VAR_35 ) , METHOD_12 ( VAR_36 ) ) ; VAR_37 = METHOD_13 ( VAR_38 , STRUCT_OR_UNION_10 , VAR_39 + VAR_40 ) ; if ( VAR_41 ) return VAR_42 ; if ( METHOD_14 ( VAR_43 ) ) VAR_44 = 1 ; VAR_45 -> VAR_46 = METHOD_15 ( METHOD_16 ( VAR_47 ) + METHOD_17 ( VAR_48 ) ) ; if ( VAR_49 ) METHOD_18 ( VAR_50 ) ; VAR_51 = VAR_52 [ VAR_53 ] . VAR_54 ; VAR_55 = VAR_56 ; goto VAR_57 ; } VAR_58 : VAR_59 = METHOD_19 ( STRUCT_OR_UNION_11 ) ; VAR_60 = VAR_61 [ VAR_62 ] . VAR_63 ; if ( METHOD_20 ( VAR_64 -> VAR_65 ) < METHOD_21 ( VAR_66 -> VAR_67 ) ) goto VAR_68 ; VAR_69 = METHOD_22 ( VAR_70 ) ; VAR_71 = METHOD_23 ( STRUCT_OR_UNION_12 , VAR_72 ) ; if ( METHOD_24 ( VAR_73 -> VAR_74 ) > METHOD_25 ( VAR_75 -> VAR_76 ) && VAR_77 != VAR_78 ) { METHOD_26 ( ""next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n"" , VAR_79 ) ; METHOD_27 ( VAR_80 != VAR_81 ) ; VAR_82 = METHOD_28 ( STRUCT_OR_UNION_13 , VAR_83 , VAR_84 ) ; if ( METHOD_29 ( VAR_85 ) ) return METHOD_30 ( VAR_86 ) ; METHOD_31 ( VAR_87 -> VAR_88 != VAR_89 -> VAR_90 ) ; VAR_91 = VAR_92 [ VAR_93 ] . VAR_94 ; if ( METHOD_32 ( VAR_95 -> VAR_96 ) < METHOD_33 ( VAR_97 -> VAR_98 ) ) { METHOD_34 ( ""next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n"" , METHOD_35 ( VAR_99 -> VAR_100 ) ) ; VAR_101 = VAR_102 ; goto VAR_103 ; } METHOD_36 ( ""next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n"" , METHOD_37 ( VAR_104 -> VAR_105 ) , METHOD_38 ( VAR_106 -> VAR_107 ) ) ; } VAR_108 = METHOD_39 ( VAR_109 , STRUCT_OR_UNION_14 , VAR_110 , VAR_111 ) ; if ( VAR_112 ) goto VAR_113 ; VAR_114 = METHOD_40 ( STRUCT_OR_UNION_15 ) ; VAR_115 = VAR_116 [ VAR_117 ] . VAR_118 ; VAR_119 : VAR_120 = VAR_121 [ VAR_122 ] . VAR_123 ; VAR_124 = METHOD_41 ( VAR_125 , STRUCT_OR_UNION_16 , VAR_126 + VAR_127 ) ; if ( VAR_128 ) goto VAR_129 ; if ( ! VAR_130 ) { METHOD_42 ( ""first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n"" , METHOD_43 ( VAR_131 -> VAR_132 ) , METHOD_44 ( VAR_133 ) , METHOD_45 ( VAR_134 ) , METHOD_46 ( VAR_135 ) ) ; VAR_136 [ VAR_137 ] . VAR_138 = METHOD_47 ( VAR_139 ) ; } else if ( METHOD_48 ( VAR_140 -> VAR_141 ) > METHOD_49 ( VAR_142 -> VAR_143 ) ) { if ( VAR_144 != METHOD_50 ( VAR_145 ) ) { VAR_146 = METHOD_51 ( VAR_147 ) - VAR_148 ; VAR_149 = ( VAR_150 - 1 ) * sizeof ( struct STRUCT_OR_UNION_17 ) ; VAR_151 = VAR_152 < 0 ? 0 : VAR_153 ; METHOD_52 ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , METHOD_53 ( VAR_154 -> VAR_155 ) , METHOD_54 ( VAR_156 ) , METHOD_55 ( VAR_157 ) , METHOD_56 ( VAR_158 ) , VAR_159 , VAR_160 , VAR_161 + 1 , VAR_162 + 2 ) ; METHOD_57 ( VAR_163 + 2 , VAR_164 + 1 , VAR_165 ) ; } VAR_166 [ VAR_167 ] . VAR_168 = VAR_169 + 1 ; } else { METHOD_58 ( VAR_170 -> VAR_171 == VAR_172 -> VAR_173 ) ; VAR_174 = ( METHOD_59 ( VAR_175 ) - VAR_176 ) * sizeof ( struct STRUCT_OR_UNION_18 ) ; VAR_177 = VAR_178 < 0 ? 0 : VAR_179 ; METHOD_60 ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , METHOD_61 ( VAR_180 -> VAR_181 ) , METHOD_62 ( VAR_182 ) , METHOD_63 ( VAR_183 ) , METHOD_64 ( VAR_184 ) , VAR_185 , VAR_186 , VAR_187 + 1 , VAR_188 + 2 ) ; METHOD_65 ( VAR_189 + 1 , VAR_190 , VAR_191 ) ; VAR_192 [ VAR_193 ] . VAR_194 = VAR_195 ; } METHOD_66 ( & VAR_196 -> VAR_197 , 1 ) ; VAR_198 = VAR_199 [ VAR_200 ] . VAR_201 ; VAR_202 -> VAR_203 = VAR_204 -> VAR_205 ; METHOD_67 ( VAR_206 , METHOD_68 ( VAR_207 ) ) ; VAR_208 -> VAR_209 = VAR_210 -> VAR_211 ; VAR_212 : <S2SV_StartBug> if ( VAR_213 != VAR_214 ) <S2SV_EndBug> METHOD_69 ( STRUCT_OR_UNION_19 , VAR_215 , VAR_216 ) ; VAR_217 = METHOD_70 ( VAR_218 , STRUCT_OR_UNION_20 , VAR_219 ) ; if ( VAR_220 ) goto VAR_221 ; VAR_222 = METHOD_71 ( VAR_223 , STRUCT_OR_UNION_21 , VAR_224 + VAR_225 ) ; VAR_226 : if ( VAR_227 ) { METHOD_72 ( VAR_228 ) ; METHOD_73 ( VAR_229 ) ; } METHOD_74 ( STRUCT_OR_UNION_22 ) ; return VAR_230 ; }",<S2SV_ModStart> ( VAR_56 && ! ( VAR_213 & <S2SV_ModEnd> VAR_214 ) && <S2SV_ModStart> : if ( ! ( VAR_213 & VAR_214 ) <S2SV_ModEnd> ) METHOD_69 (,"CWE-000 int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( ""append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n"" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n"" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( ""first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge : <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }",<S2SV_ModStart> ( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
170,"CWE-362 static TYPE_0 <S2SV_StartBug> METHOD_0 ( unsigned TYPE_1 VAR_0 ) <S2SV_EndBug> { struct STRUCT_OR_UNION_0 TYPE_2 * VAR_1 = ( TYPE_3 TYPE_4 * ) VAR_2 ; struct STRUCT_OR_UNION_1 VAR_3 ; <S2SV_StartBug> TYPE_5 * VAR_4 ; <S2SV_EndBug> TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; if ( METHOD_1 ( & VAR_7 , VAR_8 , sizeof ( struct STRUCT_OR_UNION_2 ) ) ) { printk ( TYPE_8 TYPE_9 ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , VAR_9 , VAR_10 , VAR_11 ) ; <S2SV_StartBug> return - VAR_12 ; <S2SV_EndBug> } if ( ( ( VAR_13 = METHOD_2 ( VAR_14 . VAR_15 . VAR_16 , & VAR_17 ) ) < 0 ) || ( VAR_18 == VAR_19 ) ) { printk ( TYPE_10 TYPE_11 ""%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , VAR_20 , VAR_21 , VAR_22 ) ; return - VAR_23 ; } dctlprintk ( VAR_24 , printk ( MYIOC_s_DEBUG_FMT ""mptctl_replace_fw<S2SV_blank>called.\\n"" , VAR_25 -> VAR_26 ) ) ; if ( VAR_27 -> VAR_28 == VAR_29 ) return 0 ; METHOD_3 ( VAR_30 ) ; VAR_31 = METHOD_4 ( VAR_32 . VAR_33 , 4 ) ; METHOD_5 ( VAR_34 , VAR_35 ) ; if ( VAR_36 -> VAR_37 == VAR_38 ) return - VAR_39 ; if ( METHOD_6 ( VAR_40 -> VAR_41 , VAR_42 -> VAR_43 , VAR_44 ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>image<S2SV_blank>"" ""@<S2SV_blank>%p\\n"" , VAR_45 -> VAR_46 , VAR_47 , VAR_48 , VAR_49 ) ; METHOD_7 ( VAR_50 ) ; return - VAR_51 ; } VAR_52 -> VAR_53 . VAR_54 = VAR_55 ; return 0 ; }","<S2SV_ModStart> TYPE_7 METHOD_0 ( TYPE_5 * VAR_52 , <S2SV_ModStart> STRUCT_OR_UNION_2 VAR_32 ; <S2SV_ModEnd> TYPE_7 VAR_55 ; <S2SV_ModStart> return - VAR_51 <S2SV_ModEnd> ; } dctlprintk","CWE-362 static int <S2SV_StartBug> mptctl_replace_fw ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_replace_fw __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_replace_fw karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int newFwSize ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_replace_fw ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_replace_fw<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> cached_fw == NULL ) return 0 ; mpt_free_fw_memory ( ioc ) ; newFwSize = ALIGN ( karg . newImageSize , 4 ) ; mpt_alloc_fw_memory ( ioc , newFwSize ) ; if ( ioc -> cached_fw == NULL ) return - ENOMEM ; if ( copy_from_user ( ioc -> cached_fw , uarg -> newImage , newFwSize ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>image<S2SV_blank>"" ""@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; mpt_free_fw_memory ( ioc ) ; return - EFAULT ; } ioc -> facts . FWImageSize = newFwSize ; return 0 ; }","<S2SV_ModStart> int mptctl_replace_fw ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_replace_fw karg ; <S2SV_ModEnd> int newFwSize ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk"
171,"CWE-284 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 [ VAR_2 ] = { 0 } ; TYPE_3 VAR_3 = VAR_4 ; TYPE_4 VAR_5 = 0 ; const TYPE_5 VAR_6 [ VAR_7 ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; if ( METHOD_1 ( VAR_8 , VAR_9 , VAR_10 ) ) { TYPE_6 VAR_11 ; METHOD_2 ( ""%s,<S2SV_blank>local<S2SV_blank>bdaddr<S2SV_blank>is<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%s"" , VAR_12 , VAR_13 ) ; <S2SV_StartBug> if ( ( VAR_14 = METHOD_3 ( VAR_15 , VAR_16 ) ) != - 1 ) <S2SV_EndBug> { METHOD_4 ( VAR_17 , 0 , sizeof ( VAR_18 ) ) ; <S2SV_StartBug> METHOD_5 ( VAR_19 , VAR_20 , VAR_21 ) ; <S2SV_EndBug> if ( ( METHOD_6 ( VAR_22 , VAR_23 ) ) && ( METHOD_7 ( VAR_24 -> VAR_25 , VAR_26 , VAR_27 ) != 0 ) ) { VAR_28 = VAR_29 ; METHOD_8 ( ""%s:<S2SV_blank>Got<S2SV_blank>Factory<S2SV_blank>BDA<S2SV_blank>%s"" , VAR_30 , VAR_31 ) ; } METHOD_9 ( VAR_32 ) ; } } if ( ! VAR_33 ) { VAR_34 = sizeof ( VAR_35 ) ; if ( METHOD_10 ( ""Adapter"" , ""Address"" , VAR_36 , & VAR_37 ) ) { METHOD_11 ( VAR_38 , VAR_39 ) ; METHOD_12 ( ""local<S2SV_blank>bdaddr<S2SV_blank>from<S2SV_blank>bt_config.xml<S2SV_blank>is<S2SV_blank><S2SV_blank>%s"" , VAR_40 ) ; return ; } } if ( ! VAR_41 ) { VAR_42 = METHOD_13 ( VAR_43 , VAR_44 ) ; } if ( ! VAR_45 ) { VAR_46 = METHOD_14 ( VAR_47 , VAR_48 ) ; } if ( ! VAR_49 ) { TYPE_7 VAR_50 ; METHOD_15 ( ( unsigned TYPE_8 ) ( METHOD_16 ( 0 ) ) ) ; VAR_51 -> VAR_52 [ 0 ] = 0x22 ; VAR_53 -> VAR_54 [ 1 ] = 0x22 ; VAR_55 -> VAR_56 [ 2 ] = ( TYPE_9 ) ( ( METHOD_17 ( ) >> 8 ) & 0xFF ) ; VAR_57 -> VAR_58 [ 3 ] = ( TYPE_10 ) ( ( METHOD_18 ( ) >> 8 ) & 0xFF ) ; VAR_59 -> VAR_60 [ 4 ] = ( TYPE_11 ) ( ( METHOD_19 ( ) >> 8 ) & 0xFF ) ; VAR_61 -> VAR_62 [ 5 ] = ( TYPE_12 ) ( ( METHOD_20 ( ) >> 8 ) & 0xFF ) ; METHOD_21 ( VAR_63 , VAR_64 , sizeof ( VAR_65 ) ) ; METHOD_22 ( ""No<S2SV_blank>preset<S2SV_blank>BDA.<S2SV_blank>Generating<S2SV_blank>BDA:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>prop<S2SV_blank>%s"" , ( TYPE_13 * ) VAR_66 , VAR_67 ) ; if ( METHOD_23 ( VAR_68 , ( TYPE_14 * ) VAR_69 ) < 0 ) METHOD_24 ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>random<S2SV_blank>BDA<S2SV_blank>in<S2SV_blank>prop<S2SV_blank>%s"" , VAR_70 ) ; } TYPE_15 VAR_71 ; METHOD_25 ( VAR_72 , VAR_73 , sizeof ( VAR_74 ) ) ; VAR_75 = sizeof ( VAR_76 ) ; if ( METHOD_26 ( ""Adapter"" , ""Address"" , VAR_77 , & VAR_78 ) ) { if ( METHOD_27 ( VAR_79 , VAR_80 ) == 0 ) { return ; } } METHOD_28 ( ""Adapter"" , ""Address"" , VAR_81 ) ; }","<S2SV_ModStart> ( VAR_32 = METHOD_29 ( <S2SV_ModStart> VAR_80 , VAR_16 ) <S2SV_ModStart> ) ) ; METHOD_29 ( <S2SV_ModStart> VAR_80 , VAR_21 )","CWE-284 static void btif_fetch_local_bdaddr ( bt_bdaddr_t * local_addr ) { char val [ PROPERTY_VALUE_MAX ] = { 0 } ; uint8_t valid_bda = FALSE ; int val_size = 0 ; const uint8_t null_bdaddr [ BD_ADDR_LEN ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; if ( property_get ( PROPERTY_BT_BDADDR_PATH , val , NULL ) ) { int addr_fd ; BTIF_TRACE_DEBUG ( ""%s,<S2SV_blank>local<S2SV_blank>bdaddr<S2SV_blank>is<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%s"" , __func__ , val ) ; <S2SV_StartBug> if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 ) <S2SV_EndBug> { memset ( val , 0 , sizeof ( val ) ) ; <S2SV_StartBug> read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ; <S2SV_EndBug> if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) { valid_bda = TRUE ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank>Got<S2SV_blank>Factory<S2SV_blank>BDA<S2SV_blank>%s"" , __func__ , val ) ; } close ( addr_fd ) ; } } if ( ! valid_bda ) { val_size = sizeof ( val ) ; if ( btif_config_get_str ( ""Adapter"" , ""Address"" , val , & val_size ) ) { string_to_bdaddr ( val , local_addr ) ; BTIF_TRACE_DEBUG ( ""local<S2SV_blank>bdaddr<S2SV_blank>from<S2SV_blank>bt_config.xml<S2SV_blank>is<S2SV_blank><S2SV_blank>%s"" , val ) ; return ; } } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( PERSIST_BDADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( FACTORY_BT_ADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { bdstr_t bdstr ; srand ( ( unsigned int ) ( time ( 0 ) ) ) ; local_addr -> address [ 0 ] = 0x22 ; local_addr -> address [ 1 ] = 0x22 ; local_addr -> address [ 2 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 3 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 4 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 5 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; BTIF_TRACE_DEBUG ( ""No<S2SV_blank>preset<S2SV_blank>BDA.<S2SV_blank>Generating<S2SV_blank>BDA:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>prop<S2SV_blank>%s"" , ( char * ) bdstr , PERSIST_BDADDR_PROPERTY ) ; if ( property_set ( PERSIST_BDADDR_PROPERTY , ( char * ) bdstr ) < 0 ) BTIF_TRACE_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>random<S2SV_blank>BDA<S2SV_blank>in<S2SV_blank>prop<S2SV_blank>%s"" , PERSIST_BDADDR_PROPERTY ) ; } bdstr_t bdstr ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; val_size = sizeof ( val ) ; if ( btif_config_get_str ( ""Adapter"" , ""Address"" , val , & val_size ) ) { if ( strcmp ( bdstr , val ) == 0 ) { return ; } } btif_config_set_str ( ""Adapter"" , ""Address"" , bdstr ) ; }","<S2SV_ModStart> ( addr_fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> val , O_RDONLY ) <S2SV_ModStart> ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> val , FACTORY_BT_BDADDR_STORAGE_LEN )"
172,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 , VAR_5 = 0 ; TYPE_6 VAR_6 ; TYPE_7 VAR_7 = 1 ; TYPE_8 VAR_8 = VAR_9 ; TYPE_9 VAR_10 = 0 ; VAR_11 -> VAR_12 = 0 ; while ( VAR_13 ) { VAR_14 = VAR_15 ; VAR_16 = METHOD_1 ( VAR_17 , & VAR_18 , & VAR_19 ) ; if ( ! METHOD_2 ( VAR_20 + VAR_21 , ""ptr"" , 3 ) ) { continue ; } else if ( ! METHOD_3 ( VAR_22 + VAR_23 , ""byte"" , 4 ) ) { VAR_24 -> VAR_25 |= VAR_26 | VAR_27 ; VAR_28 -> VAR_29 = VAR_30 ; VAR_31 = VAR_32 ; } else if ( ! METHOD_4 ( VAR_33 + VAR_34 , ""word"" , 4 ) ) { VAR_35 -> VAR_36 |= VAR_37 | VAR_38 ; VAR_39 -> VAR_40 = VAR_41 ; VAR_42 = VAR_43 ; } else if ( ! METHOD_5 ( VAR_44 + VAR_45 , ""dword"" , 5 ) ) { VAR_46 -> VAR_47 |= VAR_48 | VAR_49 ; VAR_50 -> VAR_51 = VAR_52 ; VAR_53 = VAR_54 ; } else if ( ! METHOD_6 ( VAR_55 + VAR_56 , ""qword"" , 5 ) ) { VAR_57 -> VAR_58 |= VAR_59 | VAR_60 ; VAR_61 -> VAR_62 = VAR_63 ; VAR_64 = VAR_65 ; } else if ( ! METHOD_7 ( VAR_66 + VAR_67 , ""oword"" , 5 ) ) { VAR_68 -> VAR_69 |= VAR_70 | VAR_71 ; VAR_72 -> VAR_73 = VAR_74 ; VAR_75 = VAR_76 ; } else if ( ! METHOD_8 ( VAR_77 + VAR_78 , ""tbyte"" , 5 ) ) { VAR_79 -> VAR_80 |= VAR_81 | VAR_82 ; VAR_83 -> VAR_84 = VAR_85 ; VAR_86 = VAR_87 ; } else { VAR_88 = 0 ; } } if ( VAR_89 [ VAR_90 ] == '[' ) { if ( ! VAR_91 -> VAR_92 ) { VAR_93 -> VAR_94 = VAR_95 ; } VAR_96 -> VAR_97 = VAR_98 -> VAR_99 [ 0 ] = VAR_100 -> VAR_101 [ 1 ] = 0 ; TYPE_10 VAR_102 = 1 ; TYPE_11 VAR_103 = VAR_104 ; TYPE_12 VAR_105 = VAR_106 ; while ( VAR_107 [ VAR_108 ] != ']' ) { if ( VAR_109 > VAR_110 ) { break ; } VAR_111 = VAR_112 ; if ( ! VAR_113 [ VAR_114 ] ) { break ; } VAR_115 = METHOD_9 ( VAR_116 , & VAR_117 , & VAR_118 ) ; if ( VAR_119 == VAR_120 ) { if ( VAR_121 [ VAR_122 ] == '+' || VAR_123 [ VAR_124 ] == '-' || VAR_125 [ VAR_126 ] == ']' ) { if ( VAR_127 != VAR_128 ) { <S2SV_StartBug> VAR_129 -> VAR_130 [ VAR_131 ] = VAR_132 ; <S2SV_EndBug> VAR_133 -> VAR_134 [ VAR_135 ] = VAR_136 ; <S2SV_StartBug> ++ VAR_137 ; <S2SV_EndBug> } else { <S2SV_StartBug> VAR_138 -> VAR_139 += VAR_140 ; <S2SV_EndBug> <S2SV_StartBug> VAR_141 -> VAR_142 [ VAR_143 ] = VAR_144 ; <S2SV_EndBug> } VAR_145 = 1 ; VAR_146 = VAR_147 ; } else if ( VAR_148 [ VAR_149 ] == '*' ) { } } else if ( VAR_150 == VAR_151 ) { TYPE_13 VAR_152 = 0 ; if ( VAR_153 != VAR_154 ) { VAR_155 -> VAR_156 = 0 ; } VAR_157 = VAR_158 ; VAR_159 = METHOD_10 ( VAR_160 , VAR_161 , & VAR_162 , & VAR_163 ) ; if ( VAR_164 ) { VAR_165 -> VAR_166 = VAR_167 ; if ( VAR_168 > 8 ) { VAR_169 -> VAR_170 = VAR_171 ; VAR_172 -> VAR_173 = VAR_174 - 9 ; } VAR_175 = VAR_176 ; } else if ( VAR_177 > 8 ) { VAR_178 -> VAR_179 = VAR_180 - 9 ; } if ( VAR_181 & VAR_182 & VAR_183 ) { VAR_184 -> VAR_185 = VAR_186 ; VAR_187 -> VAR_188 = VAR_189 ; METHOD_11 ( VAR_190 , VAR_191 , & VAR_192 , VAR_193 , VAR_194 ) ; return VAR_195 ; } if ( ! VAR_196 ) { VAR_197 -> VAR_198 |= VAR_199 ; } VAR_200 -> VAR_201 = VAR_202 ; VAR_203 -> VAR_204 = VAR_205 ; if ( ! ( VAR_206 & VAR_207 ) ) { VAR_208 -> VAR_209 = 0 ; } } else { TYPE_14 * VAR_210 = METHOD_12 ( VAR_211 , '+' ) ; VAR_212 -> VAR_213 = 1 ; if ( ! VAR_214 ) { VAR_215 = METHOD_13 ( VAR_216 , '-' ) ; if ( VAR_217 ) { VAR_218 -> VAR_219 = - 1 ; } } TYPE_15 * VAR_220 = METHOD_14 ( VAR_221 , '+' ) ; TYPE_16 * VAR_222 = METHOD_15 ( VAR_223 , '-' ) ; TYPE_17 * VAR_224 = METHOD_16 ( VAR_225 , ']' ) ; if ( VAR_226 && VAR_227 && VAR_228 < VAR_229 && VAR_230 < VAR_231 ) { VAR_232 -> VAR_233 = - 1 ; } TYPE_18 * VAR_234 ; VAR_235 = METHOD_17 ( METHOD_18 ( VAR_236 + VAR_237 ) + 1 ) ; METHOD_19 ( VAR_238 , VAR_239 + VAR_240 ) ; METHOD_20 ( VAR_241 , ""+-"" ) ; TYPE_19 VAR_242 = METHOD_21 ( VAR_243 , VAR_244 ) ; METHOD_22 ( VAR_245 ) ; VAR_246 *= VAR_247 ; } } } else if ( VAR_248 == VAR_249 ) { VAR_250 = VAR_251 ; VAR_252 * VAR_253 ; if ( VAR_254 ) { VAR_255 -> VAR_256 = VAR_257 ; METHOD_23 ( VAR_258 -> VAR_259 , VAR_260 , VAR_261 - 1 ) ; VAR_262 -> VAR_263 [ VAR_264 - 1 ] = '\\0' ; return VAR_265 ; } VAR_266 -> VAR_267 = METHOD_24 ( VAR_268 , VAR_269 , & VAR_270 , & VAR_271 -> VAR_272 ) ; VAR_273 -> VAR_274 = VAR_275 ; if ( VAR_276 -> VAR_277 > 8 ) { VAR_278 -> VAR_279 = VAR_280 ; VAR_281 -> VAR_282 -= 9 ; } if ( VAR_283 -> VAR_284 & VAR_285 & VAR_286 ) { METHOD_25 ( VAR_287 , VAR_288 , & VAR_289 , VAR_290 , VAR_291 ) ; return VAR_292 ; } if ( VAR_293 -> VAR_294 == VAR_295 ) { VAR_296 -> VAR_297 = VAR_298 ; if ( VAR_299 -> VAR_300 && VAR_301 -> VAR_302 -> VAR_303 == 0 ) { return VAR_304 ; } VAR_305 -> VAR_306 = VAR_307 ; TYPE_20 * VAR_308 = VAR_309 -> VAR_310 ? ( TYPE_21 * ) ( VAR_311 -> VAR_312 -> VAR_313 ) : VAR_314 ; if ( VAR_315 && ( VAR_316 = METHOD_26 ( VAR_317 -> VAR_318 , VAR_319 ) ) ) { VAR_320 -> VAR_321 = VAR_322 ; } TYPE_22 * VAR_323 = METHOD_27 ( VAR_324 , '-' ) ; if ( VAR_325 ) { VAR_326 -> VAR_327 = - 1 ; VAR_328 = ++ VAR_329 ; } VAR_330 -> VAR_331 = METHOD_28 ( VAR_332 , VAR_333 ) ; } else if ( VAR_334 -> VAR_335 < VAR_336 ) { METHOD_29 ( VAR_337 -> VAR_338 , VAR_339 , VAR_340 - 1 ) ; VAR_341 -> VAR_342 [ VAR_343 - 1 ] = '\\0' ; } } else { VAR_344 -> VAR_345 = VAR_346 ; VAR_347 -> VAR_348 = 1 ; TYPE_23 * VAR_349 = METHOD_30 ( VAR_350 , '-' ) ; if ( VAR_351 ) { VAR_352 -> VAR_353 = - 1 ; VAR_354 = ++ VAR_355 ; } VAR_356 -> VAR_357 = METHOD_31 ( VAR_358 , VAR_359 ) ; } return VAR_360 ; }",<S2SV_ModStart> VAR_336 ) { if ( VAR_291 < 2 ) { <S2SV_ModStart> = VAR_246 ; } <S2SV_ModStart> += VAR_246 ; if ( VAR_291 < 2 ) { <S2SV_ModStart> = VAR_336 ; },"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }",<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
173,"CWE-125 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 = ( TYPE_3 ) VAR_2 ; TYPE_4 * VAR_3 = VAR_4 , * VAR_5 = VAR_6 ; if ( ! VAR_7 ) { VAR_8 ; } switch ( VAR_9 -> VAR_10 ) { case VAR_11 : VAR_12 = METHOD_1 ( VAR_13 , VAR_14 , VAR_15 ) ; if ( ! VAR_16 ) goto VAR_17 ; VAR_18 = METHOD_2 ( VAR_19 -> VAR_20 . VAR_21 . VAR_22 ) ; if ( ! VAR_23 ) goto VAR_24 ; if ( METHOD_3 ( VAR_25 , & VAR_26 , VAR_27 ) == - 1 ) goto VAR_28 ; METHOD_4 ( VAR_29 ) ; VAR_30 = METHOD_5 ( VAR_31 -> VAR_32 . VAR_33 . VAR_34 ) ; if ( ! VAR_35 ) goto VAR_36 ; if ( METHOD_6 ( VAR_37 , & VAR_38 , VAR_39 ) == - 1 ) goto VAR_40 ; METHOD_7 ( VAR_41 ) ; VAR_42 = METHOD_8 ( VAR_43 -> VAR_44 . VAR_45 . VAR_46 , METHOD_9 ) ; if ( ! VAR_47 ) goto VAR_48 ; if ( METHOD_10 ( VAR_49 , & VAR_50 , VAR_51 ) == - 1 ) goto VAR_52 ; METHOD_11 ( VAR_53 ) ; VAR_54 = METHOD_12 ( VAR_55 -> VAR_56 . VAR_57 . VAR_58 , METHOD_13 ) ; if ( ! VAR_59 ) goto VAR_60 ; if ( METHOD_14 ( VAR_61 , & VAR_62 , VAR_63 ) == - 1 ) goto VAR_64 ; METHOD_15 ( VAR_65 ) ; VAR_66 = METHOD_16 ( VAR_67 -> VAR_68 . VAR_69 . VAR_70 ) ; if ( ! VAR_71 ) goto VAR_72 ; if ( METHOD_17 ( VAR_73 , & VAR_74 , VAR_75 ) == - 1 ) goto VAR_76 ; METHOD_18 ( VAR_77 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_78 : VAR_79 = METHOD_19 ( VAR_80 , VAR_81 , VAR_82 ) ; if ( ! VAR_83 ) goto VAR_84 ; VAR_85 = METHOD_20 ( VAR_86 -> VAR_87 . VAR_88 . VAR_89 ) ; if ( ! VAR_90 ) goto VAR_91 ; if ( METHOD_21 ( VAR_92 , & VAR_93 , VAR_94 ) == - 1 ) goto VAR_95 ; METHOD_22 ( VAR_96 ) ; VAR_97 = METHOD_23 ( VAR_98 -> VAR_99 . VAR_100 . VAR_101 ) ; if ( ! VAR_102 ) goto VAR_103 ; if ( METHOD_24 ( VAR_104 , & VAR_105 , VAR_106 ) == - 1 ) goto VAR_107 ; METHOD_25 ( VAR_108 ) ; VAR_109 = METHOD_26 ( VAR_110 -> VAR_111 . VAR_112 . VAR_113 , METHOD_27 ) ; if ( ! VAR_114 ) goto VAR_115 ; if ( METHOD_28 ( VAR_116 , & VAR_117 , VAR_118 ) == - 1 ) goto VAR_119 ; METHOD_29 ( VAR_120 ) ; VAR_121 = METHOD_30 ( VAR_122 -> VAR_123 . VAR_124 . VAR_125 , METHOD_31 ) ; if ( ! VAR_126 ) goto VAR_127 ; if ( METHOD_32 ( VAR_128 , & VAR_129 , VAR_130 ) == - 1 ) goto VAR_131 ; METHOD_33 ( VAR_132 ) ; VAR_133 = METHOD_34 ( VAR_134 -> VAR_135 . VAR_136 . VAR_137 ) ; if ( ! VAR_138 ) goto VAR_139 ; if ( METHOD_35 ( VAR_140 , & VAR_141 , VAR_142 ) == - 1 ) goto VAR_143 ; METHOD_36 ( VAR_144 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_145 : VAR_146 = METHOD_37 ( VAR_147 , VAR_148 , VAR_149 ) ; if ( ! VAR_150 ) goto VAR_151 ; VAR_152 = METHOD_38 ( VAR_153 -> VAR_154 . VAR_155 . VAR_156 ) ; if ( ! VAR_157 ) goto VAR_158 ; if ( METHOD_39 ( VAR_159 , & VAR_160 , VAR_161 ) == - 1 ) goto VAR_162 ; METHOD_40 ( VAR_163 ) ; VAR_164 = METHOD_41 ( VAR_165 -> VAR_166 . VAR_167 . VAR_168 , METHOD_42 ) ; if ( ! VAR_169 ) goto VAR_170 ; if ( METHOD_43 ( VAR_171 , & VAR_172 , VAR_173 ) == - 1 ) goto VAR_174 ; METHOD_44 ( VAR_175 ) ; VAR_176 = METHOD_45 ( VAR_177 -> VAR_178 . VAR_179 . VAR_180 , VAR_181 ) ; if ( ! VAR_182 ) goto VAR_183 ; if ( METHOD_46 ( VAR_184 , & VAR_185 , VAR_186 ) == - 1 ) goto VAR_187 ; METHOD_47 ( VAR_188 ) ; VAR_189 = METHOD_48 ( VAR_190 -> VAR_191 . VAR_192 . VAR_193 , METHOD_49 ) ; if ( ! VAR_194 ) goto VAR_195 ; if ( METHOD_50 ( VAR_196 , & VAR_197 , VAR_198 ) == - 1 ) goto VAR_199 ; METHOD_51 ( VAR_200 ) ; VAR_201 = METHOD_52 ( VAR_202 -> VAR_203 . VAR_204 . VAR_205 , METHOD_53 ) ; if ( ! VAR_206 ) goto VAR_207 ; if ( METHOD_54 ( VAR_208 , & VAR_209 , VAR_210 ) == - 1 ) goto VAR_211 ; METHOD_55 ( VAR_212 ) ; break ; case VAR_213 : VAR_214 = METHOD_56 ( VAR_215 , VAR_216 , VAR_217 ) ; if ( ! VAR_218 ) goto VAR_219 ; VAR_220 = METHOD_57 ( VAR_221 -> VAR_222 . VAR_223 . VAR_224 ) ; if ( ! VAR_225 ) goto VAR_226 ; if ( METHOD_58 ( VAR_227 , & VAR_228 , VAR_229 ) == - 1 ) goto VAR_230 ; METHOD_59 ( VAR_231 ) ; break ; case VAR_232 : VAR_233 = METHOD_60 ( VAR_234 , VAR_235 , VAR_236 ) ; if ( ! VAR_237 ) goto VAR_238 ; VAR_239 = METHOD_61 ( VAR_240 -> VAR_241 . VAR_242 . VAR_243 , METHOD_62 ) ; if ( ! VAR_244 ) goto VAR_245 ; if ( METHOD_63 ( VAR_246 , & VAR_247 , VAR_248 ) == - 1 ) goto VAR_249 ; METHOD_64 ( VAR_250 ) ; break ; case VAR_251 : VAR_252 = METHOD_65 ( VAR_253 , VAR_254 , VAR_255 ) ; if ( ! VAR_256 ) goto VAR_257 ; VAR_258 = METHOD_66 ( VAR_259 -> VAR_260 . VAR_261 . VAR_262 , METHOD_67 ) ; if ( ! VAR_263 ) goto VAR_264 ; if ( METHOD_68 ( VAR_265 , & VAR_266 , VAR_267 ) == - 1 ) goto VAR_268 ; METHOD_69 ( VAR_269 ) ; VAR_270 = METHOD_70 ( VAR_271 -> VAR_272 . VAR_273 . VAR_274 ) ; if ( ! VAR_275 ) goto VAR_276 ; if ( METHOD_71 ( VAR_277 , & VAR_278 , VAR_279 ) == - 1 ) goto VAR_280 ; METHOD_72 ( VAR_281 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_282 : VAR_283 = METHOD_73 ( VAR_284 , VAR_285 , VAR_286 ) ; if ( ! VAR_287 ) goto VAR_288 ; VAR_289 = METHOD_74 ( VAR_290 -> VAR_291 . VAR_292 . VAR_293 ) ; if ( ! VAR_294 ) goto VAR_295 ; if ( METHOD_75 ( VAR_296 , & VAR_297 , VAR_298 ) == - 1 ) goto VAR_299 ; METHOD_76 ( VAR_300 ) ; VAR_301 = METHOD_77 ( VAR_302 -> VAR_303 . VAR_304 . VAR_305 ) ; if ( ! VAR_306 ) goto VAR_307 ; if ( METHOD_78 ( VAR_308 , & VAR_309 , VAR_310 ) == - 1 ) goto VAR_311 ; METHOD_79 ( VAR_312 ) ; VAR_313 = METHOD_80 ( VAR_314 -> VAR_315 . VAR_316 . VAR_317 ) ; if ( ! VAR_318 ) goto VAR_319 ; if ( METHOD_81 ( VAR_320 , & VAR_321 , VAR_322 ) == - 1 ) goto VAR_323 ; METHOD_82 ( VAR_324 ) ; break ; case VAR_325 : VAR_326 = METHOD_83 ( VAR_327 , VAR_328 , VAR_329 ) ; if ( ! VAR_330 ) goto VAR_331 ; VAR_332 = METHOD_84 ( VAR_333 -> VAR_334 . VAR_335 . VAR_336 ) ; if ( ! VAR_337 ) goto VAR_338 ; if ( METHOD_85 ( VAR_339 , & VAR_340 , VAR_341 ) == - 1 ) goto VAR_342 ; METHOD_86 ( VAR_343 ) ; VAR_344 = METHOD_87 ( VAR_345 -> VAR_346 . VAR_347 . VAR_348 ) ; if ( ! VAR_349 ) goto VAR_350 ; if ( METHOD_88 ( VAR_351 , & VAR_352 , VAR_353 ) == - 1 ) goto VAR_354 ; METHOD_89 ( VAR_355 ) ; VAR_356 = METHOD_90 ( VAR_357 -> VAR_358 . VAR_359 . VAR_360 ) ; if ( ! VAR_361 ) goto VAR_362 ; if ( METHOD_91 ( VAR_363 , & VAR_364 , VAR_365 ) == - 1 ) goto VAR_366 ; METHOD_92 ( VAR_367 ) ; VAR_368 = METHOD_93 ( VAR_369 -> VAR_370 . VAR_371 . VAR_372 ) ; if ( ! VAR_373 ) goto VAR_374 ; if ( METHOD_94 ( VAR_375 , & VAR_376 , VAR_377 ) == - 1 ) goto VAR_378 ; METHOD_95 ( VAR_379 ) ; break ; case VAR_380 : VAR_381 = METHOD_96 ( VAR_382 , VAR_383 , VAR_384 ) ; if ( ! VAR_385 ) goto VAR_386 ; VAR_387 = METHOD_97 ( VAR_388 -> VAR_389 . VAR_390 . VAR_391 ) ; if ( ! VAR_392 ) goto VAR_393 ; if ( METHOD_98 ( VAR_394 , & VAR_395 , VAR_396 ) == - 1 ) goto VAR_397 ; METHOD_99 ( VAR_398 ) ; VAR_399 = METHOD_100 ( VAR_400 -> VAR_401 . VAR_402 . VAR_403 ) ; if ( ! VAR_404 ) goto VAR_405 ; if ( METHOD_101 ( VAR_406 , & VAR_407 , VAR_408 ) == - 1 ) goto VAR_409 ; METHOD_102 ( VAR_410 ) ; VAR_411 = METHOD_103 ( VAR_412 -> VAR_413 . VAR_414 . VAR_415 , METHOD_104 ) ; if ( ! VAR_416 ) goto VAR_417 ; if ( METHOD_105 ( VAR_418 , & VAR_419 , VAR_420 ) == - 1 ) goto VAR_421 ; METHOD_106 ( VAR_422 ) ; VAR_423 = METHOD_107 ( VAR_424 -> VAR_425 . VAR_426 . VAR_427 , METHOD_108 ) ; if ( ! VAR_428 ) goto VAR_429 ; if ( METHOD_109 ( VAR_430 , & VAR_431 , VAR_432 ) == - 1 ) goto VAR_433 ; METHOD_110 ( VAR_434 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_435 : VAR_436 = METHOD_111 ( VAR_437 , VAR_438 , VAR_439 ) ; if ( ! VAR_440 ) goto VAR_441 ; VAR_442 = METHOD_112 ( VAR_443 -> VAR_444 . VAR_445 . VAR_446 ) ; if ( ! VAR_447 ) goto VAR_448 ; if ( METHOD_113 ( VAR_449 , & VAR_450 , VAR_451 ) == - 1 ) goto VAR_452 ; METHOD_114 ( VAR_453 ) ; VAR_454 = METHOD_115 ( VAR_455 -> VAR_456 . VAR_457 . VAR_458 ) ; if ( ! VAR_459 ) goto VAR_460 ; if ( METHOD_116 ( VAR_461 , & VAR_462 , VAR_463 ) == - 1 ) goto VAR_464 ; METHOD_117 ( VAR_465 ) ; VAR_466 = METHOD_118 ( VAR_467 -> VAR_468 . VAR_469 . VAR_470 , METHOD_119 ) ; if ( ! VAR_471 ) goto VAR_472 ; if ( METHOD_120 ( VAR_473 , & VAR_474 , VAR_475 ) == - 1 ) goto VAR_476 ; METHOD_121 ( VAR_477 ) ; VAR_478 = METHOD_122 ( VAR_479 -> VAR_480 . VAR_481 . VAR_482 , METHOD_123 ) ; if ( ! VAR_483 ) goto VAR_484 ; if ( METHOD_124 ( VAR_485 , & VAR_486 , VAR_487 ) == - 1 ) goto VAR_488 ; METHOD_125 ( VAR_489 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_490 : VAR_491 = METHOD_126 ( VAR_492 , VAR_493 , VAR_494 ) ; if ( ! VAR_495 ) goto VAR_496 ; VAR_497 = METHOD_127 ( VAR_498 -> VAR_499 . VAR_500 . VAR_501 ) ; if ( ! VAR_502 ) goto VAR_503 ; if ( METHOD_128 ( VAR_504 , & VAR_505 , VAR_506 ) == - 1 ) goto VAR_507 ; METHOD_129 ( VAR_508 ) ; VAR_509 = METHOD_130 ( VAR_510 -> VAR_511 . VAR_512 . VAR_513 , METHOD_131 ) ; if ( ! VAR_514 ) goto VAR_515 ; if ( METHOD_132 ( VAR_516 , & VAR_517 , VAR_518 ) == - 1 ) goto VAR_519 ; METHOD_133 ( VAR_520 ) ; VAR_521 = METHOD_134 ( VAR_522 -> VAR_523 . VAR_524 . VAR_525 , METHOD_135 ) ; if ( ! VAR_526 ) goto VAR_527 ; if ( METHOD_136 ( VAR_528 , & VAR_529 , VAR_530 ) == - 1 ) goto VAR_531 ; METHOD_137 ( VAR_532 ) ; break ; case VAR_533 : VAR_534 = METHOD_138 ( VAR_535 , VAR_536 , VAR_537 ) ; if ( ! VAR_538 ) goto VAR_539 ; VAR_540 = METHOD_139 ( VAR_541 -> VAR_542 . VAR_543 . VAR_544 ) ; if ( ! VAR_545 ) goto VAR_546 ; if ( METHOD_140 ( VAR_547 , & VAR_548 , VAR_549 ) == - 1 ) goto VAR_550 ; METHOD_141 ( VAR_551 ) ; VAR_552 = METHOD_142 ( VAR_553 -> VAR_554 . VAR_555 . VAR_556 , METHOD_143 ) ; if ( ! VAR_557 ) goto VAR_558 ; if ( METHOD_144 ( VAR_559 , & VAR_560 , VAR_561 ) == - 1 ) goto VAR_562 ; METHOD_145 ( VAR_563 ) ; VAR_564 = METHOD_146 ( VAR_565 -> VAR_566 . VAR_567 . VAR_568 , METHOD_147 ) ; if ( ! VAR_569 ) goto VAR_570 ; if ( METHOD_148 ( VAR_571 , & VAR_572 , VAR_573 ) == - 1 ) goto VAR_574 ; METHOD_149 ( VAR_575 ) ; break ; case VAR_576 : VAR_577 = METHOD_150 ( VAR_578 , VAR_579 , VAR_580 ) ; if ( ! VAR_581 ) goto VAR_582 ; VAR_583 = METHOD_151 ( VAR_584 -> VAR_585 . VAR_586 . VAR_587 , VAR_588 ) ; if ( ! VAR_589 ) goto VAR_590 ; if ( METHOD_152 ( VAR_591 , & VAR_592 , VAR_593 ) == - 1 ) goto VAR_594 ; METHOD_153 ( VAR_595 ) ; VAR_596 = METHOD_154 ( VAR_597 -> VAR_598 . VAR_599 . VAR_600 , METHOD_155 ) ; if ( ! VAR_601 ) goto VAR_602 ; if ( METHOD_156 ( VAR_603 , & VAR_604 , VAR_605 ) == - 1 ) goto VAR_606 ; METHOD_157 ( VAR_607 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_608 : VAR_609 = METHOD_158 ( VAR_610 , VAR_611 , VAR_612 ) ; if ( ! VAR_613 ) goto VAR_614 ; VAR_615 = METHOD_159 ( VAR_616 -> VAR_617 . VAR_618 . VAR_619 , VAR_620 ) ; if ( ! VAR_621 ) goto VAR_622 ; if ( METHOD_160 ( VAR_623 , & VAR_624 , VAR_625 ) == - 1 ) goto VAR_626 ; METHOD_161 ( VAR_627 ) ; VAR_628 = METHOD_162 ( VAR_629 -> VAR_630 . VAR_631 . VAR_632 , METHOD_163 ) ; if ( ! VAR_633 ) goto VAR_634 ; if ( METHOD_164 ( VAR_635 , & VAR_636 , VAR_637 ) == - 1 ) goto VAR_638 ; METHOD_165 ( VAR_639 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_640 : VAR_641 = METHOD_166 ( VAR_642 , VAR_643 , VAR_644 ) ; if ( ! VAR_645 ) goto VAR_646 ; VAR_647 = METHOD_167 ( VAR_648 -> VAR_649 . VAR_650 . VAR_651 ) ; if ( ! VAR_652 ) goto VAR_653 ; if ( METHOD_168 ( VAR_654 , & VAR_655 , VAR_656 ) == - 1 ) goto VAR_657 ; METHOD_169 ( VAR_658 ) ; VAR_659 = METHOD_170 ( VAR_660 -> VAR_661 . VAR_662 . VAR_663 ) ; if ( ! VAR_664 ) goto VAR_665 ; if ( METHOD_171 ( VAR_666 , & VAR_667 , VAR_668 ) == - 1 ) goto VAR_669 ; METHOD_172 ( VAR_670 ) ; break ; case VAR_671 : VAR_672 = METHOD_173 ( VAR_673 , VAR_674 , VAR_675 ) ; if ( ! VAR_676 ) goto VAR_677 ; VAR_678 = METHOD_174 ( VAR_679 -> VAR_680 . VAR_681 . VAR_682 , METHOD_175 ) ; if ( ! VAR_683 ) goto VAR_684 ; if ( METHOD_176 ( VAR_685 , & VAR_686 , VAR_687 ) == - 1 ) goto VAR_688 ; METHOD_177 ( VAR_689 ) ; VAR_690 = METHOD_178 ( VAR_691 -> VAR_692 . VAR_693 . VAR_694 , VAR_695 ) ; if ( ! VAR_696 ) goto VAR_697 ; if ( METHOD_179 ( VAR_698 , & VAR_699 , VAR_700 ) == - 1 ) goto VAR_701 ; METHOD_180 ( VAR_702 ) ; VAR_703 = METHOD_181 ( VAR_704 -> VAR_705 . VAR_706 . VAR_707 , METHOD_182 ) ; if ( ! VAR_708 ) goto VAR_709 ; if ( METHOD_183 ( VAR_710 , & VAR_711 , VAR_712 ) == - 1 ) goto VAR_713 ; METHOD_184 ( VAR_714 ) ; VAR_715 = METHOD_185 ( VAR_716 -> VAR_717 . VAR_718 . VAR_719 , METHOD_186 ) ; if ( ! VAR_720 ) goto VAR_721 ; if ( METHOD_187 ( VAR_722 , & VAR_723 , VAR_724 ) == - 1 ) goto VAR_725 ; METHOD_188 ( VAR_726 ) ; break ; case VAR_727 : VAR_728 = METHOD_189 ( VAR_729 , VAR_730 , VAR_731 ) ; if ( ! VAR_732 ) goto VAR_733 ; VAR_734 = METHOD_190 ( VAR_735 -> VAR_736 . VAR_737 . VAR_738 ) ; if ( ! VAR_739 ) goto VAR_740 ; if ( METHOD_191 ( VAR_741 , & VAR_742 , VAR_743 ) == - 1 ) goto VAR_744 ; METHOD_192 ( VAR_745 ) ; VAR_746 = METHOD_193 ( VAR_747 -> VAR_748 . VAR_749 . VAR_750 ) ; if ( ! VAR_751 ) goto VAR_752 ; if ( METHOD_194 ( VAR_753 , & VAR_754 , VAR_755 ) == - 1 ) goto VAR_756 ; METHOD_195 ( VAR_757 ) ; break ; case VAR_758 : VAR_759 = METHOD_196 ( VAR_760 , VAR_761 , VAR_762 ) ; if ( ! VAR_763 ) goto VAR_764 ; VAR_765 = METHOD_197 ( VAR_766 -> VAR_767 . VAR_768 . VAR_769 , VAR_770 ) ; if ( ! VAR_771 ) goto VAR_772 ; if ( METHOD_198 ( VAR_773 , & VAR_774 , VAR_775 ) == - 1 ) goto VAR_776 ; METHOD_199 ( VAR_777 ) ; break ; case VAR_778 : VAR_779 = METHOD_200 ( VAR_780 , VAR_781 , VAR_782 ) ; if ( ! VAR_783 ) goto VAR_784 ; VAR_785 = METHOD_201 ( VAR_786 -> VAR_787 . VAR_788 . VAR_789 ) ; if ( ! VAR_790 ) goto VAR_791 ; if ( METHOD_202 ( VAR_792 , & VAR_793 , VAR_794 ) == - 1 ) goto VAR_795 ; METHOD_203 ( VAR_796 ) ; VAR_797 = METHOD_204 ( VAR_798 -> VAR_799 . VAR_800 . VAR_801 , VAR_802 ) ; if ( ! VAR_803 ) goto VAR_804 ; if ( METHOD_205 ( VAR_805 , & VAR_806 , VAR_807 ) == - 1 ) goto VAR_808 ; METHOD_206 ( VAR_809 ) ; VAR_810 = METHOD_207 ( VAR_811 -> VAR_812 . VAR_813 . VAR_814 ) ; if ( ! VAR_815 ) goto VAR_816 ; if ( METHOD_208 ( VAR_817 , & VAR_818 , VAR_819 ) == - 1 ) goto VAR_820 ; METHOD_209 ( VAR_821 ) ; break ; case VAR_822 : VAR_823 = METHOD_210 ( VAR_824 , VAR_825 , VAR_826 ) ; if ( ! VAR_827 ) goto VAR_828 ; VAR_829 = METHOD_211 ( VAR_830 -> VAR_831 . VAR_832 . VAR_833 , METHOD_212 ) ; if ( ! VAR_834 ) goto VAR_835 ; if ( METHOD_213 ( VAR_836 , & VAR_837 , VAR_838 ) == - 1 ) goto VAR_839 ; METHOD_214 ( VAR_840 ) ; break ; case VAR_841 : VAR_842 = METHOD_215 ( VAR_843 , VAR_844 , VAR_845 ) ; if ( ! VAR_846 ) goto VAR_847 ; VAR_848 = METHOD_216 ( VAR_849 -> VAR_850 . VAR_851 . VAR_852 , METHOD_217 ) ; if ( ! VAR_853 ) goto VAR_854 ; if ( METHOD_218 ( VAR_855 , & VAR_856 , VAR_857 ) == - 1 ) goto VAR_858 ; METHOD_219 ( VAR_859 ) ; break ; case VAR_860 : VAR_861 = METHOD_220 ( VAR_862 , VAR_863 , VAR_864 ) ; if ( ! VAR_865 ) goto VAR_866 ; VAR_867 = METHOD_221 ( VAR_868 -> VAR_869 . VAR_870 . VAR_871 ) ; if ( ! VAR_872 ) goto VAR_873 ; if ( METHOD_222 ( VAR_874 , & VAR_875 , VAR_876 ) == - 1 ) goto VAR_877 ; METHOD_223 ( VAR_878 ) ; break ; case VAR_879 : VAR_880 = METHOD_224 ( VAR_881 , VAR_882 , VAR_883 ) ; if ( ! VAR_884 ) goto VAR_885 ; break ; case VAR_886 : VAR_887 = METHOD_225 ( VAR_888 , VAR_889 , VAR_890 ) ; if ( ! VAR_891 ) goto VAR_892 ; break ; case VAR_893 : VAR_894 = METHOD_226 ( VAR_895 , VAR_896 , VAR_897 ) ; if ( ! VAR_898 ) goto VAR_899 ; break ; } VAR_900 = METHOD_227 ( VAR_901 -> VAR_902 ) ; if ( ! VAR_903 ) goto VAR_904 ; if ( METHOD_228 ( VAR_905 , & VAR_906 , VAR_907 ) < 0 ) goto VAR_908 ; METHOD_229 ( VAR_909 ) ; VAR_910 = METHOD_230 ( VAR_911 -> VAR_912 ) ; if ( ! VAR_913 ) goto VAR_914 ; if ( METHOD_231 ( VAR_915 , & VAR_916 , VAR_917 ) < 0 ) goto VAR_918 ; METHOD_232 ( VAR_919 ) ; VAR_920 = METHOD_233 ( VAR_921 -> VAR_922 ) ; if ( ! VAR_923 ) goto VAR_924 ; if ( METHOD_234 ( VAR_925 , & VAR_926 , VAR_927 ) < 0 ) goto VAR_928 ; METHOD_235 ( VAR_929 ) ; VAR_930 = METHOD_236 ( VAR_931 -> VAR_932 ) ; if ( ! VAR_933 ) goto VAR_934 ; if ( METHOD_237 ( VAR_935 , & VAR_936 , VAR_937 ) < 0 ) goto VAR_938 ; METHOD_238 ( VAR_939 ) ; return VAR_940 ; VAR_941 : METHOD_239 ( VAR_942 ) ; METHOD_240 ( VAR_943 ) ; return VAR_944 ; }","<S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_69 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ; <S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_136 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ; <S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_273 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ; <S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_426 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ; <S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_481 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ; <S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_599 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ; <S2SV_ModStart> VAR_942 ) ; VAR_942 = METHOD_241 ( VAR_931 -> VAR_869 . VAR_631 . VAR_945 ) ; if ( ! VAR_942 ) goto VAR_941 ; if ( METHOD_237 ( VAR_943 , & VAR_946 , VAR_942 ) == - 1 ) goto VAR_941 ; METHOD_238 ( VAR_942 ) ;","CWE-125 PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }","<S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ;"
174,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * VAR_5 , TYPE_7 VAR_6 , TYPE_8 VAR_7 ) { TYPE_9 * VAR_8 ; TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; if ( VAR_11 != 0 ) { * VAR_12 = ( TYPE_12 ) VAR_13 ; return VAR_14 ; } VAR_15 = ( TYPE_13 * ) VAR_16 ; <S2SV_StartBug> if ( ! VAR_17 -> VAR_18 ) { <S2SV_EndBug> * VAR_19 = VAR_20 ; return VAR_21 ; } if ( VAR_22 && METHOD_1 ( VAR_23 , VAR_24 ) ) { VAR_25 = VAR_26 ; } VAR_27 = VAR_28 -> VAR_29 ; switch ( VAR_30 -> VAR_31 ) { case 0 : VAR_32 = METHOD_2 ( VAR_33 , VAR_34 , VAR_35 , VAR_36 , VAR_37 , VAR_38 , VAR_39 ) ; break ; case 1 : VAR_40 = METHOD_3 ( VAR_41 , VAR_42 , VAR_43 , VAR_44 , VAR_45 , VAR_46 , VAR_47 ) ; break ; default : VAR_48 = VAR_49 ; break ; } if ( VAR_50 != 0 ) { * VAR_51 = VAR_52 ; METHOD_4 ( * VAR_53 , VAR_54 ) ; return VAR_55 ; } * VAR_56 = 0 ; return VAR_57 ; }",<S2SV_ModStart> ; if ( VAR_42 -> VAR_58 ||,"CWE-000 OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }",<S2SV_ModStart> ; if ( ctx -> terminated ||
175,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 * VAR_3 = VAR_4 ; TYPE_5 VAR_5 ; TYPE_6 VAR_6 ; <S2SV_StartBug> if ( METHOD_1 ( VAR_7 , & VAR_8 ) ) { <S2SV_EndBug> TYPE_7 TYPE_8 ; <S2SV_StartBug> VAR_9 = METHOD_2 ( VAR_10 , & VAR_11 ) ; <S2SV_EndBug> if ( VAR_12 == VAR_13 ) goto VAR_14 ; <S2SV_StartBug> TYPE_9 = METHOD_3 ( VAR_15 , & VAR_16 , VAR_17 ) ; <S2SV_EndBug> if ( TYPE_10 != 0 ) goto VAR_18 ; METHOD_4 ( VAR_19 ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( VAR_20 , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } if ( METHOD_5 ( VAR_21 , & VAR_22 ) ) { TYPE_11 TYPE_12 ; VAR_23 = METHOD_6 ( VAR_24 , & VAR_25 ) ; if ( VAR_26 == VAR_27 ) goto VAR_28 ; TYPE_13 = METHOD_7 ( VAR_29 , & VAR_30 , VAR_31 ) ; if ( TYPE_14 != 0 ) goto VAR_32 ; METHOD_8 ( VAR_33 ) ; } else { VAR_34 = VAR_35 ; } * VAR_36 = METHOD_9 ( VAR_37 , VAR_38 , VAR_39 ) ; return 0 ; VAR_40 : METHOD_10 ( VAR_41 ) ; return 1 ; }","<S2SV_ModStart> ; if ( METHOD_11 <S2SV_ModEnd> ( VAR_24 , <S2SV_ModStart> , & VAR_11 , & VAR_41 ) < 0 ) { return 1 ; } if ( VAR_41 == VAR_35 ) { PyErr_SetString ( VAR_20 , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } else <S2SV_ModEnd> { TYPE_11 TYPE_14 <S2SV_ModStart> TYPE_11 TYPE_14 ; TYPE_14 = METHOD_7 ( VAR_41 , & VAR_37 , VAR_39 ) ; if ( TYPE_14 != 0 <S2SV_ModEnd> ) goto VAR_40 <S2SV_ModStart> goto VAR_40 ; METHOD_8 ( VAR_41 ) ; } if ( METHOD_11 ( VAR_24 , & VAR_25 , & VAR_41 ) < 0 ) { return 1 ; } if ( VAR_41 == VAR_35 || VAR_41 == VAR_42 ) { METHOD_8 ( VAR_41 ) ; VAR_38 = VAR_35 ; } else { TYPE_11 TYPE_14 ; <S2SV_ModStart> VAR_41 , & VAR_38 <S2SV_ModEnd> , VAR_39 ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * VAR_36 =","CWE-125 int obj2ast_withitem ( PyObject * obj , withitem_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty context_expr ; expr_ty optional_vars ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & context_expr , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_optional_vars ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_optional_vars ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & optional_vars , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { optional_vars = NULL ; } * out = withitem ( context_expr , optional_vars , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_context_expr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & context_expr , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; optional_vars = NULL ; } else { int res ; <S2SV_ModStart> tmp , & optional_vars <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out ="
176,"CWE-125 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 = ( TYPE_3 ) VAR_2 ; TYPE_4 * VAR_3 = VAR_4 , * VAR_5 = VAR_6 ; if ( ! VAR_7 ) { <S2SV_StartBug> METHOD_1 ( VAR_8 ) ; <S2SV_EndBug> return VAR_9 ; } VAR_10 = METHOD_2 ( VAR_11 , VAR_12 , VAR_13 ) ; if ( ! VAR_14 ) return VAR_15 ; VAR_16 = METHOD_3 ( VAR_17 -> VAR_18 ) ; if ( ! VAR_19 ) goto VAR_20 ; if ( METHOD_4 ( VAR_21 , & VAR_22 , VAR_23 ) == - 1 ) goto VAR_24 ; METHOD_5 ( VAR_25 ) ; VAR_26 = METHOD_6 ( VAR_27 -> VAR_28 ) ; if ( ! VAR_29 ) goto VAR_30 ; if ( METHOD_7 ( VAR_31 , & VAR_32 , VAR_33 ) == - 1 ) goto VAR_34 ; METHOD_8 ( VAR_35 ) ; return VAR_36 ; VAR_37 : METHOD_9 ( VAR_38 ) ; METHOD_10 ( VAR_39 ) ; return VAR_40 ; }",<S2SV_ModStart> VAR_27 ) { VAR_41 <S2SV_ModEnd> ; } VAR_39,"CWE-125 PyObject * ast2obj_keyword ( void * _o ) { keyword_ty o = ( keyword_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( keyword_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
177,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , <S2SV_EndBug> TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 * VAR_3 = va_arg ( VAR_4 , TYPE_5 * ) ; if ( VAR_5 ) { TYPE_6 * VAR_6 = ( TYPE_7 * ) VAR_7 ; if ( ! METHOD_1 ( VAR_8 -> VAR_9 , VAR_10 -> VAR_11 , VAR_12 -> VAR_13 , VAR_14 -> VAR_15 ) ) return VAR_16 ; else return VAR_17 ; } else return VAR_18 ; }","<S2SV_ModStart> TYPE_1 * VAR_8 <S2SV_ModEnd> , TYPE_3 VAR_4","CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_active_map_t * data = va_arg ( args , vpx_active_map_t * ) ; if ( data ) { vpx_active_map_t * map = ( vpx_active_map_t * ) data ; if ( ! vp8_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args"
178,"CWE-74 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { if ( METHOD_1 ( VAR_1 -> VAR_2 ) < 0 ) return - 1 ; VAR_3 -> VAR_4 = VAR_5 ; if ( METHOD_2 ( VAR_6 ) != VAR_7 ) { METHOD_3 ( VAR_8 ) ; return - 1 ; } if ( METHOD_4 ( VAR_9 -> VAR_10 , ""*<S2SV_blank>OK"" , VAR_11 ) ) { if ( ! METHOD_5 ( VAR_12 -> VAR_13 , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , VAR_14 ) && METHOD_6 ( VAR_15 ) ) { goto VAR_16 ; } TYPE_1 TYPE_2 if ( ! VAR_17 -> VAR_18 -> VAR_19 && ( VAR_20 || ( VAR_21 -> VAR_22 & VAR_23 ) ) ) { enum VAR_24 VAR_25 ; if ( VAR_26 ) VAR_27 = VAR_28 ; else if ( ( VAR_29 = METHOD_7 ( VAR_30 , METHOD_8 ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == VAR_31 ) { goto VAR_32 ; } if ( VAR_33 == VAR_34 ) { <S2SV_StartBug> enum VAR_35 VAR_36 = METHOD_9 ( VAR_37 , ""STARTTLS"" , VAR_38 ) ; <S2SV_EndBug> if ( VAR_39 == VAR_40 ) goto VAR_41 ; if ( VAR_42 != VAR_43 ) { if ( METHOD_10 ( VAR_44 -> VAR_45 ) ) { METHOD_11 ( METHOD_12 ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; goto VAR_46 ; } else { if ( METHOD_13 ( VAR_47 , ""CAPABILITY"" , VAR_48 ) ) goto VAR_49 ; } } } } if ( VAR_50 && ! VAR_51 -> VAR_52 -> VAR_53 ) { METHOD_14 ( METHOD_15 ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto VAR_54 ; } } else if ( METHOD_16 ( VAR_55 -> VAR_56 , ""*<S2SV_blank>PREAUTH"" , VAR_57 ) ) { TYPE_3 TYPE_4 if ( VAR_58 -> VAR_59 -> VAR_60 == 0 ) { TYPE_5 VAR_61 = VAR_62 ; if ( VAR_63 ) { VAR_64 = VAR_65 ; } else if ( VAR_66 != VAR_67 ) { VAR_68 = METHOD_17 ( METHOD_18 ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) , VAR_69 ) != VAR_70 ; } if ( ! VAR_71 ) { METHOD_19 ( METHOD_20 ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto VAR_72 ; } } VAR_73 -> VAR_74 = VAR_75 ; if ( METHOD_21 ( VAR_76 ) != 0 ) goto VAR_77 ; METHOD_22 ( & VAR_78 -> VAR_79 ) ; } else { METHOD_23 ( ""imap_open_connection()"" , VAR_80 -> VAR_81 ) ; goto VAR_82 ; } return 0 ; TYPE_6 TYPE_7 VAR_83 : METHOD_24 ( VAR_84 ) ; VAR_85 : METHOD_25 ( & VAR_86 -> VAR_87 ) ; return - 1 ; }","<S2SV_ModStart> , ""STARTTLS"" , VAR_88 ) ; METHOD_26 ( VAR_86 -> VAR_59 <S2SV_ModEnd> ) ; if","CWE-74 int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>OK"" , CASE_IGNORE ) ) { if ( ! mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , CASE_IGNORE ) && check_capabilities ( adata ) ) { goto bail ; }  ifdef USE_SSL if ( ! adata -> conn -> ssf && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { <S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto err_close_conn ; }   } else if ( mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>PREAUTH"" , CASE_IGNORE ) ) {  ifdef USE_SSL if ( adata -> conn -> ssf == 0 ) { bool proceed = true ; if ( C_SslForceTls ) { proceed = false ; } else if ( C_SslStarttls != MUTT_NO ) { proceed = mutt_yesorno ( _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) , C_SslStarttls ) != MUTT_NO ; } if ( ! proceed ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto err_close_conn ; } }   adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ;  ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ;   bail : FREE ( & adata -> capstr ) ; return - 1 ; }","<S2SV_ModStart> , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> ) ; if"
179,"CWE-59 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , const TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 ; if ( VAR_5 ) { METHOD_1 ( VAR_6 ) ; VAR_7 = VAR_8 ; } if ( ! VAR_9 ) return ; VAR_10 = METHOD_2 ( VAR_11 , VAR_12 , VAR_13 , VAR_14 ) ; <S2SV_StartBug> VAR_15 = METHOD_3 ( VAR_16 , ""a"" ) ; <S2SV_EndBug> if ( VAR_17 ) { TYPE_6 VAR_18 = METHOD_4 ( VAR_19 ) ; METHOD_5 ( VAR_20 , VAR_21 , VAR_22 | METHOD_6 ( VAR_23 , VAR_24 ) ) ; METHOD_7 ( VAR_25 , VAR_26 , VAR_27 | METHOD_8 ( VAR_28 , VAR_29 ) ) ; } METHOD_9 ( VAR_30 ) ; }","<S2SV_ModStart> ; VAR_19 = METHOD_10 <S2SV_ModEnd> ( VAR_30 ,","CWE-59 void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; <S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }","<S2SV_ModStart> ; log_file = fopen_safe <S2SV_ModEnd> ( file_name ,"
180,"CWE-20 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { TYPE_1 VAR_2 = METHOD_1 ( VAR_3 -> VAR_4 ) ; TYPE_2 VAR_5 = VAR_6 + METHOD_2 ( VAR_7 -> VAR_8 ) - 1 ; unsigned TYPE_3 VAR_9 , VAR_10 ; struct STRUCT_OR_UNION_2 VAR_11 ; TYPE_4 VAR_12 = 0 ; if ( VAR_13 >= METHOD_3 ( VAR_14 ) || VAR_15 -> VAR_16 < VAR_17 -> VAR_18 ) return - VAR_19 ; VAR_20 . VAR_21 = 0 ; if ( VAR_22 <= METHOD_4 ( VAR_23 ) ) goto VAR_24 ; if ( METHOD_5 ( VAR_25 , VAR_26 ) ) { METHOD_6 ( VAR_27 -> VAR_28 , VAR_29 , ""Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix."" ) ; goto VAR_30 ; } VAR_31 = ( VAR_32 <= METHOD_7 ( VAR_33 ) ) ? 0 : METHOD_8 ( VAR_34 , VAR_35 ) ; VAR_36 = ( VAR_37 >= METHOD_9 ( VAR_38 ) ) ? METHOD_10 ( VAR_39 ) - 1 : METHOD_11 ( VAR_40 , VAR_41 ) ; VAR_42 . VAR_43 = VAR_44 ; VAR_45 . VAR_46 = METHOD_12 ( TYPE_5 , 1 , METHOD_13 ( VAR_47 -> VAR_48 ) ) ; for ( ; VAR_49 <= VAR_50 ; VAR_51 = VAR_52 . VAR_53 + 1 ) { VAR_54 . VAR_55 = VAR_56 ; if ( VAR_57 -> VAR_58 == 0 ) break ; else if ( VAR_59 -> VAR_60 < METHOD_14 ( VAR_61 ) ) VAR_62 . VAR_63 = VAR_64 ; else VAR_65 . VAR_66 = min_t ( unsigned TYPE_6 , VAR_67 ( VAR_68 + METHOD_15 ( VAR_69 ) , VAR_70 -> VAR_71 ) - 1 , VAR_72 ) ; METHOD_16 ( & VAR_73 -> VAR_74 ) ; VAR_75 = METHOD_17 ( VAR_76 , & VAR_77 ) ; METHOD_18 ( & VAR_78 -> VAR_79 ) ; if ( VAR_80 ) break ; METHOD_19 ( ) ; } METHOD_20 ( VAR_81 ) ; <S2SV_StartBug> METHOD_21 ( VAR_82 ) ; <S2SV_EndBug> VAR_83 : VAR_84 -> VAR_85 = METHOD_22 ( VAR_86 . VAR_87 ) ; return VAR_88 ; }","<S2SV_ModStart> METHOD_21 ( VAR_82 , VAR_89","CWE-20 int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) { __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; unsigned int start_segno , end_segno ; struct cp_control cpc ; int err = 0 ; if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) return - EINVAL ; cpc . trimmed = 0 ; if ( end <= MAIN_BLKADDR ( sbi ) ) goto out ; if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { f2fs_msg ( sbi -> sb , KERN_WARNING , ""Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix."" ) ; goto out ; } start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : GET_SEGNO ( sbi , end ) ; cpc . reason = CP_DISCARD ; cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { cpc . trim_start = start_segno ; if ( sbi -> discard_blks == 0 ) break ; else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) cpc . trim_end = end_segno ; else cpc . trim_end = min_t ( unsigned int , rounddown ( start_segno + BATCHED_TRIM_SEGMENTS ( sbi ) , sbi -> segs_per_sec ) - 1 , end_segno ) ; mutex_lock ( & sbi -> gc_mutex ) ; err = write_checkpoint ( sbi , & cpc ) ; mutex_unlock ( & sbi -> gc_mutex ) ; if ( err ) break ; schedule ( ) ; } mark_discard_range_all ( sbi ) ; <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ; }","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , false"
181,"CWE-674 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { VAR_1 * VAR_2 ; const TYPE_2 * VAR_3 ; <S2SV_StartBug> TYPE_3 VAR_4 ; <S2SV_EndBug> TYPE_4 VAR_5 ; VAR_6 = METHOD_1 ( VAR_7 , 0 ) ; VAR_8 = METHOD_2 ( VAR_9 , 1 ) ; VAR_10 = 0 ; if ( VAR_11 -> VAR_12 & VAR_13 ) { if ( VAR_14 -> VAR_15 > METHOD_3 ( VAR_16 ) ) { VAR_17 -> VAR_18 = 0 ; METHOD_4 ( VAR_19 , 0 ) ; return ; } if ( VAR_20 -> VAR_21 > 0 ) { VAR_22 += VAR_23 -> VAR_24 ; VAR_25 |= VAR_26 ; } } <S2SV_StartBug> if ( ! METHOD_5 ( VAR_27 -> VAR_28 , VAR_29 , & VAR_30 , VAR_31 ) ) { <S2SV_EndBug> if ( VAR_32 -> VAR_33 & VAR_34 ) VAR_35 -> VAR_36 = VAR_37 -> VAR_38 + ( VAR_39 . VAR_40 [ 0 ] . VAR_41 - VAR_42 ) ; METHOD_6 ( VAR_43 , 1 ) ; return ; } if ( VAR_44 -> VAR_45 & VAR_46 ) VAR_47 -> VAR_48 = 0 ; METHOD_7 ( VAR_49 , 0 ) ; }","<S2SV_ModStart> VAR_42 ; TYPE_3 VAR_50 ; TYPE_3 <S2SV_ModStart> ; } } VAR_50 = <S2SV_ModEnd> METHOD_5 ( VAR_47 <S2SV_ModStart> , VAR_31 ) ; if ( VAR_50 < 0 ) METHOD_8 ( VAR_49 , ""regexec<S2SV_blank>failed"" ) ; if ( VAR_50 == 0","CWE-674 static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }","<S2SV_ModStart> text ; int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0"
182,"CWE-787 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) <S2SV_EndBug> { TYPE_5 * VAR_4 = ( TYPE_6 * ) VAR_5 ; <S2SV_StartBug> if ( VAR_6 == VAR_7 ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_8 -> VAR_9 == 0 || VAR_10 -> VAR_11 == 0 || VAR_12 -> VAR_13 == 0 || VAR_14 == VAR_15 || VAR_16 == VAR_17 ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * VAR_18 = ( TYPE_7 ) ( ( TYPE_8 ) VAR_19 * ( TYPE_9 ) VAR_20 -> VAR_21 / ( TYPE_10 ) VAR_22 -> VAR_23 ) ; <S2SV_EndBug> <S2SV_StartBug> * VAR_24 = ( TYPE_11 ) ( ( TYPE_12 ) ( VAR_25 + 1 ) * ( TYPE_13 ) VAR_26 -> VAR_27 / ( TYPE_14 ) VAR_28 -> VAR_29 ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","<S2SV_ModStart> TYPE_2 VAR_25 , TYPE_14 <S2SV_ModEnd> * VAR_18 , <S2SV_ModStart> * VAR_18 , TYPE_14 <S2SV_ModEnd> * VAR_24 ) <S2SV_ModStart> VAR_17 ) return VAR_30 <S2SV_ModEnd> ; if ( <S2SV_ModStart> VAR_17 ) return VAR_30 <S2SV_ModEnd> ; * VAR_18 <S2SV_ModStart> * VAR_18 = <S2SV_ModEnd> ( ( TYPE_14 <S2SV_ModStart> * VAR_24 = <S2SV_ModEnd> ( ( TYPE_14 <S2SV_ModStart> ) ; return VAR_31 <S2SV_ModEnd> ; } <S2SV_null>","CWE-787 <S2SV_StartBug> uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out ) <S2SV_EndBug> { mp4object * mp4 = ( mp4object * ) handle ; <S2SV_StartBug> if ( mp4 == NULL ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> * out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","<S2SV_ModStart> uint32_t index , double <S2SV_ModEnd> * in , <S2SV_ModStart> * in , double <S2SV_ModEnd> * out ) <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; if ( <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; * in <S2SV_ModStart> * in = <S2SV_ModEnd> ( ( double <S2SV_ModStart> * out = <S2SV_ModEnd> ( ( double <S2SV_ModStart> ) ; return GPMF_OK <S2SV_ModEnd> ; } <S2SV_null>"
183,"CWE-190 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 ; while ( VAR_5 ) { <S2SV_StartBug> TYPE_6 VAR_6 ; <S2SV_EndBug> VAR_7 = ( TYPE_7 * ) VAR_8 ; VAR_9 -= 4 ; VAR_10 = METHOD_1 ( VAR_11 -> VAR_12 ) ; if ( VAR_13 == VAR_14 ) { METHOD_2 ( VAR_15 ) ; METHOD_3 ( VAR_16 ) ; } else { METHOD_4 ( VAR_17 , VAR_18 , VAR_19 ) ; } VAR_20 = VAR_21 + 4 ; if ( VAR_22 < 4 ) { METHOD_5 ( ""Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n"" , VAR_23 ) ; VAR_24 = 0 ; } } }","<S2SV_ModStart> TYPE_6 VAR_19 ; if ( VAR_24 < 4 ) { METHOD_7 ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , VAR_18 -> VAR_25 . VAR_19 , VAR_26 , VAR_27 , METHOD_6 ( VAR_28 ) ) ; VAR_24 = 0 ; continue ; }","CWE-190 static void Process_ipfix_template_withdraw ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { ipfix_template_record_t * ipfix_template_record ; while ( size_left ) { <S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; id = ntohs ( ipfix_template_record -> TemplateID ) ; if ( id == IPFIX_TEMPLATE_FLOWSET_ID ) { remove_all_translation_tables ( exporter ) ; ReInitExtensionMapList ( fs ) ; } else { remove_translation_table ( fs , exporter , id ) ; } DataPtr = DataPtr + 4 ; if ( size_left < 4 ) { dbg_printf ( ""Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n"" , size_left ) ; size_left = 0 ; } } }","<S2SV_ModStart> uint32_t id ; if ( size_left < 4 ) { LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }"
184,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 VAR_2 ; VAR_3 = METHOD_1 ( VAR_4 -> VAR_5 , VAR_6 ) ; if ( VAR_7 ) return VAR_8 ; VAR_9 = METHOD_2 ( VAR_10 , VAR_11 -> VAR_12 , VAR_13 - 1 , & VAR_14 , VAR_15 ) ; if ( VAR_16 ) return VAR_17 ; VAR_18 = METHOD_3 ( VAR_19 -> VAR_20 , VAR_21 ) ; if ( VAR_22 ) return VAR_23 ; VAR_24 -> VAR_25 [ VAR_26 ] = '\\0' ; METHOD_4 ( ""%s"" , VAR_27 -> VAR_28 ) ; VAR_29 = METHOD_5 ( VAR_30 , VAR_31 -> VAR_32 ) ; if ( VAR_33 ) return VAR_34 ; VAR_35 -> VAR_36 . VAR_37 = VAR_38 ; VAR_39 -> VAR_40 . VAR_41 = 0 ; if ( VAR_42 == VAR_43 ) VAR_44 -> VAR_45 . VAR_46 = VAR_47 ; VAR_48 -> VAR_49 . VAR_50 = VAR_51 ; METHOD_6 ( VAR_52 -> VAR_53 . VAR_54 , """" ) ; if ( VAR_55 -> VAR_56 . VAR_57 >= VAR_58 ) { TYPE_4 VAR_59 ; TYPE_5 * VAR_60 ; TYPE_6 * VAR_61 ; TYPE_7 * VAR_62 ; VAR_63 = '\\0' ; while ( 1 ) { VAR_64 = METHOD_7 ( VAR_65 , VAR_66 -> VAR_67 , VAR_68 , & VAR_69 ) ; if ( VAR_70 ) return VAR_71 ; METHOD_8 ( ""%s"" , VAR_72 -> VAR_73 ) ; if ( ! METHOD_9 ( VAR_74 -> VAR_75 , ""\\r\\n"" ) ) break ; <S2SV_StartBug> VAR_76 = METHOD_10 ( VAR_77 -> VAR_78 , ':' ) ; <S2SV_EndBug> if ( VAR_79 != VAR_80 ) { * VAR_81 = '\\0' ; VAR_82 = METHOD_11 ( VAR_83 -> VAR_84 ) ; VAR_85 = METHOD_12 ( VAR_86 + 1 ) ; METHOD_13 ( VAR_87 , VAR_88 , VAR_89 ) ; } } } if ( VAR_90 -> VAR_91 . VAR_92 ) { VAR_93 -> VAR_94 . VAR_95 = 0 ; VAR_96 -> VAR_97 . VAR_98 = VAR_99 ; VAR_100 -> VAR_101 . VAR_102 = VAR_103 ; } else { VAR_104 -> VAR_105 . VAR_106 = VAR_107 -> VAR_108 . VAR_109 ; } return VAR_110 ; }",<S2SV_ModStart> ; VAR_86 = METHOD_14 <S2SV_ModEnd> ( VAR_107 ->,"CWE-20 error_t httpReadRequestHeader ( HttpConnection * connection ) { error_t error ; size_t length ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_IDLE_TIMEOUT ) ; if ( error ) return error ; error = httpReceive ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE - 1 , & length , SOCKET_FLAG_BREAK_CRLF ) ; if ( error ) return error ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_TIMEOUT ) ; if ( error ) return error ; connection -> buffer [ length ] = '\\0' ; TRACE_INFO ( ""%s"" , connection -> buffer ) ; error = httpParseRequestLine ( connection , connection -> buffer ) ; if ( error ) return error ; connection -> request . chunkedEncoding = FALSE ; connection -> request . contentLength = 0 ;  if ( HTTP_SERVER_WEB_SOCKET_SUPPORT == ENABLED ) connection -> request . upgradeWebSocket = FALSE ; connection -> request . connectionUpgrade = FALSE ; osStrcpy ( connection -> request . clientKey , """" ) ;   if ( connection -> request . version >= HTTP_VERSION_1_0 ) { char_t firstChar ; char_t * separator ; char_t * name ; char_t * value ; firstChar = '\\0' ; while ( 1 ) { error = httpReadHeaderField ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE , & firstChar ) ; if ( error ) return error ; TRACE_DEBUG ( ""%s"" , connection -> buffer ) ; if ( ! osStrcmp ( connection -> buffer , ""\\r\\n"" ) ) break ; <S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; httpParseHeaderField ( connection , name , value ) ; } } } if ( connection -> request . chunkedEncoding ) { connection -> request . byteCount = 0 ; connection -> request . firstChunk = TRUE ; connection -> request . lastChunk = FALSE ; } else { connection -> request . byteCount = connection -> request . contentLength ; } return NO_ERROR ; }",<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
185,"CWE-400 static TYPE_0 METHOD_0 ( TYPE_1 * * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , const TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; TYPE_9 VAR_8 = VAR_9 ; if ( VAR_10 == VAR_11 ) { VAR_12 = METHOD_1 ( ) ; } * VAR_13 = METHOD_2 ( VAR_14 , 1 , sizeof ( TYPE_10 ) ) ; if ( * VAR_15 == VAR_16 ) { VAR_17 = VAR_18 ; goto VAR_19 ; } ( * VAR_20 ) -> VAR_21 = * VAR_22 ; VAR_23 = & ( * VAR_24 ) -> VAR_25 ; METHOD_3 ( & ( * VAR_26 ) -> VAR_27 , 0 , VAR_28 , VAR_29 , VAR_30 , 0 , 0 , VAR_31 , VAR_32 ) ; ( * VAR_33 ) -> VAR_34 = VAR_35 ; ( * VAR_36 ) -> VAR_37 = 0 ; ( * VAR_38 ) -> VAR_39 = 0 ; ( * VAR_40 ) -> VAR_41 = 0 ; ( * VAR_42 ) -> VAR_43 = VAR_44 ; ( * VAR_45 ) -> VAR_46 = VAR_47 ; ( * VAR_48 ) -> VAR_49 = ( 1u << 31 ) - 1 ; ( * VAR_50 ) -> VAR_51 = ( 1u << 31 ) - 1 ; ( * VAR_52 ) -> VAR_53 = VAR_54 ; ( * VAR_55 ) -> VAR_56 = 1 ; if ( VAR_57 ) { ( * VAR_58 ) -> VAR_59 = 1 ; } METHOD_4 ( & ( * VAR_60 ) -> VAR_61 ) ; METHOD_5 ( & ( * VAR_62 ) -> VAR_63 ) ; ( * VAR_64 ) -> VAR_65 = VAR_66 ; ( * VAR_67 ) -> VAR_68 . VAR_69 = 100 ; ( * VAR_70 ) -> VAR_71 = VAR_72 ; ( * VAR_73 ) -> VAR_74 = VAR_75 ; <S2SV_StartBug> if ( VAR_76 ) { <S2SV_EndBug> if ( ( VAR_77 -> VAR_78 & VAR_79 ) && VAR_80 -> VAR_81 ) { ( * VAR_82 ) -> VAR_83 |= VAR_84 ; } if ( VAR_85 -> VAR_86 & VAR_87 ) { ( * VAR_88 ) -> VAR_89 . VAR_90 = VAR_91 -> VAR_92 ; } if ( VAR_93 -> VAR_94 & VAR_95 ) { ( * VAR_96 ) -> VAR_97 = VAR_98 -> VAR_99 ; } if ( ( VAR_100 -> VAR_101 & VAR_102 ) && VAR_103 -> VAR_104 ) { ( * VAR_105 ) -> VAR_106 |= VAR_107 ; } if ( ( VAR_108 -> VAR_109 & VAR_110 ) && VAR_111 -> VAR_112 ) { ( * VAR_113 ) -> VAR_114 |= VAR_115 ; } if ( VAR_116 -> VAR_117 & VAR_118 ) { METHOD_6 ( ( * VAR_119 ) -> VAR_120 , VAR_121 -> VAR_122 , sizeof ( ( * VAR_123 ) -> VAR_124 ) ) ; } if ( VAR_125 -> VAR_126 & VAR_127 ) { ( * VAR_128 ) -> VAR_129 = VAR_130 -> VAR_131 ; } if ( ( VAR_132 -> VAR_133 & VAR_134 ) && VAR_135 -> VAR_136 ) { ( * VAR_137 ) -> VAR_138 |= VAR_139 ; } if ( VAR_140 -> VAR_141 & VAR_142 ) { ( * VAR_143 ) -> VAR_144 = VAR_145 -> VAR_146 ; } if ( VAR_147 -> VAR_148 & VAR_149 ) { VAR_150 = VAR_151 -> VAR_152 ; } if ( ( VAR_153 -> VAR_154 & VAR_155 ) && VAR_156 -> VAR_157 ) { ( * VAR_158 ) -> VAR_159 |= VAR_160 ; } if ( VAR_161 -> VAR_162 & VAR_163 ) { ( * VAR_164 ) -> VAR_165 = VAR_166 -> VAR_167 ; } <S2SV_StartBug> } <S2SV_EndBug> VAR_168 = METHOD_7 ( & ( * VAR_169 ) -> VAR_170 , VAR_171 , VAR_172 ) ; if ( VAR_173 != 0 ) { goto VAR_174 ; } VAR_175 = METHOD_8 ( & ( * VAR_176 ) -> VAR_177 , VAR_178 ) ; if ( VAR_179 != 0 ) { goto VAR_180 ; } VAR_181 = METHOD_9 ( & ( * VAR_182 ) -> VAR_183 , VAR_184 ) ; if ( VAR_185 != 0 ) { goto VAR_186 ; } VAR_187 = ( ( * VAR_188 ) -> VAR_189 + VAR_190 - 1 ) / VAR_191 ; if ( VAR_192 == 0 ) { VAR_193 = 1 ; } VAR_194 = METHOD_10 ( & ( * VAR_195 ) -> VAR_196 . VAR_197 , VAR_198 , VAR_199 , 1 , VAR_200 + 1 , VAR_201 ) ; if ( VAR_202 != 0 ) { goto VAR_203 ; } METHOD_11 ( & ( * VAR_204 ) -> VAR_205 , VAR_206 ) ; ( * VAR_207 ) -> VAR_208 = * VAR_209 ; ( * VAR_210 ) -> VAR_211 = VAR_212 ; METHOD_12 ( * VAR_213 ) ; if ( VAR_214 ) { TYPE_11 * VAR_215 = & ( * VAR_216 ) -> VAR_217 ; if ( VAR_218 && ( ( * VAR_219 ) -> VAR_220 & VAR_221 ) == 0 ) { VAR_222 -> VAR_223 = VAR_224 ; VAR_225 -> VAR_226 = VAR_227 ; } else { VAR_228 -> VAR_229 = VAR_230 ; } if ( ! VAR_231 ) { ( * VAR_232 ) -> VAR_233 . VAR_234 = VAR_235 ; METHOD_13 ( & ( * VAR_236 ) -> VAR_237 . VAR_238 , VAR_239 , VAR_240 ) ; } } return 0 ; VAR_241 : METHOD_14 ( & ( * VAR_242 ) -> VAR_243 ) ; VAR_244 : METHOD_15 ( & ( * VAR_245 ) -> VAR_246 ) ; VAR_247 : METHOD_16 ( & ( * VAR_248 ) -> VAR_249 ) ; VAR_250 : METHOD_17 ( VAR_251 , * VAR_252 ) ; VAR_253 : return VAR_254 ; }",<S2SV_ModStart> = VAR_75 ; ( * VAR_252 ) -> VAR_255 = VAR_256 ; <S2SV_ModStart> VAR_167 ; } if ( ( VAR_166 -> VAR_162 & VAR_257 ) && VAR_166 -> VAR_255 ) { ( * VAR_252 ) -> VAR_255 = VAR_166 -> VAR_255 ; },"CWE-400 static int session_new ( nghttp2_session * * session_ptr , const nghttp2_session_callbacks * callbacks , void * user_data , int server , const nghttp2_option * option , nghttp2_mem * mem ) { int rv ; size_t nbuffer ; size_t max_deflate_dynamic_table_size = NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE ; if ( mem == NULL ) { mem = nghttp2_mem_default ( ) ; } * session_ptr = nghttp2_mem_calloc ( mem , 1 , sizeof ( nghttp2_session ) ) ; if ( * session_ptr == NULL ) { rv = NGHTTP2_ERR_NOMEM ; goto fail_session ; } ( * session_ptr ) -> mem = * mem ; mem = & ( * session_ptr ) -> mem ; nghttp2_stream_init ( & ( * session_ptr ) -> root , 0 , NGHTTP2_STREAM_FLAG_NONE , NGHTTP2_STREAM_IDLE , NGHTTP2_DEFAULT_WEIGHT , 0 , 0 , NULL , mem ) ; ( * session_ptr ) -> remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> recv_window_size = 0 ; ( * session_ptr ) -> consumed_size = 0 ; ( * session_ptr ) -> recv_reduction = 0 ; ( * session_ptr ) -> local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> goaway_flags = NGHTTP2_GOAWAY_NONE ; ( * session_ptr ) -> local_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> remote_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> pending_local_max_concurrent_stream = NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ; ( * session_ptr ) -> pending_enable_push = 1 ; if ( server ) { ( * session_ptr ) -> server = 1 ; } init_settings ( & ( * session_ptr ) -> remote_settings ) ; init_settings ( & ( * session_ptr ) -> local_settings ) ; ( * session_ptr ) -> max_incoming_reserved_streams = NGHTTP2_MAX_INCOMING_RESERVED_STREAMS ; ( * session_ptr ) -> remote_settings . max_concurrent_streams = 100 ; ( * session_ptr ) -> max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN ; ( * session_ptr ) -> max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; <S2SV_StartBug> if ( option ) { <S2SV_EndBug> if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ; } if ( option -> opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS ) { ( * session_ptr ) -> remote_settings . max_concurrent_streams = option -> peer_max_concurrent_streams ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS ) { ( * session_ptr ) -> max_incoming_reserved_streams = option -> max_reserved_remote_streams ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC ) && option -> no_recv_client_magic ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING ) && option -> no_http_messaging ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING ; } if ( option -> opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES ) { memcpy ( ( * session_ptr ) -> user_recv_ext_types , option -> user_recv_ext_types , sizeof ( ( * session_ptr ) -> user_recv_ext_types ) ) ; } if ( option -> opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES ) { ( * session_ptr ) -> builtin_recv_ext_types = option -> builtin_recv_ext_types ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK ) && option -> no_auto_ping_ack ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH ) { ( * session_ptr ) -> max_send_header_block_length = option -> max_send_header_block_length ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE ) { max_deflate_dynamic_table_size = option -> max_deflate_dynamic_table_size ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS ) && option -> no_closed_streams ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK ) { ( * session_ptr ) -> max_outbound_ack = option -> max_outbound_ack ; } <S2SV_StartBug> } <S2SV_EndBug> rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ; if ( rv != 0 ) { goto fail_hd_deflater ; } rv = nghttp2_hd_inflate_init ( & ( * session_ptr ) -> hd_inflater , mem ) ; if ( rv != 0 ) { goto fail_hd_inflater ; } rv = nghttp2_map_init ( & ( * session_ptr ) -> streams , mem ) ; if ( rv != 0 ) { goto fail_map ; } nbuffer = ( ( * session_ptr ) -> max_send_header_block_length + NGHTTP2_FRAMEBUF_CHUNKLEN - 1 ) / NGHTTP2_FRAMEBUF_CHUNKLEN ; if ( nbuffer == 0 ) { nbuffer = 1 ; } rv = nghttp2_bufs_init3 ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_FRAMEBUF_CHUNKLEN , nbuffer , 1 , NGHTTP2_FRAME_HDLEN + 1 , mem ) ; if ( rv != 0 ) { goto fail_aob_framebuf ; } active_outbound_item_reset ( & ( * session_ptr ) -> aob , mem ) ; ( * session_ptr ) -> callbacks = * callbacks ; ( * session_ptr ) -> user_data = user_data ; session_inbound_frame_reset ( * session_ptr ) ; if ( nghttp2_enable_strict_preface ) { nghttp2_inbound_frame * iframe = & ( * session_ptr ) -> iframe ; if ( server && ( ( * session_ptr ) -> opt_flags & NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ) == 0 ) { iframe -> state = NGHTTP2_IB_READ_CLIENT_MAGIC ; iframe -> payloadleft = NGHTTP2_CLIENT_MAGIC_LEN ; } else { iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } if ( ! server ) { ( * session_ptr ) -> aob . state = NGHTTP2_OB_SEND_CLIENT_MAGIC ; nghttp2_bufs_add ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_CLIENT_MAGIC , NGHTTP2_CLIENT_MAGIC_LEN ) ; } } return 0 ; fail_aob_framebuf : nghttp2_map_free ( & ( * session_ptr ) -> streams ) ; fail_map : nghttp2_hd_inflate_free ( & ( * session_ptr ) -> hd_inflater ) ; fail_hd_inflater : nghttp2_hd_deflate_free ( & ( * session_ptr ) -> hd_deflater ) ; fail_hd_deflater : nghttp2_mem_free ( mem , * session_ptr ) ; fail_session : return rv ; }",<S2SV_ModStart> = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; ( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ; <S2SV_ModStart> max_outbound_ack ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) { ( * session_ptr ) -> max_settings = option -> max_settings ; }
186,"CWE-532 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 * VAR_1 ) { TYPE_2 VAR_2 ; VAR_3 * VAR_4 ; TYPE_3 VAR_5 ; METHOD_1 ( & VAR_6 -> VAR_7 -> VAR_8 -> VAR_9 , ""sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n"" ) ; VAR_10 = METHOD_2 ( VAR_11 , VAR_12 ) ; if ( ! VAR_13 ) return - VAR_14 ; VAR_15 [ 0 ] = 0xff ; VAR_16 [ 1 ] = 0xff ; VAR_17 = METHOD_3 ( VAR_18 -> VAR_19 -> VAR_20 , METHOD_4 ( VAR_21 -> VAR_22 -> VAR_23 , 0 ) , VAR_24 , VAR_25 | VAR_26 , 0 , 0 , VAR_27 , VAR_28 , 10000 ) ; <S2SV_StartBug> if ( VAR_29 < 0 ) <S2SV_EndBug> <S2SV_StartBug> METHOD_5 ( & VAR_30 -> VAR_31 , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> VAR_32 ) ; else { VAR_33 = METHOD_6 ( VAR_34 ) ; METHOD_7 ( & VAR_35 -> VAR_36 -> VAR_37 -> VAR_38 , ""read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n"" , VAR_39 [ 0 ] , VAR_40 [ 1 ] ) ; * VAR_41 = METHOD_8 ( VAR_42 ) ; } METHOD_9 ( VAR_43 ) ; return VAR_44 ; }","<S2SV_ModStart> if ( VAR_44 != VAR_28 ) { <S2SV_ModEnd> METHOD_5 ( & <S2SV_ModStart> -> VAR_38 , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , VAR_44 ) ; if ( VAR_44 >= 0 ) VAR_44 = - VAR_45 ; } <S2SV_ModEnd> else { VAR_42","CWE-532 static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , ""sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n"" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ; <S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , ""read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n"" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }","<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status"
187,"CWE-264 METHOD_0 ( TYPE_0 , unsigned TYPE_1 , TYPE_2 , TYPE_3 TYPE_4 * , TYPE_5 , unsigned TYPE_6 , TYPE_7 , TYPE_8 TYPE_9 * , TYPE_10 , TYPE_11 TYPE_12 * , TYPE_13 ) { unsigned TYPE_14 VAR_0 ; struct STRUCT_OR_UNION_0 * VAR_1 ; switch ( TYPE_15 ) { case VAR_2 : VAR_3 = METHOD_1 ( ) -> VAR_4 & VAR_5 ; VAR_6 = METHOD_2 ( VAR_7 , METHOD_3 ( ) ) ; if ( METHOD_4 ( VAR_8 , ( unsigned TYPE_16 TYPE_17 * ) TYPE_18 ) ) return - VAR_9 ; return 0 ; case VAR_10 : break ; case VAR_11 : if ( TYPE_19 < sizeof ( unsigned TYPE_20 ) ) return - VAR_12 ; VAR_13 = ( METHOD_5 ( ) -> VAR_14 >> VAR_15 ) & VAR_16 ; if ( METHOD_6 ( VAR_17 , ( unsigned TYPE_21 TYPE_22 * ) TYPE_23 ) ) return - VAR_18 ; return 1 ; case VAR_19 : if ( TYPE_24 < sizeof ( unsigned TYPE_25 ) ) return - VAR_20 ; VAR_21 = ( struct STRUCT_OR_UNION_1 * ) ( ( TYPE_26 * ) VAR_22 + VAR_23 -> VAR_24 ) ; VAR_25 = VAR_26 -> VAR_27 ; if ( METHOD_7 ( VAR_28 , ( unsigned TYPE_27 TYPE_28 * ) TYPE_29 ) ) return - VAR_29 ; return 1 ; case VAR_30 : <S2SV_StartBug> if ( TYPE_30 < sizeof ( * VAR_31 ) ) <S2SV_EndBug> return - VAR_32 ; if ( METHOD_8 ( TYPE_31 , VAR_33 , TYPE_32 ) != 0 ) return - VAR_34 ; return 1 ; default : break ; } return - VAR_35 ; }",<S2SV_ModStart> if ( TYPE_32 > <S2SV_ModEnd> sizeof ( *,"CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }",<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
188,"CWE-125 TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { if ( VAR_4 <= 0 || VAR_5 <= 0 || VAR_6 > 32767 || VAR_7 > 32767 ) { METHOD_1 ( VAR_8 , ""Invalid<S2SV_blank>Size"" ) ; return 0 ; } if ( ! METHOD_2 ( VAR_9 ) ) { METHOD_3 ( VAR_10 , ""Invalid<S2SV_blank>BPP"" ) ; return 0 ; } TYPE_5 * VAR_11 = METHOD_4 ( 0 , ""Graphics"" ) ; if ( ! VAR_12 ) return 0 ; TYPE_6 VAR_13 ; METHOD_5 ( & VAR_14 ) ; VAR_15 . VAR_16 . VAR_17 = VAR_18 ; VAR_19 . VAR_20 . VAR_21 = VAR_22 ; VAR_23 . VAR_24 = VAR_25 ; VAR_26 . VAR_27 . VAR_28 = ( unsigned TYPE_7 ) VAR_29 ; VAR_30 . VAR_31 . VAR_32 = ( unsigned TYPE_8 ) VAR_33 ; VAR_34 . VAR_35 . VAR_36 = ( unsigned TYPE_9 ) VAR_37 ; if ( METHOD_6 ( VAR_38 ) ) { if ( METHOD_7 ( METHOD_8 ( VAR_39 , ""zigzag"" , 0 ) ) ) VAR_40 . VAR_41 . VAR_42 = ( TYPE_10 ) ( VAR_43 . VAR_44 . VAR_45 | VAR_46 ) ; if ( METHOD_9 ( METHOD_10 ( VAR_47 , ""msb"" , 0 ) ) ) VAR_48 . VAR_49 . VAR_50 = ( TYPE_11 ) ( VAR_51 . VAR_52 . VAR_53 | VAR_54 ) ; if ( METHOD_11 ( METHOD_12 ( VAR_55 , ""vertical_byte"" , 0 ) ) ) { if ( VAR_56 . VAR_57 . VAR_58 == 1 ) VAR_59 . VAR_60 . VAR_61 = ( TYPE_12 ) ( VAR_62 . VAR_63 . VAR_64 | VAR_65 ) ; else <S2SV_StartBug> METHOD_13 ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> } TYPE_13 * VAR_66 = METHOD_14 ( VAR_67 , ""color_order"" , 0 ) ; if ( VAR_68 ) { if ( METHOD_15 ( VAR_69 , ""rgb"" ) ) ; else if ( ! METHOD_16 ( VAR_70 , ""brg"" ) ) VAR_71 . VAR_72 . VAR_73 = ( TYPE_14 ) ( VAR_74 . VAR_75 . VAR_76 | VAR_77 ) ; else if ( ! METHOD_17 ( VAR_78 , ""bgr"" ) ) VAR_79 . VAR_80 . VAR_81 = ( TYPE_15 ) ( VAR_82 . VAR_83 . VAR_84 | VAR_85 ) ; else if ( ! METHOD_18 ( VAR_86 , ""gbr"" ) ) VAR_87 . VAR_88 . VAR_89 = ( TYPE_16 ) ( VAR_90 . VAR_91 . VAR_92 | VAR_93 ) ; else if ( ! METHOD_19 ( VAR_94 , ""grb"" ) ) VAR_95 . VAR_96 . VAR_97 = ( TYPE_17 ) ( VAR_98 . VAR_99 . VAR_100 | VAR_101 ) ; else if ( ! METHOD_20 ( VAR_102 , ""rbg"" ) ) VAR_103 . VAR_104 . VAR_105 = ( TYPE_18 ) ( VAR_106 . VAR_107 . VAR_108 | VAR_109 ) ; else METHOD_21 ( ""color_order<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3<S2SV_blank>characters"" ) ; METHOD_22 ( VAR_110 ) ; } } METHOD_23 ( & VAR_111 ) ; METHOD_24 ( & VAR_112 ) ; return VAR_113 ; }","<S2SV_ModStart> ) ; else { METHOD_3 ( VAR_10 , <S2SV_ModEnd> ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_ModStart> ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; return 0 ; } if ( VAR_112 . VAR_107 . VAR_33 & 7 ) { METHOD_3 ( VAR_10 , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; }","CWE-125 JsVar * jswrap_graphics_createArrayBuffer ( int width , int height , int bpp , JsVar * options ) { if ( width <= 0 || height <= 0 || width > 32767 || height > 32767 ) { jsExceptionHere ( JSET_ERROR , ""Invalid<S2SV_blank>Size"" ) ; return 0 ; } if ( ! isValidBPP ( bpp ) ) { jsExceptionHere ( JSET_ERROR , ""Invalid<S2SV_blank>BPP"" ) ; return 0 ; } JsVar * parent = jspNewObject ( 0 , ""Graphics"" ) ; if ( ! parent ) return 0 ; JsGraphics gfx ; graphicsStructInit ( & gfx ) ; gfx . data . type = JSGRAPHICSTYPE_ARRAYBUFFER ; gfx . data . flags = JSGRAPHICSFLAGS_NONE ; gfx . graphicsVar = parent ; gfx . data . width = ( unsigned short ) width ; gfx . data . height = ( unsigned short ) height ; gfx . data . bpp = ( unsigned char ) bpp ; if ( jsvIsObject ( options ) ) { if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , ""zigzag"" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , ""msb"" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , ""vertical_byte"" , 0 ) ) ) { if ( gfx . data . bpp == 1 ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else <S2SV_StartBug> jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> } JsVar * colorv = jsvObjectGetChild ( options , ""color_order"" , 0 ) ; if ( colorv ) { if ( jsvIsStringEqual ( colorv , ""rgb"" ) ) ; else if ( ! jsvIsStringEqual ( colorv , ""brg"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BRG ) ; else if ( ! jsvIsStringEqual ( colorv , ""bgr"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BGR ) ; else if ( ! jsvIsStringEqual ( colorv , ""gbr"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GBR ) ; else if ( ! jsvIsStringEqual ( colorv , ""grb"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GRB ) ; else if ( ! jsvIsStringEqual ( colorv , ""rbg"" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_RBG ) ; else jsWarn ( ""color_order<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3<S2SV_blank>characters"" ) ; jsvUnLock ( colorv ) ; } } lcdInit_ArrayBuffer ( & gfx ) ; graphicsSetVar ( & gfx ) ; return parent ; }","<S2SV_ModStart> ) ; else { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_ModStart> ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; }"
189,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , struct STRUCT_OR_UNION_4 * STRUCT_OR_UNION_5 ) { if ( STRUCT_OR_UNION_6 -> VAR_0 & VAR_1 ) return 0 ; <S2SV_StartBug> if ( METHOD_1 ( STRUCT_OR_UNION_7 ) -> METHOD_2 ( STRUCT_OR_UNION_8 , VAR_2 ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( METHOD_3 ( STRUCT_OR_UNION_9 , STRUCT_OR_UNION_10 ) && ( STRUCT_OR_UNION_11 -> VAR_3 == VAR_4 || <S2SV_EndBug> ( STRUCT_OR_UNION_12 -> VAR_5 -> VAR_6 == 0 && STRUCT_OR_UNION_13 -> VAR_7 -> VAR_8 == VAR_9 && <S2SV_StartBug> STRUCT_OR_UNION_14 -> VAR_10 -> VAR_11 != VAR_12 ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }","<S2SV_ModStart> ; if ( ! METHOD_3 ( STRUCT_OR_UNION_9 , STRUCT_OR_UNION_14 ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> STRUCT_OR_UNION_14 -> VAR_10 <S2SV_ModStart> VAR_12 ) ) <S2SV_ModEnd> return 1 ;","CWE-200 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }","<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;"
190,"CWE-552 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , <S2SV_StartBug> const struct STRUCT_OR_UNION_0 * VAR_4 , <S2SV_EndBug> TYPE_5 * VAR_5 ) { TYPE_6 VAR_6 = - 1 ; TYPE_7 * VAR_7 = METHOD_1 ( VAR_8 ) ; <S2SV_StartBug> TYPE_8 VAR_9 = 0 ; <S2SV_EndBug> VAR_10 = 0 ; <S2SV_StartBug> if ( ! VAR_11 || ( VAR_12 && ! VAR_13 ) ) <S2SV_EndBug> METHOD_2 ( VAR_14 ) ; if ( VAR_15 ) VAR_16 = * VAR_17 ; if ( METHOD_3 ( & VAR_18 , VAR_19 -> VAR_20 , VAR_21 , VAR_22 , VAR_23 , <S2SV_StartBug> ( struct STRUCT_OR_UNION_1 * ) VAR_24 , <S2SV_EndBug> VAR_25 , <S2SV_StartBug> VAR_26 ) != VAR_27 ) <S2SV_EndBug> { METHOD_4 ( VAR_28 ) ; } <S2SV_StartBug> VAR_29 : <S2SV_EndBug> return VAR_30 ; }","<S2SV_ModStart> TYPE_4 VAR_23 , <S2SV_ModEnd> struct STRUCT_OR_UNION_1 * <S2SV_ModStart> ; TYPE_8 VAR_25 = 0 ; TYPE_8 VAR_31 <S2SV_ModStart> ! VAR_21 ) || VAR_22 > VAR_32 ) METHOD_4 ( VAR_28 ) ; if ( VAR_24 && <S2SV_ModEnd> VAR_26 ) VAR_25 <S2SV_ModStart> , VAR_23 , <S2SV_ModEnd> VAR_24 , VAR_25 <S2SV_ModStart> , VAR_25 , & VAR_31 <S2SV_ModEnd> ) != VAR_27 <S2SV_ModStart> ) ; } if ( VAR_24 && VAR_26 ) { if ( VAR_31 > sizeof ( struct STRUCT_OR_UNION_2 ) ) METHOD_4 ( VAR_28 ) ; * VAR_26 = VAR_31 ; } if ( VAR_30 > ( TYPE_6 ) VAR_22 ) { VAR_30 = - 1 ; METHOD_4 ( VAR_28 ) ; }","CWE-552 static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags , <S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> oe_socklen_t * addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; <S2SV_StartBug> oe_socklen_t addrlen_in = 0 ; <S2SV_EndBug> oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen ) addrlen_in = * addrlen ; if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags , <S2SV_StartBug> ( struct oe_sockaddr * ) src_addr , <S2SV_EndBug> addrlen_in , <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }","<S2SV_ModStart> int flags , <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> ; oe_socklen_t addrlen_in = 0 ; oe_socklen_t addrlen_out <S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( src_addr && <S2SV_ModEnd> addrlen ) addrlen_in <S2SV_ModStart> , flags , <S2SV_ModEnd> src_addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( src_addr && addrlen ) { if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }"
191,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 -> VAR_4 ; TYPE_4 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_5 * VAR_8 = VAR_9 -> VAR_10 ; TYPE_6 * VAR_11 = VAR_12 -> VAR_13 ; TYPE_7 * VAR_14 = & VAR_15 -> VAR_16 ; TYPE_8 VAR_17 = VAR_18 -> VAR_19 -> VAR_20 ; TYPE_9 VAR_21 = VAR_22 -> VAR_23 ; TYPE_10 VAR_24 ; TYPE_11 VAR_25 ; TYPE_12 VAR_26 ; { TYPE_13 * VAR_27 ; TYPE_14 * VAR_28 = VAR_29 -> VAR_30 . VAR_31 ; TYPE_15 * VAR_32 = ( TYPE_16 * ) VAR_33 ; TYPE_17 * VAR_34 ; VAR_35 = VAR_36 -> VAR_37 . VAR_38 ; VAR_39 = ( TYPE_18 * ) VAR_40 ; * VAR_41 = 0 ; * ( VAR_42 + 1 ) = 0 ; * VAR_43 = VAR_44 ; VAR_45 -> VAR_46 . VAR_47 = ( TYPE_19 ) - 1 ; VAR_48 -> VAR_49 . VAR_50 = ( TYPE_20 ) - 1 ; } VAR_51 -> VAR_52 = METHOD_1 ( VAR_53 ) ; METHOD_2 ( ""SH:<S2SV_blank>num_ref_idx_override_flag"" , VAR_54 -> VAR_55 ) ; VAR_56 = VAR_57 -> VAR_58 -> VAR_59 [ 0 ] ; if ( VAR_60 -> VAR_61 ) { VAR_62 = METHOD_3 ( VAR_63 , VAR_64 ) + 1 ; } { TYPE_21 VAR_65 = VAR_66 << VAR_67 ; if ( VAR_68 > VAR_69 ) { return VAR_70 ; } VAR_71 -> VAR_72 [ 0 ] = VAR_73 ; METHOD_4 ( ""SH:<S2SV_blank>num_ref_idx_l0_active_minus1"" , VAR_74 -> VAR_75 [ 0 ] - 1 ) ; } { TYPE_22 VAR_76 = METHOD_5 ( VAR_77 ) ; METHOD_6 ( ""SH:<S2SV_blank>ref_pic_list_reordering_flag_l0"" , VAR_78 ) ; { TYPE_23 VAR_79 = ( VAR_80 -> VAR_81 != VAR_82 -> VAR_83 -> VAR_84 ) ; if ( VAR_85 -> VAR_86 || ( VAR_87 & ! VAR_88 -> VAR_89 ) || VAR_90 -> VAR_91 != VAR_92 -> VAR_93 [ 0 ] ) { METHOD_7 ( VAR_94 ) ; } if ( VAR_95 -> VAR_96 & VAR_97 -> VAR_98 ) VAR_99 -> VAR_100 = 0 ; } VAR_101 -> VAR_102 = VAR_103 -> VAR_104 [ 0 ] ; if ( VAR_105 ) { TYPE_24 VAR_106 ; VAR_107 -> VAR_108 [ 0 ] = VAR_109 -> VAR_110 -> VAR_111 [ 0 ] ; VAR_112 = METHOD_8 ( VAR_113 , 0 ) ; if ( VAR_114 == - 1 ) return VAR_115 ; VAR_116 -> VAR_117 [ 0 ] = VAR_118 -> VAR_119 -> VAR_120 [ 0 ] ; } else VAR_121 -> VAR_122 [ 0 ] = VAR_123 -> VAR_124 -> VAR_125 [ 0 ] ; } { TYPE_25 * * VAR_126 , * * VAR_127 ; TYPE_26 VAR_128 ; struct STRUCT_OR_UNION_0 * VAR_129 ; VAR_130 = VAR_131 -> VAR_132 + VAR_133 ; VAR_134 [ 0 ] = 0 ; VAR_135 ++ ; for ( VAR_136 = 0 ; VAR_137 < VAR_138 -> VAR_139 [ 0 ] ; VAR_140 ++ ) { VAR_141 = VAR_142 -> VAR_143 [ 0 ] [ VAR_144 ] ; VAR_145 [ VAR_146 ] = ( VAR_147 -> VAR_148 ) ; } VAR_149 = VAR_150 -> VAR_151 + VAR_152 ; VAR_153 [ 0 ] = 0 ; if ( VAR_154 ) { TYPE_27 * * VAR_155 , * * VAR_156 ; TYPE_28 * * VAR_157 , * * VAR_158 ; VAR_159 = VAR_160 -> VAR_161 + VAR_162 ; VAR_163 = VAR_164 -> VAR_165 + VAR_166 ; VAR_167 [ 0 ] = 0 ; VAR_168 ++ ; VAR_169 [ 0 ] = 0 ; VAR_170 ++ ; VAR_171 = 0 ; for ( VAR_172 = 0 ; VAR_173 < VAR_174 -> VAR_175 [ 0 ] ; VAR_176 ++ ) { VAR_177 = VAR_178 -> VAR_179 [ 0 ] [ VAR_180 ] ; VAR_181 [ 0 ] = ( VAR_182 -> VAR_183 ) ; VAR_184 [ 1 ] = ( VAR_185 -> VAR_186 ) ; VAR_187 [ 0 ] = ( VAR_188 -> VAR_189 ) + 1 ; VAR_190 [ 1 ] = ( VAR_191 -> VAR_192 ) + 1 ; VAR_193 += 2 ; VAR_194 += 2 ; } VAR_195 = VAR_196 -> VAR_197 + VAR_198 ; VAR_199 [ 0 ] = 0 ; VAR_200 = VAR_201 -> VAR_202 + VAR_203 ; VAR_204 [ 0 ] = 0 ; } if ( VAR_205 -> VAR_206 >= 3 ) { TYPE_29 VAR_207 ; TYPE_30 VAR_208 ; VAR_209 = METHOD_9 ( VAR_210 , VAR_211 -> VAR_212 ) ; VAR_213 = 2 * ( ( 2 * VAR_214 ) + 1 ) ; VAR_215 = VAR_216 * sizeof ( TYPE_31 * ) ; VAR_217 += VAR_218 * sizeof ( TYPE_32 * ) ; METHOD_10 ( ( TYPE_33 * ) VAR_219 -> VAR_220 -> VAR_221 , VAR_222 -> VAR_223 , VAR_224 ) ; } } if ( VAR_225 -> VAR_226 ) { VAR_227 = METHOD_11 ( VAR_228 , VAR_229 ) ; if ( VAR_230 != VAR_231 ) return VAR_232 ; METHOD_12 ( VAR_233 ) ; VAR_234 -> VAR_235 = VAR_236 -> VAR_237 ; } else { VAR_238 -> VAR_239 -> VAR_240 = 0 ; VAR_241 -> VAR_242 = VAR_243 -> VAR_244 ; } VAR_245 -> VAR_246 -> VAR_247 = VAR_248 -> VAR_249 -> VAR_250 ; if ( VAR_251 && ( VAR_252 == 0 ) ) { METHOD_13 ( VAR_253 ) ; } if ( VAR_254 -> VAR_255 != 0 ) { if ( ! VAR_256 -> VAR_257 -> VAR_258 ) <S2SV_StartBug> VAR_259 -> VAR_260 = METHOD_14 ( VAR_261 ) ; <S2SV_EndBug> else VAR_262 -> VAR_263 += VAR_264 -> VAR_265 ; } if ( VAR_266 -> VAR_267 == VAR_268 ) { VAR_269 = METHOD_15 ( VAR_270 , VAR_271 ) ; if ( VAR_272 > VAR_273 ) { return VAR_274 ; } VAR_275 -> VAR_276 = VAR_277 ; METHOD_16 ( ""SH:<S2SV_blank>cabac_init_idc"" , VAR_278 -> VAR_279 ) ; } VAR_280 = VAR_281 -> VAR_282 + METHOD_17 ( VAR_283 , VAR_284 ) ; if ( ( VAR_285 < 0 ) || ( VAR_286 > 51 ) ) { return VAR_287 ; } VAR_288 -> VAR_289 = VAR_290 ; METHOD_18 ( ""SH:<S2SV_blank>slice_qp_delta"" , ( TYPE_34 ) ( VAR_291 -> VAR_292 - VAR_293 -> VAR_294 ) ) ; if ( VAR_295 -> VAR_296 == 1 ) { VAR_297 = METHOD_19 ( VAR_298 , VAR_299 ) ; if ( VAR_300 > VAR_301 ) { return VAR_302 ; } METHOD_20 ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , VAR_303 ) ; VAR_304 -> VAR_305 = VAR_306 ; if ( VAR_307 != 1 ) { VAR_308 = METHOD_21 ( VAR_309 , VAR_310 ) << 1 ; if ( ( VAR_311 > VAR_312 ) || ( VAR_313 > VAR_314 ) ) { return VAR_315 ; } VAR_316 -> VAR_317 = VAR_318 ; METHOD_22 ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , VAR_319 -> VAR_320 >> 1 ) ; VAR_321 = METHOD_23 ( VAR_322 , VAR_323 ) << 1 ; if ( ( VAR_324 > VAR_325 ) || ( VAR_326 > VAR_327 ) ) { return VAR_328 ; } VAR_329 -> VAR_330 = VAR_331 ; METHOD_24 ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , VAR_332 -> VAR_333 >> 1 ) ; } else { VAR_334 -> VAR_335 = 0 ; VAR_336 -> VAR_337 = 0 ; } } else { VAR_338 -> VAR_339 = 0 ; VAR_340 -> VAR_341 = 0 ; VAR_342 -> VAR_343 = 0 ; } VAR_344 -> VAR_345 = 2 ; if ( VAR_346 -> VAR_347 ) { VAR_348 ; VAR_349 ; VAR_350 -> METHOD_25 = VAR_351 ; VAR_352 -> VAR_353 = VAR_354 ; METHOD_26 ( VAR_355 , VAR_356 ) ; if ( VAR_357 -> VAR_358 -> VAR_359 ) VAR_360 -> VAR_361 = VAR_362 ; else VAR_363 -> VAR_364 = VAR_365 ; } else { VAR_366 ; VAR_367 ; VAR_368 -> METHOD_27 = VAR_369 ; VAR_370 -> VAR_371 = VAR_372 ; if ( VAR_373 -> VAR_374 -> VAR_375 ) { VAR_376 -> VAR_377 = VAR_378 ; } else VAR_379 -> VAR_380 = VAR_381 ; } VAR_382 -> VAR_383 = 0 ; VAR_384 -> VAR_385 = VAR_386 ; VAR_387 = VAR_388 -> METHOD_28 ( VAR_389 , VAR_390 , VAR_391 ) ; if ( VAR_392 != VAR_393 ) return VAR_394 ; return VAR_395 ; }",<S2SV_ModStart> -> VAR_258 ) { VAR_331 = METHOD_14 ( VAR_389 ) ; if ( VAR_331 < 0 ) { return VAR_396 ; } <S2SV_ModStart> -> VAR_265 = VAR_331 ; } <S2SV_ModEnd> else VAR_262 ->,"CWE-119 WORD32 ih264d_parse_pslice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_mbaff = ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; { WORD8 * pi1_buf ; WORD16 * pi2_mv = ps_dec -> s_default_mv_pred . i2_mv ; WORD32 * pi4_mv = ( WORD32 * ) pi2_mv ; WORD16 * pi16_refFrame ; pi1_buf = ps_dec -> s_default_mv_pred . i1_ref_frame ; pi16_refFrame = ( WORD16 * ) pi1_buf ; * pi4_mv = 0 ; * ( pi4_mv + 1 ) = 0 ; * pi16_refFrame = OUT_OF_RANGE_REF ; ps_dec -> s_default_mv_pred . u1_col_ref_pic_idx = ( UWORD8 ) - 1 ; ps_dec -> s_default_mv_pred . u1_pic_type = ( UWORD8 ) - 1 ; } ps_cur_slice -> u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_override_flag"" , ps_cur_slice -> u1_num_ref_idx_active_override_flag ) ; u4_temp = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 0 ] ; if ( ps_cur_slice -> u1_num_ref_idx_active_override_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) + 1 ; } { UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag ; if ( u4_temp > u1_max_ref_idx ) { return ERROR_NUM_REF ; } ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>num_ref_idx_l0_active_minus1"" , ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] - 1 ) ; } { UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>ref_pic_list_reordering_flag_l0"" , uc_refIdxReFlagL0 ) ; { UWORD8 init_idx_flg = ( ps_dec -> u1_pr_sl_type != ps_dec -> ps_cur_slice -> u1_slice_type ) ; if ( ps_dec -> u1_first_pb_nal_in_pic || ( init_idx_flg & ! ps_dec -> u1_sl_typ_5_9 ) || ps_dec -> u1_num_ref_idx_lx_active_prev != ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ) { ih264d_init_ref_idx_lx_p ( ps_dec ) ; } if ( ps_dec -> u1_first_pb_nal_in_pic & ps_dec -> u1_sl_typ_5_9 ) ps_dec -> u1_first_pb_nal_in_pic = 0 ; } ps_dec -> u1_num_ref_idx_lx_active_prev = ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; if ( uc_refIdxReFlagL0 ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 0 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; } else ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; } { void * * pui_map_ref_idx_to_poc_lx0 , * * pui_map_ref_idx_to_poc_lx1 ; WORD8 idx ; struct pic_buffer_t * ps_pic ; pui_map_ref_idx_to_poc_lx0 = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L0 ; pui_map_ref_idx_to_poc_lx0 [ 0 ] = 0 ; pui_map_ref_idx_to_poc_lx0 ++ ; for ( idx = 0 ; idx < ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; pui_map_ref_idx_to_poc_lx0 [ idx ] = ( ps_pic -> pu1_buf1 ) ; } pui_map_ref_idx_to_poc_lx1 = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L1 ; pui_map_ref_idx_to_poc_lx1 [ 0 ] = 0 ; if ( u1_mbaff ) { void * * ppv_map_ref_idx_to_poc_lx_t , * * ppv_map_ref_idx_to_poc_lx_b ; void * * ppv_map_ref_idx_to_poc_lx_t1 , * * ppv_map_ref_idx_to_poc_lx_b1 ; ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; idx = 0 ; for ( idx = 0 ; idx < ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t += 2 ; ppv_map_ref_idx_to_poc_lx_b += 2 ; } ppv_map_ref_idx_to_poc_lx_t1 = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_t1 [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b1 = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_b1 [ 0 ] = 0 ; } if ( ps_dec -> u4_num_cores >= 3 ) { WORD32 num_entries ; WORD32 size ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; memcpy ( ( void * ) ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc , ps_dec -> ppv_map_ref_idx_to_poc , size ) ; } } if ( ps_pps -> u1_wted_pred_flag ) { ret = ih264d_parse_pred_weight_table ( ps_cur_slice , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_form_pred_weight_matrix ( ps_dec ) ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } else { ps_dec -> ps_cur_slice -> u2_log2Y_crwd = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( u1_mbaff && ( u1_field_pic_flag == 0 ) ) { ih264d_convert_frm_mbaff_list ( ps_dec ) ; } if ( ps_cur_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } if ( ps_pps -> u1_entropy_coding_mode == CABAC ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_CABAC_INIT_IDC ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> u1_cabac_init_idc = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>cabac_init_idc"" , ps_cur_slice -> u1_cabac_init_idc ) ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) { return ERROR_INV_RANGE_QP_T ; } ps_cur_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_qp_delta"" , ( WORD8 ) ( ps_cur_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , u4_temp ) ; ps_cur_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , ps_cur_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , ps_cur_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_cur_slice -> i1_slice_beta_offset = 0 ; } } else { ps_cur_slice -> u1_disable_dblk_filter_idc = 0 ; ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_cur_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac ; ps_dec -> pf_parse_inter_mb = ih264d_parse_pmb_cabac ; ih264d_init_cabac_contexts ( P_SLICE , ps_dec ) ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; } else { SWITCHONTRACE ; SWITCHOFFTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc ; ps_dec -> pf_parse_inter_mb = ih264d_parse_pmb_cavlc ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; } ps_dec -> u1_B = 0 ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ret = ps_dec -> pf_parse_inter_slice ( ps_dec , ps_cur_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; return OK ; }",<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm ->
192,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_EndBug> TYPE_3 VAR_2 ) { <S2SV_StartBug> const TYPE_4 VAR_3 = METHOD_1 ( VAR_4 , <S2SV_EndBug> <S2SV_StartBug> VAR_5 -> VAR_6 . VAR_7 [ VAR_8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VAR_9 -> VAR_10 ) <S2SV_EndBug> ++ VAR_11 -> VAR_12 . VAR_13 [ VAR_14 ] [ VAR_15 ] ; return VAR_16 ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static TYPE_5 <S2SV_ModEnd> METHOD_0 ( TYPE_1 <S2SV_ModStart> * VAR_11 , TYPE_6 * VAR_17 , TYPE_7 <S2SV_ModEnd> * VAR_4 , <S2SV_ModStart> ) { const TYPE_5 <S2SV_ModEnd> VAR_16 = METHOD_1 <S2SV_ModStart> VAR_11 -> VAR_6 -> <S2SV_ModEnd> VAR_7 [ VAR_14 <S2SV_ModStart> ] ) ; TYPE_8 * VAR_12 = VAR_17 -> VAR_12 ; if ( VAR_12 ) ++ VAR_12 -> <S2SV_ModEnd> VAR_16 [ VAR_14","CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int size_group ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ; return y_mode ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_y ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = read_intra_mode <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> y_mode_prob [ size_group <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> y_mode [ size_group"
193,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 VAR_2 ; for ( VAR_3 = 0 ; VAR_4 [ VAR_5 ] ; VAR_6 ++ ) { TYPE_4 * VAR_7 = VAR_8 [ VAR_9 ] ; if ( VAR_10 -> VAR_11 ) { switch ( VAR_12 -> VAR_13 ) { case VAR_14 : <S2SV_StartBug> if ( VAR_15 -> VAR_16 ) METHOD_1 ( VAR_17 -> VAR_18 ) ; <S2SV_EndBug> VAR_19 -> VAR_20 = METHOD_2 ( ( TYPE_5 * ) VAR_21 -> VAR_22 [ 0 ] . VAR_23 . VAR_24 ) ; break ; case VAR_25 : <S2SV_StartBug> VAR_26 -> VAR_27 = VAR_28 -> VAR_29 [ 0 ] . VAR_30 ; <S2SV_EndBug> if ( VAR_31 -> VAR_32 ) METHOD_3 ( VAR_33 -> VAR_34 ) ; VAR_35 -> VAR_36 = CHECKED_XMALLOC ( unsigned TYPE_6 , VAR_37 -> VAR_38 ) ; METHOD_4 ( VAR_39 -> VAR_40 , VAR_41 -> VAR_42 [ 0 ] . VAR_43 . VAR_44 , VAR_45 -> VAR_46 ) ; break ; case VAR_47 : <S2SV_StartBug> if ( VAR_48 -> VAR_49 ) METHOD_5 ( VAR_50 -> VAR_51 ) ; <S2SV_EndBug> VAR_52 -> VAR_53 = CHECKED_XMALLOC ( TYPE_7 , VAR_54 -> VAR_55 [ 0 ] . VAR_56 ) ; METHOD_6 ( VAR_57 -> VAR_58 , VAR_59 -> VAR_60 [ 0 ] . VAR_61 . VAR_62 , VAR_63 -> VAR_64 [ 0 ] . VAR_65 ) ; break ; case VAR_66 : <S2SV_StartBug> if ( VAR_67 -> VAR_68 ) METHOD_7 ( VAR_69 -> VAR_70 ) ; <S2SV_EndBug> VAR_71 -> VAR_72 = CHECKED_XMALLOC ( TYPE_8 , VAR_73 -> VAR_74 [ 0 ] . VAR_75 ) ; METHOD_8 ( VAR_76 -> VAR_77 , VAR_78 -> VAR_79 [ 0 ] . VAR_80 . VAR_81 , VAR_82 -> VAR_83 [ 0 ] . VAR_84 ) ; break ; default : break ; } } } }",<S2SV_ModStart> case VAR_14 : METHOD_9 ( VAR_82 -> VAR_85 == VAR_86 ) ; <S2SV_ModStart> case VAR_25 : METHOD_9 ( ( VAR_82 -> VAR_85 == VAR_87 ) || ( VAR_82 -> VAR_85 == VAR_88 ) ) ; <S2SV_ModStart> case VAR_47 : METHOD_9 ( VAR_82 -> VAR_85 == VAR_86 ) ; <S2SV_ModStart> case VAR_66 : METHOD_9 ( VAR_82 -> VAR_85 == VAR_86 ) ;,"CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> content_id , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; default : break ; } } } }",<S2SV_ModStart> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
194,"CWE-416 struct STRUCT_OR_UNION_0 * METHOD_0 ( const struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , const struct STRUCT_OR_UNION_3 * VAR_2 , TYPE_0 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = METHOD_1 ( VAR_5 ) ; const struct STRUCT_OR_UNION_5 * VAR_6 = METHOD_2 ( VAR_7 ) ; struct STRUCT_OR_UNION_6 * VAR_8 , VAR_9 ; struct STRUCT_OR_UNION_7 * VAR_10 ; METHOD_3 ( VAR_11 , 0 , sizeof ( * VAR_12 ) ) ; VAR_13 -> VAR_14 = VAR_15 ; VAR_16 -> VAR_17 = VAR_18 -> VAR_19 ; <S2SV_StartBug> VAR_20 = METHOD_4 ( VAR_21 , VAR_22 -> VAR_23 , & VAR_24 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_25 -> VAR_26 = VAR_27 -> VAR_28 ; <S2SV_EndBug> VAR_29 -> VAR_30 = VAR_31 -> VAR_32 ; VAR_33 -> VAR_34 = VAR_35 -> VAR_36 ; VAR_37 -> VAR_38 = VAR_39 -> VAR_40 ; VAR_41 -> VAR_42 = METHOD_5 ( VAR_43 -> VAR_44 ) ; METHOD_6 ( VAR_45 , METHOD_7 ( VAR_46 ) ) ; VAR_47 = METHOD_8 ( VAR_48 , VAR_49 , VAR_50 ) ; if ( METHOD_9 ( VAR_51 ) ) return VAR_52 ; return VAR_53 ; }","<S2SV_ModStart> -> VAR_19 ; METHOD_10 ( ) ; <S2SV_ModStart> ( VAR_49 , METHOD_11 ( <S2SV_ModStart> VAR_22 -> VAR_23 ) <S2SV_ModStart> VAR_24 ) ; METHOD_12 ( ) ;","CWE-416 struct dst_entry * inet6_csk_route_req ( const struct sock * sk , struct flowi6 * fl6 , const struct request_sock * req , u8 proto ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = proto ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> fl6 -> flowi6_oif = ireq -> ir_iif ; fl6 -> flowi6_mark = ireq -> ir_mark ; fl6 -> fl6_dport = ireq -> ir_rmt_port ; fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( IS_ERR ( dst ) ) return NULL ; return dst ; }","<S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;"
195,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { struct STRUCT_OR_UNION_2 * VAR_0 , * VAR_1 = VAR_2 ; struct STRUCT_OR_UNION_3 * VAR_3 ; TYPE_1 VAR_4 ; VAR_5 = METHOD_1 ( sizeof ( struct STRUCT_OR_UNION_4 ) , VAR_6 ) ; METHOD_2 ( & STRUCT_OR_UNION_5 -> VAR_7 . VAR_8 ) ; if ( ! VAR_9 ) goto VAR_10 ; VAR_11 -> VAR_12 = 8 ; VAR_13 -> VAR_14 = 8 ; VAR_15 -> VAR_16 = 0 ; VAR_17 -> VAR_18 = 0xff ; METHOD_3 ( VAR_19 , VAR_20 , STRUCT_OR_UNION_6 ) { struct STRUCT_OR_UNION_7 * VAR_21 = VAR_22 -> VAR_23 . VAR_24 ; TYPE_2 VAR_25 , VAR_26 ; TYPE_3 VAR_27 ; if ( ! METHOD_4 ( VAR_28 ) ) continue ; if ( METHOD_5 ( VAR_29 ) ) { VAR_30 -> VAR_31 = 32 ; VAR_32 -> VAR_33 = 16 ; <S2SV_StartBug> VAR_34 -> VAR_35 = VAR_36 -> VAR_37 = 0xffff ; <S2SV_EndBug> } else if ( METHOD_6 ( VAR_38 ) && ! VAR_39 -> VAR_40 && METHOD_7 ( VAR_41 , VAR_42 ) == VAR_43 ) { VAR_44 -> VAR_45 = 4 ; VAR_46 -> VAR_47 = 0xf ; VAR_48 -> VAR_49 = 0xf ; } VAR_50 -> VAR_51 [ METHOD_8 ( VAR_52 ) ] = VAR_53 ; VAR_54 = METHOD_9 ( VAR_55 , VAR_56 ) ; VAR_57 = METHOD_10 ( VAR_58 , VAR_59 ) ; VAR_60 = METHOD_11 ( VAR_61 , VAR_62 ) ; if ( VAR_63 ) VAR_64 -> VAR_65 [ VAR_66 ] [ METHOD_12 ( VAR_67 ) - 1 ] = VAR_68 ; } VAR_69 : VAR_70 = METHOD_13 ( STRUCT_OR_UNION_8 -> VAR_71 . VAR_72 , METHOD_14 ( & STRUCT_OR_UNION_9 -> VAR_73 . VAR_74 ) ) ; METHOD_15 ( STRUCT_OR_UNION_10 -> VAR_75 . VAR_76 , VAR_77 ) ; METHOD_16 ( & STRUCT_OR_UNION_11 -> VAR_78 . VAR_79 ) ; if ( VAR_80 ) METHOD_17 ( VAR_81 , VAR_82 ) ; METHOD_18 ( STRUCT_OR_UNION_12 ) ; }",<S2SV_ModStart> -> VAR_47 = ( 1 << VAR_83 ) - 1 ;,"CWE-189 static void recalculate_apic_map ( struct kvm * kvm ) { struct kvm_apic_map * new , * old = NULL ; struct kvm_vcpu * vcpu ; int i ; new = kzalloc ( sizeof ( struct kvm_apic_map ) , GFP_KERNEL ) ; mutex_lock ( & kvm -> arch . apic_map_lock ) ; if ( ! new ) goto out ; new -> ldr_bits = 8 ; new -> cid_shift = 8 ; new -> cid_mask = 0 ; new -> lid_mask = 0xff ; kvm_for_each_vcpu ( i , vcpu , kvm ) { struct kvm_lapic * apic = vcpu -> arch . apic ; u16 cid , lid ; u32 ldr ; if ( ! kvm_apic_present ( vcpu ) ) continue ; if ( apic_x2apic_mode ( apic ) ) { new -> ldr_bits = 32 ; new -> cid_shift = 16 ; <S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> } else if ( kvm_apic_sw_enabled ( apic ) && ! new -> cid_mask && kvm_apic_get_reg ( apic , APIC_DFR ) == APIC_DFR_CLUSTER ) { new -> cid_shift = 4 ; new -> cid_mask = 0xf ; new -> lid_mask = 0xf ; } new -> phys_map [ kvm_apic_id ( apic ) ] = apic ; ldr = kvm_apic_get_reg ( apic , APIC_LDR ) ; cid = apic_cluster_id ( new , ldr ) ; lid = apic_logical_id ( new , ldr ) ; if ( lid ) new -> logical_map [ cid ] [ ffs ( lid ) - 1 ] = apic ; } out : old = rcu_dereference_protected ( kvm -> arch . apic_map , lockdep_is_held ( & kvm -> arch . apic_map_lock ) ) ; rcu_assign_pointer ( kvm -> arch . apic_map , new ) ; mutex_unlock ( & kvm -> arch . apic_map_lock ) ; if ( old ) kfree_rcu ( old , rcu ) ; kvm_vcpu_request_scan_ioapic ( kvm ) ; }",<S2SV_ModStart> -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;
196,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = 0 ; TYPE_3 VAR_3 , VAR_4 ; unsigned TYPE_4 VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 ; TYPE_5 VAR_8 ; struct STRUCT_OR_UNION_5 VAR_9 ; TYPE_6 VAR_10 = 0 ; if ( ! METHOD_1 ( STRUCT_OR_UNION_6 -> VAR_11 ) -> VAR_12 ) return 0 ; METHOD_2 ( & VAR_13 , STRUCT_OR_UNION_7 ) ; METHOD_3 ( VAR_14 , STRUCT_OR_UNION_8 , & VAR_15 ) ; if ( VAR_16 & VAR_17 ) { VAR_18 . VAR_19 += 14 ; VAR_20 . VAR_21 -= 14 ; if ( VAR_22 . VAR_23 < 0 ) VAR_24 . VAR_25 = 0 ; } VAR_26 : while ( VAR_27 . VAR_28 > 2 ) { VAR_29 = ( struct STRUCT_OR_UNION_9 * ) VAR_30 . VAR_31 ; if ( VAR_32 -> VAR_33 < 3 ) goto VAR_34 ; VAR_35 = METHOD_4 ( VAR_36 . VAR_37 ) ; if ( METHOD_5 ( & VAR_38 , VAR_39 ) ) goto VAR_40 ; VAR_41 . VAR_42 += VAR_43 -> VAR_44 ; VAR_45 . VAR_46 -= VAR_47 -> VAR_48 ; if ( VAR_49 . VAR_50 < 0 ) goto VAR_51 ; switch ( VAR_52 ) { TYPE_7 TYPE_8 case METHOD_6 ( 'R' , 'R' ) : if ( ( VAR_53 -> VAR_54 . VAR_55 . VAR_56 [ 0 ] & ( VAR_57 | VAR_58 | VAR_59 | VAR_60 ) ) == 0 ) goto VAR_61 ; break ; case METHOD_7 ( 'S' , 'P' ) : if ( METHOD_8 ( VAR_62 , STRUCT_OR_UNION_10 ) ) goto VAR_63 ; break ; case METHOD_9 ( 'C' , 'E' ) : VAR_64 . VAR_65 = METHOD_10 ( VAR_66 -> VAR_67 . VAR_68 . VAR_69 ) ; VAR_70 . VAR_71 = METHOD_11 ( VAR_72 -> VAR_73 . VAR_74 . VAR_75 ) ; VAR_76 . VAR_77 = METHOD_12 ( VAR_78 -> VAR_79 . VAR_80 . VAR_81 ) ; break ; case METHOD_13 ( 'E' , 'R' ) : <S2SV_StartBug> METHOD_14 ( STRUCT_OR_UNION_11 -> VAR_82 ) -> VAR_83 = 1 ; <S2SV_EndBug> METHOD_15 ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { TYPE_9 VAR_84 ; for ( VAR_85 = 0 ; VAR_86 < VAR_87 -> VAR_88 . VAR_89 . VAR_90 ; VAR_91 ++ ) METHOD_16 ( ""%c"" , VAR_92 -> VAR_93 . VAR_94 . VAR_95 [ VAR_96 ] ) ; } METHOD_17 ( ""\\n"" ) ; break ; case METHOD_18 ( 'P' , 'X' ) : STRUCT_OR_UNION_12 -> VAR_97 = METHOD_19 ( VAR_98 -> VAR_99 . VAR_100 . VAR_101 ) ; METHOD_20 ( STRUCT_OR_UNION_13 , METHOD_21 ( VAR_102 -> VAR_103 . VAR_104 . VAR_105 ) ) ; METHOD_22 ( STRUCT_OR_UNION_14 , METHOD_23 ( VAR_106 -> VAR_107 . VAR_108 . VAR_109 ) ) ; METHOD_24 ( STRUCT_OR_UNION_15 , METHOD_25 ( VAR_110 -> VAR_111 . VAR_112 . VAR_113 ) ) ; break ; case METHOD_26 ( 'P' , 'N' ) : { TYPE_10 VAR_114 , VAR_115 ; VAR_116 = METHOD_27 ( VAR_117 -> VAR_118 . VAR_119 . VAR_120 ) ; VAR_121 = METHOD_28 ( VAR_122 -> VAR_123 . VAR_124 . VAR_125 ) ; if ( ( VAR_126 & ~ 0xff ) && VAR_127 == 0 ) { STRUCT_OR_UNION_16 -> VAR_128 = METHOD_29 ( VAR_129 >> 8 , VAR_130 & 0xff ) ; } else { STRUCT_OR_UNION_17 -> VAR_131 = METHOD_30 ( VAR_132 , VAR_133 ) ; } } break ; case METHOD_31 ( 'T' , 'F' ) : VAR_134 = 0 ; if ( VAR_135 -> VAR_136 . VAR_137 . VAR_138 & VAR_139 ) { STRUCT_OR_UNION_18 -> VAR_140 . VAR_141 = METHOD_32 ( VAR_142 -> VAR_143 . VAR_144 . VAR_145 [ VAR_146 ++ ] . VAR_147 , 0 ) ; STRUCT_OR_UNION_19 -> VAR_148 . VAR_149 = 0 ; } if ( VAR_150 -> VAR_151 . VAR_152 . VAR_153 & VAR_154 ) { STRUCT_OR_UNION_20 -> VAR_155 . VAR_156 = METHOD_33 ( VAR_157 -> VAR_158 . VAR_159 . VAR_160 [ VAR_161 ++ ] . VAR_162 , 0 ) ; STRUCT_OR_UNION_21 -> VAR_163 . VAR_164 = 0 ; } if ( VAR_165 -> VAR_166 . VAR_167 . VAR_168 & VAR_169 ) { STRUCT_OR_UNION_22 -> VAR_170 . VAR_171 = METHOD_34 ( VAR_172 -> VAR_173 . VAR_174 . VAR_175 [ VAR_176 ++ ] . VAR_177 , 0 ) ; STRUCT_OR_UNION_23 -> VAR_178 . VAR_179 = 0 ; } if ( VAR_180 -> VAR_181 . VAR_182 . VAR_183 & VAR_184 ) { STRUCT_OR_UNION_24 -> VAR_185 . VAR_186 = METHOD_35 ( VAR_187 -> VAR_188 . VAR_189 . VAR_190 [ VAR_191 ++ ] . VAR_192 , 0 ) ; STRUCT_OR_UNION_25 -> VAR_193 . VAR_194 = 0 ; } break ; case METHOD_36 ( 'S' , 'L' ) : { TYPE_11 VAR_195 ; struct STRUCT_OR_UNION_26 * VAR_196 ; struct STRUCT_OR_UNION_27 * VAR_197 ; VAR_198 = VAR_199 -> VAR_200 - 5 ; VAR_201 = & VAR_202 -> VAR_203 . VAR_204 . VAR_205 ; STRUCT_OR_UNION_28 -> VAR_206 = VAR_207 ; while ( VAR_208 > 1 ) { VAR_209 = 0 ; switch ( VAR_210 -> VAR_211 & ~ 1 ) { case 0 : STRUCT_OR_UNION_29 -> VAR_212 += VAR_213 -> VAR_214 ; break ; case 2 : STRUCT_OR_UNION_30 -> VAR_215 += 1 ; break ; case 4 : STRUCT_OR_UNION_31 -> VAR_216 += 2 ; break ; case 8 : VAR_217 = 1 ; STRUCT_OR_UNION_32 -> VAR_218 += 1 ; break ; default : METHOD_37 ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } VAR_219 -= VAR_220 -> VAR_221 + 2 ; VAR_222 = VAR_223 ; VAR_224 = ( struct STRUCT_OR_UNION_33 * ) ( ( ( TYPE_12 * ) VAR_225 ) + VAR_226 -> VAR_227 + 2 ) ; if ( VAR_228 < 2 ) { if ( ( ( VAR_229 -> VAR_230 . VAR_231 . VAR_232 & 1 ) != 0 ) && ( ( VAR_233 -> VAR_234 & 1 ) == 0 ) ) STRUCT_OR_UNION_34 -> VAR_235 += 1 ; break ; } if ( ! VAR_236 && ( VAR_237 -> VAR_238 & 1 ) == 0 ) STRUCT_OR_UNION_35 -> VAR_239 += 1 ; } } VAR_240 = STRUCT_OR_UNION_36 -> VAR_241 ; break ; case METHOD_38 ( 'R' , 'E' ) : METHOD_39 ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto VAR_242 ; case METHOD_40 ( 'C' , 'L' ) : if ( VAR_243 & VAR_244 ) { METHOD_41 ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto VAR_245 ; } VAR_246 = METHOD_42 ( VAR_247 -> VAR_248 . VAR_249 . VAR_250 ) ; if ( VAR_251 == METHOD_43 ( STRUCT_OR_UNION_37 ) -> VAR_252 && METHOD_44 ( STRUCT_OR_UNION_38 ) -> VAR_253 == 0 ) { METHOD_45 ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto VAR_254 ; } METHOD_46 ( STRUCT_OR_UNION_39 ) -> VAR_255 = VAR_256 ; VAR_257 = METHOD_47 ( STRUCT_OR_UNION_40 -> VAR_258 , VAR_259 , 0 ) ; if ( METHOD_48 ( VAR_260 ) ) { VAR_261 = METHOD_49 ( VAR_262 ) ; goto VAR_263 ; } STRUCT_OR_UNION_41 -> VAR_264 = VAR_265 -> VAR_266 ; METHOD_50 ( STRUCT_OR_UNION_42 , VAR_267 -> VAR_268 ) ; STRUCT_OR_UNION_43 -> VAR_269 = VAR_270 -> VAR_271 ; STRUCT_OR_UNION_44 -> VAR_272 = VAR_273 -> VAR_274 ; STRUCT_OR_UNION_45 -> VAR_275 = VAR_276 -> VAR_277 ; STRUCT_OR_UNION_46 -> VAR_278 = VAR_279 -> VAR_280 ; STRUCT_OR_UNION_47 -> VAR_281 = VAR_282 -> VAR_283 ; STRUCT_OR_UNION_48 -> VAR_284 = VAR_285 -> VAR_286 ; STRUCT_OR_UNION_49 -> VAR_287 = VAR_288 -> VAR_289 ; STRUCT_OR_UNION_50 -> VAR_290 = VAR_291 -> VAR_292 ; METHOD_51 ( VAR_293 ) ; break ; TYPE_13 TYPE_14 case METHOD_52 ( 'Z' , 'F' ) : { TYPE_15 VAR_294 ; if ( METHOD_53 ( STRUCT_OR_UNION_51 -> VAR_295 ) -> VAR_296 ) break ; VAR_297 = METHOD_54 ( VAR_298 -> VAR_299 . VAR_300 . VAR_301 ) ; if ( VAR_302 == METHOD_55 ( 'p' , 'z' ) ) { TYPE_16 VAR_303 = METHOD_56 ( & VAR_304 -> VAR_305 . VAR_306 . VAR_307 [ 1 ] ) ; if ( VAR_308 > 17 ) { METHOD_57 ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , VAR_309 ) ; } else { METHOD_58 ( STRUCT_OR_UNION_52 ) -> VAR_310 = VAR_311 ; METHOD_59 ( STRUCT_OR_UNION_53 ) -> VAR_312 [ 0 ] = METHOD_60 ( & VAR_313 -> VAR_314 . VAR_315 . VAR_316 [ 0 ] ) ; METHOD_61 ( STRUCT_OR_UNION_54 ) -> VAR_317 [ 1 ] = METHOD_62 ( & VAR_318 -> VAR_319 . VAR_320 . VAR_321 [ 1 ] ) ; STRUCT_OR_UNION_55 -> VAR_322 = METHOD_63 ( VAR_323 -> VAR_324 . VAR_325 . VAR_326 ) ; } } else { METHOD_64 ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , VAR_327 -> VAR_328 . VAR_329 . VAR_330 [ 0 ] , VAR_331 -> VAR_332 . VAR_333 . VAR_334 [ 1 ] ) ; } break ; } default : break ; } } VAR_335 = METHOD_65 ( & VAR_336 ) ; if ( VAR_337 == 0 ) goto VAR_338 ; if ( VAR_339 == 1 ) VAR_340 = 0 ; VAR_341 : METHOD_66 ( VAR_342 . VAR_343 ) ; return VAR_344 ; VAR_345 : VAR_346 = - VAR_347 ; goto VAR_348 ; }","<S2SV_ModStart> 'R' ) : if ( VAR_331 -> VAR_332 . VAR_94 . VAR_90 + VAR_349 ( struct STRUCT_OR_UNION_9 , VAR_332 . VAR_94 . VAR_95 ) > VAR_331 -> VAR_227 ) goto VAR_348 ;","CWE-20 static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , struct inode * inode , int flags ) { int symlink_len = 0 ; int cnt , sig ; unsigned int reloc_block ; struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; if ( flags & RR_REGARD_XA ) { rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) {  ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ;   case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : <S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block ; reloc = isofs_iget_reloc ( inode -> i_sb , reloc_block , 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ;  ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; }   default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","<S2SV_ModStart> 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;"
197,"CWE-125 int METHOD_0 ( TYPE_0 * VAR_0 , const TYPE_1 * VAR_1 , const TYPE_2 * VAR_2 _U_ ) { const struct STRUCT_OR_UNION_0 * VAR_3 ; const TYPE_3 * VAR_4 ; unsigned VAR_5 , VAR_6 ; TYPE_4 VAR_7 ; VAR_8 = ( const struct STRUCT_OR_UNION_1 * ) VAR_9 ; VAR_10 = VAR_11 -> VAR_12 ; if ( ! METHOD_1 ( VAR_13 -> VAR_14 ) ) { VAR_15 = VAR_16 - VAR_17 ; goto VAR_18 ; } VAR_19 = ( VAR_20 -> VAR_21 + 1 ) << 3 ; METHOD_2 ( VAR_22 -> VAR_23 ) ; VAR_24 = VAR_25 -> VAR_26 ; if ( VAR_27 <= VAR_28 && VAR_29 < VAR_30 [ VAR_31 ] ) { METHOD_3 ( ( VAR_32 , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , VAR_33 , VAR_34 ) ) ; goto VAR_35 ; } METHOD_4 ( ( VAR_36 , ""mobility:<S2SV_blank>%s"" , METHOD_5 ( VAR_37 , ""type-%u"" , VAR_38 ) ) ) ; switch ( VAR_39 ) { case VAR_40 : VAR_41 = VAR_42 ; break ; case VAR_43 : case VAR_44 : VAR_45 = VAR_46 ; if ( VAR_47 -> VAR_48 ) { METHOD_6 ( * VAR_49 , VAR_50 + 8 ) ; METHOD_7 ( ( VAR_51 , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , VAR_52 == VAR_53 ? ""Home"" : ""Care-of"" , METHOD_8 ( & VAR_54 [ VAR_55 ] ) , METHOD_9 ( & VAR_56 [ VAR_57 + 4 ] ) ) ) ; } VAR_58 += 8 ; break ; case VAR_59 : case VAR_60 : METHOD_10 ( VAR_61 -> VAR_62 [ 0 ] ) ; METHOD_11 ( ( VAR_63 , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , METHOD_12 ( & VAR_64 -> VAR_65 [ 0 ] ) ) ) ; VAR_66 = VAR_67 ; if ( VAR_68 -> VAR_69 ) { METHOD_13 ( * VAR_70 , VAR_71 + 8 ) ; METHOD_14 ( ( VAR_72 , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , VAR_73 == VAR_74 ? ""Home"" : ""Care-of"" , METHOD_15 ( & VAR_75 [ VAR_76 ] ) , METHOD_16 ( & VAR_77 [ VAR_78 + 4 ] ) ) ) ; } VAR_79 += 8 ; if ( VAR_80 -> VAR_81 ) { METHOD_17 ( * VAR_82 , VAR_83 + 8 ) ; METHOD_18 ( ( VAR_84 , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , VAR_85 == VAR_86 ? ""Home"" : ""Care-of"" , METHOD_19 ( & VAR_87 [ VAR_88 ] ) , METHOD_20 ( & VAR_89 [ VAR_90 + 4 ] ) ) ) ; } VAR_91 += 8 ; break ; case VAR_92 : METHOD_21 ( VAR_93 -> VAR_94 [ 0 ] ) ; METHOD_22 ( ( VAR_95 , ""<S2SV_blank>seq=%u"" , METHOD_23 ( & VAR_96 -> VAR_97 [ 0 ] ) ) ) ; VAR_98 = VAR_99 ; METHOD_24 ( * VAR_100 , VAR_101 + 1 ) ; if ( VAR_102 [ VAR_103 ] & 0xf0 ) METHOD_25 ( ( VAR_104 , ""<S2SV_blank>"" ) ) ; if ( VAR_105 [ VAR_106 ] & 0x80 ) METHOD_26 ( ( VAR_107 , ""A"" ) ) ; if ( VAR_108 [ VAR_109 ] & 0x40 ) METHOD_27 ( ( VAR_110 , ""H"" ) ) ; if ( VAR_111 [ VAR_112 ] & 0x20 ) METHOD_28 ( ( VAR_113 , ""L"" ) ) ; if ( VAR_114 [ VAR_115 ] & 0x10 ) METHOD_29 ( ( VAR_116 , ""K"" ) ) ; VAR_117 += 1 ; VAR_118 += 1 ; METHOD_30 ( * VAR_119 , VAR_120 + 2 ) ; METHOD_31 ( ( VAR_121 , ""<S2SV_blank>lifetime=%u"" , METHOD_32 ( & VAR_122 [ VAR_123 ] ) << 2 ) ) ; VAR_124 += 2 ; break ; case VAR_125 : METHOD_33 ( VAR_126 -> VAR_127 [ 0 ] ) ; METHOD_34 ( ( VAR_128 , ""<S2SV_blank>status=%u"" , VAR_129 -> VAR_130 [ 0 ] ) ) ; if ( VAR_131 -> VAR_132 [ 1 ] & 0x80 ) METHOD_35 ( ( VAR_133 , ""<S2SV_blank>K"" ) ) ; VAR_134 = VAR_135 ; METHOD_36 ( * VAR_136 , VAR_137 + 2 ) ; METHOD_37 ( ( VAR_138 , ""<S2SV_blank>seq=%u"" , METHOD_38 ( & VAR_139 [ VAR_140 ] ) ) ) ; VAR_141 += 2 ; METHOD_39 ( * VAR_142 , VAR_143 + 2 ) ; METHOD_40 ( ( VAR_144 , ""<S2SV_blank>lifetime=%u"" , METHOD_41 ( & VAR_145 [ VAR_146 ] ) << 2 ) ) ; VAR_147 += 2 ; break ; case VAR_148 : METHOD_42 ( VAR_149 -> VAR_150 [ 0 ] ) ; METHOD_43 ( ( VAR_151 , ""<S2SV_blank>status=%u"" , VAR_152 -> VAR_153 [ 0 ] ) ) ; VAR_154 = VAR_155 ; METHOD_44 ( * VAR_156 , VAR_157 + 16 ) ; METHOD_45 ( ( VAR_158 , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , METHOD_46 ( VAR_159 , & VAR_160 [ VAR_161 ] ) ) ) ; VAR_162 += 16 ; break ; default : METHOD_47 ( ( VAR_163 , ""<S2SV_blank>len=%u"" , VAR_164 -> VAR_165 ) ) ; return ( VAR_166 ) ; break ; } if ( VAR_167 -> VAR_168 ) if ( METHOD_48 ( VAR_169 , & VAR_170 [ VAR_171 ] , VAR_172 - VAR_173 ) ) goto VAR_174 ; return ( VAR_175 ) ; VAR_176 : METHOD_49 ( ( VAR_177 , ""%s"" , VAR_178 ) ) ; <S2SV_StartBug> return ( VAR_179 ) ; <S2SV_EndBug> }",<S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; },"CWE-125 int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 1 ) ; if ( bp [ hlen ] & 0xf0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ; hlen += 1 ; hlen += 1 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 16 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> }",<S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
198,"CWE-20 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 ) { TYPE_7 * VAR_6 , * VAR_7 = VAR_8 ; struct STRUCT_OR_UNION_0 STRUCT_OR_UNION_1 ; <S2SV_StartBug> TYPE_8 VAR_9 = 0 ; <S2SV_EndBug> if ( ! VAR_10 ) { TYPE_9 VAR_11 ; for ( VAR_12 = 1 ; VAR_13 < VAR_14 ; VAR_15 ++ ) { if ( ! METHOD_1 ( VAR_16 [ VAR_17 ] , VAR_18 ) ) { * VAR_19 = VAR_20 ; return 0 ; } } * VAR_21 = VAR_22 ; return 0 ; } * VAR_23 = VAR_24 ; VAR_25 = METHOD_2 ( VAR_26 + 1 , VAR_27 ) ; if ( ! VAR_28 ) return - VAR_29 ; METHOD_3 ( VAR_30 , VAR_31 , VAR_32 ) ; VAR_33 [ VAR_34 ] = 0 ; if ( VAR_35 ) { VAR_36 = - VAR_37 ; VAR_38 = METHOD_4 ( VAR_39 , VAR_40 ) ; if ( ! VAR_41 ) goto VAR_42 ; } METHOD_5 ( & VAR_43 ) ; VAR_44 = METHOD_6 ( & VAR_45 , & VAR_46 , VAR_47 , VAR_48 , & STRUCT_OR_UNION_2 , VAR_49 ) ; if ( VAR_50 == - VAR_51 && VAR_52 ) { STRUCT_OR_UNION_3 . VAR_53 = VAR_54 ; STRUCT_OR_UNION_4 . VAR_55 = VAR_56 ; VAR_57 = VAR_58 ; } else if ( VAR_59 ) goto VAR_60 ; VAR_61 = METHOD_7 ( & VAR_62 , & STRUCT_OR_UNION_5 , VAR_63 ) ; METHOD_8 ( & STRUCT_OR_UNION_6 ) ; VAR_64 : METHOD_9 ( & VAR_65 ) ; VAR_66 : METHOD_10 ( VAR_67 ) ; METHOD_11 ( VAR_68 ) ; return VAR_69 ; }",<S2SV_ModStart> VAR_69 = 0 ; if ( ! VAR_56 ) return - VAR_51,"CWE-20 static int security_context_to_sid_core ( const char * scontext , u32 scontext_len , u32 * sid , u32 def_sid , gfp_t gfp_flags , int force ) { char * scontext2 , * str = NULL ; struct context context ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> if ( ! ss_initialized ) { int i ; for ( i = 1 ; i < SECINITSID_NUM ; i ++ ) { if ( ! strcmp ( initial_sid_to_string [ i ] , scontext ) ) { * sid = i ; return 0 ; } } * sid = SECINITSID_KERNEL ; return 0 ; } * sid = SECSID_NULL ; scontext2 = kmalloc ( scontext_len + 1 , gfp_flags ) ; if ( ! scontext2 ) return - ENOMEM ; memcpy ( scontext2 , scontext , scontext_len ) ; scontext2 [ scontext_len ] = 0 ; if ( force ) { rc = - ENOMEM ; str = kstrdup ( scontext2 , gfp_flags ) ; if ( ! str ) goto out ; } read_lock ( & policy_rwlock ) ; rc = string_to_context_struct ( & policydb , & sidtab , scontext2 , scontext_len , & context , def_sid ) ; if ( rc == - EINVAL && force ) { context . str = str ; context . len = scontext_len ; str = NULL ; } else if ( rc ) goto out_unlock ; rc = sidtab_context_to_sid ( & sidtab , & context , sid ) ; context_destroy ( & context ) ; out_unlock : read_unlock ( & policy_rwlock ) ; out : kfree ( scontext2 ) ; kfree ( str ) ; return rc ; }",<S2SV_ModStart> rc = 0 ; if ( ! scontext_len ) return - EINVAL
199,"CWE-119 TYPE_0 TYPE_1 METHOD_0 ( TYPE_2 * VAR_0 , const TYPE_3 * VAR_1 , unsigned TYPE_4 * * VAR_2 , unsigned TYPE_5 * * VAR_3 , TYPE_6 * * VAR_4 , unsigned TYPE_7 * VAR_5 , unsigned TYPE_8 * VAR_6 , unsigned TYPE_9 * VAR_7 ) { VAR_8 * VAR_9 ; const unsigned TYPE_10 VAR_10 = 512 ; TYPE_11 VAR_11 [ 512 + 1 ] ; unsigned TYPE_12 VAR_12 = 0 ; unsigned TYPE_13 * VAR_13 = VAR_14 ; unsigned TYPE_14 VAR_15 = 0 ; VAR_16 = METHOD_1 ( VAR_17 , ""r"" ) ; if ( VAR_18 == VAR_19 ) { METHOD_2 ( VAR_20 , VAR_21 ) ; return ; } while ( METHOD_3 ( VAR_22 , VAR_23 , VAR_24 ) != VAR_25 ) { if ( METHOD_4 ( VAR_26 ) == VAR_27 ) { METHOD_5 ( * VAR_28 ) ; METHOD_6 ( * VAR_29 ) ; METHOD_7 ( * VAR_30 ) ; METHOD_8 ( VAR_31 ) ; * VAR_32 = 0 ; * VAR_33 = 0 ; * VAR_34 = 0 ; METHOD_9 ( VAR_35 ) ; METHOD_10 ( VAR_36 , VAR_37 ) ; return ; } if ( VAR_38 [ 0 ] == '%' ) { continue ; } else { if ( VAR_39 == 0 ) { <S2SV_StartBug> if ( METHOD_11 ( VAR_40 , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , VAR_41 , VAR_42 , VAR_43 ) == 3 ) { <S2SV_EndBug> * VAR_44 = ( unsigned TYPE_15 * ) METHOD_12 ( sizeof ( unsigned TYPE_16 ) * ( * VAR_45 ) ) ; * VAR_46 = ( unsigned TYPE_17 * ) METHOD_13 ( sizeof ( unsigned TYPE_18 ) * ( ( TYPE_19 ) ( * VAR_47 ) + 1 ) ) ; * VAR_48 = ( TYPE_20 * ) METHOD_14 ( sizeof ( TYPE_21 ) * ( * VAR_49 ) ) ; VAR_50 = ( unsigned TYPE_22 * ) METHOD_15 ( sizeof ( unsigned TYPE_23 ) * ( * VAR_51 ) ) ; if ( ( * VAR_52 == VAR_53 ) || ( * VAR_54 == VAR_55 ) || ( * VAR_56 == VAR_57 ) || ( VAR_58 == VAR_59 ) ) { METHOD_16 ( * VAR_60 ) ; METHOD_17 ( * VAR_61 ) ; METHOD_18 ( * VAR_62 ) ; METHOD_19 ( VAR_63 ) ; * VAR_64 = 0 ; * VAR_65 = 0 ; * VAR_66 = 0 ; METHOD_20 ( VAR_67 ) ; METHOD_21 ( VAR_68 , VAR_69 ) ; return ; } METHOD_22 ( * VAR_70 , 0 , sizeof ( unsigned TYPE_24 ) * ( ( TYPE_25 ) ( * VAR_71 ) + 1 ) ) ; METHOD_23 ( * VAR_72 , 0 , sizeof ( unsigned TYPE_26 ) * ( * VAR_73 ) ) ; METHOD_24 ( * VAR_74 , 0 , sizeof ( TYPE_27 ) * ( * VAR_75 ) ) ; METHOD_25 ( VAR_76 , 0 , sizeof ( unsigned TYPE_28 ) * ( * VAR_77 ) ) ; for ( VAR_78 = 0 ; VAR_79 <= * VAR_80 ; ++ VAR_81 ) ( * VAR_82 ) [ VAR_83 ] = ( * VAR_84 ) ; ( * VAR_85 ) [ 0 ] = 0 ; VAR_86 = 0 ; VAR_87 = 1 ; } else { METHOD_26 ( VAR_88 , VAR_89 ) ; METHOD_27 ( VAR_90 ) ; return ; } } else { unsigned TYPE_29 VAR_91 = 0 , VAR_92 = 0 ; TYPE_30 VAR_93 = 0 ; if ( METHOD_28 ( VAR_94 , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & VAR_95 , & VAR_96 , & VAR_97 ) != 3 ) { METHOD_29 ( * VAR_98 ) ; METHOD_30 ( * VAR_99 ) ; METHOD_31 ( * VAR_100 ) ; METHOD_32 ( VAR_101 ) ; * VAR_102 = 0 ; * VAR_103 = 0 ; * VAR_104 = 0 ; METHOD_33 ( VAR_105 ) ; METHOD_34 ( VAR_106 , VAR_107 ) ; return ; } <S2SV_StartBug> VAR_108 -- ; <S2SV_EndBug> VAR_109 -- ; ( * VAR_110 ) [ VAR_111 ] = VAR_112 ; ( * VAR_113 ) [ VAR_114 ] = VAR_115 ; VAR_116 ++ ; VAR_117 [ VAR_118 ] = 1 ; ( * VAR_119 ) [ VAR_120 + 1 ] = VAR_121 ; } } } METHOD_35 ( VAR_122 ) ; if ( VAR_123 != ( * VAR_124 ) ) { METHOD_36 ( * VAR_125 ) ; METHOD_37 ( * VAR_126 ) ; METHOD_38 ( * VAR_127 ) ; METHOD_39 ( VAR_128 ) ; * VAR_129 = 0 ; * VAR_130 = 0 ; * VAR_131 = 0 ; METHOD_40 ( VAR_132 , VAR_133 ) ; return ; } if ( VAR_134 != VAR_135 ) { for ( VAR_136 = 0 ; VAR_137 < ( * VAR_138 ) ; VAR_139 ++ ) { if ( VAR_140 [ VAR_141 ] == 0 ) { ( * VAR_142 ) [ VAR_143 + 1 ] = ( * VAR_144 ) [ VAR_145 ] ; } } METHOD_41 ( VAR_146 ) ; } }","<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , VAR_124 ) && 0 != * VAR_138 && 0 != * VAR_42 && 0 != * VAR_124 ) <S2SV_ModEnd> { * VAR_130 <S2SV_ModStart> return ; } METHOD_42 ( 0 != VAR_120 && 0 != VAR_112 ) ;","CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csr_reader ( libxsmm_generated_code * io_generated_code , const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i <= * o_row_count ; ++ l_i ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_DESC ) ; fclose ( l_csr_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_ELEMS ) ; return ; } <S2SV_StartBug> l_row -- ; <S2SV_EndBug> l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_LEN ) ; return ; } if ( l_row_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } free ( l_row_idx_id ) ; } }","<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx <S2SV_ModStart> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;"
200,"CWE-617 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 , VAR_5 , VAR_6 ; if ( VAR_7 -> VAR_8 ) { TYPE_6 VAR_9 , VAR_10 , VAR_11 = VAR_12 -> VAR_13 ; <S2SV_StartBug> TYPE_7 * VAR_14 = METHOD_1 ( VAR_15 , VAR_16 ) ; <S2SV_EndBug> for ( VAR_17 = 0 ; VAR_18 < VAR_19 -> VAR_20 ; ++ VAR_21 ) { for ( VAR_22 = 0 ; VAR_23 < VAR_24 ; ++ VAR_25 ) VAR_26 -> VAR_27 [ VAR_28 ] [ VAR_29 + VAR_30 ] = VAR_31 -> VAR_32 [ VAR_33 ] [ VAR_34 + VAR_35 ] * VAR_36 [ VAR_37 ] + VAR_38 -> VAR_39 [ VAR_40 ] [ VAR_41 ] * VAR_42 [ VAR_43 - 1 - VAR_44 ] ; } } VAR_45 = VAR_46 -> VAR_47 ; VAR_48 -> VAR_49 = VAR_50 - VAR_51 ; for ( VAR_52 = 0 ; VAR_53 < VAR_54 -> VAR_55 ; ++ VAR_56 ) for ( VAR_57 = 0 ; VAR_58 + VAR_59 < VAR_60 ; ++ VAR_61 ) VAR_62 -> VAR_63 [ VAR_64 ] [ VAR_65 ] = VAR_66 -> VAR_67 [ VAR_68 ] [ VAR_69 + VAR_70 ] ; if ( ! VAR_71 ) return 0 ; if ( VAR_72 < VAR_73 ) VAR_74 = VAR_75 ; VAR_76 -> VAR_77 += VAR_78 - VAR_79 ; return VAR_80 - VAR_81 ; }","<S2SV_ModStart> , VAR_43 ) ; if ( VAR_42 == VAR_82 ) return 0","CWE-617 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }","<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0"
201,"CWE-20 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 , VAR_4 = VAR_5 , VAR_6 = VAR_7 ; TYPE_5 VAR_8 ; TYPE_6 VAR_9 ; VAR_10 * TYPE_7 ; TYPE_8 VAR_11 ; TYPE_9 VAR_12 , VAR_13 ; METHOD_1 ( VAR_14 != ( const TYPE_10 * ) VAR_15 ) ; METHOD_2 ( VAR_16 -> VAR_17 == VAR_18 ) ; if ( VAR_19 -> VAR_20 != VAR_21 ) ( TYPE_11 ) METHOD_3 ( VAR_22 , METHOD_4 ( ) , ""%s"" , VAR_23 -> VAR_24 ) ; METHOD_5 ( VAR_25 != ( TYPE_12 * ) VAR_26 ) ; METHOD_6 ( VAR_27 -> VAR_28 == VAR_29 ) ; VAR_30 = METHOD_7 ( VAR_31 , VAR_32 ) ; VAR_33 = METHOD_8 ( VAR_34 , VAR_35 , VAR_36 , VAR_37 ) ; if ( VAR_38 == VAR_39 ) { VAR_40 = METHOD_9 ( VAR_41 ) ; return ( ( TYPE_13 * ) VAR_42 ) ; } <S2SV_StartBug> if ( METHOD_10 ( VAR_43 , & VAR_44 ) != VAR_45 ) { <S2SV_EndBug> METHOD_11 ( VAR_46 , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( VAR_47 . VAR_48 & VAR_49 ) VAR_50 = VAR_51 ; if ( VAR_52 . VAR_53 & VAR_54 && VAR_55 . VAR_56 > 0 ) VAR_57 = VAR_58 ; ( TYPE_14 ) METHOD_12 ( VAR_59 , 128 , VAR_60 ) ; if ( VAR_61 . VAR_62 . VAR_63 & VAR_64 ) { VAR_65 = VAR_66 ; if ( VAR_67 . VAR_68 . VAR_69 & VAR_70 ) { VAR_71 = VAR_72 ; TYPE_15 = VAR_73 ; } else { VAR_74 = VAR_75 ; TYPE_16 = VAR_76 ; } } else if ( VAR_77 . VAR_78 . VAR_79 & VAR_80 ) { VAR_81 = VAR_82 ; if ( VAR_83 . VAR_84 . VAR_85 & VAR_86 ) { METHOD_13 ( VAR_87 , ""ImageTypeNotSupported"" ) ; } else { VAR_88 = VAR_89 ; TYPE_17 = VAR_90 ; } } else if ( VAR_91 . VAR_92 . VAR_93 & VAR_94 ) { switch ( VAR_95 . VAR_96 . VAR_97 ) { case VAR_98 : { VAR_99 = VAR_100 ; VAR_101 = VAR_102 ; TYPE_18 = VAR_103 ; break ; } case VAR_104 : { VAR_105 = VAR_106 ; VAR_107 = VAR_108 ; TYPE_19 = VAR_109 ; break ; } case VAR_110 : { VAR_111 = VAR_112 ; VAR_113 = VAR_114 ; TYPE_20 = VAR_115 ; break ; } default : { METHOD_14 ( VAR_116 , ""ImageTypeNotSupported"" ) ; } } } else { METHOD_15 ( VAR_117 , ""ImageTypeNotSupported"" ) ; } VAR_118 = 1 ; if ( VAR_119 ) { VAR_120 = 0 ; if ( VAR_121 . VAR_122 & VAR_123 ) VAR_124 ++ ; if ( VAR_125 . VAR_126 & VAR_127 ) VAR_128 ++ ; if ( VAR_129 . VAR_130 & VAR_131 ) VAR_132 ++ ; if ( VAR_133 . VAR_134 & VAR_135 ) VAR_136 ++ ; if ( VAR_137 . VAR_138 & VAR_139 ) VAR_140 ++ ; if ( VAR_141 . VAR_142 & VAR_143 ) VAR_144 ++ ; } if ( VAR_145 ) VAR_146 = VAR_147 . VAR_148 ; <S2SV_StartBug> for ( VAR_149 = 0 ; VAR_150 < VAR_151 ; VAR_152 ++ ) <S2SV_EndBug> { if ( VAR_153 != 0 ) { METHOD_16 ( VAR_154 , VAR_155 , VAR_156 ) ; if ( METHOD_17 ( VAR_157 ) == ( TYPE_21 * ) VAR_158 ) return ( METHOD_18 ( VAR_159 ) ) ; VAR_160 = METHOD_19 ( VAR_161 ) ; } VAR_162 -> VAR_163 = VAR_164 ; VAR_165 -> VAR_166 = VAR_167 ; VAR_168 -> VAR_169 = VAR_170 . VAR_171 ; VAR_172 -> VAR_173 = VAR_174 . VAR_175 ; VAR_176 -> VAR_177 = VAR_178 ; VAR_179 -> VAR_180 = VAR_181 ; VAR_182 -> VAR_183 = 8 ; if ( VAR_184 -> VAR_185 != VAR_186 ) { ( TYPE_22 ) METHOD_20 ( VAR_187 ) ; return ( METHOD_21 ( VAR_188 ) ) ; } VAR_189 = METHOD_22 ( VAR_190 , VAR_191 -> VAR_192 , VAR_193 -> VAR_194 , VAR_195 ) ; if ( VAR_196 == VAR_197 ) return ( METHOD_23 ( VAR_198 ) ) ; if ( ( TYPE_23 ) ( VAR_199 , & VAR_200 , VAR_201 ) != VAR_202 ) { ( TYPE_24 ) METHOD_24 ( VAR_203 ) ; return ( METHOD_25 ( VAR_204 ) ) ; } } ( TYPE_25 ) METHOD_26 ( VAR_205 ) ; return ( METHOD_27 ( VAR_206 ) ) ; }","<S2SV_ModStart> != VAR_202 ) <S2SV_ModEnd> METHOD_15 ( VAR_117 <S2SV_ModStart> ""ImproperImageHeader"" ) ; <S2SV_ModEnd> if ( VAR_200 <S2SV_ModStart> . VAR_183 ; if ( VAR_151 < 1 ) METHOD_15 ( VAR_117 , ""ImproperImageHeader"" ) ;","CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; PixelTrait alpha_trait ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } <S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { alpha_trait = BlendPixelTrait ; decoder = ReadUncompressedRGBA ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { alpha_trait = UndefinedPixelTrait ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { alpha_trait = BlendPixelTrait ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { alpha_trait = BlendPixelTrait ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> { if ( n != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> alpha_trait = alpha_trait ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> != MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; <S2SV_ModEnd> if ( dds_info <S2SV_ModStart> . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;"
202,"CWE-119 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 * VAR_5 ; register TYPE_7 * VAR_6 ; register TYPE_8 VAR_7 , VAR_8 ; register unsigned TYPE_9 * VAR_9 ; TYPE_10 VAR_10 ; TYPE_11 VAR_11 , VAR_12 ; TYPE_12 VAR_13 , VAR_14 , VAR_15 ; unsigned TYPE_13 * VAR_16 ; METHOD_1 ( VAR_17 != ( const TYPE_14 * ) VAR_18 ) ; METHOD_2 ( VAR_19 -> VAR_20 == VAR_21 ) ; if ( VAR_22 -> VAR_23 != VAR_24 ) ( TYPE_15 ) METHOD_3 ( VAR_25 , METHOD_4 ( ) , ""%s"" , VAR_26 -> VAR_27 ) ; METHOD_5 ( VAR_28 != ( TYPE_16 * ) VAR_29 ) ; METHOD_6 ( VAR_30 -> VAR_31 == VAR_32 ) ; VAR_33 = METHOD_7 ( VAR_34 , VAR_35 ) ; VAR_36 = METHOD_8 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; if ( VAR_41 == VAR_42 ) { VAR_43 = METHOD_9 ( VAR_44 ) ; return ( ( TYPE_17 * ) VAR_45 ) ; } VAR_46 . VAR_47 = METHOD_10 ( VAR_48 ) ; do { if ( VAR_49 . VAR_50 != 0x01DA ) METHOD_11 ( VAR_51 , ""ImproperImageHeader"" ) ; VAR_52 . VAR_53 = ( unsigned TYPE_18 ) METHOD_12 ( VAR_54 ) ; switch ( VAR_55 . VAR_56 ) { case 0x00 : VAR_57 -> VAR_58 = VAR_59 ; break ; case 0x01 : VAR_60 -> VAR_61 = VAR_62 ; break ; default : METHOD_13 ( VAR_63 , ""ImproperImageHeader"" ) ; } VAR_64 . VAR_65 = ( unsigned TYPE_19 ) METHOD_14 ( VAR_66 ) ; if ( ( VAR_67 . VAR_68 == 0 ) || ( VAR_69 . VAR_70 > 2 ) ) METHOD_15 ( VAR_71 , ""ImproperImageHeader"" ) ; <S2SV_StartBug> VAR_72 . VAR_73 = METHOD_16 ( VAR_74 ) ; <S2SV_EndBug> VAR_75 . VAR_76 = METHOD_17 ( VAR_77 ) ; VAR_78 . VAR_79 = METHOD_18 ( VAR_80 ) ; VAR_81 . VAR_82 = METHOD_19 ( VAR_83 ) ; if ( ( VAR_84 . VAR_85 == 0 ) || ( VAR_86 . VAR_87 > 4 ) ) METHOD_20 ( VAR_88 , ""ImproperImageHeader"" ) ; VAR_89 . VAR_90 = METHOD_21 ( VAR_91 ) ; VAR_92 . VAR_93 = METHOD_22 ( VAR_94 ) ; VAR_95 . VAR_96 = METHOD_23 ( VAR_97 ) ; VAR_98 = METHOD_24 ( VAR_99 , sizeof ( VAR_100 . VAR_101 ) , ( unsigned TYPE_20 * ) VAR_102 . VAR_103 ) ; if ( ( TYPE_21 ) VAR_104 != sizeof ( VAR_105 . VAR_106 ) ) METHOD_25 ( VAR_107 , ""ImproperImageHeader"" ) ; VAR_108 . VAR_109 [ sizeof ( VAR_110 . VAR_111 ) - 1 ] = '\\0' ; if ( * VAR_112 . VAR_113 != '\\0' ) ( TYPE_22 ) METHOD_26 ( VAR_114 , ""label"" , VAR_115 . VAR_116 , VAR_117 ) ; VAR_118 . VAR_119 = METHOD_27 ( VAR_120 ) ; if ( VAR_121 . VAR_122 != 0 ) METHOD_28 ( VAR_123 , ""ImproperImageHeader"" ) ; VAR_124 = METHOD_29 ( VAR_125 , sizeof ( VAR_126 . VAR_127 ) , VAR_128 . VAR_129 ) ; if ( ( TYPE_23 ) VAR_130 != sizeof ( VAR_131 . VAR_132 ) ) METHOD_30 ( VAR_133 , ""ImproperImageHeader"" ) ; VAR_134 -> VAR_135 = VAR_136 . VAR_137 ; VAR_138 -> VAR_139 = VAR_140 . VAR_141 ; VAR_142 -> VAR_143 = ( TYPE_24 ) METHOD_31 ( VAR_144 . VAR_145 , VAR_146 ) ; if ( VAR_147 . VAR_148 == 0 ) VAR_149 -> VAR_150 = ( TYPE_25 ) METHOD_32 ( ( TYPE_26 ) 8 * VAR_151 . VAR_152 , VAR_153 ) ; if ( VAR_154 . VAR_155 < 3 ) { VAR_156 -> VAR_157 = VAR_158 ; VAR_159 -> VAR_160 = ( TYPE_27 ) ( VAR_161 . VAR_162 > 1 ? 65535 : 256 ) ; } if ( ( VAR_163 -> VAR_164 != VAR_165 ) && ( VAR_166 -> VAR_167 != 0 ) ) if ( VAR_168 -> VAR_169 >= ( VAR_170 -> VAR_171 + VAR_172 -> VAR_173 - 1 ) ) break ; VAR_174 = METHOD_33 ( VAR_175 , VAR_176 -> VAR_177 , VAR_178 -> VAR_179 , VAR_180 ) ; if ( VAR_181 == VAR_182 ) return ( METHOD_34 ( VAR_183 ) ) ; VAR_184 = ( TYPE_28 ) VAR_185 . VAR_186 ; VAR_187 = ( TYPE_29 ) VAR_188 . VAR_189 * VAR_190 . VAR_191 ; if ( ( 4 * VAR_192 * VAR_193 ) != ( ( TYPE_30 ) ( TYPE_31 ) ( 4 * VAR_194 * VAR_195 ) ) ) METHOD_35 ( VAR_196 , ""MemoryAllocationFailed"" ) ; VAR_197 = METHOD_36 ( VAR_198 . VAR_199 , VAR_200 . VAR_201 * 4 * VAR_202 * sizeof ( * VAR_203 ) ) ; if ( VAR_204 == ( TYPE_32 * ) VAR_205 ) METHOD_37 ( VAR_206 , ""MemoryAllocationFailed"" ) ; VAR_207 = ( unsigned TYPE_33 * ) METHOD_38 ( VAR_208 ) ; if ( ( TYPE_34 ) VAR_209 . VAR_210 != 0x01 ) { unsigned TYPE_35 * VAR_211 ; VAR_212 = ( unsigned TYPE_36 * ) METHOD_39 ( VAR_213 . VAR_214 , VAR_215 * sizeof ( * VAR_216 ) ) ; if ( VAR_217 == ( unsigned TYPE_37 * ) VAR_218 ) METHOD_40 ( VAR_219 , ""MemoryAllocationFailed"" ) ; for ( VAR_220 = 0 ; VAR_221 < ( TYPE_38 ) VAR_222 . VAR_223 ; VAR_224 ++ ) { VAR_225 = VAR_226 + VAR_227 * VAR_228 ; for ( VAR_229 = 0 ; VAR_230 < ( TYPE_39 ) VAR_231 . VAR_232 ; VAR_233 ++ ) { VAR_234 = METHOD_41 ( VAR_235 , VAR_236 * VAR_237 . VAR_238 , VAR_239 ) ; if ( METHOD_42 ( VAR_240 ) != VAR_241 ) break ; if ( VAR_242 == 2 ) for ( VAR_243 = 0 ; VAR_244 < ( TYPE_40 ) VAR_245 . VAR_246 ; VAR_247 ++ ) { * VAR_248 = VAR_249 [ 2 * VAR_250 ] ; * ( VAR_251 + 1 ) = VAR_252 [ 2 * VAR_253 + 1 ] ; VAR_254 += 8 ; } else for ( VAR_255 = 0 ; VAR_256 < ( TYPE_41 ) VAR_257 . VAR_258 ; VAR_259 ++ ) { * VAR_260 = VAR_261 [ VAR_262 ] ; VAR_263 += 4 ; } } } VAR_264 = ( unsigned TYPE_42 * ) METHOD_43 ( VAR_265 ) ; } else { TYPE_43 * VAR_266 ; TYPE_44 * VAR_267 ; TYPE_45 VAR_268 , * VAR_269 ; unsigned TYPE_46 * VAR_270 ; unsigned TYPE_47 VAR_271 ; VAR_272 = ( TYPE_48 * ) METHOD_44 ( ( TYPE_49 ) VAR_273 . VAR_274 , VAR_275 . VAR_276 * sizeof ( * VAR_277 ) ) ; VAR_278 = ( TYPE_50 * ) METHOD_45 ( VAR_279 . VAR_280 , VAR_281 . VAR_282 * sizeof ( * VAR_283 ) ) ; VAR_284 = METHOD_46 ( ( TYPE_51 ) VAR_285 . VAR_286 + 10UL , 4UL * sizeof ( * VAR_287 ) ) ; if ( ( VAR_288 == ( TYPE_52 * ) VAR_289 ) || ( VAR_290 == ( TYPE_53 * ) VAR_291 ) || ( VAR_292 == ( TYPE_54 * ) VAR_293 ) ) { if ( VAR_294 == ( TYPE_55 * ) VAR_295 ) VAR_296 = ( TYPE_56 * ) METHOD_47 ( VAR_297 ) ; if ( VAR_298 == ( TYPE_57 * ) VAR_299 ) VAR_300 = ( TYPE_58 * ) METHOD_48 ( VAR_301 ) ; if ( VAR_302 == ( TYPE_59 * ) VAR_303 ) VAR_304 = METHOD_49 ( VAR_305 ) ; METHOD_50 ( VAR_306 , ""MemoryAllocationFailed"" ) ; } VAR_307 = ( unsigned TYPE_60 * ) METHOD_51 ( VAR_308 ) ; for ( VAR_309 = 0 ; VAR_310 < ( TYPE_61 ) ( VAR_311 . VAR_312 * VAR_313 . VAR_314 ) ; VAR_315 ++ ) VAR_316 [ VAR_317 ] = ( TYPE_62 ) METHOD_52 ( VAR_318 ) ; for ( VAR_319 = 0 ; VAR_320 < ( TYPE_63 ) ( VAR_321 . VAR_322 * VAR_323 . VAR_324 ) ; VAR_325 ++ ) { VAR_326 [ VAR_327 ] = METHOD_53 ( VAR_328 ) ; if ( VAR_329 [ VAR_330 ] > ( 4 * ( TYPE_64 ) VAR_331 . VAR_332 + 10 ) ) METHOD_54 ( VAR_333 , ""ImproperImageHeader"" ) ; } VAR_334 = 0 ; VAR_335 = 0 ; for ( VAR_336 = 0 ; ( ( VAR_337 < ( TYPE_65 ) VAR_338 . VAR_339 ) && ( VAR_340 == 0 ) ) ; VAR_341 ++ ) for ( VAR_342 = 0 ; ( ( VAR_343 < ( TYPE_66 ) VAR_344 . VAR_345 ) && ( VAR_346 == 0 ) ) ; VAR_347 ++ ) { if ( VAR_348 [ VAR_349 + VAR_350 * VAR_351 . VAR_352 ] < VAR_353 ) VAR_354 = 1 ; VAR_355 = VAR_356 [ VAR_357 + VAR_358 * VAR_359 . VAR_360 ] ; } VAR_361 = ( TYPE_67 ) METHOD_55 ( VAR_362 ) ; if ( VAR_363 == 1 ) { for ( VAR_364 = 0 ; VAR_365 < ( TYPE_68 ) VAR_366 . VAR_367 ; VAR_368 ++ ) { VAR_369 = VAR_370 ; for ( VAR_371 = 0 ; VAR_372 < ( TYPE_69 ) VAR_373 . VAR_374 ; VAR_375 ++ ) { if ( VAR_376 != VAR_377 [ VAR_378 + VAR_379 * VAR_380 . VAR_381 ] ) { VAR_382 = VAR_383 [ VAR_384 + VAR_385 * VAR_386 . VAR_387 ] ; VAR_388 = ( TYPE_70 ) METHOD_56 ( VAR_389 , ( TYPE_71 ) VAR_390 , VAR_391 ) ; } VAR_392 = METHOD_57 ( VAR_393 , ( TYPE_72 ) VAR_394 [ VAR_395 + VAR_396 * VAR_397 . VAR_398 ] , VAR_399 ) ; if ( METHOD_58 ( VAR_400 ) != VAR_401 ) break ; VAR_402 += ( TYPE_73 ) VAR_403 [ VAR_404 + VAR_405 * VAR_406 . VAR_407 ] ; VAR_408 = METHOD_59 ( VAR_409 , ( TYPE_74 ) ( VAR_410 [ VAR_411 + VAR_412 * VAR_413 . VAR_414 ] / VAR_415 ) , VAR_416 , ( TYPE_75 ) VAR_417 . VAR_418 , VAR_419 + VAR_420 * VAR_421 ) ; if ( VAR_422 == VAR_423 ) METHOD_60 ( VAR_424 , ""ImproperImageHeader"" ) ; VAR_425 += ( VAR_426 . VAR_427 * 4 * VAR_428 ) ; } } } else { TYPE_76 VAR_429 ; VAR_430 = METHOD_61 ( VAR_431 ) ; VAR_432 = VAR_433 ; for ( VAR_434 = 0 ; VAR_435 < ( TYPE_77 ) VAR_436 . VAR_437 ; VAR_438 ++ ) { for ( VAR_439 = 0 ; VAR_440 < ( TYPE_78 ) VAR_441 . VAR_442 ; VAR_443 ++ ) { if ( VAR_444 != VAR_445 [ VAR_446 + VAR_447 * VAR_448 . VAR_449 ] ) { VAR_450 = VAR_451 [ VAR_452 + VAR_453 * VAR_454 . VAR_455 ] ; VAR_456 = ( TYPE_79 ) METHOD_62 ( VAR_457 , ( TYPE_80 ) VAR_458 , VAR_459 ) ; } VAR_460 = METHOD_63 ( VAR_461 , ( TYPE_81 ) VAR_462 [ VAR_463 + VAR_464 * VAR_465 . VAR_466 ] , VAR_467 ) ; if ( METHOD_64 ( VAR_468 ) != VAR_469 ) break ; VAR_470 += ( TYPE_82 ) VAR_471 [ VAR_472 + VAR_473 * VAR_474 . VAR_475 ] ; VAR_476 = METHOD_65 ( VAR_477 , ( TYPE_83 ) ( VAR_478 [ VAR_479 + VAR_480 * VAR_481 . VAR_482 ] / VAR_483 ) , VAR_484 , ( TYPE_84 ) VAR_485 . VAR_486 , VAR_487 + VAR_488 * VAR_489 ) ; if ( VAR_490 == VAR_491 ) METHOD_66 ( VAR_492 , ""ImproperImageHeader"" ) ; } VAR_493 += ( VAR_494 . VAR_495 * 4 * VAR_496 ) ; } VAR_497 = ( TYPE_85 ) METHOD_67 ( VAR_498 , VAR_499 , VAR_500 ) ; } VAR_501 = METHOD_68 ( VAR_502 ) ; VAR_503 = ( TYPE_86 * ) METHOD_69 ( VAR_504 ) ; VAR_505 = ( TYPE_87 * ) METHOD_70 ( VAR_506 ) ; } VAR_507 -> VAR_508 = VAR_509 . VAR_510 == 4 ? VAR_511 : VAR_512 ; VAR_513 -> VAR_514 = VAR_515 . VAR_516 ; VAR_517 -> VAR_518 = VAR_519 . VAR_520 ; if ( VAR_521 -> VAR_522 == VAR_523 ) { if ( VAR_524 == 2 ) { for ( VAR_525 = 0 ; VAR_526 < ( TYPE_88 ) VAR_527 -> VAR_528 ; VAR_529 ++ ) { VAR_530 = VAR_531 + ( VAR_532 -> VAR_533 - VAR_534 - 1 ) * 8 * VAR_535 -> VAR_536 ; VAR_537 = METHOD_71 ( VAR_538 , 0 , VAR_539 , VAR_540 -> VAR_541 , 1 , VAR_542 ) ; if ( VAR_543 == ( TYPE_89 * ) VAR_544 ) break ; for ( VAR_545 = 0 ; VAR_546 < ( TYPE_90 ) VAR_547 -> VAR_548 ; VAR_549 ++ ) { METHOD_72 ( VAR_550 , METHOD_73 ( ( unsigned TYPE_91 ) ( ( * ( VAR_551 + 0 ) << 8 ) | ( * ( VAR_552 + 1 ) ) ) ) , VAR_553 ) ; METHOD_74 ( VAR_554 , METHOD_75 ( ( unsigned TYPE_92 ) ( ( * ( VAR_555 + 2 ) << 8 ) | ( * ( VAR_556 + 3 ) ) ) ) , VAR_557 ) ; METHOD_76 ( VAR_558 , METHOD_77 ( ( unsigned TYPE_93 ) ( ( * ( VAR_559 + 4 ) << 8 ) | ( * ( VAR_560 + 5 ) ) ) ) , VAR_561 ) ; METHOD_78 ( VAR_562 , VAR_563 , VAR_564 ) ; if ( VAR_565 -> VAR_566 != VAR_567 ) METHOD_79 ( VAR_568 , METHOD_80 ( ( unsigned TYPE_94 ) ( ( * ( VAR_569 + 6 ) << 8 ) | ( * ( VAR_570 + 7 ) ) ) ) , VAR_571 ) ; VAR_572 += 8 ; VAR_573 += METHOD_81 ( VAR_574 ) ; } if ( METHOD_82 ( VAR_575 , VAR_576 ) == VAR_577 ) break ; if ( VAR_578 -> VAR_579 == ( TYPE_95 * ) VAR_580 ) { VAR_581 = METHOD_83 ( VAR_582 , VAR_583 , ( TYPE_96 ) VAR_584 , VAR_585 -> VAR_586 ) ; if ( VAR_587 == VAR_588 ) break ; } } } else for ( VAR_589 = 0 ; VAR_590 < ( TYPE_97 ) VAR_591 -> VAR_592 ; VAR_593 ++ ) { VAR_594 = VAR_595 + ( VAR_596 -> VAR_597 - VAR_598 - 1 ) * 4 * VAR_599 -> VAR_600 ; VAR_601 = METHOD_84 ( VAR_602 , 0 , VAR_603 , VAR_604 -> VAR_605 , 1 , VAR_606 ) ; if ( VAR_607 == ( TYPE_98 * ) VAR_608 ) break ; for ( VAR_609 = 0 ; VAR_610 < ( TYPE_99 ) VAR_611 -> VAR_612 ; VAR_613 ++ ) { METHOD_85 ( VAR_614 , METHOD_86 ( * VAR_615 ) , VAR_616 ) ; METHOD_87 ( VAR_617 , METHOD_88 ( * ( VAR_618 + 1 ) ) , VAR_619 ) ; METHOD_89 ( VAR_620 , METHOD_90 ( * ( VAR_621 + 2 ) ) , VAR_622 ) ; METHOD_91 ( VAR_623 , VAR_624 , VAR_625 ) ; if ( VAR_626 -> VAR_627 != VAR_628 ) METHOD_92 ( VAR_629 , METHOD_93 ( * ( VAR_630 + 3 ) ) , VAR_631 ) ; VAR_632 += 4 ; VAR_633 += METHOD_94 ( VAR_634 ) ; } if ( METHOD_95 ( VAR_635 , VAR_636 ) == VAR_637 ) break ; if ( VAR_638 -> VAR_639 == ( TYPE_100 * ) VAR_640 ) { VAR_641 = METHOD_96 ( VAR_642 , VAR_643 , ( TYPE_101 ) VAR_644 , VAR_645 -> VAR_646 ) ; if ( VAR_647 == VAR_648 ) break ; } } } else { if ( METHOD_97 ( VAR_649 , VAR_650 -> VAR_651 , VAR_652 ) == VAR_653 ) METHOD_98 ( VAR_654 , ""MemoryAllocationFailed"" ) ; if ( VAR_655 == 2 ) { for ( VAR_656 = 0 ; VAR_657 < ( TYPE_102 ) VAR_658 -> VAR_659 ; VAR_660 ++ ) { VAR_661 = VAR_662 + ( VAR_663 -> VAR_664 - VAR_665 - 1 ) * 8 * VAR_666 -> VAR_667 ; VAR_668 = METHOD_99 ( VAR_669 , 0 , VAR_670 , VAR_671 -> VAR_672 , 1 , VAR_673 ) ; if ( VAR_674 == ( TYPE_103 * ) VAR_675 ) break ; for ( VAR_676 = 0 ; VAR_677 < ( TYPE_104 ) VAR_678 -> VAR_679 ; VAR_680 ++ ) { VAR_681 = ( * VAR_682 << 8 ) ; VAR_683 |= ( * ( VAR_684 + 1 ) ) ; METHOD_100 ( VAR_685 , ( TYPE_105 ) VAR_686 , VAR_687 ) ; VAR_688 += 8 ; VAR_689 += METHOD_101 ( VAR_690 ) ; } if ( METHOD_102 ( VAR_691 , VAR_692 ) == VAR_693 ) break ; if ( VAR_694 -> VAR_695 == ( TYPE_106 * ) VAR_696 ) { VAR_697 = METHOD_103 ( VAR_698 , VAR_699 , ( TYPE_107 ) VAR_700 , VAR_701 -> VAR_702 ) ; if ( VAR_703 == VAR_704 ) break ; } } } else for ( VAR_705 = 0 ; VAR_706 < ( TYPE_108 ) VAR_707 -> VAR_708 ; VAR_709 ++ ) { VAR_710 = VAR_711 + ( VAR_712 -> VAR_713 - VAR_714 - 1 ) * 4 * VAR_715 -> VAR_716 ; VAR_717 = METHOD_104 ( VAR_718 , 0 , VAR_719 , VAR_720 -> VAR_721 , 1 , VAR_722 ) ; if ( VAR_723 == ( TYPE_109 * ) VAR_724 ) break ; for ( VAR_725 = 0 ; VAR_726 < ( TYPE_110 ) VAR_727 -> VAR_728 ; VAR_729 ++ ) { METHOD_105 ( VAR_730 , * VAR_731 , VAR_732 ) ; VAR_733 += 4 ; VAR_734 += METHOD_106 ( VAR_735 ) ; } if ( METHOD_107 ( VAR_736 , VAR_737 ) == VAR_738 ) break ; if ( VAR_739 -> VAR_740 == ( TYPE_111 * ) VAR_741 ) { VAR_742 = METHOD_108 ( VAR_743 , VAR_744 , ( TYPE_112 ) VAR_745 , VAR_746 -> VAR_747 ) ; if ( VAR_748 == VAR_749 ) break ; } } ( TYPE_113 ) METHOD_109 ( VAR_750 , VAR_751 ) ; } VAR_752 = METHOD_110 ( VAR_753 ) ; if ( METHOD_111 ( VAR_754 ) != VAR_755 ) { METHOD_112 ( VAR_756 , VAR_757 , ""UnexpectedEndOfFile"" , VAR_758 -> VAR_759 ) ; break ; } if ( VAR_760 -> VAR_761 != 0 ) if ( VAR_762 -> VAR_763 >= ( VAR_764 -> VAR_765 + VAR_766 -> VAR_767 - 1 ) ) break ; VAR_768 . VAR_769 = METHOD_113 ( VAR_770 ) ; if ( VAR_771 . VAR_772 == 0x01DA ) { METHOD_114 ( VAR_773 , VAR_774 , VAR_775 ) ; if ( METHOD_115 ( VAR_776 ) == ( TYPE_114 * ) VAR_777 ) { VAR_778 = METHOD_116 ( VAR_779 ) ; return ( ( TYPE_115 * ) VAR_780 ) ; } VAR_781 = METHOD_117 ( VAR_782 ) ; VAR_783 = METHOD_118 ( VAR_784 , VAR_785 , METHOD_119 ( VAR_786 ) , METHOD_120 ( VAR_787 ) ) ; if ( VAR_788 == VAR_789 ) break ; } } while ( VAR_790 . VAR_791 == 0x01DA ) ; ( TYPE_116 ) METHOD_121 ( VAR_792 ) ; return ( METHOD_122 ( VAR_793 ) ) ; }","<S2SV_ModStart> METHOD_113 ( VAR_793 ) ; if ( ( VAR_790 . VAR_73 == 0 ) || ( VAR_790 . VAR_73 > 3 ) ) METHOD_98 ( VAR_757 , ""ImproperImageHeader""","CWE-119 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; count = ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; if ( ( size_t ) count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; if ( ( size_t ) count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = ( size_t ) ( iris_info . bytes_per_pixel > 1 ? 65535 : 256 ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ( ssize_t ) ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"""
203,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> TYPE_4 VAR_3 ; VAR_4 * VAR_5 ; <S2SV_StartBug> TYPE_5 VAR_6 ; <S2SV_EndBug> VAR_7 * VAR_8 ; if ( METHOD_1 ( VAR_9 ) > 0 && METHOD_2 ( VAR_10 ) > 0 ) { METHOD_3 ( VAR_11 -> VAR_12 ) ; VAR_13 = METHOD_4 ( VAR_14 ) ; for ( VAR_15 = VAR_16 -> VAR_17 , VAR_18 = VAR_19 -> VAR_20 [ 0 ] ; VAR_21 > 0 ; -- VAR_22 , VAR_23 += VAR_24 ) { for ( VAR_25 = VAR_26 -> VAR_27 , VAR_28 = VAR_29 ; VAR_30 > 0 ; -- VAR_31 , ++ VAR_32 ) { * VAR_33 = METHOD_5 ( * VAR_34 , VAR_35 ) ; } } } }",<S2SV_ModStart> VAR_35 ) { TYPE_6 VAR_22 ; TYPE_6 <S2SV_ModEnd> VAR_31 ; VAR_7 <S2SV_ModStart> * VAR_29 ; TYPE_6 <S2SV_ModEnd> VAR_24 ; VAR_7,"CWE-190 void jas_matrix_asl ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = jas_seqent_asl ( * data , n ) ; } } } }",<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
204,"CWE-399 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 -> VAR_4 ; struct STRUCT_OR_UNION_3 * VAR_5 = VAR_6 -> VAR_7 ; struct STRUCT_OR_UNION_4 * VAR_8 ; struct STRUCT_OR_UNION_5 * VAR_9 = VAR_10 , * VAR_11 = VAR_12 ; TYPE_1 VAR_13 = VAR_14 -> VAR_15 | ~ VAR_16 -> VAR_17 ; TYPE_2 VAR_18 = VAR_19 -> VAR_20 & VAR_21 -> VAR_22 ; TYPE_3 1 TYPE_4 2 TYPE_5 4 TYPE_6 8 unsigned TYPE_7 VAR_23 = 0 ; TYPE_8 VAR_24 = 0 ; TYPE_9 VAR_25 = 1 ; TYPE_10 VAR_26 = 0 ; if ( VAR_27 -> VAR_28 & VAR_29 ) { VAR_30 = METHOD_1 ( VAR_31 , VAR_32 , VAR_33 -> VAR_34 ) ; if ( ! VAR_35 ) { METHOD_2 ( ""%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n"" , VAR_36 ) ; return ; } if ( VAR_37 && VAR_38 != VAR_39 ) { METHOD_3 ( ""%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n"" , VAR_40 ) ; return ; } } else if ( ! METHOD_4 ( VAR_41 ) && ( VAR_42 != VAR_43 -> VAR_44 || VAR_45 -> VAR_46 < 32 ) ) { if ( ! ( VAR_47 -> VAR_48 & VAR_49 ) ) METHOD_5 ( VAR_50 , VAR_51 -> VAR_52 & VAR_53 ? VAR_54 : VAR_55 , VAR_56 , VAR_57 -> VAR_58 , VAR_59 ) ; VAR_60 = 1 ; } <S2SV_StartBug> for ( VAR_61 = VAR_62 -> VAR_63 ; VAR_64 ; VAR_65 = VAR_66 -> VAR_67 ) { <S2SV_EndBug> if ( VAR_68 == VAR_69 ) { VAR_70 = 0 ; continue ; } if ( VAR_71 && VAR_72 -> VAR_73 == VAR_74 -> VAR_75 && METHOD_6 ( VAR_76 -> VAR_77 , VAR_78 ) ) continue ; if ( VAR_79 -> VAR_80 & VAR_81 ) { if ( VAR_82 -> VAR_83 == VAR_84 -> VAR_85 && METHOD_7 ( VAR_86 -> VAR_87 , VAR_88 ) ) VAR_89 = VAR_90 ; else { if ( ! VAR_91 ) continue ; if ( ! VAR_92 || VAR_93 -> VAR_94 != VAR_95 -> VAR_96 || ! METHOD_8 ( VAR_97 -> VAR_98 , VAR_99 ) ) VAR_100 = METHOD_9 ( VAR_101 , VAR_102 -> VAR_103 , VAR_104 -> VAR_105 ) ; if ( ! VAR_106 ) continue ; if ( VAR_107 -> VAR_108 != VAR_109 -> VAR_110 ) continue ; } } else { if ( VAR_111 -> VAR_112 != VAR_113 -> VAR_114 ) continue ; VAR_115 = VAR_116 ; if ( VAR_117 != VAR_118 ) VAR_119 = 1 ; } if ( VAR_120 -> VAR_121 == VAR_122 -> VAR_123 ) VAR_124 |= TYPE_11 ; if ( VAR_125 -> VAR_126 == VAR_127 -> VAR_128 ) VAR_129 |= TYPE_12 ; if ( VAR_130 == VAR_131 -> VAR_132 ) VAR_133 |= TYPE_13 ; if ( VAR_134 == VAR_135 -> VAR_136 ) VAR_137 |= TYPE_14 ; if ( VAR_138 == VAR_139 && VAR_140 -> VAR_141 < 31 ) { TYPE_15 VAR_142 = VAR_143 -> VAR_144 | ~ VAR_145 -> VAR_146 ; TYPE_16 VAR_147 = VAR_148 -> VAR_149 & VAR_150 -> VAR_151 ; if ( ! METHOD_10 ( VAR_152 ) ) { if ( VAR_153 -> VAR_154 == VAR_155 || VAR_156 -> VAR_157 == VAR_158 ) VAR_159 |= TYPE_17 ; if ( VAR_160 == VAR_161 || VAR_162 == VAR_163 ) VAR_164 |= TYPE_18 ; if ( VAR_165 == VAR_166 || VAR_167 == VAR_168 ) VAR_169 |= TYPE_19 ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( VAR_170 & TYPE_20 ) ) METHOD_11 ( VAR_171 , VAR_172 , VAR_173 -> VAR_174 , 32 , VAR_175 ) ; if ( VAR_176 && VAR_177 -> VAR_178 < 31 ) { if ( ! ( VAR_179 & TYPE_21 ) ) METHOD_12 ( VAR_180 , VAR_181 , VAR_182 , 32 , VAR_183 ) ; if ( ! ( VAR_184 & TYPE_22 ) ) METHOD_13 ( VAR_185 , VAR_186 , VAR_187 , 32 , VAR_188 ) ; } if ( ! ( VAR_189 & TYPE_23 ) ) { unsigned TYPE_24 VAR_190 ; METHOD_14 ( VAR_191 , VAR_192 , VAR_193 -> VAR_194 , 32 , VAR_195 ) ; VAR_196 = METHOD_15 ( METHOD_16 ( VAR_197 ) , VAR_198 , VAR_199 -> VAR_200 ) ; if ( VAR_201 && VAR_202 != VAR_203 ) { if ( METHOD_17 ( METHOD_18 ( VAR_204 ) , VAR_205 -> VAR_206 ) ) METHOD_19 ( METHOD_20 ( VAR_207 ) ) ; } } TYPE_25 TYPE_26 TYPE_27 TYPE_28 }",<S2SV_ModStart> 1 ; } if ( VAR_101 -> VAR_208 ) goto VAR_209 ; <S2SV_ModStart> } } } VAR_209 :,"CWE-399 void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ;   LOCAL_OK 1   BRD_OK 2   BRD0_OK 4   BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n"" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n"" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } <S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } }   LOCAL_OK   BRD_OK   BRD0_OK   BRD1_OK }",<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :
205,"CWE-125 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 = ( TYPE_3 ) VAR_2 ; TYPE_4 * VAR_3 = VAR_4 , * VAR_5 = VAR_6 ; if ( ! VAR_7 ) { <S2SV_StartBug> METHOD_1 ( VAR_8 ) ; <S2SV_EndBug> return VAR_9 ; } switch ( VAR_10 -> VAR_11 ) { case VAR_12 : VAR_13 = METHOD_2 ( VAR_14 , VAR_15 , VAR_16 ) ; if ( ! VAR_17 ) goto VAR_18 ; VAR_19 = METHOD_3 ( VAR_20 -> VAR_21 . VAR_22 . VAR_23 ) ; if ( ! VAR_24 ) goto VAR_25 ; if ( METHOD_4 ( VAR_26 , & VAR_27 , VAR_28 ) == - 1 ) goto VAR_29 ; METHOD_5 ( VAR_30 ) ; VAR_31 = METHOD_6 ( VAR_32 -> VAR_33 . VAR_34 . VAR_35 ) ; if ( ! VAR_36 ) goto VAR_37 ; if ( METHOD_7 ( VAR_38 , & VAR_39 , VAR_40 ) == - 1 ) goto VAR_41 ; METHOD_8 ( VAR_42 ) ; VAR_43 = METHOD_9 ( VAR_44 -> VAR_45 . VAR_46 . VAR_47 , METHOD_10 ) ; if ( ! VAR_48 ) goto VAR_49 ; if ( METHOD_11 ( VAR_50 , & VAR_51 , VAR_52 ) == - 1 ) goto VAR_53 ; METHOD_12 ( VAR_54 ) ; VAR_55 = METHOD_13 ( VAR_56 -> VAR_57 . VAR_58 . VAR_59 , METHOD_14 ) ; if ( ! VAR_60 ) goto VAR_61 ; if ( METHOD_15 ( VAR_62 , & VAR_63 , VAR_64 ) == - 1 ) goto VAR_65 ; METHOD_16 ( VAR_66 ) ; VAR_67 = METHOD_17 ( VAR_68 -> VAR_69 . VAR_70 . VAR_71 ) ; if ( ! VAR_72 ) goto VAR_73 ; if ( METHOD_18 ( VAR_74 , & VAR_75 , VAR_76 ) == - 1 ) goto VAR_77 ; METHOD_19 ( VAR_78 ) ; VAR_79 = METHOD_20 ( VAR_80 -> VAR_81 . VAR_82 . VAR_83 ) ; if ( ! VAR_84 ) goto VAR_85 ; if ( METHOD_21 ( VAR_86 , & VAR_87 , VAR_88 ) == - 1 ) goto VAR_89 ; METHOD_22 ( VAR_90 ) ; break ; case VAR_91 : VAR_92 = METHOD_23 ( VAR_93 , VAR_94 , VAR_95 ) ; if ( ! VAR_96 ) goto VAR_97 ; VAR_98 = METHOD_24 ( VAR_99 -> VAR_100 . VAR_101 . VAR_102 ) ; if ( ! VAR_103 ) goto VAR_104 ; if ( METHOD_25 ( VAR_105 , & VAR_106 , VAR_107 ) == - 1 ) goto VAR_108 ; METHOD_26 ( VAR_109 ) ; VAR_110 = METHOD_27 ( VAR_111 -> VAR_112 . VAR_113 . VAR_114 ) ; if ( ! VAR_115 ) goto VAR_116 ; if ( METHOD_28 ( VAR_117 , & VAR_118 , VAR_119 ) == - 1 ) goto VAR_120 ; METHOD_29 ( VAR_121 ) ; VAR_122 = METHOD_30 ( VAR_123 -> VAR_124 . VAR_125 . VAR_126 , METHOD_31 ) ; if ( ! VAR_127 ) goto VAR_128 ; if ( METHOD_32 ( VAR_129 , & VAR_130 , VAR_131 ) == - 1 ) goto VAR_132 ; METHOD_33 ( VAR_133 ) ; VAR_134 = METHOD_34 ( VAR_135 -> VAR_136 . VAR_137 . VAR_138 , METHOD_35 ) ; if ( ! VAR_139 ) goto VAR_140 ; if ( METHOD_36 ( VAR_141 , & VAR_142 , VAR_143 ) == - 1 ) goto VAR_144 ; METHOD_37 ( VAR_145 ) ; VAR_146 = METHOD_38 ( VAR_147 -> VAR_148 . VAR_149 . VAR_150 ) ; if ( ! VAR_151 ) goto VAR_152 ; if ( METHOD_39 ( VAR_153 , & VAR_154 , VAR_155 ) == - 1 ) goto VAR_156 ; METHOD_40 ( VAR_157 ) ; VAR_158 = METHOD_41 ( VAR_159 -> VAR_160 . VAR_161 . VAR_162 ) ; if ( ! VAR_163 ) goto VAR_164 ; if ( METHOD_42 ( VAR_165 , & VAR_166 , VAR_167 ) == - 1 ) goto VAR_168 ; METHOD_43 ( VAR_169 ) ; break ; case VAR_170 : VAR_171 = METHOD_44 ( VAR_172 , VAR_173 , VAR_174 ) ; if ( ! VAR_175 ) goto VAR_176 ; VAR_177 = METHOD_45 ( VAR_178 -> VAR_179 . VAR_180 . VAR_181 ) ; if ( ! VAR_182 ) goto VAR_183 ; if ( METHOD_46 ( VAR_184 , & VAR_185 , VAR_186 ) == - 1 ) goto VAR_187 ; METHOD_47 ( VAR_188 ) ; VAR_189 = METHOD_48 ( VAR_190 -> VAR_191 . VAR_192 . VAR_193 , METHOD_49 ) ; if ( ! VAR_194 ) goto VAR_195 ; if ( METHOD_50 ( VAR_196 , & VAR_197 , VAR_198 ) == - 1 ) goto VAR_199 ; METHOD_51 ( VAR_200 ) ; VAR_201 = METHOD_52 ( VAR_202 -> VAR_203 . VAR_204 . VAR_205 , VAR_206 ) ; if ( ! VAR_207 ) goto VAR_208 ; if ( METHOD_53 ( VAR_209 , & VAR_210 , VAR_211 ) == - 1 ) goto VAR_212 ; METHOD_54 ( VAR_213 ) ; VAR_214 = METHOD_55 ( VAR_215 -> VAR_216 . VAR_217 . VAR_218 , METHOD_56 ) ; if ( ! VAR_219 ) goto VAR_220 ; if ( METHOD_57 ( VAR_221 , & VAR_222 , VAR_223 ) == - 1 ) goto VAR_224 ; METHOD_58 ( VAR_225 ) ; VAR_226 = METHOD_59 ( VAR_227 -> VAR_228 . VAR_229 . VAR_230 , METHOD_60 ) ; if ( ! VAR_231 ) goto VAR_232 ; if ( METHOD_61 ( VAR_233 , & VAR_234 , VAR_235 ) == - 1 ) goto VAR_236 ; METHOD_62 ( VAR_237 ) ; break ; case VAR_238 : VAR_239 = METHOD_63 ( VAR_240 , VAR_241 , VAR_242 ) ; if ( ! VAR_243 ) goto VAR_244 ; VAR_245 = METHOD_64 ( VAR_246 -> VAR_247 . VAR_248 . VAR_249 ) ; if ( ! VAR_250 ) goto VAR_251 ; if ( METHOD_65 ( VAR_252 , & VAR_253 , VAR_254 ) == - 1 ) goto VAR_255 ; METHOD_66 ( VAR_256 ) ; break ; case VAR_257 : VAR_258 = METHOD_67 ( VAR_259 , VAR_260 , VAR_261 ) ; if ( ! VAR_262 ) goto VAR_263 ; VAR_264 = METHOD_68 ( VAR_265 -> VAR_266 . VAR_267 . VAR_268 , METHOD_69 ) ; if ( ! VAR_269 ) goto VAR_270 ; if ( METHOD_70 ( VAR_271 , & VAR_272 , VAR_273 ) == - 1 ) goto VAR_274 ; METHOD_71 ( VAR_275 ) ; break ; case VAR_276 : VAR_277 = METHOD_72 ( VAR_278 , VAR_279 , VAR_280 ) ; if ( ! VAR_281 ) goto VAR_282 ; VAR_283 = METHOD_73 ( VAR_284 -> VAR_285 . VAR_286 . VAR_287 , METHOD_74 ) ; if ( ! VAR_288 ) goto VAR_289 ; if ( METHOD_75 ( VAR_290 , & VAR_291 , VAR_292 ) == - 1 ) goto VAR_293 ; METHOD_76 ( VAR_294 ) ; VAR_295 = METHOD_77 ( VAR_296 -> VAR_297 . VAR_298 . VAR_299 ) ; if ( ! VAR_300 ) goto VAR_301 ; if ( METHOD_78 ( VAR_302 , & VAR_303 , VAR_304 ) == - 1 ) goto VAR_305 ; METHOD_79 ( VAR_306 ) ; VAR_307 = METHOD_80 ( VAR_308 -> VAR_309 . VAR_310 . VAR_311 ) ; if ( ! VAR_312 ) goto VAR_313 ; if ( METHOD_81 ( VAR_314 , & VAR_315 , VAR_316 ) == - 1 ) goto VAR_317 ; METHOD_82 ( VAR_318 ) ; break ; case VAR_319 : VAR_320 = METHOD_83 ( VAR_321 , VAR_322 , VAR_323 ) ; if ( ! VAR_324 ) goto VAR_325 ; VAR_326 = METHOD_84 ( VAR_327 -> VAR_328 . VAR_329 . VAR_330 ) ; if ( ! VAR_331 ) goto VAR_332 ; if ( METHOD_85 ( VAR_333 , & VAR_334 , VAR_335 ) == - 1 ) goto VAR_336 ; METHOD_86 ( VAR_337 ) ; VAR_338 = METHOD_87 ( VAR_339 -> VAR_340 . VAR_341 . VAR_342 ) ; if ( ! VAR_343 ) goto VAR_344 ; if ( METHOD_88 ( VAR_345 , & VAR_346 , VAR_347 ) == - 1 ) goto VAR_348 ; METHOD_89 ( VAR_349 ) ; VAR_350 = METHOD_90 ( VAR_351 -> VAR_352 . VAR_353 . VAR_354 ) ; if ( ! VAR_355 ) goto VAR_356 ; if ( METHOD_91 ( VAR_357 , & VAR_358 , VAR_359 ) == - 1 ) goto VAR_360 ; METHOD_92 ( VAR_361 ) ; break ; case VAR_362 : VAR_363 = METHOD_93 ( VAR_364 , VAR_365 , VAR_366 ) ; if ( ! VAR_367 ) goto VAR_368 ; VAR_369 = METHOD_94 ( VAR_370 -> VAR_371 . VAR_372 . VAR_373 ) ; if ( ! VAR_374 ) goto VAR_375 ; if ( METHOD_95 ( VAR_376 , & VAR_377 , VAR_378 ) == - 1 ) goto VAR_379 ; METHOD_96 ( VAR_380 ) ; VAR_381 = METHOD_97 ( VAR_382 -> VAR_383 . VAR_384 . VAR_385 ) ; if ( ! VAR_386 ) goto VAR_387 ; if ( METHOD_98 ( VAR_388 , & VAR_389 , VAR_390 ) == - 1 ) goto VAR_391 ; METHOD_99 ( VAR_392 ) ; VAR_393 = METHOD_100 ( VAR_394 -> VAR_395 . VAR_396 . VAR_397 ) ; if ( ! VAR_398 ) goto VAR_399 ; if ( METHOD_101 ( VAR_400 , & VAR_401 , VAR_402 ) == - 1 ) goto VAR_403 ; METHOD_102 ( VAR_404 ) ; VAR_405 = METHOD_103 ( VAR_406 -> VAR_407 . VAR_408 . VAR_409 ) ; if ( ! VAR_410 ) goto VAR_411 ; if ( METHOD_104 ( VAR_412 , & VAR_413 , VAR_414 ) == - 1 ) goto VAR_415 ; METHOD_105 ( VAR_416 ) ; break ; case VAR_417 : VAR_418 = METHOD_106 ( VAR_419 , VAR_420 , VAR_421 ) ; if ( ! VAR_422 ) goto VAR_423 ; VAR_424 = METHOD_107 ( VAR_425 -> VAR_426 . VAR_427 . VAR_428 ) ; if ( ! VAR_429 ) goto VAR_430 ; if ( METHOD_108 ( VAR_431 , & VAR_432 , VAR_433 ) == - 1 ) goto VAR_434 ; METHOD_109 ( VAR_435 ) ; VAR_436 = METHOD_110 ( VAR_437 -> VAR_438 . VAR_439 . VAR_440 ) ; if ( ! VAR_441 ) goto VAR_442 ; if ( METHOD_111 ( VAR_443 , & VAR_444 , VAR_445 ) == - 1 ) goto VAR_446 ; METHOD_112 ( VAR_447 ) ; VAR_448 = METHOD_113 ( VAR_449 -> VAR_450 . VAR_451 . VAR_452 , METHOD_114 ) ; if ( ! VAR_453 ) goto VAR_454 ; if ( METHOD_115 ( VAR_455 , & VAR_456 , VAR_457 ) == - 1 ) goto VAR_458 ; METHOD_116 ( VAR_459 ) ; VAR_460 = METHOD_117 ( VAR_461 -> VAR_462 . VAR_463 . VAR_464 , METHOD_118 ) ; if ( ! VAR_465 ) goto VAR_466 ; if ( METHOD_119 ( VAR_467 , & VAR_468 , VAR_469 ) == - 1 ) goto VAR_470 ; METHOD_120 ( VAR_471 ) ; VAR_472 = METHOD_121 ( VAR_473 -> VAR_474 . VAR_475 . VAR_476 ) ; if ( ! VAR_477 ) goto VAR_478 ; if ( METHOD_122 ( VAR_479 , & VAR_480 , VAR_481 ) == - 1 ) goto VAR_482 ; METHOD_123 ( VAR_483 ) ; break ; case VAR_484 : VAR_485 = METHOD_124 ( VAR_486 , VAR_487 , VAR_488 ) ; if ( ! VAR_489 ) goto VAR_490 ; VAR_491 = METHOD_125 ( VAR_492 -> VAR_493 . VAR_494 . VAR_495 ) ; if ( ! VAR_496 ) goto VAR_497 ; if ( METHOD_126 ( VAR_498 , & VAR_499 , VAR_500 ) == - 1 ) goto VAR_501 ; METHOD_127 ( VAR_502 ) ; VAR_503 = METHOD_128 ( VAR_504 -> VAR_505 . VAR_506 . VAR_507 ) ; if ( ! VAR_508 ) goto VAR_509 ; if ( METHOD_129 ( VAR_510 , & VAR_511 , VAR_512 ) == - 1 ) goto VAR_513 ; METHOD_130 ( VAR_514 ) ; VAR_515 = METHOD_131 ( VAR_516 -> VAR_517 . VAR_518 . VAR_519 , METHOD_132 ) ; if ( ! VAR_520 ) goto VAR_521 ; if ( METHOD_133 ( VAR_522 , & VAR_523 , VAR_524 ) == - 1 ) goto VAR_525 ; METHOD_134 ( VAR_526 ) ; VAR_527 = METHOD_135 ( VAR_528 -> VAR_529 . VAR_530 . VAR_531 , METHOD_136 ) ; if ( ! VAR_532 ) goto VAR_533 ; if ( METHOD_137 ( VAR_534 , & VAR_535 , VAR_536 ) == - 1 ) goto VAR_537 ; METHOD_138 ( VAR_538 ) ; VAR_539 = METHOD_139 ( VAR_540 -> VAR_541 . VAR_542 . VAR_543 ) ; if ( ! VAR_544 ) goto VAR_545 ; if ( METHOD_140 ( VAR_546 , & VAR_547 , VAR_548 ) == - 1 ) goto VAR_549 ; METHOD_141 ( VAR_550 ) ; break ; case VAR_551 : VAR_552 = METHOD_142 ( VAR_553 , VAR_554 , VAR_555 ) ; if ( ! VAR_556 ) goto VAR_557 ; VAR_558 = METHOD_143 ( VAR_559 -> VAR_560 . VAR_561 . VAR_562 ) ; if ( ! VAR_563 ) goto VAR_564 ; if ( METHOD_144 ( VAR_565 , & VAR_566 , VAR_567 ) == - 1 ) goto VAR_568 ; METHOD_145 ( VAR_569 ) ; VAR_570 = METHOD_146 ( VAR_571 -> VAR_572 . VAR_573 . VAR_574 , METHOD_147 ) ; if ( ! VAR_575 ) goto VAR_576 ; if ( METHOD_148 ( VAR_577 , & VAR_578 , VAR_579 ) == - 1 ) goto VAR_580 ; METHOD_149 ( VAR_581 ) ; VAR_582 = METHOD_150 ( VAR_583 -> VAR_584 . VAR_585 . VAR_586 , METHOD_151 ) ; if ( ! VAR_587 ) goto VAR_588 ; if ( METHOD_152 ( VAR_589 , & VAR_590 , VAR_591 ) == - 1 ) goto VAR_592 ; METHOD_153 ( VAR_593 ) ; break ; case VAR_594 : VAR_595 = METHOD_154 ( VAR_596 , VAR_597 , VAR_598 ) ; if ( ! VAR_599 ) goto VAR_600 ; VAR_601 = METHOD_155 ( VAR_602 -> VAR_603 . VAR_604 . VAR_605 ) ; if ( ! VAR_606 ) goto VAR_607 ; if ( METHOD_156 ( VAR_608 , & VAR_609 , VAR_610 ) == - 1 ) goto VAR_611 ; METHOD_157 ( VAR_612 ) ; VAR_613 = METHOD_158 ( VAR_614 -> VAR_615 . VAR_616 . VAR_617 , METHOD_159 ) ; if ( ! VAR_618 ) goto VAR_619 ; if ( METHOD_160 ( VAR_620 , & VAR_621 , VAR_622 ) == - 1 ) goto VAR_623 ; METHOD_161 ( VAR_624 ) ; VAR_625 = METHOD_162 ( VAR_626 -> VAR_627 . VAR_628 . VAR_629 , METHOD_163 ) ; if ( ! VAR_630 ) goto VAR_631 ; if ( METHOD_164 ( VAR_632 , & VAR_633 , VAR_634 ) == - 1 ) goto VAR_635 ; METHOD_165 ( VAR_636 ) ; break ; case VAR_637 : VAR_638 = METHOD_166 ( VAR_639 , VAR_640 , VAR_641 ) ; if ( ! VAR_642 ) goto VAR_643 ; VAR_644 = METHOD_167 ( VAR_645 -> VAR_646 . VAR_647 . VAR_648 , VAR_649 ) ; if ( ! VAR_650 ) goto VAR_651 ; if ( METHOD_168 ( VAR_652 , & VAR_653 , VAR_654 ) == - 1 ) goto VAR_655 ; METHOD_169 ( VAR_656 ) ; VAR_657 = METHOD_170 ( VAR_658 -> VAR_659 . VAR_660 . VAR_661 , METHOD_171 ) ; if ( ! VAR_662 ) goto VAR_663 ; if ( METHOD_172 ( VAR_664 , & VAR_665 , VAR_666 ) == - 1 ) goto VAR_667 ; METHOD_173 ( VAR_668 ) ; VAR_669 = METHOD_174 ( VAR_670 -> VAR_671 . VAR_672 . VAR_673 ) ; if ( ! VAR_674 ) goto VAR_675 ; if ( METHOD_175 ( VAR_676 , & VAR_677 , VAR_678 ) == - 1 ) goto VAR_679 ; METHOD_176 ( VAR_680 ) ; break ; case VAR_681 : VAR_682 = METHOD_177 ( VAR_683 , VAR_684 , VAR_685 ) ; if ( ! VAR_686 ) goto VAR_687 ; VAR_688 = METHOD_178 ( VAR_689 -> VAR_690 . VAR_691 . VAR_692 , VAR_693 ) ; if ( ! VAR_694 ) goto VAR_695 ; if ( METHOD_179 ( VAR_696 , & VAR_697 , VAR_698 ) == - 1 ) goto VAR_699 ; METHOD_180 ( VAR_700 ) ; VAR_701 = METHOD_181 ( VAR_702 -> VAR_703 . VAR_704 . VAR_705 , METHOD_182 ) ; if ( ! VAR_706 ) goto VAR_707 ; if ( METHOD_183 ( VAR_708 , & VAR_709 , VAR_710 ) == - 1 ) goto VAR_711 ; METHOD_184 ( VAR_712 ) ; VAR_713 = METHOD_185 ( VAR_714 -> VAR_715 . VAR_716 . VAR_717 ) ; if ( ! VAR_718 ) goto VAR_719 ; if ( METHOD_186 ( VAR_720 , & VAR_721 , VAR_722 ) == - 1 ) goto VAR_723 ; METHOD_187 ( VAR_724 ) ; break ; case VAR_725 : VAR_726 = METHOD_188 ( VAR_727 , VAR_728 , VAR_729 ) ; if ( ! VAR_730 ) goto VAR_731 ; VAR_732 = METHOD_189 ( VAR_733 -> VAR_734 . VAR_735 . VAR_736 ) ; if ( ! VAR_737 ) goto VAR_738 ; if ( METHOD_190 ( VAR_739 , & VAR_740 , VAR_741 ) == - 1 ) goto VAR_742 ; METHOD_191 ( VAR_743 ) ; VAR_744 = METHOD_192 ( VAR_745 -> VAR_746 . VAR_747 . VAR_748 ) ; if ( ! VAR_749 ) goto VAR_750 ; if ( METHOD_193 ( VAR_751 , & VAR_752 , VAR_753 ) == - 1 ) goto VAR_754 ; METHOD_194 ( VAR_755 ) ; break ; case VAR_756 : VAR_757 = METHOD_195 ( VAR_758 , VAR_759 , VAR_760 ) ; if ( ! VAR_761 ) goto VAR_762 ; VAR_763 = METHOD_196 ( VAR_764 -> VAR_765 . VAR_766 . VAR_767 , METHOD_197 ) ; if ( ! VAR_768 ) goto VAR_769 ; if ( METHOD_198 ( VAR_770 , & VAR_771 , VAR_772 ) == - 1 ) goto VAR_773 ; METHOD_199 ( VAR_774 ) ; VAR_775 = METHOD_200 ( VAR_776 -> VAR_777 . VAR_778 . VAR_779 , VAR_780 ) ; if ( ! VAR_781 ) goto VAR_782 ; if ( METHOD_201 ( VAR_783 , & VAR_784 , VAR_785 ) == - 1 ) goto VAR_786 ; METHOD_202 ( VAR_787 ) ; VAR_788 = METHOD_203 ( VAR_789 -> VAR_790 . VAR_791 . VAR_792 , METHOD_204 ) ; if ( ! VAR_793 ) goto VAR_794 ; if ( METHOD_205 ( VAR_795 , & VAR_796 , VAR_797 ) == - 1 ) goto VAR_798 ; METHOD_206 ( VAR_799 ) ; VAR_800 = METHOD_207 ( VAR_801 -> VAR_802 . VAR_803 . VAR_804 , METHOD_208 ) ; if ( ! VAR_805 ) goto VAR_806 ; if ( METHOD_209 ( VAR_807 , & VAR_808 , VAR_809 ) == - 1 ) goto VAR_810 ; METHOD_210 ( VAR_811 ) ; break ; case VAR_812 : VAR_813 = METHOD_211 ( VAR_814 , VAR_815 , VAR_816 ) ; if ( ! VAR_817 ) goto VAR_818 ; VAR_819 = METHOD_212 ( VAR_820 -> VAR_821 . VAR_822 . VAR_823 ) ; if ( ! VAR_824 ) goto VAR_825 ; if ( METHOD_213 ( VAR_826 , & VAR_827 , VAR_828 ) == - 1 ) goto VAR_829 ; METHOD_214 ( VAR_830 ) ; VAR_831 = METHOD_215 ( VAR_832 -> VAR_833 . VAR_834 . VAR_835 ) ; if ( ! VAR_836 ) goto VAR_837 ; if ( METHOD_216 ( VAR_838 , & VAR_839 , VAR_840 ) == - 1 ) goto VAR_841 ; METHOD_217 ( VAR_842 ) ; break ; case VAR_843 : VAR_844 = METHOD_218 ( VAR_845 , VAR_846 , VAR_847 ) ; if ( ! VAR_848 ) goto VAR_849 ; VAR_850 = METHOD_219 ( VAR_851 -> VAR_852 . VAR_853 . VAR_854 , VAR_855 ) ; if ( ! VAR_856 ) goto VAR_857 ; if ( METHOD_220 ( VAR_858 , & VAR_859 , VAR_860 ) == - 1 ) goto VAR_861 ; METHOD_221 ( VAR_862 ) ; break ; case VAR_863 : VAR_864 = METHOD_222 ( VAR_865 , VAR_866 , VAR_867 ) ; if ( ! VAR_868 ) goto VAR_869 ; VAR_870 = METHOD_223 ( VAR_871 -> VAR_872 . VAR_873 . VAR_874 ) ; if ( ! VAR_875 ) goto VAR_876 ; if ( METHOD_224 ( VAR_877 , & VAR_878 , VAR_879 ) == - 1 ) goto VAR_880 ; METHOD_225 ( VAR_881 ) ; VAR_882 = METHOD_226 ( VAR_883 -> VAR_884 . VAR_885 . VAR_886 , VAR_887 ) ; if ( ! VAR_888 ) goto VAR_889 ; if ( METHOD_227 ( VAR_890 , & VAR_891 , VAR_892 ) == - 1 ) goto VAR_893 ; METHOD_228 ( VAR_894 ) ; VAR_895 = METHOD_229 ( VAR_896 -> VAR_897 . VAR_898 . VAR_899 ) ; if ( ! VAR_900 ) goto VAR_901 ; if ( METHOD_230 ( VAR_902 , & VAR_903 , VAR_904 ) == - 1 ) goto VAR_905 ; METHOD_231 ( VAR_906 ) ; break ; case VAR_907 : VAR_908 = METHOD_232 ( VAR_909 , VAR_910 , VAR_911 ) ; if ( ! VAR_912 ) goto VAR_913 ; VAR_914 = METHOD_233 ( VAR_915 -> VAR_916 . VAR_917 . VAR_918 , METHOD_234 ) ; if ( ! VAR_919 ) goto VAR_920 ; if ( METHOD_235 ( VAR_921 , & VAR_922 , VAR_923 ) == - 1 ) goto VAR_924 ; METHOD_236 ( VAR_925 ) ; break ; case VAR_926 : VAR_927 = METHOD_237 ( VAR_928 , VAR_929 , VAR_930 ) ; if ( ! VAR_931 ) goto VAR_932 ; VAR_933 = METHOD_238 ( VAR_934 -> VAR_935 . VAR_936 . VAR_937 , METHOD_239 ) ; if ( ! VAR_938 ) goto VAR_939 ; if ( METHOD_240 ( VAR_940 , & VAR_941 , VAR_942 ) == - 1 ) goto VAR_943 ; METHOD_241 ( VAR_944 ) ; break ; case VAR_945 : VAR_946 = METHOD_242 ( VAR_947 , VAR_948 , VAR_949 ) ; if ( ! VAR_950 ) goto VAR_951 ; VAR_952 = METHOD_243 ( VAR_953 -> VAR_954 . VAR_955 . VAR_956 ) ; if ( ! VAR_957 ) goto VAR_958 ; if ( METHOD_244 ( VAR_959 , & VAR_960 , VAR_961 ) == - 1 ) goto VAR_962 ; METHOD_245 ( VAR_963 ) ; break ; case VAR_964 : VAR_965 = METHOD_246 ( VAR_966 , VAR_967 , VAR_968 ) ; if ( ! VAR_969 ) goto VAR_970 ; break ; case VAR_971 : VAR_972 = METHOD_247 ( VAR_973 , VAR_974 , VAR_975 ) ; if ( ! VAR_976 ) goto VAR_977 ; break ; case VAR_978 : VAR_979 = METHOD_248 ( VAR_980 , VAR_981 , VAR_982 ) ; if ( ! VAR_983 ) goto VAR_984 ; break ; } VAR_985 = METHOD_249 ( VAR_986 -> VAR_987 ) ; if ( ! VAR_988 ) goto VAR_989 ; if ( METHOD_250 ( VAR_990 , & VAR_991 , VAR_992 ) < 0 ) goto VAR_993 ; METHOD_251 ( VAR_994 ) ; VAR_995 = METHOD_252 ( VAR_996 -> VAR_997 ) ; if ( ! VAR_998 ) goto VAR_999 ; if ( METHOD_253 ( VAR_1000 , & VAR_1001 , VAR_1002 ) < 0 ) goto VAR_1003 ; METHOD_254 ( VAR_1004 ) ; return VAR_1005 ; VAR_1006 : METHOD_255 ( VAR_1007 ) ; METHOD_256 ( VAR_1008 ) ; return VAR_1009 ; }",<S2SV_ModStart> VAR_996 ) { VAR_1010 <S2SV_ModEnd> ; } switch,"CWE-125 PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
206,"CWE-617 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , const struct STRUCT_OR_UNION_2 * VAR_2 ) { TYPE_1 VAR_3 ; if ( ! METHOD_1 ( VAR_4 ) ) return METHOD_2 ( VAR_5 , VAR_6 , VAR_7 ) ; if ( VAR_8 -> VAR_9 == 9 && VAR_10 -> VAR_11 == 13 ) { if ( VAR_12 -> VAR_13 == 2 ) { if ( METHOD_3 ( VAR_14 ) ) return VAR_15 ; VAR_16 = METHOD_4 ( VAR_17 , VAR_18 ) & VAR_19 ; } else if ( VAR_20 -> VAR_21 == 0 ) { if ( METHOD_5 ( VAR_22 ) ) return VAR_23 ; VAR_24 = VAR_25 ; } else { <S2SV_StartBug> METHOD_6 ( ) ; <S2SV_EndBug> } } else if ( VAR_26 -> VAR_27 == 14 && ( VAR_28 -> VAR_29 & 12 ) == 8 ) { if ( METHOD_7 ( VAR_30 ) ) return VAR_31 ; VAR_32 = ( ( VAR_33 -> VAR_34 & 3 ) << 3 ) | ( VAR_35 -> VAR_36 & 7 ) ; } else { <S2SV_StartBug> METHOD_8 ( ) ; <S2SV_EndBug> } if ( ! METHOD_9 ( VAR_37 , VAR_38 ) ) return VAR_39 ; if ( VAR_40 -> VAR_41 ) { if ( METHOD_10 ( VAR_42 ) ) return VAR_43 ; METHOD_11 ( VAR_44 , VAR_45 , VAR_46 -> VAR_47 ) ; } else { VAR_48 -> VAR_49 = METHOD_12 ( VAR_50 , VAR_51 ) ; } return VAR_52 ; }",<S2SV_ModStart> } else { return VAR_43 ; } } else if ( VAR_35 -> VAR_27 == 0 && VAR_35 -> VAR_34 == 9 ) { if ( METHOD_7 ( VAR_50 ) ) return VAR_43 ; VAR_51 = VAR_25 ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return VAR_43 <S2SV_ModEnd> ; } if,"CWE-617 static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }",<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
207,"CWE-399 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 ) <S2SV_EndBug> { struct STRUCT_OR_UNION_1 * VAR_2 ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 ; TYPE_2 VAR_3 ; if ( VAR_4 -> VAR_5 [ VAR_6 ] == VAR_7 ) return ; STRUCT_OR_UNION_4 = & VAR_8 -> STRUCT_OR_UNION_5 [ VAR_9 ] ; VAR_10 = STRUCT_OR_UNION_6 -> VAR_11 ; <S2SV_StartBug> METHOD_1 ( VAR_12 , & STRUCT_OR_UNION_7 -> VAR_13 , VAR_14 ) ; <S2SV_EndBug> VAR_15 = METHOD_2 ( VAR_16 -> VAR_17 ++ ) ; VAR_18 -> VAR_19 [ VAR_20 ] = VAR_21 ; METHOD_3 ( VAR_22 ) ; VAR_23 -> VAR_24 [ VAR_25 ] -> VAR_26 = 0 ; METHOD_4 ( VAR_27 -> VAR_28 [ VAR_29 ] ) ; VAR_30 -> VAR_31 [ VAR_32 ] = VAR_33 ; }","<S2SV_ModStart> , TYPE_1 VAR_32 , TYPE_3 VAR_34 <S2SV_ModStart> -> VAR_13 , VAR_34 <S2SV_ModEnd> ) ; VAR_20","CWE-399 <S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> { struct xenvif * vif ; struct pending_tx_info * pending_tx_info ; pending_ring_idx_t index ; if ( netbk -> mmap_pages [ pending_idx ] == NULL ) return ; pending_tx_info = & netbk -> pending_tx_info [ pending_idx ] ; vif = pending_tx_info -> vif ; <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; netbk -> mmap_pages [ pending_idx ] -> mapping = 0 ; put_page ( netbk -> mmap_pages [ pending_idx ] ) ; netbk -> mmap_pages [ pending_idx ] = NULL ; }","<S2SV_ModStart> , u16 pending_idx , u8 status <S2SV_ModStart> -> req , status <S2SV_ModEnd> ) ; index"
208,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , const TYPE_1 TYPE_2 * VAR_0 , TYPE_3 VAR_1 , TYPE_4 * VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 = STRUCT_OR_UNION_3 -> VAR_4 ; struct STRUCT_OR_UNION_4 * VAR_5 ; unsigned TYPE_5 VAR_6 ; TYPE_6 VAR_7 = - VAR_8 ; if ( ! METHOD_1 ( VAR_9 , VAR_10 ) ) return - VAR_11 ; METHOD_2 ( & VAR_12 -> VAR_13 , VAR_14 ) ; METHOD_3 ( ! VAR_15 -> VAR_16 ) VAR_17 : while ( ! METHOD_4 ) { METHOD_5 ( & VAR_18 -> VAR_19 , VAR_20 ) ; if ( STRUCT_OR_UNION_5 -> VAR_21 & VAR_22 ) return - VAR_23 ; if ( METHOD_6 ( VAR_24 -> VAR_25 , METHOD_7 ) ) return - VAR_26 ; METHOD_8 ( & VAR_27 -> VAR_28 , VAR_29 ) ; } VAR_30 -> VAR_31 = 1 ; VAR_32 = VAR_33 -> VAR_34 ; VAR_35 = min_t ( unsigned , VAR_36 , VAR_37 -> report_length ) ; METHOD_9 ( & VAR_38 -> VAR_39 , VAR_40 ) ; VAR_41 = METHOD_10 ( VAR_42 -> VAR_43 , VAR_44 , VAR_45 ) ; if ( VAR_46 != 0 ) { METHOD_11 ( VAR_47 -> VAR_48 . VAR_49 -> VAR_50 , ""copy_from_user<S2SV_blank>error\\n"" ) ; VAR_51 = - VAR_52 ; goto VAR_53 ; } METHOD_12 ( & VAR_54 -> VAR_55 , VAR_56 ) ; if ( ! VAR_57 -> VAR_58 ) { METHOD_13 ( VAR_59 -> VAR_60 , VAR_61 ) ; goto VAR_62 ; } VAR_63 -> VAR_64 = 0 ; VAR_65 -> VAR_66 = 0 ; VAR_67 -> VAR_68 = VAR_69 ; VAR_70 -> VAR_71 = VAR_72 ; VAR_73 -> VAR_74 = VAR_75 ; <S2SV_StartBug> VAR_76 = METHOD_14 ( VAR_77 -> VAR_78 , VAR_79 , VAR_80 ) ; <S2SV_EndBug> if ( VAR_81 < 0 ) { METHOD_15 ( VAR_82 -> VAR_83 . VAR_84 -> VAR_85 , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n"" , VAR_86 ) ; <S2SV_StartBug> goto VAR_87 ; <S2SV_EndBug> } else { VAR_88 = VAR_89 ; } <S2SV_StartBug> METHOD_16 ( & VAR_90 -> VAR_91 , VAR_92 ) ; <S2SV_EndBug> return VAR_93 ; VAR_94 : METHOD_17 ( & VAR_95 -> VAR_96 , VAR_97 ) ; <S2SV_StartBug> VAR_98 : <S2SV_EndBug> VAR_99 -> VAR_100 = 0 ; METHOD_18 ( & VAR_101 -> VAR_102 , VAR_103 ) ; METHOD_19 ( & VAR_104 -> VAR_105 ) ; return VAR_106 ; }","<S2SV_ModStart> = VAR_104 ; METHOD_18 ( & VAR_104 -> VAR_102 , VAR_103 ) ; <S2SV_ModStart> ) ; goto VAR_94 <S2SV_ModEnd> ; } else <S2SV_ModStart> VAR_89 ; } <S2SV_ModEnd> return VAR_106 ; <S2SV_ModStart> VAR_103 ) ; <S2SV_ModEnd> VAR_104 -> VAR_100","CWE-189 static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ;   WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , ""copy_from_user<S2SV_blank>error\\n"" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n"" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }","<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending"
209,"CWE-59 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; TYPE_2 VAR_2 [ VAR_3 ] , VAR_4 [ VAR_5 ] , * VAR_6 ; VAR_7 = METHOD_1 ( VAR_8 -> VAR_9 . METHOD_2 ) ; if ( VAR_10 ) { METHOD_3 ( VAR_11 ) ; return ; } VAR_12 = METHOD_4 ( VAR_13 , VAR_14 , VAR_15 ""/init.lxc.static"" ) ; if ( VAR_16 < 0 || VAR_17 >= VAR_18 ) { METHOD_5 ( ""Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>lxc.init.static"" ) ; return ; } if ( ! METHOD_6 ( VAR_19 ) ) { METHOD_7 ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>on<S2SV_blank>host"" , VAR_20 ) ; return ; } VAR_21 = METHOD_8 ( VAR_22 , VAR_23 , ""%s%s"" , VAR_24 -> VAR_25 . METHOD_9 , ""/init.lxc.static"" ) ; if ( VAR_26 < 0 || VAR_27 >= VAR_28 ) { METHOD_10 ( ""Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>container\'s<S2SV_blank>lxc.init.static"" ) ; return ; } if ( ! METHOD_11 ( VAR_29 ) ) { TYPE_3 * VAR_30 = METHOD_12 ( VAR_31 , ""wb"" ) ; if ( ! VAR_32 ) { METHOD_13 ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\'%s\'"" , VAR_33 ) ; return ; } METHOD_14 ( VAR_34 ) ; } <S2SV_StartBug> VAR_35 = METHOD_15 ( VAR_36 , VAR_37 , ""none"" , VAR_38 , VAR_39 ) ; <S2SV_EndBug> if ( VAR_40 < 0 ) METHOD_16 ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ; METHOD_17 ( ""lxc.init.static<S2SV_blank>bound<S2SV_blank>into<S2SV_blank>container<S2SV_blank>at<S2SV_blank>%s"" , VAR_41 ) ; }","<S2SV_ModStart> } VAR_40 = METHOD_18 ( VAR_41 , VAR_37 , ""none"" , VAR_38 , VAR_39 , VAR_24 -> VAR_25 . METHOD_15 <S2SV_ModEnd> ) ; if","CWE-59 void lxc_execute_bind_init ( struct lxc_conf * conf ) { int ret ; char path [ PATH_MAX ] , destpath [ PATH_MAX ] , * p ; p = choose_init ( conf -> rootfs . mount ) ; if ( p ) { free ( p ) ; return ; } ret = snprintf ( path , PATH_MAX , SBINDIR ""/init.lxc.static"" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( ""Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>lxc.init.static"" ) ; return ; } if ( ! file_exists ( path ) ) { INFO ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>on<S2SV_blank>host"" , path ) ; return ; } ret = snprintf ( destpath , PATH_MAX , ""%s%s"" , conf -> rootfs . mount , ""/init.lxc.static"" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( ""Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>container\'s<S2SV_blank>lxc.init.static"" ) ; return ; } if ( ! file_exists ( destpath ) ) { FILE * pathfile = fopen ( destpath , ""wb"" ) ; if ( ! pathfile ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\'%s\'"" , destpath ) ; return ; } fclose ( pathfile ) ; } <S2SV_StartBug> ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ; <S2SV_EndBug> if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ; INFO ( ""lxc.init.static<S2SV_blank>bound<S2SV_blank>into<S2SV_blank>container<S2SV_blank>at<S2SV_blank>%s"" , path ) ; }","<S2SV_ModStart> } ret = safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> ) ; if"
210,"CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { TYPE_1 VAR_1 = 0 , VAR_2 ; TYPE_2 VAR_3 = 0 ; struct STRUCT_OR_UNION_3 * STRUCT_OR_UNION_4 = METHOD_1 ( STRUCT_OR_UNION_5 ) ; struct STRUCT_OR_UNION_6 * VAR_4 = STRUCT_OR_UNION_7 -> VAR_5 ; struct STRUCT_OR_UNION_8 * VAR_6 = METHOD_2 ( VAR_7 ) ; struct STRUCT_OR_UNION_9 * VAR_8 = VAR_9 ; TYPE_3 * VAR_10 = VAR_11 ; struct STRUCT_OR_UNION_10 * VAR_12 [ VAR_13 ] = { } ; TYPE_4 VAR_14 ; TYPE_5 VAR_15 ; struct STRUCT_OR_UNION_11 VAR_16 ; METHOD_3 ( STRUCT_OR_UNION_12 , STRUCT_OR_UNION_13 , ( unsigned TYPE_6 TYPE_7 ) METHOD_4 ( STRUCT_OR_UNION_14 ) -> VAR_17 , STRUCT_OR_UNION_15 -> VAR_18 . VAR_19 , STRUCT_OR_UNION_16 -> VAR_20 . VAR_21 , VAR_22 -> VAR_23 , VAR_24 -> VAR_25 , METHOD_5 ( & VAR_26 , VAR_27 -> VAR_28 ) , METHOD_6 ( & VAR_29 , VAR_30 -> VAR_31 ) ) ; if ( METHOD_7 ( STRUCT_OR_UNION_17 -> VAR_32 ) ) VAR_33 -> VAR_34 &= ~ VAR_35 ; METHOD_8 ( VAR_36 | VAR_37 | VAR_38 | VAR_39 | VAR_40 | VAR_41 | VAR_42 ) if ( ! ( VAR_43 -> VAR_44 & METHOD_9 ) ) return 0 ; VAR_45 = METHOD_10 ( STRUCT_OR_UNION_18 , VAR_46 ) ; if ( VAR_47 ) return VAR_48 ; if ( METHOD_11 ( STRUCT_OR_UNION_19 , VAR_49 ) ) { VAR_50 = METHOD_12 ( STRUCT_OR_UNION_20 ) ; if ( VAR_51 ) return VAR_52 ; } VAR_53 = METHOD_13 ( STRUCT_OR_UNION_21 -> VAR_54 ) && VAR_55 -> VAR_56 & VAR_57 ; if ( VAR_58 ) { <S2SV_StartBug> VAR_59 = METHOD_14 ( STRUCT_OR_UNION_22 , 1 ) ; <S2SV_EndBug> if ( VAR_60 < 0 ) { METHOD_15 ( VAR_61 ) ; goto VAR_62 ; } } VAR_63 = METHOD_16 ( STRUCT_OR_UNION_23 , & VAR_64 , 1 , & VAR_65 ) ; if ( VAR_66 < 0 ) { VAR_67 = VAR_68 ; goto VAR_69 ; } else if ( VAR_70 ) { METHOD_17 ( VAR_71 , ""Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n"" ) ; METHOD_18 ( ) ; } VAR_72 = 1 ; if ( VAR_73 ) { VAR_74 = METHOD_19 ( STRUCT_OR_UNION_24 , VAR_75 -> VAR_76 ) ; if ( VAR_77 ) <S2SV_StartBug> goto VAR_78 ; <S2SV_EndBug> METHOD_20 ( STRUCT_OR_UNION_25 ) ; if ( METHOD_21 ( STRUCT_OR_UNION_26 ) >= VAR_79 -> VAR_80 ) { if ( METHOD_22 ( STRUCT_OR_UNION_27 ) ) { VAR_81 = METHOD_23 ( STRUCT_OR_UNION_28 , VAR_82 -> VAR_83 ) ; if ( VAR_84 ) goto VAR_85 ; } VAR_86 = METHOD_24 ( STRUCT_OR_UNION_29 , VAR_87 , VAR_88 -> VAR_89 ) ; } else VAR_90 = METHOD_25 ( STRUCT_OR_UNION_30 , VAR_91 , VAR_92 -> VAR_93 ) ; if ( VAR_94 < 0 ) { if ( VAR_95 != - VAR_96 ) METHOD_26 ( VAR_97 ) ; VAR_98 = - VAR_99 ; goto VAR_100 ; } } if ( ( VAR_101 -> VAR_102 & VAR_103 && ! METHOD_27 ( VAR_104 -> VAR_105 , STRUCT_OR_UNION_31 -> VAR_106 ) ) || ( VAR_107 -> VAR_108 & VAR_109 && ! METHOD_28 ( VAR_110 -> VAR_111 , STRUCT_OR_UNION_32 -> VAR_112 ) ) ) { if ( VAR_113 -> VAR_114 & VAR_115 && ! METHOD_29 ( VAR_116 -> VAR_117 , STRUCT_OR_UNION_33 -> VAR_118 ) && METHOD_30 ( VAR_119 , VAR_120 ) ) { VAR_121 [ VAR_122 ] = METHOD_31 ( VAR_123 , METHOD_32 ( VAR_124 -> VAR_125 ) ) ; if ( METHOD_33 ( VAR_126 [ VAR_127 ] ) ) { VAR_128 = METHOD_34 ( VAR_129 [ VAR_130 ] ) ; goto VAR_131 ; } } if ( VAR_132 -> VAR_133 & VAR_134 && ! METHOD_35 ( VAR_135 -> VAR_136 , STRUCT_OR_UNION_34 -> VAR_137 ) && METHOD_36 ( VAR_138 , VAR_139 ) ) { VAR_140 [ VAR_141 ] = METHOD_37 ( VAR_142 , METHOD_38 ( VAR_143 -> VAR_144 ) ) ; if ( METHOD_39 ( VAR_145 [ VAR_146 ] ) ) { VAR_147 = METHOD_40 ( VAR_148 [ VAR_149 ] ) ; goto VAR_150 ; } } VAR_151 = METHOD_41 ( VAR_152 , VAR_153 + 2 * METHOD_42 ( VAR_154 ) ) ; if ( METHOD_43 ( VAR_155 ) ) { VAR_156 = METHOD_44 ( VAR_157 ) ; METHOD_45 ( VAR_158 ) ; goto VAR_159 ; } VAR_160 = METHOD_46 ( STRUCT_OR_UNION_35 , VAR_161 ) ; if ( VAR_162 < 0 ) goto VAR_163 ; } else { VAR_164 = METHOD_47 ( VAR_165 , VAR_166 ) ; if ( METHOD_48 ( VAR_167 ) ) { VAR_168 = METHOD_49 ( VAR_169 ) ; METHOD_50 ( VAR_170 ) ; goto VAR_171 ; } } METHOD_51 ( STRUCT_OR_UNION_36 , VAR_172 ) ; METHOD_52 ( STRUCT_OR_UNION_37 ) ; VAR_173 = METHOD_53 ( VAR_174 , STRUCT_OR_UNION_38 , VAR_175 ) ; if ( VAR_176 < 0 ) METHOD_54 ( VAR_177 ) ; VAR_178 : METHOD_55 ( VAR_179 , VAR_180 ) ; VAR_181 : if ( VAR_182 && VAR_183 ) { METHOD_56 ( STRUCT_OR_UNION_39 , 1 , & VAR_184 , VAR_185 ) ; VAR_186 = 0 ; } VAR_187 : if ( VAR_188 ) METHOD_57 ( STRUCT_OR_UNION_40 , 1 ) ; VAR_189 : for ( VAR_190 = 0 ; VAR_191 < VAR_192 ; VAR_193 ++ ) METHOD_58 ( VAR_194 [ VAR_195 ] ) ; if ( ! VAR_196 && VAR_197 -> VAR_198 & VAR_199 ) { VAR_200 = METHOD_59 ( STRUCT_OR_UNION_41 , VAR_201 ) ; if ( VAR_202 < 0 ) METHOD_60 ( VAR_203 ) ; } if ( VAR_204 ) METHOD_61 ( STRUCT_OR_UNION_42 , 1 , & VAR_205 , VAR_206 ) ; METHOD_62 ( VAR_207 ) ; return VAR_208 ; }",<S2SV_ModStart> VAR_188 ) { METHOD_20 ( STRUCT_OR_UNION_42 ) ; <S2SV_ModStart> ) goto VAR_181 <S2SV_ModEnd> ; if (,"CWE-000 int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = OCFS2_SB ( sb ) ; struct buffer_head * bh = NULL ; handle_t * handle = NULL ; struct dquot * transfer_to [ MAXQUOTAS ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( S_ISLNK ( inode -> i_mode ) ) attr -> ia_valid &= ~ ATTR_SIZE ;   OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; if ( size_change ) { <S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ML_ERROR , ""Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n"" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - ENOSPC ) mlog_errno ( status ) ; status = - ENOSPC ; goto bail_unlock ; } } if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & ATTR_MODE ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }",<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
211,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { VAR_3 * VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 ; METHOD_1 ( VAR_7 >= 0 ) ; METHOD_2 ( VAR_8 -> VAR_9 == VAR_10 ) ; VAR_11 = METHOD_3 ( VAR_12 ) ; if ( VAR_13 -> VAR_14 == VAR_15 ) { <S2SV_StartBug> VAR_16 = METHOD_4 ( 64 , ( VAR_17 + 1 ) * 2 ) ; <S2SV_EndBug> VAR_18 -> VAR_19 = ( TYPE_6 * ) METHOD_5 ( sizeof ( TYPE_7 ) + VAR_20 * sizeof ( TYPE_8 * ) ) ; if ( VAR_21 -> VAR_22 == VAR_23 ) return VAR_24 ; METHOD_6 ( VAR_25 -> VAR_26 -> VAR_27 , 0 , VAR_28 * sizeof ( TYPE_9 * ) ) ; VAR_29 -> VAR_30 -> VAR_31 = VAR_32 ; } else if ( VAR_33 >= VAR_34 -> VAR_35 -> VAR_36 ) { VAR_37 = VAR_38 -> VAR_39 -> VAR_40 * 2 ; <S2SV_StartBug> VAR_41 -> VAR_42 = ( TYPE_10 * ) METHOD_7 ( <S2SV_EndBug> VAR_43 -> VAR_44 , sizeof ( TYPE_11 ) + VAR_45 * sizeof ( TYPE_12 * ) ) ; if ( VAR_46 -> VAR_47 == VAR_48 ) return VAR_49 ; for ( VAR_50 = VAR_51 -> VAR_52 -> VAR_53 ; VAR_54 < VAR_55 ; VAR_56 ++ ) VAR_57 -> VAR_58 -> VAR_59 [ VAR_60 ] = VAR_61 ; VAR_62 -> VAR_63 -> VAR_64 = VAR_65 ; } VAR_66 -> VAR_67 = VAR_68 ; VAR_69 -> VAR_70 -> VAR_71 [ VAR_72 ] = VAR_73 ; return VAR_74 ; }",<S2SV_ModStart> { VAR_65 = 64 ; while ( VAR_65 <= VAR_72 ) VAR_65 *= 2 <S2SV_ModEnd> ; VAR_69 -> <S2SV_ModStart> * 2 ; while ( VAR_65 <= VAR_72 ) VAR_65 *= 2 ;,"CWE-119 int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }",<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
212,"CWE-264 METHOD_0 ( TYPE_0 , TYPE_1 , TYPE_2 , TYPE_3 TYPE_4 * , TYPE_5 , TYPE_6 , TYPE_7 ) { const TYPE_8 * VAR_0 [ ] = { METHOD_1 ( ) -> VAR_1 , METHOD_2 ( ) -> VAR_2 , METHOD_3 ( ) -> VAR_3 , METHOD_4 ( ) -> VAR_4 , METHOD_5 ( ) -> VAR_5 , ""alpha"" , ""dummy"" , ""dummy"" , ""dummy"" , } ; unsigned TYPE_9 VAR_6 ; const TYPE_10 * VAR_7 ; TYPE_11 VAR_8 , VAR_9 = - VAR_10 ; VAR_11 = TYPE_12 - 1 ; if ( VAR_12 >= METHOD_6 ( VAR_13 ) ) { METHOD_7 ( ""sysinfo(%d)"" , TYPE_13 ) ; goto VAR_14 ; } METHOD_8 ( & VAR_15 ) ; VAR_16 = VAR_17 [ VAR_18 ] ; VAR_19 = METHOD_9 ( VAR_20 ) + 1 ; <S2SV_StartBug> if ( VAR_21 > TYPE_14 ) <S2SV_EndBug> VAR_22 = TYPE_15 ; if ( METHOD_10 ( TYPE_16 , VAR_23 , VAR_24 ) ) VAR_25 = - VAR_26 ; else VAR_27 = 0 ; METHOD_11 ( & VAR_28 ) ; VAR_29 : return VAR_30 ; }",<S2SV_ModStart> ; if ( ( unsigned TYPE_11 ) VAR_24 > ( unsigned TYPE_11 ) <S2SV_ModEnd> TYPE_15 ) VAR_24,"CWE-264 SYSCALL_DEFINE3 ( osf_sysinfo , int , command , char __user * , buf , long , count ) { const char * sysinfo_table [ ] = { utsname ( ) -> sysname , utsname ( ) -> nodename , utsname ( ) -> release , utsname ( ) -> version , utsname ( ) -> machine , ""alpha"" , ""dummy"" , ""dummy"" , ""dummy"" , } ; unsigned long offset ; const char * res ; long len , err = - EINVAL ; offset = command - 1 ; if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) { printk ( ""sysinfo(%d)"" , command ) ; goto out ; } down_read ( & uts_sem ) ; res = sysinfo_table [ offset ] ; len = strlen ( res ) + 1 ; <S2SV_StartBug> if ( len > count ) <S2SV_EndBug> len = count ; if ( copy_to_user ( buf , res , len ) ) err = - EFAULT ; else err = 0 ; up_read ( & uts_sem ) ; out : return err ; }",<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
213,"CWE-90 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { VAR_6 * VAR_7 ; TYPE_7 VAR_8 ; TYPE_8 VAR_9 ; TYPE_9 VAR_10 = VAR_11 ; TYPE_10 VAR_12 ; VAR_13 * VAR_14 ; unsigned TYPE_11 VAR_15 ; TYPE_12 VAR_16 = VAR_17 ; VAR_18 * VAR_19 ; TYPE_13 VAR_20 ; TYPE_14 VAR_21 = 0 ; TYPE_15 * VAR_22 = VAR_23 ; METHOD_1 ( VAR_24 ) ; METHOD_2 ( VAR_25 -> VAR_26 ) ; METHOD_3 ( VAR_27 , VAR_28 , VAR_29 , VAR_30 , & VAR_31 ) ; if ( VAR_32 == VAR_33 ) return VAR_34 ; if ( ! ( VAR_35 & VAR_36 ) || ( VAR_37 & VAR_38 ) || ( VAR_39 & VAR_40 ) || ( VAR_41 & VAR_42 ) || ( VAR_43 & VAR_44 ) || ( VAR_45 & VAR_46 ) || ( VAR_47 & VAR_48 ) || ( VAR_49 & VAR_50 ) || ( VAR_51 & VAR_52 ) ) return VAR_53 ; if ( ( VAR_54 & VAR_55 ) && VAR_56 -> VAR_57 != 0 ) return VAR_58 ; if ( ( VAR_59 & VAR_60 ) && VAR_61 -> VAR_62 == VAR_63 ) return VAR_64 ; if ( ( VAR_65 & VAR_66 ) && ( VAR_67 & VAR_68 ) ) return VAR_69 ; if ( ( VAR_70 & ~ VAR_71 ) ) <S2SV_StartBug> return VAR_72 ; <S2SV_EndBug> VAR_73 = METHOD_4 ( VAR_74 , VAR_75 -> VAR_76 , & VAR_77 , & VAR_78 ) ; switch ( VAR_79 ) { case VAR_80 : break ; case 0 : METHOD_5 ( VAR_81 , VAR_82 , & VAR_83 ) ; return VAR_84 ; default : return VAR_85 ; } VAR_86 = METHOD_6 ( 1 , sizeof ( * VAR_87 ) ) ; if ( VAR_88 == VAR_89 ) return VAR_90 ; METHOD_7 ( & VAR_91 , 0 , sizeof ( TYPE_16 ) ) ; if ( ( VAR_92 & VAR_93 ) ) { VAR_94 = METHOD_8 ( VAR_95 , VAR_96 -> VAR_97 , & VAR_98 , & VAR_99 ) ; if ( VAR_100 ) goto VAR_101 ; } if ( VAR_102 ) { VAR_103 = METHOD_9 ( VAR_104 , VAR_105 , VAR_106 ? & VAR_107 : VAR_108 , VAR_109 -> VAR_110 ) ; if ( VAR_111 ) goto VAR_112 ; } if ( ( VAR_113 = METHOD_10 ( VAR_114 -> VAR_115 , & VAR_116 ) ) ) goto VAR_117 ; VAR_118 -> VAR_119 = VAR_120 ; VAR_121 -> VAR_122 = VAR_123 ; if ( ( VAR_124 & VAR_125 ) ) VAR_126 -> VAR_127 = VAR_128 -> VAR_129 ; else VAR_130 -> VAR_131 = VAR_132 -> VAR_133 . VAR_134 ; if ( ( VAR_135 & VAR_136 ) ) VAR_137 -> VAR_138 = VAR_139 -> VAR_140 ; else VAR_141 -> VAR_142 = VAR_143 -> VAR_144 . VAR_145 ; if ( VAR_146 & VAR_147 ) VAR_148 -> VAR_149 = VAR_150 -> VAR_151 ; else VAR_152 -> VAR_153 = VAR_154 -> VAR_155 . VAR_156 ; if ( ( VAR_157 & VAR_158 ) ) VAR_159 -> VAR_160 = VAR_161 -> VAR_162 ; else VAR_163 -> VAR_164 = VAR_165 -> VAR_166 . VAR_167 ; VAR_168 -> VAR_169 = 0 ; if ( VAR_170 ) { if ( VAR_171 . VAR_172 ) VAR_173 -> VAR_174 = METHOD_11 ( VAR_175 , VAR_176 . VAR_177 ) ; else VAR_178 -> VAR_179 = 0 ; } if ( ( VAR_180 & VAR_181 ) ) VAR_182 -> VAR_183 = VAR_184 -> VAR_185 ; VAR_186 -> VAR_187 = 0 ; VAR_188 -> VAR_189 = 0 ; VAR_190 -> VAR_191 = 0 ; VAR_192 = METHOD_12 ( VAR_193 -> VAR_194 , VAR_195 -> VAR_196 , & VAR_197 -> VAR_198 ) ; if ( VAR_199 ) goto VAR_200 ; if ( ( VAR_201 = METHOD_13 ( VAR_202 -> VAR_203 , VAR_204 , VAR_205 ) ) ) goto VAR_206 ; if ( VAR_207 & VAR_208 ) { for ( VAR_209 = VAR_210 -> VAR_211 ; VAR_212 ; VAR_213 = VAR_214 -> VAR_215 ) { VAR_216 = METHOD_14 ( VAR_217 -> VAR_218 , VAR_219 , VAR_220 ) ; if ( VAR_221 ) goto VAR_222 ; } } VAR_223 = METHOD_15 ( VAR_224 , VAR_225 -> VAR_226 , VAR_227 , VAR_228 , & VAR_229 , & VAR_230 ) ; if ( VAR_231 ) goto VAR_232 ; VAR_233 = METHOD_16 ( VAR_234 , & VAR_235 , & VAR_236 ) ; if ( VAR_237 ) goto VAR_238 ; if ( VAR_239 & VAR_240 ) { METHOD_17 ( VAR_241 -> VAR_242 == 0 ) ; } else if ( VAR_243 ) { VAR_244 = METHOD_18 ( VAR_245 -> VAR_246 , VAR_247 , VAR_248 , VAR_249 , VAR_250 , ( VAR_251 & VAR_252 ) ? VAR_253 -> VAR_254 : 1 , VAR_255 , VAR_256 ) ; } else { VAR_257 = METHOD_19 ( VAR_258 -> VAR_259 , & VAR_260 , VAR_261 , VAR_262 , VAR_263 , VAR_264 ) ; } if ( VAR_265 ) goto VAR_266 ; VAR_267 = METHOD_20 ( VAR_268 -> VAR_269 , VAR_270 , VAR_271 ) ; if ( VAR_272 ) goto VAR_273 ; VAR_274 = METHOD_21 ( VAR_275 -> VAR_276 , VAR_277 -> VAR_278 , VAR_279 , VAR_280 , VAR_281 , VAR_282 , VAR_283 , VAR_284 ) ; if ( VAR_285 ) goto VAR_286 ; VAR_287 . VAR_288 = VAR_289 ; if ( VAR_290 & VAR_291 ) { VAR_292 . VAR_293 = VAR_294 ; VAR_295 . VAR_296 = VAR_297 -> VAR_298 ; } VAR_299 -> VAR_300 = VAR_301 | VAR_302 | VAR_303 ; VAR_304 = METHOD_22 ( VAR_305 , VAR_306 , & VAR_307 ) ; ( TYPE_17 ) METHOD_23 ( VAR_308 -> VAR_309 , VAR_310 -> VAR_311 , VAR_312 , VAR_313 , VAR_314 , VAR_315 , VAR_316 , VAR_317 ) ; VAR_318 : METHOD_24 ( VAR_319 ) ; METHOD_25 ( VAR_320 -> VAR_321 , VAR_322 ) ; if ( VAR_323 ) ( TYPE_18 ) METHOD_26 ( VAR_324 -> VAR_325 , & VAR_326 ) ; return VAR_327 ; }",<S2SV_ModStart> return VAR_72 ; if ( VAR_314 & VAR_208 ) { for ( VAR_220 = VAR_313 -> VAR_211 ; VAR_220 != VAR_108 ; VAR_220 = VAR_220 -> VAR_215 ) { if ( VAR_220 -> VAR_328 < 256 ) return VAR_329 ; } },"CWE-90 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }",<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
214,"CWE-20 <S2SV_StartBug> TYPE_0 METHOD_0 ( unsigned TYPE_1 * VAR_0 , <S2SV_EndBug> struct STRUCT_OR_UNION_0 * VAR_1 ) { TYPE_2 VAR_2 , VAR_3 ; VAR_4 = * VAR_5 ++ ; <S2SV_StartBug> if ( VAR_6 == 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> while ( VAR_7 > 0 ) { <S2SV_EndBug> if ( * VAR_8 == 0x00 ) { VAR_9 -- ; VAR_10 ++ ; switch ( * VAR_11 ) { case VAR_12 : VAR_13 = METHOD_1 ( VAR_14 + 1 , VAR_15 , VAR_16 - 1 ) ; <S2SV_StartBug> if ( VAR_17 < 0 ) <S2SV_EndBug> return 0 ; VAR_18 -= VAR_19 + 1 ; VAR_20 += VAR_21 + 1 ; break ; case VAR_22 : VAR_23 = METHOD_2 ( VAR_24 + 1 , VAR_25 , VAR_26 - 1 ) ; <S2SV_StartBug> if ( VAR_27 < 0 ) <S2SV_EndBug> return 0 ; VAR_28 -= VAR_29 + 1 ; VAR_30 += VAR_31 + 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * VAR_32 ) ; VAR_33 -- ; VAR_34 ++ ; break ; } } else break ; } return 1 ; }","<S2SV_ModStart> TYPE_1 * VAR_34 , unsigned VAR_35 <S2SV_ModStart> VAR_33 == 0 || ( unsigned ) VAR_33 > VAR_35 <S2SV_ModStart> while ( VAR_33 >= 3 && <S2SV_ModEnd> * VAR_34 == <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> 1 ) ; break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * VAR_34 ) ; VAR_31 = 1 ; break ; } <S2SV_ModStart> VAR_31 < 0 ) return 0 ; if ( METHOD_3 ( VAR_31 >= VAR_33 ) <S2SV_ModStart> + 1 ; } return VAR_33 == 0 <S2SV_ModEnd> ; } <S2SV_null>","CWE-20 <S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> return 0 ; facilities_len -= len + 1 ; p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> return 0 ; facilities_len -= len + 1 ; p += len + 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }","<S2SV_ModStart> char * p , unsigned packet_len <S2SV_ModStart> facilities_len == 0 || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> while ( facilities_len >= 3 && <S2SV_ModEnd> * p == <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> 1 ) ; break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> len < 0 ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> + 1 ; } return facilities_len == 0 <S2SV_ModEnd> ; } <S2SV_null>"
215,"CWE-264 static VAR_0 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 ) { const struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = METHOD_1 ( ) ; TYPE_1 VAR_2 = METHOD_2 ( STRUCT_OR_UNION_3 -> VAR_3 , VAR_4 -> VAR_5 ) ; TYPE_2 VAR_6 = METHOD_3 ( STRUCT_OR_UNION_4 -> VAR_7 , VAR_8 -> VAR_9 ) ; if ( ! METHOD_4 ( VAR_10 ) || ! METHOD_5 ( VAR_11 ) ) return - VAR_12 ; <S2SV_StartBug> if ( ( VAR_13 -> VAR_14 == METHOD_6 ( VAR_15 ) || METHOD_7 ( VAR_16 ) ) && <S2SV_EndBug> ( ( METHOD_8 ( VAR_17 , STRUCT_OR_UNION_5 -> VAR_18 ) || METHOD_9 ( VAR_19 , STRUCT_OR_UNION_6 -> VAR_20 ) || METHOD_10 ( VAR_21 , STRUCT_OR_UNION_7 -> VAR_22 ) ) || METHOD_11 ( VAR_23 ) ) && ( ( METHOD_12 ( VAR_24 , STRUCT_OR_UNION_8 -> VAR_25 ) || METHOD_13 ( VAR_26 , STRUCT_OR_UNION_9 -> VAR_27 ) || METHOD_14 ( VAR_28 , STRUCT_OR_UNION_10 -> VAR_29 ) ) || METHOD_15 ( VAR_30 ) ) ) { return 0 ; } return - VAR_31 ; }","<S2SV_ModStart> VAR_15 ) || METHOD_16 ( VAR_15 -> VAR_32 -> VAR_33 -> VAR_7 , <S2SV_ModEnd> VAR_16 ) )","CWE-264 static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - EINVAL ; <S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) { return 0 ; } return - EPERM ; }","<S2SV_ModStart> current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> CAP_SYS_ADMIN ) )"
216,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> VAR_2 += <S2SV_EndBug> METHOD_1 ( VAR_3 , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , VAR_4 , VAR_5 ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> VAR_5 ) { METHOD_1 ( VAR_6 <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , <S2SV_ModStart> VAR_5 ) ; METHOD_2 ( VAR_6 ) ;","CWE-20 void MoveTo ( double x1 , double y1 ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , x1 , y1 ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> y1 ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m"" , <S2SV_ModStart> y1 ) ; sendClean ( outputbuffer ) ;"
217,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; VAR_3 = METHOD_1 ( VAR_4 , VAR_5 -> VAR_6 ) ; if ( VAR_7 == VAR_8 ) return - VAR_9 ; if ( VAR_10 -> VAR_11 ) { unsigned TYPE_1 VAR_12 ; for ( VAR_13 = 0 ; VAR_14 < VAR_15 -> VAR_16 ; VAR_17 ++ ) { struct STRUCT_OR_UNION_3 VAR_18 ; <S2SV_StartBug> METHOD_2 ( & VAR_19 -> VAR_20 [ VAR_21 ] , & VAR_22 ) ; <S2SV_EndBug> if ( METHOD_3 ( & VAR_23 -> VAR_24 [ VAR_25 ] , & VAR_26 , sizeof ( VAR_27 ) ) ) return - VAR_28 ; } } if ( VAR_29 -> VAR_30 ) { struct STRUCT_OR_UNION_4 TYPE_2 * VAR_31 ; unsigned TYPE_3 VAR_32 ; for ( VAR_33 = 0 , VAR_34 = VAR_35 -> VAR_36 ; VAR_37 < VAR_38 -> VAR_39 ; VAR_40 ++ ) { struct STRUCT_OR_UNION_5 VAR_41 ; if ( VAR_42 -> VAR_43 [ VAR_44 ] . VAR_45 -> VAR_46 != VAR_47 ) continue ; <S2SV_StartBug> METHOD_4 ( VAR_48 -> VAR_49 [ VAR_50 ] . VAR_51 , <S2SV_EndBug> & VAR_52 . VAR_53 ) ; METHOD_5 ( VAR_54 -> VAR_55 [ VAR_56 ] . VAR_57 , & VAR_58 . VAR_59 ) ; VAR_60 . VAR_61 = VAR_62 -> VAR_63 [ VAR_64 ] . VAR_65 ; if ( METHOD_6 ( VAR_66 , & VAR_67 , sizeof ( * VAR_68 ) ) ) return - VAR_69 ; VAR_70 ++ ; } } return 0 ; }","<S2SV_ModStart> STRUCT_OR_UNION_3 VAR_27 ; METHOD_7 ( & VAR_27 , 0 , sizeof ( VAR_27 ) ) ; <S2SV_ModStart> ) continue ; METHOD_7 ( & VAR_67 , 0 , sizeof ( VAR_67 ) ) ;","CWE-200 static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }","<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;"
218,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; VAR_2 = METHOD_1 ( VAR_3 ) ; if ( VAR_4 ) { METHOD_2 ( VAR_5 , VAR_6 , VAR_7 -> VAR_8 , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n"" ) ; goto VAR_9 ; } VAR_10 = METHOD_3 ( VAR_11 ) ; if ( VAR_12 ) { METHOD_4 ( VAR_13 , VAR_14 , VAR_15 -> VAR_16 , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n"" ) ; goto VAR_17 ; } <S2SV_StartBug> VAR_18 -> VAR_19 = VAR_20 -> VAR_21 = VAR_22 ; <S2SV_EndBug> VAR_23 = METHOD_5 ( VAR_24 ) ; if ( VAR_25 ) goto VAR_26 ; VAR_27 = METHOD_6 ( VAR_28 ) ; if ( VAR_29 ) { METHOD_7 ( VAR_30 , VAR_31 , VAR_32 -> VAR_33 , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n"" ) ; goto VAR_34 ; } return 0 ; VAR_35 : METHOD_8 ( VAR_36 ) ; VAR_37 : METHOD_9 ( VAR_38 ) ; VAR_39 : METHOD_10 ( VAR_40 ) ; VAR_41 : return VAR_42 ; }",<S2SV_ModStart> VAR_39 ; } METHOD_11 ( VAR_22 < VAR_43 ) ; if ( METHOD_13 ( VAR_22 < METHOD_12 ( VAR_40 ) ) ) { VAR_42 = - VAR_44 ; goto VAR_37 ; },"CWE-189 static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n"" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n"" ) ; goto fail2 ; } <S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n"" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }",<S2SV_ModStart> fail2 ; } BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; }
219,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; <S2SV_EndBug> struct STRUCT_OR_UNION_6 * VAR_6 = ( struct STRUCT_OR_UNION_7 * ) VAR_7 -> VAR_8 ; struct STRUCT_OR_UNION_8 * VAR_9 ; TYPE_3 VAR_10 = 0 ; TYPE_4 VAR_11 = 0 ; TYPE_5 VAR_12 = 0 ; struct STRUCT_OR_UNION_9 * VAR_13 ; VAR_14 = METHOD_1 ( VAR_15 , VAR_16 & ~ VAR_17 , VAR_18 & VAR_19 , & VAR_20 ) ; METHOD_2 ( VAR_21 ) ; if ( ! VAR_22 ) goto VAR_23 ; VAR_24 = METHOD_3 ( VAR_25 ) ; VAR_26 = METHOD_4 ( VAR_27 -> VAR_28 ) & 1023 ; if ( VAR_29 -> VAR_30 != VAR_31 ) { VAR_32 = sizeof ( * VAR_33 ) ; VAR_34 -= VAR_35 ; } if ( VAR_36 > VAR_37 ) { VAR_38 = VAR_39 ; VAR_40 -> VAR_41 |= VAR_42 ; } VAR_43 = METHOD_5 ( VAR_44 , VAR_45 , VAR_46 -> VAR_47 , VAR_48 ) ; <S2SV_StartBug> if ( ! VAR_49 ) { <S2SV_EndBug> if ( VAR_50 ) { VAR_51 -> VAR_52 = VAR_53 ; VAR_54 -> VAR_55 = VAR_56 -> VAR_57 ; VAR_58 -> VAR_59 . VAR_60 = VAR_61 -> VAR_62 ; VAR_63 -> VAR_64 . VAR_65 = VAR_66 -> VAR_67 ; <S2SV_StartBug> } <S2SV_EndBug> VAR_68 -> VAR_69 = sizeof ( * VAR_70 ) ; } METHOD_6 ( VAR_71 , VAR_72 ) ; VAR_73 : METHOD_7 ( VAR_74 ) ; return VAR_75 ? : VAR_76 ; }",<S2SV_ModStart> STRUCT_OR_UNION_5 -> VAR_74 <S2SV_ModEnd> ; struct STRUCT_OR_UNION_8 <S2SV_ModStart> ( ! VAR_75 && VAR_68 -> VAR_8 ) { struct STRUCT_OR_UNION_7 * VAR_70 = VAR_68 -> VAR_8 ; <S2SV_ModEnd> VAR_70 -> VAR_52 <S2SV_ModStart> -> VAR_67 ; <S2SV_ModEnd> VAR_68 -> VAR_69,"CWE-20 static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }",<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
220,"CWE-125 static TYPE_0 METHOD_0 ( register TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; VAR_2 * VAR_3 ; VAR_4 * VAR_5 ; TYPE_3 VAR_6 ; TYPE_4 VAR_7 ; TYPE_5 * VAR_8 ; TYPE_6 VAR_9 ; TYPE_7 VAR_10 ; TYPE_8 VAR_11 ; TYPE_9 VAR_12 ; TYPE_10 VAR_13 ; VAR_14 = VAR_15 -> VAR_16 ; if ( ! VAR_17 -> VAR_18 ) { goto VAR_19 ; } else { VAR_20 -> VAR_21 = 0 ; } for ( VAR_22 -> VAR_23 = VAR_24 -> VAR_25 , VAR_26 -> VAR_27 = & VAR_28 -> VAR_29 [ VAR_30 -> VAR_31 ] ; VAR_32 -> VAR_33 < METHOD_1 ( TYPE_11 , VAR_34 -> compnoend ) && VAR_35 -> VAR_36 < VAR_37 -> VAR_38 ; ++ VAR_39 -> VAR_40 , ++ VAR_41 -> VAR_42 ) { <S2SV_StartBug> VAR_43 = VAR_44 -> VAR_45 -> VAR_46 ; <S2SV_EndBug> VAR_47 -> VAR_48 = VAR_49 -> VAR_50 -> VAR_51 * ( METHOD_2 ( TYPE_12 , 1 ) << ( VAR_52 -> VAR_53 + VAR_54 -> VAR_55 -> VAR_56 - 1 ) ) ; VAR_57 -> VAR_58 = VAR_59 -> VAR_60 -> VAR_61 * ( METHOD_3 ( TYPE_13 , 1 ) << ( VAR_62 -> VAR_63 + VAR_64 -> VAR_65 -> VAR_66 - 1 ) ) ; for ( VAR_67 = 1 , VAR_68 = & VAR_69 -> VAR_70 -> VAR_71 [ 1 ] ; VAR_72 < VAR_73 -> VAR_74 -> VAR_75 ; ++ VAR_76 , ++ VAR_77 ) { VAR_78 -> VAR_79 = METHOD_4 ( VAR_80 -> VAR_81 , VAR_82 -> VAR_83 -> VAR_84 * ( METHOD_5 ( TYPE_14 , 1 ) << ( VAR_85 -> VAR_86 + VAR_87 -> VAR_88 -> VAR_89 - VAR_90 - 1 ) ) ) ; VAR_91 -> VAR_92 = METHOD_6 ( VAR_93 -> VAR_94 , VAR_95 -> VAR_96 -> VAR_97 * ( METHOD_7 ( TYPE_15 , 1 ) << ( VAR_98 -> VAR_99 + VAR_100 -> VAR_101 -> VAR_102 - VAR_103 - 1 ) ) ) ; } for ( VAR_104 -> VAR_105 = VAR_106 -> VAR_107 ; VAR_108 -> VAR_109 < VAR_110 -> VAR_111 ; VAR_112 -> VAR_113 += VAR_114 -> VAR_115 - ( VAR_116 -> VAR_117 % VAR_118 -> VAR_119 ) ) { for ( VAR_120 -> VAR_121 = VAR_122 -> VAR_123 ; VAR_124 -> VAR_125 < VAR_126 -> VAR_127 ; VAR_128 -> VAR_129 += VAR_130 -> VAR_131 - ( VAR_132 -> VAR_133 % VAR_134 -> VAR_135 ) ) { for ( VAR_136 -> VAR_137 = VAR_138 -> VAR_139 , VAR_140 -> VAR_141 = & VAR_142 -> VAR_143 -> VAR_144 [ VAR_145 -> VAR_146 ] ; VAR_147 -> VAR_148 < VAR_149 -> VAR_150 -> VAR_151 && VAR_152 -> VAR_153 < VAR_154 -> VAR_155 ; ++ VAR_156 -> VAR_157 , ++ VAR_158 -> VAR_159 ) { if ( VAR_160 -> VAR_161 -> VAR_162 == 0 ) { continue ; } VAR_163 = VAR_164 -> VAR_165 -> VAR_166 - 1 - VAR_167 -> VAR_168 ; VAR_169 = METHOD_8 ( VAR_170 -> VAR_171 , VAR_172 -> VAR_173 -> VAR_174 << VAR_175 ) ; VAR_176 = METHOD_9 ( VAR_177 -> VAR_178 , VAR_179 -> VAR_180 -> VAR_181 << VAR_182 ) ; VAR_183 = VAR_184 + VAR_185 -> VAR_186 -> VAR_187 ; VAR_188 = VAR_189 + VAR_190 -> VAR_191 -> VAR_192 ; <S2SV_StartBug> if ( ( ( VAR_193 -> VAR_194 == VAR_195 -> VAR_196 && ( ( VAR_197 << VAR_198 ) % ( 1 << VAR_199 ) ) ) || <S2SV_EndBug> ! ( VAR_200 -> VAR_201 % ( VAR_202 -> VAR_203 -> VAR_204 << VAR_205 ) ) ) && <S2SV_StartBug> ( ( VAR_206 -> VAR_207 == VAR_208 -> VAR_209 && ( ( VAR_210 << VAR_211 ) % ( 1 << VAR_212 ) ) ) || <S2SV_EndBug> ! ( VAR_213 -> VAR_214 % ( VAR_215 -> VAR_216 -> VAR_217 << VAR_218 ) ) ) ) { VAR_219 = METHOD_10 ( METHOD_11 ( VAR_220 -> VAR_221 , VAR_222 -> VAR_223 -> VAR_224 << VAR_225 ) , VAR_226 -> VAR_227 -> VAR_228 ) - METHOD_12 ( VAR_229 , VAR_230 -> VAR_231 -> VAR_232 ) ; VAR_233 = METHOD_13 ( METHOD_14 ( VAR_234 -> VAR_235 , VAR_236 -> VAR_237 -> VAR_238 << VAR_239 ) , VAR_240 -> VAR_241 -> VAR_242 ) - METHOD_15 ( VAR_243 , VAR_244 -> VAR_245 -> VAR_246 ) ; VAR_247 -> VAR_248 = VAR_249 * VAR_250 -> VAR_251 -> VAR_252 + VAR_253 ; METHOD_16 ( VAR_254 -> VAR_255 < VAR_256 -> VAR_257 -> VAR_258 ) ; for ( VAR_259 -> VAR_260 = 0 ; VAR_261 -> VAR_262 < VAR_263 -> VAR_264 && VAR_265 -> VAR_266 < METHOD_17 ( TYPE_16 , VAR_267 -> lyrnoend ) ; ++ VAR_268 -> VAR_269 ) { VAR_270 = & VAR_271 -> VAR_272 -> VAR_273 [ VAR_274 -> VAR_275 ] ; if ( VAR_276 -> VAR_277 >= * VAR_278 ) { ++ ( * VAR_279 ) ; return 0 ; } VAR_280 : ; } } } } } } return 1 ; }","<S2SV_ModStart> -> VAR_144 ; if ( VAR_272 -> VAR_232 + VAR_276 -> VAR_237 -> VAR_166 > VAR_281 - 2 || VAR_272 -> VAR_246 + VAR_276 -> VAR_237 -> VAR_166 > VAR_281 - 2 ) { return - 1 ; } <S2SV_ModStart> ) % ( METHOD_17 ( TYPE_15 , 1 ) <S2SV_ModEnd> << VAR_205 ) <S2SV_ModStart> ) % ( METHOD_17 ( TYPE_15 , 1 ) <S2SV_ModEnd> << VAR_218 )","CWE-125 static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { <S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ; pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }","<S2SV_ModStart> -> pirlvls ; if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )"
221,"CWE-190 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 * VAR_4 ) { struct STRUCT_OR_UNION_3 VAR_5 ; TYPE_5 VAR_6 ; VAR_7 . VAR_8 = VAR_9 ; VAR_10 . VAR_11 = VAR_12 -> VAR_13 >> STRUCT_OR_UNION_4 -> VAR_14 ; VAR_15 . VAR_16 = VAR_17 ; VAR_18 = STRUCT_OR_UNION_5 ( STRUCT_OR_UNION_6 , & VAR_19 , VAR_20 , VAR_21 ) ; if ( ! VAR_22 ) { METHOD_1 ( VAR_23 , STRUCT_OR_UNION_7 -> VAR_24 , VAR_25 . VAR_26 ) ; VAR_27 -> VAR_28 = ( VAR_29 -> VAR_30 & ~ VAR_31 ) | VAR_32 . VAR_33 ; <S2SV_StartBug> VAR_34 -> VAR_35 = VAR_36 . VAR_37 << STRUCT_OR_UNION_8 -> VAR_38 ; <S2SV_EndBug> } return VAR_39 ; }",<S2SV_ModStart> -> VAR_35 = ( TYPE_6 ),"CWE-190 static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> } return err ; }",<S2SV_ModStart> -> b_size = ( u64 )
222,"CWE-119 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 * VAR_3 = VAR_4 -> VAR_5 -> VAR_6 ; TYPE_5 * VAR_7 = METHOD_1 ( VAR_8 -> VAR_9 -> VAR_10 [ 0 ] , VAR_11 + ( VAR_12 -> VAR_13 - VAR_14 -> VAR_15 ) , VAR_16 + ( VAR_17 -> VAR_18 - VAR_19 -> VAR_20 ) ) ; TYPE_6 VAR_21 ; if ( ! VAR_22 ) return VAR_23 ; VAR_24 -> VAR_25 = VAR_26 ; VAR_27 -> VAR_28 = VAR_29 ; <S2SV_StartBug> for ( VAR_30 = 0 ; VAR_31 < 4 && VAR_32 -> VAR_33 [ VAR_34 ] ; VAR_35 ++ ) { <S2SV_EndBug> TYPE_7 VAR_36 = VAR_37 -> VAR_38 . VAR_39 [ VAR_40 ] ; TYPE_8 VAR_41 = VAR_42 -> VAR_43 . VAR_44 [ VAR_45 ] ; VAR_46 -> VAR_47 [ VAR_48 ] += ( VAR_49 -> VAR_50 >> VAR_51 ) * VAR_52 -> VAR_53 . VAR_54 [ VAR_55 ] + ( VAR_56 -> VAR_57 >> VAR_58 ) * VAR_59 -> VAR_60 [ VAR_61 ] ; } return VAR_62 ; }",<S2SV_ModStart> [ VAR_61 ] && VAR_62 -> VAR_60 [ VAR_61 ],"CWE-119 static AVFrame * get_video_buffer ( AVFilterLink * inlink , int w , int h ) { PadContext * s = inlink -> dst -> priv ; AVFrame * frame = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , w + ( s -> w - s -> in_w ) , h + ( s -> h - s -> in_h ) ) ; int plane ; if ( ! frame ) return NULL ; frame -> width = w ; frame -> height = h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ plane ] ; int vsub = s -> draw . vsub [ plane ] ; frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] + ( s -> y >> vsub ) * frame -> linesize [ plane ] ; } return frame ; }",<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
223,"CWE-119 static enum VAR_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { TYPE_0 VAR_3 , VAR_4 , VAR_5 ; TYPE_1 VAR_6 ; VAR_7 * VAR_8 ; struct STRUCT_OR_UNION_2 * VAR_9 ; METHOD_1 ( VAR_10 , VAR_11 ) ; METHOD_2 ( VAR_12 , VAR_13 ) ; METHOD_3 ( VAR_14 -> VAR_15 , VAR_16 ) ; METHOD_4 ( VAR_17 -> VAR_18 -> VAR_19 & VAR_20 ) ; METHOD_5 ( VAR_21 -> VAR_22 == VAR_23 ) ; VAR_24 -> VAR_25 -> VAR_26 ++ ; VAR_27 = METHOD_6 ( VAR_28 ) ; METHOD_7 ( VAR_29 , ""Error"" , VAR_30 ) ; if ( VAR_31 -> VAR_32 -> VAR_33 -> VAR_34 != VAR_35 ) METHOD_8 ( VAR_36 -> VAR_37 , VAR_38 -> VAR_39 ) ; METHOD_9 ( VAR_40 -> VAR_41 , VAR_42 -> VAR_43 , VAR_44 -> VAR_45 , VAR_46 ) ; METHOD_10 ( VAR_47 -> VAR_48 , ""HTTP/1.1"" , 503 , ""Backend<S2SV_blank>fetch<S2SV_blank>failed"" ) ; METHOD_11 ( VAR_49 -> VAR_50 , ""Date:<S2SV_blank>"" , VAR_51 ) ; METHOD_12 ( VAR_52 -> VAR_53 , ""Server:<S2SV_blank>Varnish"" ) ; VAR_54 -> VAR_55 -> VAR_56 = VAR_57 ; if ( ! METHOD_13 ( & VAR_58 -> VAR_59 -> VAR_60 -> VAR_61 ) ) { VAR_62 -> VAR_63 -> VAR_64 = 1 ; VAR_65 -> VAR_66 -> VAR_67 = 5 ; VAR_68 -> VAR_69 -> VAR_70 = 5 ; } else { VAR_71 -> VAR_72 -> VAR_73 = 0 ; VAR_74 -> VAR_75 -> VAR_76 = 0 ; VAR_77 -> VAR_78 -> VAR_79 = 0 ; } VAR_80 = METHOD_14 ( ) ; METHOD_15 ( VAR_81 ) ; METHOD_16 ( VAR_82 -> VAR_83 , VAR_84 , VAR_85 , VAR_86 , VAR_87 ) ; METHOD_17 ( METHOD_18 ( VAR_88 ) ) ; if ( VAR_89 -> VAR_90 == VAR_91 || VAR_92 -> VAR_93 == VAR_94 ) { METHOD_19 ( & VAR_95 ) ; return ( VAR_96 ) ; } if ( VAR_97 -> VAR_98 == VAR_99 ) { METHOD_20 ( & VAR_100 ) ; if ( VAR_101 -> VAR_102 ++ < VAR_103 -> VAR_104 ) return ( VAR_105 ) ; METHOD_21 ( VAR_106 -> VAR_107 , VAR_108 , ""Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing"" ) ; return ( VAR_109 ) ; } METHOD_22 ( VAR_110 -> VAR_111 == VAR_112 ) ; VAR_113 -> VAR_114 -> VAR_115 = VAR_116 ; VAR_117 -> VAR_118 -> VAR_119 = VAR_120 -> VAR_121 ; VAR_122 -> VAR_123 -> VAR_124 = VAR_125 -> VAR_126 ; VAR_127 -> VAR_128 -> VAR_129 = VAR_130 -> VAR_131 ; VAR_132 -> VAR_133 -> VAR_134 = VAR_135 -> VAR_136 ; if ( METHOD_23 ( VAR_137 ) ) { ( TYPE_2 ) METHOD_24 ( VAR_138 -> VAR_139 , ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage"" ) ; METHOD_25 ( & VAR_140 ) ; return ( VAR_141 ) ; } VAR_142 = METHOD_26 ( VAR_143 ) ; VAR_144 = 0 ; while ( VAR_145 > 0 ) { VAR_146 = VAR_147 ; if ( METHOD_27 ( VAR_148 -> VAR_149 , & VAR_150 , & VAR_151 ) != VAR_152 ) break ; <S2SV_StartBug> METHOD_28 ( VAR_153 , METHOD_29 ( VAR_154 ) + VAR_155 , VAR_156 ) ; <S2SV_EndBug> METHOD_30 ( VAR_157 -> VAR_158 , VAR_159 ) ; VAR_160 -= VAR_161 ; VAR_162 += VAR_163 ; } METHOD_31 ( METHOD_32 ( VAR_164 , VAR_165 -> VAR_166 , VAR_167 , VAR_168 ) ) ; METHOD_33 ( & VAR_169 ) ; METHOD_34 ( VAR_170 , VAR_171 -> VAR_172 ) ; METHOD_35 ( VAR_173 , VAR_174 -> VAR_175 , VAR_176 ) ; return ( VAR_177 ) ; }",<S2SV_ModStart> ) break ; if ( VAR_163 > VAR_160 ) VAR_163 = VAR_160 ;,"CWE-119 static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , ""Error"" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , ""HTTP/1.1"" , 503 , ""Backend<S2SV_blank>fetch<S2SV_blank>failed"" ) ; http_TimeHeader ( bo -> beresp , ""Date:<S2SV_blank>"" , now ) ; http_SetHeader ( bo -> beresp , ""Server:<S2SV_blank>Varnish"" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , ""Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing"" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage"" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ; <S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }",<S2SV_ModStart> ) break ; if ( l > ll ) l = ll ;
224,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 ; struct STRUCT_OR_UNION_4 * VAR_4 = METHOD_1 ( VAR_5 ) ; if ( ! VAR_6 -> VAR_7 || ! METHOD_2 ( VAR_8 , & VAR_9 -> VAR_10 ) ) return - VAR_11 ; * VAR_12 = sizeof ( struct STRUCT_OR_UNION_5 ) ; VAR_13 = ( struct STRUCT_OR_UNION_6 * ) STRUCT_OR_UNION_7 ; <S2SV_StartBug> VAR_14 -> VAR_15 = VAR_16 ; <S2SV_EndBug> VAR_17 -> VAR_18 . VAR_19 = VAR_20 -> VAR_21 -> VAR_22 ; VAR_23 -> VAR_24 . VAR_25 = VAR_26 -> VAR_27 ; VAR_28 -> VAR_29 . VAR_30 = VAR_31 -> VAR_32 ; return 0 ; }","<S2SV_ModStart> ) STRUCT_OR_UNION_7 ; METHOD_3 ( VAR_28 , 0 , sizeof ( * VAR_28 ) ) ;","CWE-200 static int pvc_getname ( struct socket * sock , struct sockaddr * sockaddr , int * sockaddr_len , int peer ) { struct sockaddr_atmpvc * addr ; struct atm_vcc * vcc = ATM_SD ( sock ) ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; * sockaddr_len = sizeof ( struct sockaddr_atmpvc ) ; addr = ( struct sockaddr_atmpvc * ) sockaddr ; <S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> addr -> sap_addr . itf = vcc -> dev -> number ; addr -> sap_addr . vpi = vcc -> vpi ; addr -> sap_addr . vci = vcc -> vci ; return 0 ; }","<S2SV_ModStart> ) sockaddr ; memset ( addr , 0 , sizeof ( * addr ) ) ;"
225,CWE-17 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { if ( METHOD_1 ( & STRUCT_OR_UNION_2 -> VAR_0 ) ) { struct STRUCT_OR_UNION_3 * VAR_1 = VAR_2 ; <S2SV_StartBug> METHOD_2 ( STRUCT_OR_UNION_4 ) ; <S2SV_EndBug> METHOD_3 ( ! ( VAR_3 -> VAR_4 & VAR_5 ) ) ; METHOD_4 ( STRUCT_OR_UNION_5 ) ; } },<S2SV_ModStart> = VAR_2 ; <S2SV_ModEnd> METHOD_3 ( !,CWE-17 void __fput_sync ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ; __fput ( file ) ; } },<S2SV_ModStart> = current ; <S2SV_ModEnd> BUG_ON ( !
226,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 -> VAR_4 -> VAR_5 ; TYPE_4 * VAR_6 ; TYPE_5 VAR_7 = METHOD_1 ( VAR_8 , VAR_9 ) ; if ( VAR_10 ) { METHOD_2 ( VAR_11 -> VAR_12 , VAR_13 , ""Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n"" ) ; VAR_14 = METHOD_3 ( VAR_15 -> VAR_16 -> VAR_17 [ 0 ] , METHOD_4 ( VAR_18 -> VAR_19 , VAR_20 -> VAR_21 ) , METHOD_5 ( VAR_22 -> VAR_23 , VAR_24 -> VAR_25 ) ) ; if ( ! VAR_26 ) { METHOD_6 ( & VAR_27 ) ; return METHOD_7 ( VAR_28 ) ; } METHOD_8 ( VAR_29 , VAR_30 ) ; } else { TYPE_6 VAR_31 ; VAR_32 = VAR_33 ; <S2SV_StartBug> for ( VAR_34 = 0 ; VAR_35 < 4 && VAR_36 -> VAR_37 [ VAR_38 ] ; VAR_39 ++ ) { <S2SV_EndBug> TYPE_7 VAR_40 = VAR_41 -> VAR_42 . VAR_43 [ VAR_44 ] ; TYPE_8 VAR_45 = VAR_46 -> VAR_47 . VAR_48 [ VAR_49 ] ; VAR_50 -> VAR_51 [ VAR_52 ] -= ( VAR_53 -> VAR_54 >> VAR_55 ) * VAR_56 -> VAR_57 . VAR_58 [ VAR_59 ] + ( VAR_60 -> VAR_61 >> VAR_62 ) * VAR_63 -> VAR_64 [ VAR_65 ] ; } } if ( VAR_66 -> VAR_67 ) { METHOD_9 ( & VAR_68 -> VAR_69 , & VAR_70 -> VAR_71 , VAR_72 -> VAR_73 , VAR_74 -> VAR_75 , 0 , 0 , VAR_76 -> VAR_77 , VAR_78 -> VAR_79 ) ; } if ( VAR_80 -> VAR_81 > VAR_82 -> VAR_83 + VAR_84 -> VAR_85 ) { METHOD_10 ( & VAR_86 -> VAR_87 , & VAR_88 -> VAR_89 , VAR_90 -> VAR_91 , VAR_92 -> VAR_93 , 0 , VAR_94 -> VAR_95 + VAR_96 -> VAR_97 , VAR_98 -> VAR_99 , VAR_100 -> VAR_101 - VAR_102 -> VAR_103 - VAR_104 -> VAR_105 ) ; } METHOD_11 ( & VAR_106 -> VAR_107 , & VAR_108 -> VAR_109 , VAR_110 -> VAR_111 , VAR_112 -> VAR_113 , 0 , VAR_114 -> VAR_115 , VAR_116 -> VAR_117 , VAR_118 -> VAR_119 ) ; if ( VAR_120 ) { METHOD_12 ( & VAR_121 -> VAR_122 , VAR_123 -> VAR_124 , VAR_125 -> VAR_126 , VAR_127 -> VAR_128 , VAR_129 -> VAR_130 , VAR_131 -> VAR_132 , VAR_133 -> VAR_134 , 0 , 0 , VAR_135 -> VAR_136 , VAR_137 -> VAR_138 ) ; } METHOD_13 ( & VAR_139 -> VAR_140 , & VAR_141 -> VAR_142 , VAR_143 -> VAR_144 , VAR_145 -> VAR_146 , VAR_147 -> VAR_148 + VAR_149 -> VAR_150 , VAR_151 -> VAR_152 , VAR_153 -> VAR_154 - VAR_155 -> VAR_156 - VAR_157 -> VAR_158 , VAR_159 -> VAR_160 ) ; VAR_161 -> VAR_162 = VAR_163 -> VAR_164 ; VAR_165 -> VAR_166 = VAR_167 -> VAR_168 ; if ( VAR_169 != VAR_170 ) METHOD_14 ( & VAR_171 ) ; return METHOD_15 ( VAR_172 -> VAR_173 -> VAR_174 [ 0 ] , VAR_175 ) ; }",<S2SV_ModStart> [ VAR_65 ] && VAR_175 -> VAR_146 [ VAR_65 ],"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , ""Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n"" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ; <S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }",<S2SV_ModStart> [ i ] && out -> linesize [ i ]
227,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_7 VAR_8 = VAR_9 -> VAR_10 ; TYPE_8 VAR_11 = VAR_12 & 0xFFFF ; TYPE_9 VAR_13 = VAR_14 >> 16 ; <S2SV_StartBug> TYPE_10 VAR_15 [ 16 ] ; <S2SV_EndBug> TYPE_11 * VAR_16 ; TYPE_12 * VAR_17 ; TYPE_13 * VAR_18 = ( TYPE_14 * ) VAR_19 -> VAR_20 ; VAR_21 = ( TYPE_15 * ) VAR_22 -> VAR_23 ; VAR_24 -> VAR_25 = 0 ; VAR_26 = & VAR_27 -> VAR_28 [ 0 ] ; VAR_29 = VAR_30 - 1 ; if ( VAR_31 ) { TYPE_16 VAR_32 , VAR_33 = VAR_34 ; TYPE_17 ( * VAR_35 ) [ 3 ] = ( TYPE_18 ( * ) [ 3 ] ) VAR_36 ; TYPE_19 * VAR_37 ; METHOD_1 ( VAR_38 , VAR_39 , VAR_40 , VAR_41 ) ; VAR_42 = VAR_43 [ ( 1 << VAR_44 ) - 2 + VAR_45 ] ; while ( VAR_46 -- ) VAR_47 [ VAR_48 -- ] = * VAR_49 ++ ; } if ( VAR_50 >= 0 ) { TYPE_20 VAR_51 , VAR_52 , VAR_53 ; TYPE_21 VAR_54 , VAR_55 ; TYPE_22 VAR_56 ; if ( VAR_57 < 3 ) { METHOD_2 ( VAR_58 , VAR_59 , VAR_60 ) ; VAR_61 = ( 15 <= VAR_62 ) ? ( VAR_63 - 3 ) : 1 ; METHOD_3 ( VAR_64 , VAR_65 , VAR_66 , VAR_67 ) ; VAR_68 = 2 + ( METHOD_4 ( VAR_69 , 15 ) << 1 ) + VAR_70 ; if ( 16 <= VAR_71 ) { VAR_72 += ( ( 1 << ( VAR_73 - 3 ) ) - 4096 ) ; } } else { METHOD_5 ( VAR_74 , VAR_75 , VAR_76 ) ; VAR_77 = METHOD_6 ( 15 , VAR_78 ) ; VAR_79 += ( 3 == VAR_80 ) ? 0 : ( 2 ) ; if ( 14 == VAR_81 ) VAR_82 = 4 ; else if ( 15 <= VAR_83 ) { VAR_84 += 15 ; VAR_85 = ( VAR_86 - 3 ) ; } else VAR_87 = 0 ; if ( 16 <= VAR_88 ) { VAR_89 += ( ( 1 << ( VAR_90 - 3 ) ) - 4096 ) ; } if ( VAR_91 ) { METHOD_7 ( VAR_92 , VAR_93 , VAR_94 , VAR_95 ) ; VAR_96 += VAR_97 ; } } VAR_98 = ( VAR_99 + 2 ) >> 1 ; VAR_100 [ VAR_101 -- ] = ( VAR_102 & 1 ) ? - VAR_103 : VAR_104 ; VAR_105 = ( VAR_106 > 3 ) ? 2 : 1 ; while ( VAR_107 >= 0 ) { METHOD_8 ( VAR_108 , VAR_109 , VAR_110 ) ; VAR_111 = ( 15 <= VAR_112 ) ? ( VAR_113 - 3 ) : VAR_114 ; METHOD_9 ( VAR_115 , VAR_116 , VAR_117 , VAR_118 ) ; VAR_119 = ( METHOD_10 ( 15 , VAR_120 ) << VAR_121 ) + VAR_122 ; if ( 16 <= VAR_123 ) { VAR_124 += ( ( 1 << ( VAR_125 - 3 ) ) - 4096 ) ; } VAR_126 = ( VAR_127 + 2 ) >> 1 ; VAR_128 [ VAR_129 -- ] = ( VAR_130 & 1 ) ? - VAR_131 : VAR_132 ; VAR_133 += ( VAR_134 < 6 ) ? ( VAR_135 > ( 3 << ( VAR_136 - 1 ) ) ) : 0 ; } } if ( VAR_137 < ( 16 - VAR_138 ) ) { TYPE_23 VAR_139 ; const TYPE_24 ( * VAR_140 ) [ 16 ] = ( const TYPE_25 ( * ) [ 16 ] ) VAR_141 ; METHOD_11 ( VAR_142 , VAR_143 , VAR_144 , 4 ) ; VAR_145 = VAR_146 [ VAR_147 - 11 ] [ VAR_148 ] ; METHOD_12 ( VAR_149 , ( VAR_150 >> 4 ) ) ; VAR_151 &= 0xf ; } else VAR_152 = 0 ; { const TYPE_26 * VAR_153 ; TYPE_27 VAR_154 ; TYPE_28 VAR_155 ; TYPE_29 VAR_156 = VAR_157 + VAR_158 - 1 + VAR_159 ; TYPE_30 VAR_160 = VAR_161 ; VAR_162 = VAR_163 - 1 ; VAR_164 = ( TYPE_31 * ) VAR_165 ; while ( ( VAR_166 > 0 ) && VAR_167 ) { TYPE_32 VAR_168 ; METHOD_13 ( VAR_169 , VAR_170 , VAR_171 , 3 ) ; VAR_172 = VAR_173 [ VAR_174 + ( VAR_175 << 3 ) ] ; VAR_176 = VAR_177 >> 2 ; METHOD_14 ( VAR_178 , ( VAR_179 & 0x03 ) ) ; METHOD_15 ( VAR_180 -> VAR_181 , VAR_182 ) ; * VAR_183 ++ = VAR_184 [ VAR_185 -- ] ; VAR_186 -= VAR_187 ; VAR_188 -= ( VAR_189 + 1 ) ; } if ( VAR_190 < 0 ) return - 1 ; while ( VAR_191 >= 0 ) { METHOD_16 ( VAR_192 -> VAR_193 , VAR_194 ) ; * VAR_195 ++ = VAR_196 [ VAR_197 -- ] ; VAR_198 -- ; } } { TYPE_33 VAR_199 ; VAR_200 = ( TYPE_34 * ) VAR_201 - ( TYPE_35 * ) VAR_202 ; VAR_203 = METHOD_17 ( VAR_204 ) ; VAR_205 -> VAR_206 = ( TYPE_36 * ) ( ( TYPE_37 * ) VAR_207 -> VAR_208 + VAR_209 ) ; } VAR_210 -> VAR_211 = VAR_212 ; return 0 ; }",<S2SV_ModStart> 16 ; TYPE_19 VAR_213 [ 19 ] ; TYPE_19 * VAR_196 = & VAR_213 [ 3 <S2SV_ModEnd> ] ; TYPE_15,"CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; if ( u4_trailing_ones < 3 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : 1 ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = 2 + ( MIN ( u4_lev_prefix , 15 ) << 1 ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } } else { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = ( u4_lev_prefix - 3 ) ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } if ( u4_total_coeff < ( 16 - u4_isdc ) ) { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 16 ] = ( const UWORD8 ( * ) [ 16 ] ) gau1_ih264d_table_total_zero_11to15 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 4 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 11 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }",<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
228,"CWE-190 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; VAR_4 * VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 [ 3 ] ; TYPE_7 * VAR_8 ; TYPE_8 VAR_9 ; TYPE_9 VAR_10 ; <S2SV_StartBug> VAR_11 = 0 ; <S2SV_EndBug> VAR_12 = 0 ; if ( VAR_13 ) { METHOD_1 ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } METHOD_2 ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( METHOD_3 ( VAR_14 , & VAR_15 ) ) { METHOD_4 ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; goto VAR_16 ; } METHOD_5 ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , VAR_17 . VAR_18 , VAR_19 . VAR_20 , VAR_21 . VAR_22 , VAR_23 . VAR_24 , VAR_25 . VAR_26 ) ) ; if ( ! ( VAR_27 = METHOD_6 ( VAR_28 ) ) ) { METHOD_7 ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; goto VAR_29 ; } METHOD_8 ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( TYPE_10 , VAR_30 -> len ) , JAS_CAST ( TYPE_11 , VAR_31 -> VAR_32 ) , JAS_CAST ( TYPE_12 , VAR_33 -> VAR_34 ) , JAS_CAST ( TYPE_13 , VAR_35 -> VAR_36 ) , JAS_CAST ( TYPE_14 , VAR_37 -> VAR_38 ) , JAS_CAST ( TYPE_15 , VAR_39 -> enctype ) , JAS_CAST ( TYPE_16 , VAR_40 -> VAR_41 ) , JAS_CAST ( TYPE_17 , VAR_42 -> VAR_43 ) , JAS_CAST ( TYPE_18 , VAR_44 -> VAR_45 ) , JAS_CAST ( TYPE_19 , VAR_46 -> numcolors ) , JAS_CAST ( TYPE_20 , VAR_47 -> mincolors ) ) ) ; if ( VAR_48 -> VAR_49 < 0 || VAR_50 -> VAR_51 < 0 || VAR_52 -> VAR_53 < 0 || VAR_54 -> VAR_55 < 0 || VAR_56 -> VAR_57 < 0 || VAR_58 -> VAR_59 < 0 || VAR_60 -> VAR_61 < 0 ) { <S2SV_StartBug> METHOD_9 ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; <S2SV_EndBug> goto VAR_62 ; } if ( ! METHOD_10 ( & VAR_63 , VAR_64 ) ) { METHOD_11 ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; goto VAR_65 ; } if ( ( VAR_66 = VAR_67 . VAR_68 - ( VAR_69 + VAR_70 + METHOD_12 ( VAR_71 ) ) ) < 0 ) { METHOD_13 ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; goto VAR_72 ; } if ( VAR_73 > 0 ) { METHOD_14 ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( METHOD_15 ( VAR_74 , VAR_75 ) ) { goto VAR_76 ; } } VAR_77 = METHOD_16 ( VAR_78 ) ; for ( VAR_79 = 0 , VAR_80 = VAR_81 ; VAR_82 < VAR_83 ; ++ VAR_84 , ++ VAR_85 ) { VAR_86 -> VAR_87 = 0 ; VAR_88 -> VAR_89 = 0 ; VAR_90 -> VAR_91 = 1 ; VAR_92 -> VAR_93 = 1 ; VAR_94 -> VAR_95 = VAR_96 -> VAR_97 ; VAR_98 -> VAR_99 = VAR_100 -> VAR_101 ; VAR_102 -> VAR_103 = 8 ; VAR_104 -> VAR_105 = VAR_106 ; } if ( ! ( VAR_107 = METHOD_17 ( VAR_108 , VAR_109 , VAR_110 ) ) ) { goto VAR_111 ; } if ( VAR_112 == 3 ) { METHOD_18 ( VAR_113 , VAR_114 ) ; METHOD_19 ( VAR_115 , 0 , METHOD_20 ( VAR_116 ) ) ; METHOD_21 ( VAR_117 , 1 , METHOD_22 ( VAR_118 ) ) ; METHOD_23 ( VAR_119 , 2 , METHOD_24 ( VAR_120 ) ) ; } else { METHOD_25 ( VAR_121 , VAR_122 ) ; METHOD_26 ( VAR_123 , 0 , METHOD_27 ( VAR_124 ) ) ; } if ( METHOD_28 ( VAR_125 , VAR_126 , VAR_127 ) ) { goto VAR_128 ; } METHOD_29 ( VAR_129 ) ; return VAR_130 ; VAR_131 : if ( VAR_132 ) { METHOD_30 ( VAR_133 ) ; } if ( VAR_134 ) { METHOD_31 ( VAR_135 ) ; } return 0 ; }","<S2SV_ModStart> TYPE_20 VAR_75 ; TYPE_21 VAR_136 ; TYPE_22 VAR_137 ; VAR_135 = 0 ; VAR_133 = 0 ; if ( METHOD_32 ( VAR_13 , & VAR_136 ) ) { goto VAR_131 <S2SV_ModEnd> ; } METHOD_14 <S2SV_ModStart> METHOD_14 ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto VAR_131 ; } if ( ! METHOD_33 ( VAR_133 -> VAR_97 , VAR_133 -> VAR_101 , VAR_133 -> VAR_53 , & VAR_137 ) ) { METHOD_14 ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto VAR_131 ; } if ( VAR_136 . VAR_138 > 0 && VAR_137 > VAR_136 . VAR_138 ) { METHOD_14 ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\n"" , VAR_136 . VAR_138","CWE-190 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; <S2SV_StartBug> image = 0 ; <S2SV_EndBug> info = 0 ; if ( optstr ) { jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } jas_eprintf ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; goto error ; } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; if ( ! ( info = bmp_getinfo ( in ) ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; goto error ; } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long , info -> len ) , JAS_CAST ( long , info -> width ) , JAS_CAST ( long , info -> height ) , JAS_CAST ( long , info -> numplanes ) , JAS_CAST ( long , info -> depth ) , JAS_CAST ( long , info -> enctype ) , JAS_CAST ( long , info -> siz ) , JAS_CAST ( long , info -> hres ) , JAS_CAST ( long , info -> vres ) , JAS_CAST ( long , info -> numcolors ) , JAS_CAST ( long , info -> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { <S2SV_StartBug> jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; <S2SV_EndBug> goto error ; } if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; goto error ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; goto error ; } if ( n > 0 ) { jas_eprintf ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( bmp_gobble ( in , n ) ) { goto error ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { goto error ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { goto error ; } bmp_info_destroy ( info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { jas_image_destroy ( image ) ; } return 0 ; }","<S2SV_ModStart> long n ; bmp_dec_importopts_t opts ; size_t num_samples ; image = 0 ; info = 0 ; if ( bmp_dec_parseopts ( optstr , & opts ) ) { goto error <S2SV_ModEnd> ; } jas_eprintf <S2SV_ModStart> jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) { jas_eprintf ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto error ; } if ( opts . max_samples > 0 && num_samples > opts . max_samples ) { jas_eprintf ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\n"" , opts . max_samples"
229,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 * VAR_2 ; VAR_3 * VAR_4 ; if ( VAR_5 -> VAR_6 < 2 || VAR_7 -> VAR_8 > VAR_9 ) return VAR_10 ; VAR_11 = & VAR_12 -> VAR_13 ; if ( VAR_14 == VAR_15 ) if ( VAR_16 -> VAR_17 == VAR_18 ) { TYPE_4 VAR_19 ; TYPE_5 VAR_20 ; VAR_21 = METHOD_1 ( VAR_22 -> VAR_23 ) + METHOD_2 ( VAR_24 -> VAR_25 ) ; if ( ( VAR_26 -> VAR_27 + VAR_28 + 22 ) > VAR_29 ) return VAR_30 ; VAR_31 = VAR_32 -> VAR_33 + VAR_34 -> VAR_35 - 2 ; VAR_36 = METHOD_3 ( VAR_37 , ""Authorization:<S2SV_blank>Basic<S2SV_blank>"" ) ; VAR_38 = METHOD_4 ( VAR_39 + VAR_40 , ""%s:%s"" , VAR_41 -> VAR_42 , VAR_43 -> VAR_44 ) ; METHOD_5 ( VAR_45 + VAR_46 , VAR_47 , VAR_48 , & VAR_49 ) ; if ( ( VAR_50 -> VAR_51 + VAR_52 + VAR_53 ) > VAR_54 ) return VAR_55 ; METHOD_6 ( VAR_56 + VAR_57 , VAR_58 , VAR_59 + VAR_60 , & VAR_61 ) ; VAR_62 += VAR_63 ; if ( ( VAR_64 -> VAR_65 + VAR_66 + 2 ) > VAR_67 ) return VAR_68 ; METHOD_7 ( VAR_69 + VAR_70 , ""\\r\\n\\r\\n"" ) ; VAR_71 -> VAR_72 = VAR_73 -> VAR_74 + VAR_75 + 2 ; } else if ( VAR_76 == VAR_77 ) if ( VAR_78 -> VAR_79 == VAR_80 ) { TYPE_6 VAR_81 ; const TYPE_7 * VAR_82 ; const TYPE_8 * VAR_83 ; TYPE_9 VAR_84 ; TYPE_10 VAR_85 [ VAR_86 + 1 ] ; VAR_87 -> VAR_88 [ VAR_89 -> VAR_90 ] = '\\0' ; <S2SV_StartBug> VAR_91 = METHOD_8 ( VAR_92 -> VAR_93 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( VAR_94 == VAR_95 ) return VAR_96 ; VAR_97 = VAR_98 + 1 ; <S2SV_StartBug> VAR_99 = METHOD_9 ( VAR_100 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( VAR_101 == VAR_102 ) return VAR_103 ; VAR_104 = VAR_105 - VAR_106 ; if ( VAR_107 -> VAR_108 == VAR_109 || VAR_110 -> VAR_111 == VAR_112 ) { if ( VAR_113 -> METHOD_10 == VAR_114 ) return VAR_115 ; VAR_116 = VAR_117 -> METHOD_11 ( VAR_118 -> VAR_119 , VAR_120 ) ; if ( VAR_121 ) return VAR_122 ; METHOD_12 ( VAR_123 -> VAR_124 , VAR_125 , VAR_126 -> VAR_127 ) ; VAR_128 -> VAR_129 ++ ; } VAR_130 = METHOD_13 ( VAR_131 , VAR_132 -> VAR_133 , METHOD_14 ( VAR_134 -> VAR_135 ) , VAR_136 , VAR_137 , VAR_138 ) ; if ( VAR_139 ) return VAR_140 ; VAR_141 = METHOD_15 ( VAR_142 -> VAR_143 ) + METHOD_16 ( VAR_144 -> VAR_145 ) + VAR_146 + METHOD_17 ( VAR_147 -> VAR_148 ) + METHOD_18 ( VAR_149 -> VAR_150 ) + METHOD_19 ( VAR_151 ) + METHOD_20 ( VAR_152 -> VAR_153 ) ; if ( ( VAR_154 -> VAR_155 + VAR_156 + 121 ) > VAR_157 ) return VAR_158 ; VAR_159 = VAR_160 -> VAR_161 + VAR_162 -> VAR_163 - 2 ; VAR_164 = METHOD_21 ( VAR_165 , ""Authorization:<S2SV_blank>Digest<S2SV_blank>"" ) ; VAR_166 += METHOD_22 ( VAR_167 + VAR_168 , ""username=\\""%s\\"",<S2SV_blank>"" , VAR_169 -> VAR_170 ) ; VAR_171 += METHOD_23 ( VAR_172 + VAR_173 , ""realm=\\""%s\\"",<S2SV_blank>"" , VAR_174 -> VAR_175 ) ; VAR_176 += METHOD_24 ( VAR_177 + VAR_178 , ""uri=\\"""" ) ; osStrncpy ( VAR_179 + VAR_180 , VAR_181 , VAR_182 ) ; VAR_183 += VAR_184 ; VAR_185 += METHOD_25 ( VAR_186 + VAR_187 , ""\\"",<S2SV_blank>"" ) ; VAR_188 += METHOD_26 ( VAR_189 + VAR_190 , ""nonce=\\""%s\\"",<S2SV_blank>"" , VAR_191 -> VAR_192 ) ; if ( VAR_193 -> VAR_194 == VAR_195 ) { VAR_196 += METHOD_27 ( VAR_197 + VAR_198 , ""qop=auth,<S2SV_blank>"" ) ; VAR_199 += METHOD_28 ( VAR_200 + VAR_201 , ""nc=%08x,<S2SV_blank>"" , VAR_202 -> VAR_203 ) ; VAR_204 += METHOD_29 ( VAR_205 + VAR_206 , ""cnonce=\\""%s\\"",<S2SV_blank>"" , VAR_207 -> VAR_208 ) ; } VAR_209 += METHOD_30 ( VAR_210 + VAR_211 , ""response=\\""%s\\"""" , VAR_212 ) ; if ( VAR_213 -> VAR_214 [ 0 ] != '\\0' ) { VAR_215 += METHOD_31 ( VAR_216 + VAR_217 , "",<S2SV_blank>opaque=\\""%s\\"""" , VAR_218 -> VAR_219 ) ; } METHOD_32 ( VAR_220 + VAR_221 , ""\\r\\n\\r\\n"" ) ; VAR_222 -> VAR_223 = VAR_224 -> VAR_225 + VAR_226 + 2 ; } else { } return VAR_227 ; }","<S2SV_ModStart> ; VAR_105 = METHOD_33 <S2SV_ModEnd> ( VAR_224 -> <S2SV_ModStart> ; VAR_105 = METHOD_33 <S2SV_ModEnd> ( VAR_181 ,","CWE-20 error_t httpClientFormatAuthorizationField ( HttpClientContext * context ) { size_t n ; char_t * p ; HttpClientAuthParams * authParams ; if ( context -> bufferLen < 2 || context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; authParams = & context -> authParams ;  if ( HTTP_CLIENT_BASIC_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_BASIC ) { size_t k ; size_t m ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> password ) ; if ( ( context -> bufferLen + n + 22 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , ""Authorization:<S2SV_blank>Basic<S2SV_blank>"" ) ; m = osSprintf ( p + n , ""%s:%s"" , authParams -> username , authParams -> password ) ; base64Encode ( p + n , m , NULL , & k ) ; if ( ( context -> bufferLen + n + k ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; base64Encode ( p + n , m , p + n , & k ) ; n += k ; if ( ( context -> bufferLen + n + 2 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osSprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else    if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_DIGEST ) { error_t error ; const char_t * q ; const char_t * uri ; size_t uriLen ; char_t response [ HTTP_CLIENT_MAX_RESPONSE_LEN + 1 ] ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uri = q + 1 ; <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uriLen = q - uri ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH || authParams -> qop == HTTP_AUTH_QOP_AUTH_INT ) { if ( context -> randCallback == NULL ) return ERROR_PRNG_NOT_READY ; error = context -> randCallback ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE ) ; if ( error ) return error ; httpEncodeHexString ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE , authParams -> cnonce ) ; authParams -> nc ++ ; } error = httpClientComputeDigest ( authParams , context -> method , osStrlen ( context -> method ) , uri , uriLen , response ) ; if ( error ) return error ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> realm ) + uriLen + osStrlen ( authParams -> nonce ) + osStrlen ( authParams -> cnonce ) + osStrlen ( response ) + osStrlen ( authParams -> opaque ) ; if ( ( context -> bufferLen + n + 121 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , ""Authorization:<S2SV_blank>Digest<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""username=\\""%s\\"",<S2SV_blank>"" , authParams -> username ) ; n += osSprintf ( p + n , ""realm=\\""%s\\"",<S2SV_blank>"" , authParams -> realm ) ; n += osSprintf ( p + n , ""uri=\\"""" ) ; osStrncpy ( p + n , uri , uriLen ) ; n += uriLen ; n += osSprintf ( p + n , ""\\"",<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""nonce=\\""%s\\"",<S2SV_blank>"" , authParams -> nonce ) ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH ) { n += osSprintf ( p + n , ""qop=auth,<S2SV_blank>"" ) ; n += osSprintf ( p + n , ""nc=%08x,<S2SV_blank>"" , authParams -> nc ) ; n += osSprintf ( p + n , ""cnonce=\\""%s\\"",<S2SV_blank>"" , authParams -> cnonce ) ; } n += osSprintf ( p + n , ""response=\\""%s\\"""" , response ) ; if ( authParams -> opaque [ 0 ] != '\\0' ) { n += osSprintf ( p + n , "",<S2SV_blank>opaque=\\""%s\\"""" , authParams -> opaque ) ; } osSprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else   { } return NO_ERROR ; }","<S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( uri ,"
230,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 = METHOD_1 ( VAR_4 ) ; struct STRUCT_OR_UNION_4 * VAR_5 ; struct STRUCT_OR_UNION_5 * VAR_6 ; TYPE_1 VAR_7 = METHOD_2 ( VAR_8 -> VAR_9 ) ; TYPE_2 VAR_10 ; TYPE_3 VAR_11 , VAR_12 , VAR_13 ; METHOD_3 ( & VAR_14 -> VAR_15 ) ; if ( VAR_16 == VAR_17 ) VAR_18 = & VAR_19 -> VAR_20 ; else if ( VAR_21 == VAR_22 ) VAR_23 = & VAR_24 -> VAR_25 ; else METHOD_4 ( ) ; <S2SV_StartBug> METHOD_5 ( ! VAR_26 ) ; <S2SV_EndBug> VAR_27 = METHOD_6 ( VAR_28 , VAR_29 == VAR_30 ) ; METHOD_7 ( VAR_31 , VAR_32 == VAR_33 ) ; VAR_34 = 0 ; for ( VAR_35 = 0 ; VAR_36 < VAR_37 -> VAR_38 -> VAR_39 ; VAR_40 ++ ) { if ( VAR_41 -> VAR_42 -> VAR_43 [ VAR_44 ] . VAR_45 != VAR_46 ) VAR_47 ++ ; } VAR_48 = VAR_49 -> VAR_50 ; if ( ! VAR_51 ) { METHOD_8 ( VAR_52 ) ; VAR_53 = VAR_54 ; goto VAR_55 ; } VAR_56 -> VAR_57 = VAR_58 ; VAR_59 -> VAR_60 = - 1 ; for ( VAR_61 = 0 , VAR_62 = 0 ; VAR_63 < VAR_64 -> VAR_65 -> VAR_66 ; VAR_67 ++ ) { if ( VAR_68 -> VAR_69 -> VAR_70 [ VAR_71 ] . VAR_72 == VAR_73 ) continue ; VAR_74 -> VAR_75 [ VAR_76 ] = VAR_77 -> VAR_78 -> VAR_79 [ VAR_80 ] ; if ( VAR_81 -> VAR_82 [ VAR_83 ] . VAR_84 < VAR_85 ) { ++ VAR_86 -> VAR_87 ; } VAR_88 ++ ; } VAR_89 : VAR_90 -> VAR_91 = VAR_92 -> VAR_93 ; METHOD_9 ( VAR_94 -> VAR_95 , VAR_96 ) ; METHOD_10 ( ) ; <S2SV_StartBug> METHOD_11 ( & VAR_97 -> VAR_98 ) ; <S2SV_EndBug> }",<S2SV_ModStart> ! VAR_94 ) ; if ( ! VAR_94 -> VAR_95 ) goto VAR_99 <S2SV_ModStart> ( ) ; VAR_99 :,"CWE-000 static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }",<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
231,"CWE-476 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; TYPE_2 VAR_2 ; TYPE_3 VAR_3 ; struct STRUCT_OR_UNION_1 * VAR_4 ; VAR_5 = VAR_6 -> VAR_7 ; VAR_8 -> VAR_9 = METHOD_1 ( VAR_10 , sizeof ( struct STRUCT_OR_UNION_2 * ) , VAR_11 ) ; if ( ! VAR_12 -> VAR_13 ) { METHOD_2 ( VAR_14 , & VAR_15 -> VAR_16 -> VAR_17 , ""out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; return - VAR_18 ; } METHOD_3 ( VAR_19 -> VAR_20 , 0 , sizeof ( struct STRUCT_OR_UNION_3 * ) * VAR_21 ) ; for ( VAR_22 = 0 ; VAR_23 < VAR_24 ; VAR_25 ++ ) { VAR_26 -> VAR_27 [ VAR_28 ] = METHOD_4 ( sizeof ( struct STRUCT_OR_UNION_4 ) , VAR_29 ) ; if ( ! VAR_30 -> VAR_31 [ VAR_32 ] ) { for ( VAR_33 = 0 ; VAR_34 < VAR_35 ; VAR_36 ++ ) METHOD_5 ( VAR_37 -> VAR_38 [ VAR_39 ] ) ; METHOD_6 ( VAR_40 -> VAR_41 ) ; VAR_42 -> VAR_43 = VAR_44 ; return - VAR_45 ; } } for ( VAR_46 = 0 ; VAR_47 < VAR_48 ; VAR_49 ++ ) { VAR_50 = VAR_51 -> VAR_52 [ VAR_53 ] ; METHOD_7 ( VAR_54 , 0 , sizeof ( struct STRUCT_OR_UNION_5 ) ) ; VAR_55 -> VAR_56 = VAR_57 ; VAR_58 -> VAR_59 = VAR_60 ; VAR_61 -> VAR_62 = VAR_63 ; METHOD_8 ( & VAR_64 -> VAR_65 , & VAR_66 -> VAR_67 ) ; } if ( METHOD_9 ( VAR_68 ) ) { METHOD_10 ( VAR_69 , & VAR_70 -> VAR_71 -> VAR_72 , ""Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n"" ) ; METHOD_11 ( VAR_73 ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }",<S2SV_ModStart> VAR_73 ) ; return - VAR_45 ; } return <S2SV_ModEnd> 0 ; },"CWE-476 int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , ""out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , ""Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n"" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }",<S2SV_ModStart> instance ) ; return - ENOMEM ; } return <S2SV_ModEnd> 0 ; }
232,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 ; TYPE_3 VAR_7 ; TYPE_4 VAR_8 ; VAR_9 = - VAR_10 ; if ( VAR_11 -> VAR_12 & VAR_13 ) goto VAR_14 ; <S2SV_StartBug> VAR_15 = METHOD_1 ( VAR_16 , VAR_17 , 0 , & VAR_18 ) ; <S2SV_EndBug> if ( ! VAR_19 ) goto VAR_20 ; VAR_21 = VAR_22 -> VAR_23 ; if ( VAR_24 < VAR_25 ) { VAR_26 -> VAR_27 |= VAR_28 ; VAR_29 = VAR_30 ; } VAR_31 = METHOD_2 ( VAR_32 , 0 , VAR_33 -> VAR_34 , VAR_35 ) ; if ( VAR_36 ) goto VAR_37 ; VAR_38 = ( VAR_39 & VAR_40 ) ? VAR_41 -> VAR_42 : VAR_43 ; VAR_44 : METHOD_3 ( VAR_45 , VAR_46 ) ; METHOD_4 ( VAR_47 ) ; return VAR_48 ; VAR_49 : return VAR_50 ; }",<S2SV_ModStart> goto VAR_49 ; VAR_33 -> VAR_51 = 0 ;,"CWE-200 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }",<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
233,"CWE-787 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 , VAR_3 , VAR_4 , VAR_5 ; TYPE_4 * VAR_6 , VAR_7 [ 5 ] = { 0 } ; VAR_8 = VAR_9 = VAR_10 = VAR_11 = 0 ; if ( VAR_12 [ 0 ] == '(' ) { <S2SV_StartBug> VAR_13 = METHOD_1 ( METHOD_2 ( VAR_14 ) + 1 ) ; <S2SV_EndBug> METHOD_3 ( VAR_15 , VAR_16 , METHOD_4 ( VAR_17 ) + 1 ) ; return VAR_18 ; } else if ( VAR_19 [ 0 ] == '<' ) { VAR_20 = 1 ; ++ VAR_21 ; } if ( VAR_22 && ( VAR_23 > 5 ) && ( VAR_24 [ VAR_25 ] == 'F' ) && ( VAR_26 [ VAR_27 + 1 ] == 'E' ) && ( VAR_28 [ VAR_29 + 2 ] == 'F' ) && ( VAR_30 [ VAR_31 + 3 ] == 'F' ) ) { VAR_32 = 1 ; VAR_33 += 4 ; } else return VAR_34 ; <S2SV_StartBug> VAR_35 = METHOD_5 ( VAR_36 ) ; <S2SV_EndBug> for ( ; VAR_37 < VAR_38 ; ++ VAR_39 ) { VAR_40 [ 0 ] = VAR_41 [ VAR_42 ++ ] ; VAR_43 [ 1 ] = VAR_44 [ VAR_45 ++ ] ; VAR_46 [ 2 ] = VAR_47 [ VAR_48 ++ ] ; VAR_49 [ 3 ] = VAR_50 [ VAR_51 ] ; VAR_52 [ VAR_53 ++ ] = METHOD_6 ( VAR_54 , VAR_55 , 16 ) ; } return VAR_56 ; }",<S2SV_ModStart> { VAR_56 = METHOD_7 <S2SV_ModEnd> ( METHOD_4 ( <S2SV_ModStart> ; VAR_56 = METHOD_7 <S2SV_ModEnd> ( VAR_38 ),"CWE-787 static char * decode_text_string ( const char * str , size_t str_len ) { int idx , is_hex , is_utf16be , ascii_idx ; char * ascii , hex_buf [ 5 ] = { 0 } ; is_hex = is_utf16be = idx = ascii_idx = 0 ; if ( str [ 0 ] == '(' ) { <S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; } else if ( str [ 0 ] == '<' ) { is_hex = 1 ; ++ idx ; } if ( is_hex && ( str_len > 5 ) && ( str [ idx ] == 'F' ) && ( str [ idx + 1 ] == 'E' ) && ( str [ idx + 2 ] == 'F' ) && ( str [ idx + 3 ] == 'F' ) ) { is_utf16be = 1 ; idx += 4 ; } else return NULL ; <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ; hex_buf [ 1 ] = str [ idx ++ ] ; hex_buf [ 2 ] = str [ idx ++ ] ; hex_buf [ 3 ] = str [ idx ] ; ascii [ ascii_idx ++ ] = strtol ( hex_buf , NULL , 16 ) ; } return ascii ; }",<S2SV_ModStart> { ascii = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> ; ascii = safe_calloc <S2SV_ModEnd> ( str_len )
234,"CWE-732 TYPE_0 * * <S2SV_StartBug> METHOD_0 ( const struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) <S2SV_EndBug> { static const TYPE_1 * VAR_0 [ ] = { ""DISPLAY"" , ""HOME"" , ""LOGNAME"" , ""MAIL"" , ""PATH"" , ""TERM"" , ""USER"" , ""USERNAME"" , VAR_1 } ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 ; <S2SV_StartBug> STRUCT_OR_UNION_4 = METHOD_1 ( STRUCT_OR_UNION_5 ) ; <S2SV_EndBug> if ( ! ( STRUCT_OR_UNION_6 -> VAR_2 & VAR_3 ) ) METHOD_2 ( STRUCT_OR_UNION_7 , VAR_4 ) ; if ( STRUCT_OR_UNION_8 -> VAR_5 ) METHOD_3 ( STRUCT_OR_UNION_9 , STRUCT_OR_UNION_10 -> VAR_6 ) ; return METHOD_4 ( STRUCT_OR_UNION_11 ) ; }","<S2SV_ModStart> STRUCT_OR_UNION_10 * STRUCT_OR_UNION_10 , const struct STRUCT_OR_UNION_12 * VAR_7 , const struct STRUCT_OR_UNION_12 * VAR_8 ) { <S2SV_ModEnd> struct STRUCT_OR_UNION_11 * <S2SV_ModStart> METHOD_1 ( STRUCT_OR_UNION_10 , VAR_7 , VAR_8 <S2SV_ModEnd> ) ; if","CWE-732 char * * <S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> { static const char * safeset [ ] = { ""DISPLAY"" , ""HOME"" , ""LOGNAME"" , ""MAIL"" , ""PATH"" , ""TERM"" , ""USER"" , ""USERNAME"" , NULL } ; struct env * env ; <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug> if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ; if ( rule -> envlist ) fillenv ( env , rule -> envlist ) ; return flattenenv ( env ) ; }","<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> struct env * <S2SV_ModStart> createenv ( rule , mypw , targpw <S2SV_ModEnd> ) ; if"
235,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 ) { VAR_2 -> VAR_3 += VAR_4 -> VAR_5 ; <S2SV_StartBug> VAR_6 -> VAR_7 = VAR_8 -> VAR_9 ; <S2SV_EndBug> VAR_10 -> VAR_11 += VAR_12 -> VAR_13 ; VAR_14 -> VAR_15 += VAR_16 -> VAR_17 ; VAR_18 -> VAR_19 += VAR_20 -> VAR_21 ; <S2SV_StartBug> VAR_22 -> VAR_23 += VAR_24 -> VAR_25 ; <S2SV_EndBug> VAR_26 -> VAR_27 += VAR_28 -> VAR_29 ; VAR_30 -> VAR_31 += VAR_32 -> VAR_33 ; VAR_34 -> VAR_35 += VAR_36 -> VAR_37 ; <S2SV_StartBug> VAR_38 -> VAR_39 += VAR_40 -> VAR_41 ; <S2SV_EndBug> VAR_42 -> VAR_43 += VAR_44 -> VAR_45 ; VAR_46 -> VAR_47 += VAR_48 -> VAR_49 ; VAR_50 -> VAR_51 += VAR_52 -> VAR_53 ; VAR_54 -> VAR_55 += VAR_56 -> VAR_57 ; VAR_58 -> VAR_59 += VAR_60 -> VAR_61 ; VAR_62 -> VAR_63 += VAR_64 -> VAR_65 ; VAR_66 -> VAR_67 += VAR_68 -> VAR_69 ; VAR_70 -> VAR_71 += VAR_72 -> VAR_73 ; VAR_74 -> VAR_75 += VAR_76 -> VAR_77 ; VAR_78 -> VAR_79 += VAR_80 -> VAR_81 ; }",<S2SV_ModStart> ; VAR_78 -> weight += VAR_80 -> weight ; VAR_78 -> <S2SV_ModStart> ; VAR_78 -> <S2SV_ModEnd> VAR_29 += VAR_80 <S2SV_ModStart> VAR_80 -> VAR_41 ; VAR_78 -> VAR_82 += VAR_80 -> VAR_82 ; VAR_78 -> VAR_83 += VAR_80 -> VAR_83 ; VAR_78 -> VAR_84 += VAR_80 -> VAR_84,"CWE-119 static void accumulate_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame += frame -> frame ; <S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> section -> intra_error += frame -> intra_error ; section -> coded_error += frame -> coded_error ; section -> sr_coded_error += frame -> sr_coded_error ; <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> section -> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion += frame -> pcnt_motion ; section -> pcnt_second_ref += frame -> pcnt_second_ref ; <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> section -> MVr += frame -> MVr ; section -> mvr_abs += frame -> mvr_abs ; section -> MVc += frame -> MVc ; section -> mvc_abs += frame -> mvc_abs ; section -> MVrv += frame -> MVrv ; section -> MVcv += frame -> MVcv ; section -> mv_in_out_count += frame -> mv_in_out_count ; section -> new_mv_count += frame -> new_mv_count ; section -> count += frame -> count ; section -> duration += frame -> duration ; }",<S2SV_ModStart> ; section -> weight += frame -> weight ; section -> <S2SV_ModStart> ; section -> <S2SV_ModEnd> pcnt_inter += frame <S2SV_ModStart> frame -> pcnt_neutral ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols
236,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_1 * VAR_2 = VAR_3 -> VAR_4 ; <S2SV_EndBug> TYPE_2 VAR_5 ; if ( METHOD_1 ( & VAR_6 -> VAR_7 ) ) return ; METHOD_2 ( & VAR_8 -> VAR_9 ) ; if ( VAR_10 -> VAR_11 & VAR_12 ) { VAR_13 = METHOD_3 ( VAR_14 ) ; if ( ! VAR_15 ) return ; } else if ( VAR_16 -> VAR_17 == VAR_18 ) { METHOD_4 ( VAR_19 -> VAR_20 ) ; METHOD_5 ( VAR_21 -> VAR_22 ) ; } <S2SV_StartBug> METHOD_6 ( & VAR_23 -> VAR_24 ) ; <S2SV_EndBug> }",<S2SV_ModStart> VAR_1 ) { METHOD_2 ( & VAR_25 ) ; METHOD_7 ( <S2SV_ModEnd> VAR_3 -> VAR_4 <S2SV_ModStart> VAR_3 -> VAR_4 ) ; <S2SV_ModEnd> METHOD_6 ( & <S2SV_ModStart> METHOD_6 ( & VAR_25 <S2SV_ModEnd> ) ; },"CWE-362 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }",<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
237,"CWE-264 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { struct STRUCT_OR_UNION_1 VAR_2 ; struct STRUCT_OR_UNION_2 * VAR_3 = METHOD_1 ( ) ; TYPE_2 * VAR_4 = VAR_5 ; TYPE_3 * VAR_6 = VAR_7 , * VAR_8 , * VAR_9 ; struct STRUCT_OR_UNION_3 * VAR_10 = VAR_11 ; const TYPE_4 * VAR_12 ; const TYPE_5 * VAR_13 = VAR_14 ; TYPE_6 VAR_15 = - VAR_16 ; if ( ! VAR_17 ) return - VAR_18 ; METHOD_2 ( VAR_19 , 0 , sizeof ( struct STRUCT_OR_UNION_4 ) ) ; if ( METHOD_3 ( VAR_20 , & VAR_21 ) < 0 ) return - VAR_22 ; VAR_23 -> VAR_24 = VAR_25 -> VAR_26 = 0 ; VAR_27 -> VAR_28 = VAR_29 -> VAR_30 = VAR_31 -> VAR_32 = VAR_33 ; VAR_34 -> VAR_35 = 0 ; if ( METHOD_4 ( VAR_36 , ""/cgroup"" ) == 0 ) { VAR_37 -> VAR_38 = VAR_39 | 00755 ; VAR_40 -> VAR_41 = 2 ; return 0 ; } VAR_42 = METHOD_5 ( VAR_43 , VAR_44 ) ; if ( ! VAR_45 ) return - VAR_46 ; VAR_47 = METHOD_6 ( VAR_48 ) ; if ( ! VAR_49 ) { VAR_50 -> VAR_51 = VAR_52 | 00755 ; VAR_53 -> VAR_54 = 2 ; return 0 ; } METHOD_7 ( VAR_55 , & VAR_56 , & VAR_57 ) ; if ( ! VAR_58 ) { VAR_59 = ""/"" ; VAR_60 = VAR_61 ; } else { VAR_62 = VAR_63 ; VAR_64 = VAR_65 ; } if ( METHOD_8 ( VAR_66 , VAR_67 , VAR_68 ) ) { <S2SV_StartBug> if ( ! METHOD_9 ( VAR_69 -> VAR_70 , VAR_71 , VAR_72 , VAR_73 ) ) { <S2SV_EndBug> VAR_74 -> VAR_75 = VAR_76 | 00555 ; VAR_77 -> VAR_78 = 2 ; VAR_79 = 0 ; goto VAR_80 ; } if ( ! METHOD_10 ( VAR_81 , VAR_82 , VAR_83 , VAR_84 , VAR_85 ) ) { VAR_86 = - VAR_87 ; goto VAR_88 ; } VAR_89 -> VAR_90 = VAR_91 | 00755 ; VAR_92 = METHOD_11 ( VAR_93 , VAR_94 , ""tasks"" ) ; if ( ! VAR_95 ) { VAR_96 -> VAR_97 = VAR_98 -> VAR_99 = 0 ; } else { VAR_100 -> VAR_101 = VAR_102 -> VAR_103 ; VAR_104 -> VAR_105 = VAR_106 -> VAR_107 ; } METHOD_12 ( VAR_108 ) ; VAR_109 -> VAR_110 = 2 ; VAR_111 = 0 ; goto VAR_112 ; } if ( ( VAR_113 = METHOD_13 ( VAR_114 , VAR_115 , VAR_116 ) ) != VAR_117 ) { VAR_118 -> VAR_119 = VAR_120 | VAR_121 -> VAR_122 ; VAR_123 -> VAR_124 = 1 ; VAR_125 -> VAR_126 = VAR_127 -> VAR_128 ; VAR_129 -> VAR_130 = VAR_131 -> VAR_132 ; VAR_133 -> VAR_134 = 0 ; METHOD_14 ( VAR_135 ) ; if ( ! METHOD_15 ( VAR_136 -> VAR_137 , VAR_138 , VAR_139 , VAR_140 ) ) { VAR_141 = - VAR_142 ; goto VAR_143 ; } if ( ! METHOD_16 ( VAR_144 , VAR_145 , VAR_146 , VAR_147 , VAR_148 ) ) { VAR_149 = - VAR_150 ; goto VAR_151 ; } VAR_152 = 0 ; } VAR_153 : METHOD_17 ( VAR_154 ) ; return VAR_155 ; }","<S2SV_ModStart> if ( ! METHOD_18 ( VAR_144 -> VAR_137 , VAR_145 , VAR_94 ) ) { VAR_155 = - VAR_142 ; goto VAR_153 ; } if ( !","CWE-264 static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , ""tasks"" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }","<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !"
238,"CWE-476 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 ; const TYPE_4 * VAR_4 = VAR_5 ; TYPE_5 * VAR_6 = & VAR_7 -> VAR_8 ; TYPE_6 VAR_9 , VAR_10 ; TYPE_7 VAR_11 = VAR_12 ; for ( ; ; ) { if ( VAR_13 -> VAR_14 > 0 ) VAR_15 = METHOD_1 ( & VAR_16 , VAR_17 -> VAR_18 , & VAR_19 , VAR_20 -> VAR_21 ) ; else VAR_22 = VAR_23 ; if ( VAR_24 < 0 && VAR_25 != VAR_26 ) { VAR_27 = - 1 ; goto VAR_28 ; } if ( VAR_29 == VAR_30 ) { if ( ( VAR_31 = METHOD_2 ( VAR_32 ) ) < 0 ) { VAR_33 = VAR_34 ; goto VAR_35 ; } if ( VAR_36 == 0 ) { METHOD_3 ( VAR_37 , ""early<S2SV_blank>EOF"" ) ; VAR_38 = VAR_39 ; goto VAR_40 ; } continue ; } METHOD_4 ( VAR_41 , VAR_42 ) ; <S2SV_StartBug> VAR_43 = 0 ; <S2SV_EndBug> if ( VAR_44 == VAR_45 ) continue ; switch ( VAR_46 -> VAR_47 ) { case VAR_48 : VAR_49 = METHOD_5 ( VAR_50 , ( TYPE_8 * ) VAR_51 , & VAR_52 ) ; break ; case VAR_53 : METHOD_6 ( VAR_54 , ""report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s"" , ( ( TYPE_9 * ) VAR_55 ) -> VAR_56 ) ; VAR_57 = - 1 ; break ; case VAR_58 : if ( VAR_59 -> METHOD_7 ) { TYPE_10 * VAR_60 = ( TYPE_11 * ) VAR_61 ; VAR_62 = VAR_63 -> METHOD_8 ( VAR_64 -> VAR_65 , VAR_66 -> VAR_67 , VAR_68 -> VAR_69 ) ; } break ; default : VAR_70 = METHOD_9 ( VAR_71 , VAR_72 ) ; break ; } METHOD_10 ( VAR_73 ) ; if ( VAR_74 == VAR_75 ) { VAR_76 = 0 ; if ( VAR_77 . VAR_78 > 0 ) { METHOD_11 ( VAR_79 , ""Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line"" ) ; VAR_80 = VAR_81 ; } goto VAR_82 ; } if ( VAR_83 < 0 ) { goto VAR_84 ; } } VAR_85 : METHOD_12 ( & VAR_86 ) ; return VAR_87 ; }",<S2SV_ModStart> VAR_87 = 0 <S2SV_ModEnd> ; switch (,"CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , ""early<S2SV_blank>EOF"" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , ""report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s"" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , ""Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line"" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }",<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (
239,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , const TYPE_1 TYPE_2 * VAR_0 , unsigned TYPE_3 VAR_1 ) { TYPE_4 VAR_2 , VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 ; struct STRUCT_OR_UNION_3 VAR_5 ; if ( METHOD_1 ( & VAR_6 , VAR_7 , sizeof ( VAR_8 ) ) != 0 ) return - VAR_9 ; if ( VAR_10 != sizeof ( VAR_11 ) + VAR_12 . VAR_13 ) { METHOD_2 ( ""Wrong<S2SV_blank>len<S2SV_blank>argument\\n"" ) ; return - VAR_14 ; } if ( VAR_15 . VAR_16 == 0 ) { METHOD_3 ( ""Entries_size<S2SV_blank>never<S2SV_blank>zero\\n"" ) ; return - VAR_17 ; } if ( VAR_18 . VAR_19 >= ( ( VAR_20 - sizeof ( struct STRUCT_OR_UNION_4 ) ) / VAR_21 - VAR_22 ) / sizeof ( struct STRUCT_OR_UNION_5 ) ) return - VAR_23 ; if ( VAR_24 . VAR_25 >= VAR_26 / sizeof ( struct STRUCT_OR_UNION_6 ) ) return - VAR_27 ; <S2SV_StartBug> VAR_28 = METHOD_4 ( VAR_29 . VAR_30 ) * VAR_31 ; <S2SV_EndBug> VAR_32 = METHOD_5 ( sizeof ( * VAR_33 ) + VAR_34 ) ; if ( ! VAR_35 ) return - VAR_36 ; if ( VAR_37 ) METHOD_6 ( VAR_38 -> VAR_39 , 0 , VAR_40 ) ; VAR_41 -> VAR_42 = METHOD_7 ( VAR_43 . VAR_44 ) ; if ( ! VAR_45 -> VAR_46 ) { VAR_47 = - VAR_48 ; goto VAR_49 ; } if ( METHOD_8 ( VAR_50 -> VAR_51 , VAR_52 . VAR_53 , VAR_54 . VAR_55 ) != 0 ) { METHOD_9 ( ""Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n"" ) ; VAR_56 = - VAR_57 ; goto VAR_58 ; } VAR_59 = METHOD_10 ( STRUCT_OR_UNION_7 , & VAR_60 , VAR_61 ) ; if ( VAR_62 == 0 ) return VAR_63 ; VAR_64 : METHOD_11 ( VAR_65 -> VAR_66 ) ; VAR_67 : METHOD_12 ( VAR_68 ) ; return VAR_69 ; }",<S2SV_ModStart> - VAR_48 ; VAR_60 . VAR_70 [ sizeof ( VAR_60 . VAR_70 ) - 1 ] = 0 ;,"CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( ""Wrong<S2SV_blank>len<S2SV_blank>argument\\n"" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( ""Entries_size<S2SV_blank>never<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( ""Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n"" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }",<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
240,"CWE-415 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> unsigned TYPE_3 * VAR_2 ; <S2SV_EndBug> METHOD_1 ( VAR_3 -> VAR_4 ) ; METHOD_2 ( VAR_5 >= 0 ) ; <S2SV_StartBug> if ( ! ( VAR_6 = METHOD_3 ( VAR_7 -> VAR_8 , VAR_9 , sizeof ( unsigned TYPE_4 ) ) ) ) { <S2SV_EndBug> return - 1 ; } VAR_10 -> VAR_11 = VAR_12 ; VAR_13 -> VAR_14 = VAR_15 ; return 0 ; }",<S2SV_ModStart> TYPE_4 * VAR_12 <S2SV_ModEnd> ; METHOD_2 ( <S2SV_ModStart> ) ) ) && VAR_15,"CWE-415 static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) { <S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> assert ( m -> buf_ ) ; assert ( bufsize >= 0 ) ; <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> return - 1 ; } m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }",<S2SV_ModStart> char * buf <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ) ) ) && bufsize
241,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 TYPE_4 * VAR_2 , unsigned TYPE_5 VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 = STRUCT_OR_UNION_3 -> VAR_5 ; TYPE_6 VAR_6 ; TYPE_7 VAR_7 ; struct STRUCT_OR_UNION_4 VAR_8 ; TYPE_8 VAR_9 = 0 ; if ( VAR_10 == VAR_11 ) return METHOD_1 ( VAR_12 , VAR_13 , VAR_14 ) ; if ( VAR_15 < sizeof ( TYPE_9 ) ) return - VAR_16 ; if ( METHOD_2 ( VAR_17 , ( TYPE_10 TYPE_11 * ) VAR_18 ) ) return - VAR_19 ; VAR_20 = VAR_21 ? 1 : 0 ; METHOD_3 ( VAR_22 ) ; switch ( VAR_23 ) { case VAR_24 : if ( VAR_25 && ! METHOD_4 ( VAR_26 ) ) VAR_27 = - VAR_28 ; else METHOD_5 ( VAR_29 , VAR_30 , VAR_31 ) ; break ; case VAR_32 : VAR_33 -> VAR_34 = ( VAR_35 ? VAR_36 : VAR_37 ) ; break ; case VAR_38 : case VAR_39 : case VAR_40 : case VAR_41 : VAR_42 = - VAR_43 ; break ; case VAR_44 : METHOD_6 ( VAR_45 , VAR_46 , VAR_47 ) ; break ; case VAR_48 : METHOD_7 ( VAR_49 , VAR_50 , VAR_51 ) ; break ; case VAR_52 : <S2SV_StartBug> if ( VAR_53 > VAR_54 ) <S2SV_EndBug> VAR_55 = VAR_56 ; VAR_57 : VAR_58 -> VAR_59 |= VAR_60 ; <S2SV_StartBug> if ( ( VAR_61 * 2 ) < VAR_62 ) <S2SV_EndBug> VAR_63 -> VAR_64 = VAR_65 ; else VAR_66 -> VAR_67 = VAR_68 * 2 ; VAR_69 -> METHOD_8 ( VAR_70 ) ; break ; case VAR_71 : if ( ! METHOD_9 ( VAR_72 ) ) { VAR_73 = - VAR_74 ; break ; } goto VAR_75 ; case VAR_76 : <S2SV_StartBug> if ( VAR_77 > VAR_78 ) <S2SV_EndBug> VAR_79 = VAR_80 ; VAR_81 : VAR_82 -> VAR_83 |= VAR_84 ; <S2SV_StartBug> if ( ( VAR_85 * 2 ) < VAR_86 ) <S2SV_EndBug> VAR_87 -> VAR_88 = VAR_89 ; else VAR_90 -> VAR_91 = VAR_92 * 2 ; break ; case VAR_93 : if ( ! METHOD_10 ( VAR_94 ) ) { VAR_95 = - VAR_96 ; break ; } goto VAR_97 ; case VAR_98 : TYPE_12 TYPE_13 if ( VAR_99 -> VAR_100 == VAR_101 ) METHOD_11 ( VAR_102 , VAR_103 ) ; METHOD_12 ( VAR_104 , VAR_105 , VAR_106 ) ; break ; case VAR_107 : METHOD_13 ( VAR_108 , VAR_109 , VAR_110 ) ; break ; case VAR_111 : VAR_112 -> VAR_113 = VAR_114 ; break ; case VAR_115 : if ( ( VAR_116 >= 0 && VAR_117 <= 6 ) || METHOD_14 ( VAR_118 ) ) VAR_119 -> VAR_120 = VAR_121 ; else VAR_122 = - VAR_123 ; break ; case VAR_124 : if ( VAR_125 < sizeof ( VAR_126 ) ) { VAR_127 = - VAR_128 ; break ; } if ( METHOD_15 ( & VAR_129 , VAR_130 , sizeof ( VAR_131 ) ) ) { VAR_132 = - VAR_133 ; break ; } if ( ! VAR_134 . VAR_135 ) METHOD_16 ( VAR_136 , VAR_137 ) ; else { if ( VAR_138 == 32 ) if ( ( unsigned TYPE_14 ) VAR_139 . VAR_140 >= VAR_141 / VAR_142 ) VAR_143 -> VAR_144 = VAR_145 ; else VAR_146 -> VAR_147 = ( unsigned TYPE_15 ) VAR_148 . VAR_149 * VAR_150 ; METHOD_17 ( VAR_151 , VAR_152 ) ; } break ; case VAR_153 : METHOD_18 ( ""setsockopt"" ) ; break ; case VAR_154 : if ( VAR_155 ) METHOD_19 ( VAR_156 , & STRUCT_OR_UNION_5 -> VAR_157 ) ; else METHOD_20 ( VAR_158 , & STRUCT_OR_UNION_6 -> VAR_159 ) ; break ; case VAR_160 : case VAR_161 : if ( VAR_162 ) { if ( VAR_163 == VAR_164 ) METHOD_21 ( VAR_165 , VAR_166 ) ; else METHOD_22 ( VAR_167 , VAR_168 ) ; METHOD_23 ( VAR_169 , VAR_170 ) ; METHOD_24 ( VAR_171 , VAR_172 ) ; } else { METHOD_25 ( VAR_173 , VAR_174 ) ; METHOD_26 ( VAR_175 , VAR_176 ) ; } break ; case VAR_177 : if ( VAR_178 & ~ VAR_179 ) { VAR_180 = - VAR_181 ; break ; } METHOD_27 ( VAR_182 , VAR_183 , VAR_184 & VAR_185 ) ; METHOD_28 ( VAR_186 , VAR_187 , VAR_188 & VAR_189 ) ; METHOD_29 ( VAR_190 , VAR_191 , VAR_192 & VAR_193 ) ; if ( VAR_194 & VAR_195 ) METHOD_30 ( VAR_196 , VAR_197 ) ; else METHOD_31 ( VAR_198 , ( 1UL << VAR_199 ) ) ; METHOD_32 ( VAR_200 , VAR_201 , VAR_202 & VAR_203 ) ; METHOD_33 ( VAR_204 , VAR_205 , VAR_206 & VAR_207 ) ; METHOD_34 ( VAR_208 , VAR_209 , VAR_210 & VAR_211 ) ; break ; case VAR_212 : if ( VAR_213 < 0 ) VAR_214 = VAR_215 ; VAR_216 -> VAR_217 = VAR_218 ? : 1 ; break ; case VAR_219 : VAR_220 = METHOD_35 ( & VAR_221 -> VAR_222 , VAR_223 , VAR_224 ) ; break ; case VAR_225 : VAR_226 = METHOD_36 ( & VAR_227 -> VAR_228 , VAR_229 , VAR_230 ) ; break ; case VAR_231 : VAR_232 = - VAR_233 ; if ( VAR_234 == sizeof ( struct STRUCT_OR_UNION_7 ) ) { struct STRUCT_OR_UNION_8 VAR_235 ; VAR_236 = - VAR_237 ; if ( METHOD_37 ( & VAR_238 , VAR_239 , sizeof ( VAR_240 ) ) ) break ; VAR_241 = METHOD_38 ( & VAR_242 , VAR_243 ) ; } break ; case VAR_244 : VAR_245 = METHOD_39 ( VAR_246 ) ; break ; case VAR_247 : if ( VAR_248 ) METHOD_40 ( VAR_249 , & STRUCT_OR_UNION_9 -> VAR_250 ) ; else METHOD_41 ( VAR_251 , & STRUCT_OR_UNION_10 -> VAR_252 ) ; break ; case VAR_253 : if ( ! METHOD_42 ( VAR_254 ) ) VAR_255 = - VAR_256 ; else VAR_257 -> VAR_258 = VAR_259 ; break ; case VAR_260 : METHOD_43 ( VAR_261 , VAR_262 , VAR_263 ) ; break ; case VAR_264 : METHOD_44 ( VAR_265 , VAR_266 , VAR_267 ) ; break ; case VAR_268 : if ( STRUCT_OR_UNION_11 -> VAR_269 -> METHOD_45 ) STRUCT_OR_UNION_12 -> VAR_270 -> METHOD_46 ( VAR_271 , VAR_272 ) ; else VAR_273 = - VAR_274 ; break ; case VAR_275 : METHOD_47 ( VAR_276 , VAR_277 , VAR_278 ) ; break ; default : VAR_279 = - VAR_280 ; break ; } METHOD_48 ( VAR_281 ) ; return VAR_282 ; }","<S2SV_ModStart> case VAR_52 : VAR_272 = METHOD_49 ( VAR_283 , VAR_272 , VAR_56 ) <S2SV_ModEnd> ; VAR_75 : <S2SV_ModStart> |= VAR_60 ; VAR_281 -> VAR_67 = METHOD_50 ( VAR_283 , <S2SV_ModEnd> VAR_272 * 2 <S2SV_ModStart> VAR_272 * 2 , VAR_65 ) <S2SV_ModEnd> ; VAR_281 -> <S2SV_ModStart> case VAR_76 : VAR_272 = METHOD_49 ( VAR_283 , VAR_272 , VAR_80 ) <S2SV_ModEnd> ; VAR_97 : <S2SV_ModStart> |= VAR_84 ; VAR_281 -> VAR_91 = METHOD_50 ( VAR_283 , <S2SV_ModEnd> VAR_272 * 2 <S2SV_ModStart> VAR_272 * 2 , VAR_89 ) <S2SV_ModEnd> ; break ;","CWE-119 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_bindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : <S2SV_StartBug> if ( val > sysctl_wmem_max ) <S2SV_EndBug> val = sysctl_wmem_max ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_SNDBUF ) <S2SV_EndBug> sk -> sk_sndbuf = SOCK_MIN_SNDBUF ; else sk -> sk_sndbuf = val * 2 ; sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : <S2SV_StartBug> if ( val > sysctl_rmem_max ) <S2SV_EndBug> val = sysctl_rmem_max ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_RCVBUF ) <S2SV_EndBug> sk -> sk_rcvbuf = SOCK_MIN_RCVBUF ; else sk -> sk_rcvbuf = val * 2 ; break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE :  ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP ) tcp_set_keepalive ( sk , valbool ) ;   sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || capable ( CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else {  if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else   sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""setsockopt"" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE , val & SOF_TIMESTAMPING_TX_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE , val & SOF_TIMESTAMPING_TX_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE , val & SOF_TIMESTAMPING_RX_HARDWARE ) ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE , val & SOF_TIMESTAMPING_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE , val & SOF_TIMESTAMPING_SYS_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE , val & SOF_TIMESTAMPING_RAW_HARDWARE ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }","<S2SV_ModStart> case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> ; set_sndbuf : <S2SV_ModStart> |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> ; sk -> <S2SV_ModStart> case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> ; set_rcvbuf : <S2SV_ModStart> |= SOCK_RCVBUF_LOCK ; sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> ; break ;"
242,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 VAR_1 , const TYPE_3 VAR_2 , const TYPE_4 VAR_3 , const unsigned TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { TYPE_7 VAR_6 ; register const unsigned TYPE_8 * VAR_7 ; register TYPE_9 * VAR_8 ; register TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; unsigned TYPE_12 VAR_11 ; VAR_12 = VAR_13 ; VAR_14 = METHOD_1 ( VAR_15 , 0 , VAR_16 , VAR_17 -> VAR_18 , 1 , VAR_19 ) ; if ( VAR_20 == ( TYPE_13 * ) VAR_21 ) return VAR_22 ; VAR_23 = METHOD_2 ( VAR_24 ) ; for ( VAR_25 = 0 ; VAR_26 < ( TYPE_14 ) VAR_27 -> VAR_28 ; VAR_29 ++ ) { if ( VAR_30 == 1 ) VAR_31 = METHOD_3 ( * VAR_32 ++ ) ; else { VAR_33 = METHOD_4 ( VAR_34 , VAR_35 , & VAR_36 ) ; VAR_37 = METHOD_5 ( VAR_38 ) ; } switch ( VAR_39 ) { case - 1 : { METHOD_6 ( VAR_40 , VAR_41 , VAR_42 ) ; break ; } case - 2 : case 0 : { METHOD_7 ( VAR_43 , VAR_44 , VAR_45 ) ; if ( VAR_46 == 1 || VAR_47 == - 2 ) METHOD_8 ( VAR_48 , VAR_49 , VAR_50 ) ; if ( VAR_51 -> VAR_52 == VAR_53 ) { if ( VAR_54 == 1 ) METHOD_9 ( VAR_55 , METHOD_10 ( VAR_56 ) , VAR_57 ) ; else METHOD_11 ( VAR_58 , METHOD_12 ( VAR_59 ) , VAR_60 ) ; METHOD_13 ( VAR_61 , VAR_62 -> VAR_63 + ( TYPE_15 ) METHOD_14 ( VAR_64 , METHOD_15 ( VAR_65 , VAR_66 ) , VAR_67 ) , VAR_68 ) ; if ( VAR_69 -> VAR_70 == 1 ) { TYPE_16 VAR_71 , VAR_72 ; VAR_73 = VAR_74 -> VAR_75 - VAR_76 ; if ( VAR_77 > 8 ) VAR_78 = 8 ; for ( VAR_79 = 0 ; VAR_80 < VAR_81 ; VAR_82 ++ ) { METHOD_16 ( VAR_83 , ( ( ( unsigned TYPE_17 ) VAR_84 ) & ( 0x01 << ( 7 - VAR_85 ) ) ) != 0 ? 0 : 255 , VAR_86 ) ; METHOD_17 ( VAR_87 , VAR_88 -> VAR_89 + ( TYPE_18 ) <S2SV_StartBug> METHOD_18 ( VAR_90 , VAR_91 ) , VAR_92 ) ; <S2SV_EndBug> VAR_93 += METHOD_19 ( VAR_94 ) ; VAR_95 ++ ; } VAR_96 -- ; continue ; } } break ; } case 1 : { if ( VAR_97 -> VAR_98 == VAR_99 ) METHOD_20 ( VAR_100 , VAR_101 , VAR_102 ) ; else METHOD_21 ( VAR_103 , VAR_104 , VAR_105 ) ; break ; } case 2 : { if ( VAR_106 -> VAR_107 == VAR_108 ) METHOD_22 ( VAR_109 , VAR_110 , VAR_111 ) ; else METHOD_23 ( VAR_112 , VAR_113 , VAR_114 ) ; break ; } case 3 : { if ( VAR_115 -> VAR_116 == VAR_117 ) METHOD_24 ( VAR_118 , VAR_119 , VAR_120 ) ; else if ( VAR_121 -> VAR_122 != VAR_123 ) METHOD_25 ( VAR_124 , VAR_125 , VAR_126 ) ; break ; } case 4 : { if ( ( METHOD_26 ( VAR_127 -> VAR_128 ) != VAR_129 ) && ( VAR_130 > 3 ) ) break ; if ( VAR_131 -> VAR_132 != VAR_133 ) METHOD_27 ( VAR_134 , VAR_135 , VAR_136 ) ; break ; } default : break ; } VAR_137 += METHOD_28 ( VAR_138 ) ; } return ( METHOD_29 ( VAR_139 , VAR_140 ) ) ; }","<S2SV_ModStart> ( TYPE_18 ) METHOD_14 ( VAR_139 , <S2SV_ModStart> VAR_139 , VAR_137 ) , VAR_140","CWE-125 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } switch ( type ) { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; x ++ ; } x -- ; continue ; } } break ; } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }","<S2SV_ModStart> ( ssize_t ) ConstrainColormapIndex ( image , <S2SV_ModStart> image , q ) , exception"
243,"CWE-426 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 VAR_2 = 0 , VAR_3 = 0 , VAR_4 = 0 , VAR_5 = 0 , VAR_6 = 0 ; TYPE_4 VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 ; TYPE_5 VAR_12 ; TYPE_6 * VAR_13 , * VAR_14 , * VAR_15 , * VAR_16 = VAR_17 ; TYPE_7 * VAR_18 = VAR_19 , * VAR_20 = VAR_21 ; struct STRUCT_OR_UNION_0 VAR_22 ; extern TYPE_8 VAR_23 ; extern TYPE_9 * VAR_24 ; TYPE_10 VAR_25 ; TYPE_11 VAR_26 [ 1 + 3 * sizeof VAR_27 ] ; struct STRUCT_OR_UNION_1 * VAR_28 = VAR_29 ; TYPE_12 VAR_30 ; TYPE_13 VAR_31 ; METHOD_1 ( ) ; METHOD_2 ( ) ; METHOD_3 ( METHOD_4 ( ) ) ; METHOD_5 ( METHOD_6 ( ) ) ; TYPE_14 TYPE_15 VAR_32 ( ) ; <S2SV_StartBug> while ( ( VAR_33 = METHOD_7 ( VAR_34 , VAR_35 , ""cDdksE:a:t:"" ) ) != - 1 ) { <S2SV_EndBug> switch ( VAR_36 ) { case 'E' : VAR_37 = METHOD_8 ( VAR_38 ) ; if ( VAR_39 == - 1 ) METHOD_9 ( ""Invalid<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>\\""%s\\"""" , VAR_40 ) ; break ; case 'c' : if ( VAR_41 ) METHOD_10 ( ) ; VAR_42 ++ ; break ; case 'k' : <S2SV_StartBug> VAR_43 ++ ; <S2SV_EndBug> break ; case 's' : if ( VAR_44 ) METHOD_11 ( ) ; VAR_45 ++ ; break ; case 'd' : if ( VAR_46 || VAR_47 ) METHOD_12 ( ) ; VAR_48 ++ ; break ; case 'D' : if ( VAR_49 || VAR_50 ) METHOD_13 ( ) ; VAR_51 ++ ; break ; case 'a' : VAR_52 = VAR_53 ; break ; case 't' : if ( ( VAR_54 = METHOD_14 ( VAR_55 ) ) == - 1 ) { METHOD_15 ( VAR_56 , ""Invalid<S2SV_blank>lifetime\\n"" ) ; METHOD_16 ( ) ; } break ; default : METHOD_17 ( ) ; } } VAR_57 -= VAR_58 ; VAR_59 += VAR_60 ; if ( VAR_61 > 0 && ( VAR_62 || VAR_63 || VAR_64 || VAR_65 || VAR_66 ) ) METHOD_18 ( ) ; <S2SV_StartBug> if ( VAR_67 == 0 && ! VAR_68 && ! VAR_69 ) { <S2SV_EndBug> VAR_70 = METHOD_19 ( ""SHELL"" ) ; if ( VAR_71 != VAR_72 && ( VAR_73 = METHOD_20 ( VAR_74 ) ) > 2 && METHOD_21 ( VAR_75 + VAR_76 - 3 , ""csh"" , 3 ) == 0 ) VAR_77 = 1 ; } if ( VAR_78 ) { const TYPE_16 * VAR_79 = VAR_80 ; VAR_81 = METHOD_22 ( VAR_82 ) ; if ( VAR_83 == VAR_84 ) { METHOD_23 ( VAR_85 , ""%s<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>cannot<S2SV_blank>kill<S2SV_blank>agent\\n"" , VAR_86 ) ; METHOD_24 ( 1 ) ; } VAR_87 = ( TYPE_17 ) METHOD_25 ( VAR_88 , 2 , VAR_89 , & VAR_90 ) ; if ( VAR_91 ) { METHOD_26 ( VAR_92 , ""%s=\\""%s\\"",<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>good<S2SV_blank>PID:<S2SV_blank>%s\\n"" , VAR_93 , VAR_94 , VAR_95 ) ; METHOD_27 ( 1 ) ; } if ( METHOD_28 ( VAR_96 , VAR_97 ) == - 1 ) { METHOD_29 ( ""kill"" ) ; METHOD_30 ( 1 ) ; } VAR_98 = VAR_99 ? ""unsetenv<S2SV_blank>%s;\\n"" : ""unset<S2SV_blank>%s;\\n"" ; METHOD_31 ( VAR_100 , VAR_101 ) ; METHOD_32 ( VAR_102 , VAR_103 ) ; METHOD_33 ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld<S2SV_blank>killed;\\n"" , ( TYPE_18 ) VAR_104 ) ; METHOD_34 ( 0 ) ; } VAR_105 = METHOD_35 ( ) ; if ( VAR_106 == VAR_107 ) { METHOD_36 ( VAR_108 , sizeof ( VAR_109 ) ) ; if ( METHOD_37 ( VAR_110 ) == VAR_111 ) { METHOD_38 ( ""mkdtemp:<S2SV_blank>private<S2SV_blank>socket<S2SV_blank>dir"" ) ; METHOD_39 ( 1 ) ; } METHOD_40 ( VAR_112 , sizeof VAR_113 , ""%s/agent.%ld"" , VAR_114 , ( TYPE_19 ) VAR_115 ) ; } else { VAR_116 [ 0 ] = '\\0' ; METHOD_41 ( VAR_117 , VAR_118 , sizeof VAR_119 ) ; } VAR_120 = METHOD_42 ( 0177 ) ; VAR_121 = METHOD_43 ( VAR_122 , VAR_123 , 0 ) ; if ( VAR_124 < 0 ) { * VAR_125 = '\\0' ; METHOD_44 ( 1 ) ; } METHOD_45 ( VAR_126 ) ; if ( VAR_127 || VAR_128 ) { METHOD_46 ( VAR_129 , VAR_130 ? VAR_131 : VAR_132 , VAR_133 , 1 ) ; VAR_134 = VAR_135 ? ""setenv<S2SV_blank>%s<S2SV_blank>%s;\\n"" : ""%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n"" ; METHOD_47 ( VAR_136 , VAR_137 , VAR_138 , VAR_139 ) ; METHOD_48 ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n"" , ( TYPE_20 ) VAR_140 ) ; METHOD_49 ( VAR_141 ) ; goto VAR_142 ; } VAR_143 = METHOD_50 ( ) ; if ( VAR_144 == - 1 ) { METHOD_51 ( ""fork"" ) ; METHOD_52 ( 1 ) ; } if ( VAR_145 != 0 ) { METHOD_53 ( VAR_146 ) ; METHOD_54 ( VAR_147 , sizeof VAR_148 , ""%ld"" , ( TYPE_21 ) VAR_149 ) ; if ( VAR_150 == 0 ) { VAR_151 = VAR_152 ? ""setenv<S2SV_blank>%s<S2SV_blank>%s;\\n"" : ""%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n"" ; METHOD_55 ( VAR_153 , VAR_154 , VAR_155 , VAR_156 ) ; METHOD_56 ( VAR_157 , VAR_158 , VAR_159 , VAR_160 ) ; METHOD_57 ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n"" , ( TYPE_22 ) VAR_161 ) ; METHOD_58 ( 0 ) ; } if ( METHOD_59 ( VAR_162 , VAR_163 , 1 ) == - 1 || METHOD_60 ( VAR_164 , VAR_165 , 1 ) == - 1 ) { METHOD_61 ( ""setenv"" ) ; METHOD_62 ( 1 ) ; } METHOD_63 ( VAR_166 [ 0 ] , VAR_167 ) ; METHOD_64 ( VAR_168 [ 0 ] ) ; METHOD_65 ( 1 ) ; } METHOD_66 ( VAR_169 , VAR_170 , VAR_171 , 0 ) ; if ( METHOD_67 ( ) == - 1 ) { METHOD_68 ( ""setsid:<S2SV_blank>%s"" , METHOD_69 ( VAR_172 ) ) ; METHOD_70 ( 1 ) ; } ( TYPE_23 ) METHOD_71 ( ""/"" ) ; if ( ( VAR_173 = METHOD_72 ( VAR_174 , VAR_175 , 0 ) ) != - 1 ) { ( TYPE_24 ) METHOD_73 ( VAR_176 , VAR_177 ) ; ( TYPE_25 ) METHOD_74 ( VAR_178 , VAR_179 ) ; ( TYPE_26 ) METHOD_75 ( VAR_180 , VAR_181 ) ; if ( VAR_182 > 2 ) METHOD_76 ( VAR_183 ) ; } VAR_184 . VAR_185 = VAR_186 . VAR_187 = 0 ; if ( METHOD_77 ( VAR_188 , & VAR_189 ) < 0 ) { METHOD_78 ( ""setrlimit<S2SV_blank>RLIMIT_CORE:<S2SV_blank>%s"" , METHOD_79 ( VAR_190 ) ) ; METHOD_80 ( 1 ) ; } VAR_191 : VAR_192 = METHOD_81 ( ) ; TYPE_27 TYPE_28 TYPE_29 ( 0 ) ; METHOD_82 ( VAR_193 , VAR_194 ) ; if ( VAR_195 > 0 ) VAR_196 = 10 ; METHOD_83 ( ) ; METHOD_84 ( VAR_197 , VAR_198 ) ; METHOD_85 ( VAR_199 , ( VAR_200 | VAR_201 ) ? VAR_202 : VAR_203 ) ; METHOD_86 ( VAR_204 , VAR_205 ) ; METHOD_87 ( VAR_206 , VAR_207 ) ; VAR_208 = 0 ; <S2SV_StartBug> if ( METHOD_88 ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , VAR_209 ) == - 1 ) <S2SV_EndBug> METHOD_89 ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , VAR_210 , METHOD_90 ( VAR_211 ) ) ; while ( 1 ) { METHOD_91 ( & VAR_212 , & VAR_213 , & VAR_214 , & VAR_215 , & VAR_216 ) ; VAR_217 = METHOD_92 ( VAR_218 + 1 , VAR_219 , VAR_220 , VAR_221 , VAR_222 ) ; VAR_223 = VAR_224 ; if ( VAR_225 != 0 ) METHOD_93 ( ) ; ( TYPE_30 ) METHOD_94 ( ) ; if ( VAR_226 < 0 ) { if ( VAR_227 == VAR_228 ) continue ; METHOD_95 ( ""select:<S2SV_blank>%s"" , METHOD_96 ( VAR_229 ) ) ; } else if ( VAR_230 > 0 ) METHOD_97 ( VAR_231 , VAR_232 ) ; } }","<S2SV_ModStart> , VAR_168 , ""cDdksE:a:P:t:"" <S2SV_ModEnd> ) ) != <S2SV_ModStart> : VAR_78 ++ ; break ; case 'P' : if ( VAR_234 != VAR_221 ) METHOD_95 ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ; VAR_234 = METHOD_98 ( VAR_55 ) <S2SV_ModStart> ; if ( VAR_234 == VAR_221 ) VAR_234 = METHOD_98 ( VAR_235 ) ; if ( <S2SV_ModStart> ( METHOD_88 ( ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" <S2SV_ModEnd> , VAR_221 )","CWE-426 int main ( int ac , char * * av ) { int c_flag = 0 , d_flag = 0 , D_flag = 0 , k_flag = 0 , s_flag = 0 ; int sock , fd , ch , result , saved_errno ; u_int nalloc ; char * shell , * format , * pidstr , * agentsocket = NULL ; fd_set * readsetp = NULL , * writesetp = NULL ; struct rlimit rlim ; extern int optind ; extern char * optarg ; pid_t pid ; char pidstrbuf [ 1 + 3 * sizeof pid ] ; struct timeval * tvp = NULL ; size_t len ; mode_t prev_mask ; ssh_malloc_init ( ) ; sanitise_stdfd ( ) ; setegid ( getgid ( ) ) ; setgid ( getgid ( ) ) ;  ifdef WITH_OPENSSL OpenSSL_add_all_algorithms ( ) ;   <S2SV_StartBug> while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) { <S2SV_EndBug> switch ( ch ) { case 'E' : fingerprint_hash = ssh_digest_alg_by_name ( optarg ) ; if ( fingerprint_hash == - 1 ) fatal ( ""Invalid<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>\\""%s\\"""" , optarg ) ; break ; case 'c' : if ( s_flag ) usage ( ) ; c_flag ++ ; break ; case 'k' : <S2SV_StartBug> k_flag ++ ; <S2SV_EndBug> break ; case 's' : if ( c_flag ) usage ( ) ; s_flag ++ ; break ; case 'd' : if ( d_flag || D_flag ) usage ( ) ; d_flag ++ ; break ; case 'D' : if ( d_flag || D_flag ) usage ( ) ; D_flag ++ ; break ; case 'a' : agentsocket = optarg ; break ; case 't' : if ( ( lifetime = convtime ( optarg ) ) == - 1 ) { fprintf ( stderr , ""Invalid<S2SV_blank>lifetime\\n"" ) ; usage ( ) ; } break ; default : usage ( ) ; } } ac -= optind ; av += optind ; if ( ac > 0 && ( c_flag || k_flag || s_flag || d_flag || D_flag ) ) usage ( ) ; <S2SV_StartBug> if ( ac == 0 && ! c_flag && ! s_flag ) { <S2SV_EndBug> shell = getenv ( ""SHELL"" ) ; if ( shell != NULL && ( len = strlen ( shell ) ) > 2 && strncmp ( shell + len - 3 , ""csh"" , 3 ) == 0 ) c_flag = 1 ; } if ( k_flag ) { const char * errstr = NULL ; pidstr = getenv ( SSH_AGENTPID_ENV_NAME ) ; if ( pidstr == NULL ) { fprintf ( stderr , ""%s<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>cannot<S2SV_blank>kill<S2SV_blank>agent\\n"" , SSH_AGENTPID_ENV_NAME ) ; exit ( 1 ) ; } pid = ( int ) strtonum ( pidstr , 2 , INT_MAX , & errstr ) ; if ( errstr ) { fprintf ( stderr , ""%s=\\""%s\\"",<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>good<S2SV_blank>PID:<S2SV_blank>%s\\n"" , SSH_AGENTPID_ENV_NAME , pidstr , errstr ) ; exit ( 1 ) ; } if ( kill ( pid , SIGTERM ) == - 1 ) { perror ( ""kill"" ) ; exit ( 1 ) ; } format = c_flag ? ""unsetenv<S2SV_blank>%s;\\n"" : ""unset<S2SV_blank>%s;\\n"" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( format , SSH_AGENTPID_ENV_NAME ) ; printf ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld<S2SV_blank>killed;\\n"" , ( long ) pid ) ; exit ( 0 ) ; } parent_pid = getpid ( ) ; if ( agentsocket == NULL ) { mktemp_proto ( socket_dir , sizeof ( socket_dir ) ) ; if ( mkdtemp ( socket_dir ) == NULL ) { perror ( ""mkdtemp:<S2SV_blank>private<S2SV_blank>socket<S2SV_blank>dir"" ) ; exit ( 1 ) ; } snprintf ( socket_name , sizeof socket_name , ""%s/agent.%ld"" , socket_dir , ( long ) parent_pid ) ; } else { socket_dir [ 0 ] = '\\0' ; strlcpy ( socket_name , agentsocket , sizeof socket_name ) ; } prev_mask = umask ( 0177 ) ; sock = unix_listener ( socket_name , SSH_LISTEN_BACKLOG , 0 ) ; if ( sock < 0 ) { * socket_name = '\\0' ; cleanup_exit ( 1 ) ; } umask ( prev_mask ) ; if ( D_flag || d_flag ) { log_init ( __progname , d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 1 ) ; format = c_flag ? ""setenv<S2SV_blank>%s<S2SV_blank>%s;\\n"" : ""%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n"" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n"" , ( long ) parent_pid ) ; fflush ( stdout ) ; goto skip ; } pid = fork ( ) ; if ( pid == - 1 ) { perror ( ""fork"" ) ; cleanup_exit ( 1 ) ; } if ( pid != 0 ) { close ( sock ) ; snprintf ( pidstrbuf , sizeof pidstrbuf , ""%ld"" , ( long ) pid ) ; if ( ac == 0 ) { format = c_flag ? ""setenv<S2SV_blank>%s<S2SV_blank>%s;\\n"" : ""%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n"" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( format , SSH_AGENTPID_ENV_NAME , pidstrbuf , SSH_AGENTPID_ENV_NAME ) ; printf ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n"" , ( long ) pid ) ; exit ( 0 ) ; } if ( setenv ( SSH_AUTHSOCKET_ENV_NAME , socket_name , 1 ) == - 1 || setenv ( SSH_AGENTPID_ENV_NAME , pidstrbuf , 1 ) == - 1 ) { perror ( ""setenv"" ) ; exit ( 1 ) ; } execvp ( av [ 0 ] , av ) ; perror ( av [ 0 ] ) ; exit ( 1 ) ; } log_init ( __progname , SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 0 ) ; if ( setsid ( ) == - 1 ) { error ( ""setsid:<S2SV_blank>%s"" , strerror ( errno ) ) ; cleanup_exit ( 1 ) ; } ( void ) chdir ( ""/"" ) ; if ( ( fd = open ( _PATH_DEVNULL , O_RDWR , 0 ) ) != - 1 ) { ( void ) dup2 ( fd , STDIN_FILENO ) ; ( void ) dup2 ( fd , STDOUT_FILENO ) ; ( void ) dup2 ( fd , STDERR_FILENO ) ; if ( fd > 2 ) close ( fd ) ; } rlim . rlim_cur = rlim . rlim_max = 0 ; if ( setrlimit ( RLIMIT_CORE , & rlim ) < 0 ) { error ( ""setrlimit<S2SV_blank>RLIMIT_CORE:<S2SV_blank>%s"" , strerror ( errno ) ) ; cleanup_exit ( 1 ) ; } skip : cleanup_pid = getpid ( ) ;  ifdef ENABLE_PKCS11 pkcs11_init ( 0 ) ;   new_socket ( AUTH_SOCKET , sock ) ; if ( ac > 0 ) parent_alive_interval = 10 ; idtab_init ( ) ; signal ( SIGPIPE , SIG_IGN ) ; signal ( SIGINT , ( d_flag | D_flag ) ? cleanup_handler : SIG_IGN ) ; signal ( SIGHUP , cleanup_handler ) ; signal ( SIGTERM , cleanup_handler ) ; nalloc = 0 ; <S2SV_StartBug> if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) <S2SV_EndBug> fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ; while ( 1 ) { prepare_select ( & readsetp , & writesetp , & max_fd , & nalloc , & tvp ) ; result = select ( max_fd + 1 , readsetp , writesetp , NULL , tvp ) ; saved_errno = errno ; if ( parent_alive_interval != 0 ) check_parent_exists ( ) ; ( void ) reaper ( ) ; if ( result < 0 ) { if ( saved_errno == EINTR ) continue ; fatal ( ""select:<S2SV_blank>%s"" , strerror ( saved_errno ) ) ; } else if ( result > 0 ) after_select ( readsetp , writesetp ) ; } }","<S2SV_ModStart> , av , ""cDdksE:a:P:t:"" <S2SV_ModEnd> ) ) != <S2SV_ModStart> : k_flag ++ ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> ; if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ( pledge ( ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" <S2SV_ModEnd> , NULL )"
244,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> TYPE_4 VAR_3 ; if ( VAR_4 -> VAR_5 != VAR_6 -> VAR_7 || VAR_8 -> VAR_9 != VAR_10 -> VAR_11 ) { return 1 ; } for ( VAR_12 = 0 ; VAR_13 < VAR_14 -> VAR_15 ; VAR_16 ++ ) { for ( VAR_17 = 0 ; VAR_18 < VAR_19 -> VAR_20 ; VAR_21 ++ ) { if ( METHOD_1 ( VAR_22 , VAR_23 , VAR_24 ) != METHOD_2 ( VAR_25 , VAR_26 , VAR_27 ) ) { return 1 ; } } } return 0 ; }",<S2SV_ModStart> VAR_25 ) { TYPE_5 VAR_26 ; TYPE_5 <S2SV_ModEnd> VAR_27 ; if,"CWE-190 int jas_matrix_cmp ( jas_matrix_t * mat0 , jas_matrix_t * mat1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; if ( mat0 -> numrows_ != mat1 -> numrows_ || mat0 -> numcols_ != mat1 -> numcols_ ) { return 1 ; } for ( i = 0 ; i < mat0 -> numrows_ ; i ++ ) { for ( j = 0 ; j < mat0 -> numcols_ ; j ++ ) { if ( jas_matrix_get ( mat0 , i , j ) != jas_matrix_get ( mat1 , i , j ) ) { return 1 ; } } } return 0 ; }",<S2SV_ModStart> mat1 ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; if
245,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = & VAR_3 -> VAR_4 ; TYPE_1 VAR_5 = 0 , VAR_6 = 0 ; METHOD_1 ( VAR_7 , ""search<S2SV_blank>H323\\n"" ) ; if ( ( VAR_8 -> VAR_9 != VAR_10 ) && ( VAR_11 -> VAR_12 -> VAR_13 != METHOD_2 ( 102 ) ) ) { METHOD_3 ( VAR_14 , ""calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>tcp\\n"" ) ; if ( VAR_15 -> VAR_16 >= 4 && ( VAR_17 -> VAR_18 [ 0 ] == 0x03 ) && ( VAR_19 -> VAR_20 [ 1 ] == 0x00 ) ) { struct STRUCT_OR_UNION_3 * VAR_21 = ( struct STRUCT_OR_UNION_4 * ) VAR_22 -> VAR_23 ; TYPE_2 VAR_24 = METHOD_4 ( VAR_25 -> VAR_26 ) ; if ( VAR_27 -> VAR_28 == VAR_29 ) { if ( VAR_30 -> VAR_31 [ 4 ] == ( VAR_32 -> VAR_33 - sizeof ( struct STRUCT_OR_UNION_5 ) - 1 ) ) { if ( ( VAR_34 -> VAR_35 [ 5 ] == 0xE0 ) || ( VAR_36 -> VAR_37 [ 5 ] == 0xD0 ) ) { METHOD_5 ( VAR_38 , ""found<S2SV_blank>RDP\\n"" ) ; METHOD_6 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; return ; } } VAR_43 -> VAR_44 . VAR_45 . VAR_46 ++ ; if ( VAR_47 -> VAR_48 . VAR_49 . VAR_50 >= 2 ) { METHOD_7 ( VAR_51 , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; METHOD_8 ( VAR_52 , VAR_53 , VAR_54 , VAR_55 ) ; } } else { METHOD_9 ( VAR_56 , VAR_57 ) ; return ; } } } else if ( VAR_58 -> VAR_59 != VAR_60 ) { VAR_61 = METHOD_10 ( VAR_62 -> VAR_63 -> VAR_64 ) , VAR_65 = METHOD_11 ( VAR_66 -> VAR_67 -> VAR_68 ) ; METHOD_12 ( VAR_69 , ""calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>udp\\n"" ) ; if ( VAR_70 -> VAR_71 >= 6 && VAR_72 -> VAR_73 [ 0 ] == 0x80 && VAR_74 -> VAR_75 [ 1 ] == 0x08 && ( VAR_76 -> VAR_77 [ 2 ] == 0xe7 || VAR_78 -> VAR_79 [ 2 ] == 0x26 ) && VAR_80 -> VAR_81 [ 4 ] == 0x00 && VAR_82 -> VAR_83 [ 5 ] == 0x00 ) { METHOD_13 ( VAR_84 , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; METHOD_14 ( VAR_85 , VAR_86 , VAR_87 , VAR_88 ) ; return ; } if ( VAR_89 == 1719 || VAR_90 == 1719 ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( VAR_91 -> VAR_92 [ 0 ] == 0x16 && VAR_93 -> VAR_94 [ 1 ] == 0x80 && VAR_95 -> VAR_96 [ 4 ] == 0x06 && VAR_97 -> VAR_98 [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> METHOD_15 ( VAR_99 , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; METHOD_16 ( VAR_100 , VAR_101 , VAR_102 , VAR_103 ) ; return ; } else if ( VAR_104 -> VAR_105 >= 20 && VAR_106 -> VAR_107 <= 117 ) { METHOD_17 ( VAR_108 , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; METHOD_18 ( VAR_109 , VAR_110 , VAR_111 , VAR_112 ) ; return ; } else { METHOD_19 ( VAR_113 , VAR_114 ) ; return ; } } } }",<S2SV_ModStart> == 1719 ) { if ( ( VAR_106 -> VAR_107 >= 5 ) && <S2SV_ModEnd> ( VAR_106 -> <S2SV_ModStart> ] == 0x16 ) && ( <S2SV_ModEnd> VAR_106 -> VAR_98 <S2SV_ModStart> ] == 0x80 ) && ( <S2SV_ModEnd> VAR_106 -> VAR_98 <S2SV_ModStart> ] == 0x06 ) && ( <S2SV_ModEnd> VAR_106 -> VAR_98 <S2SV_ModStart> == 0x00 ) ),"CWE-125 void ndpi_search_h323 ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int16_t dport = 0 , sport = 0 ; NDPI_LOG_DBG ( ndpi_struct , ""search<S2SV_blank>H323\\n"" ) ; if ( ( packet -> tcp != NULL ) && ( packet -> tcp -> dest != ntohs ( 102 ) ) ) { NDPI_LOG_DBG2 ( ndpi_struct , ""calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>tcp\\n"" ) ; if ( packet -> payload_packet_len >= 4 && ( packet -> payload [ 0 ] == 0x03 ) && ( packet -> payload [ 1 ] == 0x00 ) ) { struct tpkt * t = ( struct tpkt * ) packet -> payload ; u_int16_t len = ntohs ( t -> len ) ; if ( packet -> payload_packet_len == len ) { if ( packet -> payload [ 4 ] == ( packet -> payload_packet_len - sizeof ( struct tpkt ) - 1 ) ) { if ( ( packet -> payload [ 5 ] == 0xE0 ) || ( packet -> payload [ 5 ] == 0xD0 ) ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>RDP\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_RDP , NDPI_PROTOCOL_UNKNOWN ) ; return ; } } flow -> l4 . tcp . h323_valid_packets ++ ; if ( flow -> l4 . tcp . h323_valid_packets >= 2 ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; } } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } else if ( packet -> udp != NULL ) { sport = ntohs ( packet -> udp -> source ) , dport = ntohs ( packet -> udp -> dest ) ; NDPI_LOG_DBG2 ( ndpi_struct , ""calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>udp\\n"" ) ; if ( packet -> payload_packet_len >= 6 && packet -> payload [ 0 ] == 0x80 && packet -> payload [ 1 ] == 0x08 && ( packet -> payload [ 2 ] == 0xe7 || packet -> payload [ 2 ] == 0x26 ) && packet -> payload [ 4 ] == 0x00 && packet -> payload [ 5 ] == 0x00 ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } if ( sport == 1719 || dport == 1719 ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else if ( packet -> payload_packet_len >= 20 && packet -> payload_packet_len <= 117 ) { NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } }",<S2SV_ModStart> == 1719 ) { if ( ( packet -> payload_packet_len >= 5 ) && <S2SV_ModEnd> ( packet -> <S2SV_ModStart> ] == 0x16 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x80 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x06 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> == 0x00 ) )
246,"CWE-269 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 = STRUCT_OR_UNION_3 -> VAR_5 -> VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 = METHOD_1 ( STRUCT_OR_UNION_5 -> VAR_8 ) ; if ( ! METHOD_2 ( VAR_9 ) ) return - VAR_10 ; if ( STRUCT_OR_UNION_6 -> VAR_11 != STRUCT_OR_UNION_7 -> VAR_12 -> VAR_13 ) return - VAR_14 ; VAR_15 = METHOD_3 ( VAR_16 , VAR_17 ) ; if ( VAR_18 ) return VAR_19 ; METHOD_4 ( & VAR_20 -> VAR_21 ) ; if ( VAR_22 & VAR_23 ) VAR_24 = METHOD_5 ( STRUCT_OR_UNION_8 -> VAR_25 , VAR_26 ) ; else if ( ! METHOD_6 ( VAR_27 ) ) VAR_28 = - VAR_29 ; else VAR_30 = METHOD_7 ( VAR_31 , VAR_32 , VAR_33 , 0 ) ; if ( ! VAR_34 ) { METHOD_8 ( ) ; <S2SV_StartBug> VAR_35 |= VAR_36 -> VAR_37 . VAR_38 & VAR_39 ; <S2SV_EndBug> VAR_40 -> VAR_41 . VAR_42 = VAR_43 ; METHOD_9 ( VAR_44 -> VAR_45 ) ; METHOD_10 ( ) ; } METHOD_11 ( & VAR_46 -> VAR_47 ) ; return VAR_48 ; }",<S2SV_ModStart> . VAR_43 & ~ VAR_49 <S2SV_ModEnd> ; VAR_44 ->,"CWE-269 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }",<S2SV_ModStart> . mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
247,"CWE-120 TYPE_0 METHOD_0 ( TYPE_1 ) { VAR_0 * VAR_1 ; const TYPE_2 * VAR_2 ; TYPE_3 VAR_3 [ 100 ] , VAR_4 [ 30 ] ; TYPE_4 VAR_5 ; TYPE_5 TYPE_6 VAR_6 = METHOD_1 ( ) ; else <S2SV_StartBug> VAR_7 = METHOD_2 ( ) ; <S2SV_EndBug> TYPE_7 = VAR_8 ( VAR_9 , "".ettercap_gtk"" , VAR_10 ) ; METHOD_3 ( ""gtkui_conf_read:<S2SV_blank>%s"" , TYPE_8 ) ; VAR_11 = METHOD_4 ( TYPE_9 , ""r"" ) ; if ( ! VAR_12 ) return ; while ( METHOD_5 ( VAR_13 , 100 , VAR_14 ) ) { METHOD_6 ( VAR_15 , ""%s<S2SV_blank>=<S2SV_blank>%hd"" , VAR_16 , & VAR_17 ) ; METHOD_7 ( VAR_18 , VAR_19 ) ; } METHOD_8 ( VAR_20 ) ; }",<S2SV_ModStart> else VAR_9 = METHOD_9 <S2SV_ModEnd> ( ) ;,"CWE-120 void gtkui_conf_read ( void ) { FILE * fd ; const char * path ; char line [ 100 ] , name [ 30 ] ; short value ;  ifdef OS_WINDOWS path = ec_win_get_user_dir ( ) ;  else <S2SV_StartBug> path = g_get_tmp_dir ( ) ; <S2SV_EndBug>   filename = g_build_filename ( path , "".ettercap_gtk"" , NULL ) ; DEBUG_MSG ( ""gtkui_conf_read:<S2SV_blank>%s"" , filename ) ; fd = fopen ( filename , ""r"" ) ; if ( ! fd ) return ; while ( fgets ( line , 100 , fd ) ) { sscanf ( line , ""%s<S2SV_blank>=<S2SV_blank>%hd"" , name , & value ) ; gtkui_conf_set ( name , value ) ; } fclose ( fd ) ; }",<S2SV_ModStart> else path = g_get_home_dir <S2SV_ModEnd> ( ) ;
248,"CWE-17 struct STRUCT_OR_UNION_0 * METHOD_0 ( TYPE_0 ) { const struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = METHOD_1 ( ) ; static TYPE_1 VAR_0 ; struct STRUCT_OR_UNION_3 * VAR_1 ; TYPE_2 VAR_2 ; if ( METHOD_2 ( ) >= VAR_3 . VAR_4 && ! METHOD_3 ( VAR_5 ) ) { if ( METHOD_4 ( & VAR_6 ) >= VAR_7 . VAR_8 ) goto VAR_9 ; } VAR_10 = METHOD_5 ( VAR_11 , VAR_12 ) ; if ( METHOD_6 ( ! VAR_13 ) ) return METHOD_7 ( - VAR_14 ) ; METHOD_8 ( & VAR_15 ) ; VAR_16 -> VAR_17 = METHOD_9 ( STRUCT_OR_UNION_4 ) ; VAR_18 = METHOD_10 ( VAR_19 ) ; if ( METHOD_11 ( VAR_20 ) ) { METHOD_12 ( VAR_21 ) ; return METHOD_13 ( VAR_22 ) ; } <S2SV_StartBug> METHOD_14 ( & VAR_23 -> VAR_24 . VAR_25 ) ; <S2SV_EndBug> METHOD_15 ( & VAR_26 -> VAR_27 , 1 ) ; METHOD_16 ( & VAR_28 -> VAR_29 . VAR_30 ) ; METHOD_17 ( & VAR_31 -> VAR_32 ) ; METHOD_18 ( VAR_33 ) ; return VAR_34 ; VAR_35 : if ( METHOD_19 ( ) > VAR_36 ) { METHOD_20 ( ""VFS:<S2SV_blank>file-max<S2SV_blank>limit<S2SV_blank>%lu<S2SV_blank>reached\\n"" , METHOD_21 ( ) ) ; VAR_37 = METHOD_22 ( ) ; } return METHOD_23 ( - VAR_38 ) ; }",<S2SV_ModStart> ) ; } <S2SV_ModEnd> METHOD_15 ( &,"CWE-17 struct file * get_empty_filp ( void ) { const struct cred * cred = current_cred ( ) ; static long old_max ; struct file * f ; int error ; if ( get_nr_files ( ) >= files_stat . max_files && ! capable ( CAP_SYS_ADMIN ) ) { if ( percpu_counter_sum_positive ( & nr_files ) >= files_stat . max_files ) goto over ; } f = kmem_cache_zalloc ( filp_cachep , GFP_KERNEL ) ; if ( unlikely ( ! f ) ) return ERR_PTR ( - ENOMEM ) ; percpu_counter_inc ( & nr_files ) ; f -> f_cred = get_cred ( cred ) ; error = security_file_alloc ( f ) ; if ( unlikely ( error ) ) { file_free ( f ) ; return ERR_PTR ( error ) ; } <S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> atomic_long_set ( & f -> f_count , 1 ) ; rwlock_init ( & f -> f_owner . lock ) ; spin_lock_init ( & f -> f_lock ) ; eventpoll_init_file ( f ) ; return f ; over : if ( get_nr_files ( ) > old_max ) { pr_info ( ""VFS:<S2SV_blank>file-max<S2SV_blank>limit<S2SV_blank>%lu<S2SV_blank>reached\\n"" , get_max_files ( ) ) ; old_max = get_nr_files ( ) ; } return ERR_PTR ( - ENFILE ) ; }",<S2SV_ModStart> ) ; } <S2SV_ModEnd> atomic_long_set ( &
249,"CWE-284 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) { TYPE_2 VAR_1 = - 1 ; TYPE_3 VAR_2 = 1 ; TYPE_4 TYPE_5 TYPE_6 VAR_3 ; if ( ! VAR_4 ) { if ( METHOD_1 ( METHOD_2 ( 2 , 2 ) , & VAR_5 ) != VAR_6 ) { METHOD_3 ( VAR_7 , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; METHOD_4 ( - 1 ) ; } VAR_8 = 1 ; } struct STRUCT_OR_UNION_0 VAR_9 ; if ( 0 > ( VAR_10 = METHOD_5 ( VAR_11 , VAR_12 , VAR_13 ) ) ) { METHOD_6 ( ""socket()"" ) ; return - 1 ; } if ( METHOD_7 ( VAR_14 , VAR_15 , VAR_16 , ( TYPE_7 * ) & VAR_17 , sizeof ( TYPE_8 ) ) == - 1 ) { METHOD_8 ( ""setsockopt()"" ) ; METHOD_9 ( VAR_18 ) ; return - 1 ; } METHOD_10 ( ( TYPE_9 * ) & VAR_19 , 0 , sizeof ( VAR_20 ) ) ; VAR_21 . VAR_22 = VAR_23 ; <S2SV_StartBug> VAR_24 . VAR_25 . VAR_26 = METHOD_11 ( VAR_27 ) ; <S2SV_EndBug> VAR_28 . VAR_29 = METHOD_12 ( VAR_30 ) ; if ( 0 > METHOD_13 ( VAR_31 , ( struct STRUCT_OR_UNION_1 * ) & VAR_32 , sizeof ( VAR_33 ) ) ) { METHOD_14 ( ""bind()"" ) ; METHOD_15 ( VAR_34 ) ; return - 1 ; } if ( METHOD_16 ( VAR_35 , 1 ) == - 1 ) { METHOD_17 ( ""listen()"" ) ; METHOD_18 ( VAR_36 ) ; return - 1 ; } return VAR_37 ; }",<S2SV_ModStart> = METHOD_11 ( VAR_38 <S2SV_ModEnd> ) ; VAR_33,"CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ;  ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; }   struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }",<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
250,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 VAR_7 ; TYPE_5 VAR_8 ; TYPE_6 VAR_9 ; TYPE_7 VAR_10 ; TYPE_8 VAR_11 ; <S2SV_StartBug> if ( VAR_12 < sizeof VAR_13 ) <S2SV_EndBug> return - VAR_14 ; if ( METHOD_1 ( & VAR_15 , VAR_16 , sizeof VAR_17 ) ) return - VAR_18 ; VAR_19 = METHOD_2 ( & STRUCT_OR_UNION_5 -> VAR_20 -> VAR_21 ) ; VAR_22 = METHOD_3 ( STRUCT_OR_UNION_6 -> VAR_23 -> VAR_24 , & STRUCT_OR_UNION_7 -> VAR_25 -> VAR_26 ) ; if ( ! VAR_27 ) { VAR_28 = - VAR_29 ; goto VAR_30 ; } if ( VAR_31 . VAR_32 & ~ ( TYPE_9 ) ( VAR_33 | VAR_34 ) ) { VAR_35 = - VAR_36 ; goto VAR_37 ; } VAR_38 = VAR_39 . VAR_40 & VAR_41 ; if ( METHOD_4 ( VAR_42 , VAR_43 ) ) { VAR_44 = - VAR_45 ; goto VAR_46 ; } if ( ! STRUCT_OR_UNION_8 -> VAR_47 && VAR_48 != VAR_49 ) { VAR_50 = - VAR_51 ; goto VAR_52 ; } VAR_53 = ( VAR_54 . VAR_55 & VAR_56 ) >> VAR_57 ; if ( ! VAR_58 ) { if ( VAR_59 >= METHOD_5 ( VAR_60 ) || ! VAR_61 [ VAR_62 METHOD_6 ) { VAR_63 = - VAR_64 ; goto VAR_65 ; } if ( VAR_66 . VAR_67 * 4 != VAR_68 ) { VAR_69 = - VAR_70 ; goto VAR_71 ; } VAR_72 = VAR_73 [ VAR_74 METHOD_7 ( STRUCT_OR_UNION_9 , VAR_75 , VAR_76 + sizeof ( VAR_77 ) , VAR_78 . VAR_79 * 4 , VAR_80 . VAR_81 * 4 ) ; } else if ( VAR_82 == VAR_83 ) { struct STRUCT_OR_UNION_10 VAR_84 ; struct STRUCT_OR_UNION_11 VAR_85 ; struct STRUCT_OR_UNION_12 VAR_86 ; TYPE_10 VAR_87 = VAR_88 ; if ( VAR_89 >= METHOD_8 ( VAR_90 ) || ! VAR_91 [ VAR_92 METHOD_9 ) { VAR_93 = - VAR_94 ; goto VAR_95 ; } if ( ! STRUCT_OR_UNION_13 -> VAR_96 ) { VAR_97 = - VAR_98 ; goto VAR_99 ; } if ( VAR_100 < ( sizeof ( VAR_101 ) + sizeof ( VAR_102 ) ) ) { VAR_103 = - VAR_104 ; goto VAR_105 ; } if ( METHOD_10 ( & VAR_106 , VAR_107 + sizeof ( VAR_108 ) , sizeof ( VAR_109 ) ) ) { VAR_110 = - VAR_111 ; goto VAR_112 ; } VAR_113 -= sizeof ( VAR_114 ) + sizeof ( VAR_115 ) ; VAR_116 += sizeof ( VAR_117 ) + sizeof ( VAR_118 ) ; if ( ( VAR_119 . VAR_120 + VAR_121 . VAR_122 ) * 8 != VAR_123 ) { VAR_124 = - VAR_125 ; goto VAR_126 ; } if ( VAR_127 . VAR_128 ) { VAR_129 = - VAR_130 ; goto VAR_131 ; } if ( VAR_132 . VAR_133 ) { if ( ! VAR_134 . VAR_135 && ! VAR_136 . VAR_137 ) { VAR_138 = - VAR_139 ; goto VAR_140 ; } if ( ! METHOD_11 ( VAR_141 , ( TYPE_11 TYPE_12 * ) ( unsigned TYPE_13 ) VAR_142 . VAR_143 , ( VAR_144 . VAR_145 + VAR_146 . VAR_147 ) * 8 ) ) { VAR_148 = - VAR_149 ; goto VAR_150 ; } } else { if ( VAR_151 . VAR_152 || VAR_153 . VAR_154 ) { VAR_155 = - VAR_156 ; goto VAR_157 ; } } METHOD_12 ( & VAR_158 , VAR_159 , ( unsigned TYPE_14 ) VAR_160 . VAR_161 , VAR_162 . VAR_163 * 8 , VAR_164 . VAR_165 * 8 ) ; METHOD_13 ( & VAR_166 , VAR_167 + VAR_168 . VAR_169 , ( unsigned TYPE_15 ) VAR_170 . VAR_171 + VAR_172 . VAR_173 , VAR_174 . VAR_175 * 8 , VAR_176 . VAR_177 * 8 ) ; VAR_178 = VAR_179 [ VAR_180 METHOD_14 ( STRUCT_OR_UNION_14 , VAR_181 , & VAR_182 , & VAR_183 ) ; if ( ! VAR_184 ) VAR_185 = VAR_186 ; } else { VAR_187 = - VAR_188 ; } VAR_189 : METHOD_15 ( & STRUCT_OR_UNION_15 -> VAR_190 -> VAR_191 , VAR_192 ) ; return VAR_193 ; }",<S2SV_ModStart> ; if ( METHOD_17 ( ! METHOD_16 ( VAR_4 ) ) ) return - VAR_194 ; if (,"CWE-264 static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }",<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
251,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = 22 , VAR_4 = 0 ; if ( VAR_5 + sizeof ( TYPE_4 ) >= VAR_6 -> VAR_7 ) goto VAR_8 ; TYPE_5 VAR_9 = METHOD_1 ( * ( TYPE_6 * ) & VAR_10 -> VAR_11 [ VAR_12 ] ) ; VAR_13 += 4 ; if ( ( VAR_14 >= VAR_15 -> VAR_16 ) || ( VAR_17 >= VAR_18 -> VAR_19 - VAR_20 - 1 ) ) goto VAR_21 ; METHOD_2 ( VAR_22 , ( const TYPE_7 * ) & VAR_23 -> VAR_24 [ VAR_25 ] , VAR_26 = VAR_27 ) ; VAR_28 [ VAR_29 ++ ] = ';' ; VAR_30 += VAR_31 ; <S2SV_StartBug> VAR_32 = METHOD_3 ( * ( TYPE_8 * ) & VAR_33 -> VAR_34 [ VAR_35 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_36 += 4 + VAR_37 ; <S2SV_EndBug> VAR_38 = METHOD_4 ( * ( TYPE_9 * ) & VAR_39 -> VAR_40 [ VAR_41 ] ) ; if ( VAR_42 ) { VAR_43 += 4 ; if ( ( VAR_44 >= VAR_45 -> VAR_46 ) || ( VAR_47 >= VAR_48 -> VAR_49 - VAR_50 - 1 ) ) goto VAR_51 ; METHOD_5 ( & VAR_52 [ VAR_53 ] , ( const TYPE_10 * ) & VAR_54 -> VAR_55 [ VAR_56 ] , VAR_57 ) ; VAR_58 += VAR_59 ; VAR_60 [ VAR_61 ++ ] = ';' ; VAR_62 += VAR_63 ; } else VAR_64 += 4 + VAR_65 ; <S2SV_StartBug> VAR_66 = METHOD_6 ( * ( TYPE_11 * ) & VAR_67 -> VAR_68 [ VAR_69 ] ) ; <S2SV_EndBug> if ( ! VAR_70 ) { VAR_71 += 4 ; if ( ( VAR_72 >= VAR_73 -> VAR_74 ) || ( VAR_75 >= VAR_76 -> VAR_77 - VAR_78 - 1 ) ) goto VAR_79 ; METHOD_7 ( & VAR_80 [ VAR_81 ] , ( const TYPE_12 * ) & VAR_82 -> VAR_83 [ VAR_84 ] , VAR_85 ) ; VAR_86 += VAR_87 ; VAR_88 [ VAR_89 ++ ] = ';' ; VAR_90 += VAR_91 ; } else VAR_92 += 4 + VAR_93 ; <S2SV_StartBug> VAR_94 = METHOD_8 ( * ( TYPE_13 * ) & VAR_95 -> VAR_96 [ VAR_97 ] ) ; <S2SV_EndBug> if ( VAR_98 ) { VAR_99 += 4 ; if ( ( VAR_100 >= VAR_101 -> VAR_102 ) || ( VAR_103 >= VAR_104 -> VAR_105 - VAR_106 - 1 ) ) goto VAR_107 ; METHOD_9 ( & VAR_108 [ VAR_109 ] , ( const TYPE_14 * ) & VAR_110 -> VAR_111 [ VAR_112 ] , VAR_113 ) ; VAR_114 += VAR_115 ; VAR_116 [ VAR_117 ++ ] = ';' ; VAR_118 += VAR_119 ; } else VAR_120 += 4 + VAR_121 ; <S2SV_StartBug> VAR_122 = METHOD_10 ( * ( TYPE_15 * ) & VAR_123 -> VAR_124 [ VAR_125 ] ) ; <S2SV_EndBug> if ( ! VAR_126 ) { VAR_127 += 4 ; if ( ( VAR_128 >= VAR_129 -> VAR_130 ) || ( VAR_131 >= VAR_132 -> VAR_133 - VAR_134 - 1 ) ) goto VAR_135 ; METHOD_11 ( & VAR_136 [ VAR_137 ] , ( const TYPE_16 * ) & VAR_138 -> VAR_139 [ VAR_140 ] , VAR_141 ) ; VAR_142 += VAR_143 ; VAR_144 [ VAR_145 ++ ] = ';' ; VAR_146 += VAR_147 ; } else VAR_148 += 4 + VAR_149 ; if ( VAR_150 + sizeof ( TYPE_17 ) >= VAR_151 -> VAR_152 ) goto VAR_153 ; VAR_154 = METHOD_12 ( * ( TYPE_18 * ) & VAR_155 -> VAR_156 [ VAR_157 ] ) ; if ( VAR_158 ) { VAR_159 += 4 ; if ( ( VAR_160 >= VAR_161 -> VAR_162 ) || ( VAR_163 >= VAR_164 -> VAR_165 - VAR_166 - 1 ) ) goto VAR_167 ; METHOD_13 ( & VAR_168 [ VAR_169 ] , ( const TYPE_19 * ) & VAR_170 -> VAR_171 [ VAR_172 ] , VAR_173 ) ; VAR_174 += VAR_175 ; VAR_176 += VAR_177 ; } else <S2SV_StartBug> VAR_178 += 4 + VAR_179 ; <S2SV_EndBug> VAR_180 = METHOD_14 ( * ( TYPE_20 * ) & VAR_181 -> VAR_182 [ VAR_183 ] ) ; if ( ! VAR_184 ) { VAR_185 += 4 ; if ( ( VAR_186 >= VAR_187 -> VAR_188 ) || ( VAR_189 >= VAR_190 -> VAR_191 - VAR_192 - 1 ) ) goto VAR_193 ; METHOD_15 ( & VAR_194 [ VAR_195 ] , ( const TYPE_21 * ) & VAR_196 -> VAR_197 [ VAR_198 ] , VAR_199 ) ; VAR_200 += VAR_201 ; VAR_202 += VAR_203 ; } else VAR_204 += 4 + VAR_205 ; TYPE_22 TYPE_23 TYPE_24 ( ""[SSH]<S2SV_blank>%s\\n"" , VAR_206 ) ; return ( VAR_207 ) ; VAR_208 : TYPE_25 TYPE_26 TYPE_27 ( ""[SSH]<S2SV_blank>Invalid<S2SV_blank>packet<S2SV_blank>payload\\n"" ) ; return ( 0 ) ; }",<S2SV_ModStart> += VAR_205 ; if ( VAR_204 + sizeof ( TYPE_20 ) >= VAR_196 -> VAR_191 ) goto VAR_208 ; <S2SV_ModStart> 4 + VAR_205 ; if ( VAR_204 + sizeof ( TYPE_20 ) >= VAR_196 -> VAR_191 ) goto VAR_208 <S2SV_ModStart> + VAR_205 ; if ( VAR_204 + sizeof ( TYPE_20 ) >= VAR_196 -> VAR_191 ) goto VAR_208 ; <S2SV_ModStart> + VAR_205 ; if ( VAR_204 + sizeof ( TYPE_20 ) >= VAR_196 -> VAR_191 ) goto VAR_208 ; <S2SV_ModStart> + VAR_205 ; if ( VAR_204 + sizeof ( TYPE_20 ) >= VAR_196 -> VAR_191 ) goto VAR_208 ; <S2SV_ModStart> 4 + VAR_205 ; if ( VAR_204 + sizeof ( TYPE_20 ) >= VAR_196 -> VAR_191 ) goto VAR_208,"CWE-125 static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { u_int16_t offset = 22 , buf_out_len = 0 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ;  ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>%s\\n"" , buf ) ;   return ( buf_out_len ) ; invalid_payload :  ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>Invalid<S2SV_blank>packet<S2SV_blank>payload\\n"" ) ;   return ( 0 ) ; }",<S2SV_ModStart> += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload
252,"CWE-476 unsigned TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { unsigned TYPE_1 VAR_3 = VAR_4 -> VAR_5 ; static const TYPE_2 VAR_6 [ VAR_7 ] VAR_8 ( ( VAR_9 ( sizeof ( TYPE_3 ) ) ) ) ; unsigned TYPE_4 VAR_10 = VAR_11 ; const struct STRUCT_OR_UNION_3 * VAR_12 ; struct STRUCT_OR_UNION_4 * VAR_13 , * * VAR_14 ; const TYPE_5 * VAR_15 , * VAR_16 ; const TYPE_6 * VAR_17 ; unsigned TYPE_7 VAR_18 , VAR_19 = 0 ; const struct STRUCT_OR_UNION_5 * VAR_20 ; struct STRUCT_OR_UNION_6 VAR_21 ; unsigned TYPE_8 VAR_22 ; if ( ! METHOD_1 ( VAR_23 , METHOD_2 ( VAR_24 -> VAR_25 ) ) ) return VAR_26 ; VAR_27 = VAR_28 -> VAR_29 ? VAR_30 -> VAR_31 -> VAR_32 : VAR_33 ; VAR_34 = VAR_35 -> VAR_36 ? VAR_37 -> VAR_38 -> VAR_39 : VAR_40 ; METHOD_3 ( ) ; VAR_41 = METHOD_4 ( ) ; VAR_42 = METHOD_5 ( VAR_43 -> VAR_44 ) ; VAR_45 = METHOD_6 ( ) ; VAR_46 = VAR_47 -> VAR_48 ; VAR_49 = ( struct STRUCT_OR_UNION_7 * * ) VAR_50 -> VAR_51 [ VAR_52 ] ; VAR_53 = METHOD_7 ( VAR_54 , VAR_55 -> VAR_56 [ VAR_57 ] ) ; VAR_58 . VAR_59 = VAR_60 ; VAR_61 . VAR_62 = VAR_63 ; VAR_64 = METHOD_8 ( VAR_65 ) ; do { const struct STRUCT_OR_UNION_8 * VAR_66 ; struct STRUCT_OR_UNION_9 * VAR_67 ; if ( ! METHOD_9 ( VAR_68 , VAR_69 -> VAR_70 , VAR_71 , VAR_72 , & VAR_73 -> VAR_74 ) ) { VAR_75 = METHOD_10 ( VAR_76 ) ; continue ; } VAR_77 = METHOD_11 ( & VAR_78 -> VAR_79 ) ; METHOD_12 ( * VAR_80 , METHOD_13 ( VAR_81 -> VAR_82 ) , 1 ) ; VAR_83 = METHOD_14 ( VAR_84 ) ; if ( ! VAR_85 -> VAR_86 . VAR_87 . METHOD_15 -> METHOD_16 ) { TYPE_9 VAR_88 ; VAR_89 = ( ( struct STRUCT_OR_UNION_10 * ) VAR_90 ) -> VAR_91 ; if ( VAR_92 < 0 ) { if ( VAR_93 != VAR_94 ) { VAR_95 = ( unsigned TYPE_10 ) ( - VAR_96 ) - 1 ; break ; } if ( VAR_97 == 0 ) { VAR_98 = METHOD_17 ( VAR_99 , VAR_100 -> VAR_101 [ VAR_102 ] ) ; } else { VAR_103 = VAR_104 [ -- VAR_105 ] ; VAR_106 = METHOD_18 ( VAR_107 ) ; } continue ; } if ( VAR_108 + VAR_109 != METHOD_19 ( VAR_110 ) ) { <S2SV_StartBug> VAR_111 [ VAR_112 ++ ] = VAR_113 ; <S2SV_EndBug> } VAR_114 = METHOD_20 ( VAR_115 , VAR_116 ) ; continue ; } VAR_117 . METHOD_21 = VAR_118 -> VAR_119 . VAR_120 . METHOD_22 ; VAR_121 . VAR_122 = VAR_123 -> VAR_124 ; VAR_125 = VAR_126 -> VAR_127 . VAR_128 . METHOD_23 -> METHOD_24 ( VAR_129 , & VAR_130 ) ; if ( VAR_131 == VAR_132 ) { VAR_133 = METHOD_25 ( VAR_134 ) ; VAR_135 = METHOD_26 ( VAR_136 ) ; } else { break ; } } while ( ! VAR_137 . VAR_138 ) ; METHOD_27 ( VAR_139 ) ; METHOD_28 ( ) ; if ( VAR_140 . VAR_141 ) return VAR_142 ; else return VAR_143 ; }",<S2SV_ModStart> ) ) { if ( METHOD_29 ( VAR_112 >= VAR_100 -> VAR_144 ) ) { VAR_143 = VAR_142 ; break ; },"CWE-476 unsigned int arpt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const struct arphdr * arp ; struct arpt_entry * e , * * jumpstack ; const char * indev , * outdev ; const void * table_base ; unsigned int cpu , stackidx = 0 ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; if ( ! pskb_may_pull ( skb , arp_hdr_len ( skb -> dev ) ) ) return NF_DROP ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct arpt_entry * * ) private -> jumpstack [ cpu ] ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; acpar . state = state ; acpar . hotdrop = false ; arp = arp_hdr ( skb ) ; do { const struct xt_entry_target * t ; struct xt_counters * counter ; if ( ! arp_packet_match ( arp , skb -> dev , indev , outdev , & e -> arp ) ) { e = arpt_next_entry ( e ) ; continue ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , arp_hdr_len ( skb -> dev ) , 1 ) ; t = arpt_get_target_c ( e ) ; if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = arpt_next_entry ( e ) ; } continue ; } if ( table_base + v != arpt_next_entry ( e ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { arp = arp_hdr ( skb ) ; e = arpt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }",<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
253,"CWE-189 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; <S2SV_StartBug> for ( VAR_5 = 0 ; VAR_6 <= VAR_7 - sizeof ( TYPE_6 ) ; VAR_8 += sizeof ( TYPE_7 ) ) { <S2SV_EndBug> TYPE_8 VAR_9 = * ( TYPE_9 * ) ( VAR_10 + VAR_11 ) ; TYPE_10 VAR_12 = * ( TYPE_11 * ) ( VAR_13 + VAR_14 ) ; * ( TYPE_12 * ) ( VAR_15 + VAR_16 ) = ( ( VAR_17 & VAR_18 ) + ( VAR_19 & VAR_20 ) ) ^ ( ( VAR_21 ^ VAR_22 ) & VAR_23 ) ; } for ( ; VAR_24 < VAR_25 ; VAR_26 ++ ) VAR_27 [ VAR_28 ] = VAR_29 [ VAR_30 ] + VAR_31 [ VAR_32 ] ; }",<S2SV_ModStart> <= VAR_25 - ( TYPE_4 ),"CWE-189 static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }",<S2SV_ModStart> <= w - ( int )
254,"CWE-400 static TYPE_0 METHOD_0 ( unsigned VAR_0 ) { struct STRUCT_OR_UNION_0 * VAR_1 ; TYPE_1 TYPE_2 VAR_2 ( TYPE_3 ( VAR_3 ) , METHOD_1 ( 0 ) ) ; VAR_4 = METHOD_2 ( sizeof ( * VAR_5 ) , VAR_6 ) ; if ( VAR_7 == VAR_8 ) METHOD_3 ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>metadata<S2SV_blank>for<S2SV_blank>IRQ%d\\n"" , VAR_9 ) ; VAR_10 -> VAR_11 = VAR_12 ; VAR_13 -> VAR_14 = - 1 ; METHOD_4 ( VAR_15 , VAR_16 ) ; <S2SV_StartBug> METHOD_5 ( & VAR_17 -> VAR_18 , & VAR_19 ) ; <S2SV_EndBug> }",<S2SV_ModStart> VAR_17 ) ; METHOD_6 ( & VAR_17 -> VAR_20 ) ;,"CWE-400 static void xen_irq_init ( unsigned irq ) { struct irq_info * info ;  ifdef CONFIG_SMP cpumask_copy ( irq_get_affinity_mask ( irq ) , cpumask_of ( 0 ) ) ;   info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( info == NULL ) panic ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>metadata<S2SV_blank>for<S2SV_blank>IRQ%d\\n"" , irq ) ; info -> type = IRQT_UNBOUND ; info -> refcnt = - 1 ; set_info_for_irq ( irq , info ) ; <S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> }",<S2SV_ModStart> info ) ; INIT_LIST_HEAD ( & info -> eoi_list ) ;
255,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> const TYPE_3 * const VAR_2 = & VAR_3 -> VAR_4 ; <S2SV_EndBug> const TYPE_4 * VAR_5 = & VAR_6 -> VAR_7 ; TYPE_5 * const VAR_8 = & VAR_9 -> VAR_10 ; if ( ! VAR_11 -> VAR_12 ) { VAR_13 -> VAR_14 -= VAR_15 ; } else { <S2SV_StartBug> VAR_16 -> VAR_17 += VAR_18 -> VAR_19 - VAR_20 ; <S2SV_EndBug> } <S2SV_StartBug> VAR_21 -> VAR_22 = METHOD_1 ( VAR_23 -> VAR_24 , VAR_25 -> VAR_26 ) ; <S2SV_EndBug> VAR_27 -> VAR_28 = VAR_29 -> VAR_30 ; <S2SV_StartBug> if ( VAR_31 -> VAR_32 && VAR_33 -> VAR_34 . VAR_35 == VAR_36 ) { <S2SV_EndBug> METHOD_2 ( & VAR_37 -> VAR_38 , VAR_39 ) ; } }","<S2SV_ModStart> VAR_37 -> VAR_4 <S2SV_ModEnd> ; TYPE_5 * <S2SV_ModStart> += VAR_29 -> VAR_40 <S2SV_ModEnd> - VAR_39 ; <S2SV_ModStart> -> VAR_30 , VAR_29 <S2SV_ModEnd> -> VAR_26 ) <S2SV_ModStart> ; if ( METHOD_3 ( VAR_37 ) <S2SV_ModEnd> ) { METHOD_2","CWE-119 static void update_buffer_level ( VP9_COMP * cpi , int encoded_frame_size ) { <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; RATE_CONTROL * const rc = & cpi -> rc ; if ( ! cm -> show_frame ) { rc -> bits_off_target -= encoded_frame_size ; } else { <S2SV_StartBug> rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ; <S2SV_EndBug> } <S2SV_StartBug> rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ; <S2SV_EndBug> rc -> buffer_level = rc -> bits_off_target ; <S2SV_StartBug> if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ; } }","<S2SV_ModStart> cpi -> common <S2SV_ModEnd> ; RATE_CONTROL * <S2SV_ModStart> += rc -> avg_frame_bandwidth <S2SV_ModEnd> - encoded_frame_size ; <S2SV_ModStart> -> bits_off_target , rc <S2SV_ModEnd> -> maximum_buffer_size ) <S2SV_ModStart> ; if ( is_one_pass_cbr_svc ( cpi ) <S2SV_ModEnd> ) { update_layer_buffer_level"
256,"CWE-119 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { VAR_2 1 VAR_3 0 VAR_4 2 VAR_5 1 VAR_6 2 VAR_7 3 typedef struct STRUCT_OR_UNION_0 { unsigned TYPE_3 VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 ; } TYPE_4 ; TYPE_5 * VAR_16 ; TYPE_6 VAR_17 ; TYPE_7 VAR_18 ; TYPE_8 VAR_19 ; register TYPE_9 * VAR_20 ; register TYPE_10 VAR_21 , VAR_22 ; register unsigned TYPE_11 * VAR_23 ; TYPE_12 VAR_24 , VAR_25 , VAR_26 ; TYPE_13 VAR_27 , VAR_28 ; TYPE_14 VAR_29 ; unsigned TYPE_15 * VAR_30 , * VAR_31 ; METHOD_1 ( VAR_32 != ( const TYPE_16 * ) VAR_33 ) ; METHOD_2 ( VAR_34 -> VAR_35 == VAR_36 ) ; if ( VAR_37 -> VAR_38 != VAR_39 ) ( TYPE_17 ) METHOD_3 ( VAR_40 , METHOD_4 ( ) , ""%s"" , VAR_41 -> VAR_42 ) ; METHOD_5 ( VAR_43 != ( TYPE_18 * ) VAR_44 ) ; METHOD_6 ( VAR_45 -> VAR_46 == VAR_47 ) ; VAR_48 = METHOD_7 ( VAR_49 , VAR_50 ) ; VAR_51 = METHOD_8 ( VAR_52 , VAR_53 , VAR_54 , VAR_55 ) ; if ( VAR_56 == VAR_57 ) { VAR_58 = METHOD_9 ( VAR_59 ) ; return ( ( TYPE_19 * ) VAR_60 ) ; } ( TYPE_20 ) METHOD_10 ( & VAR_61 , 0 , sizeof ( VAR_62 ) ) ; VAR_63 . VAR_64 = METHOD_11 ( VAR_65 ) ; do { if ( VAR_66 . VAR_67 != 0x59a66a95 ) METHOD_12 ( VAR_68 , ""ImproperImageHeader"" ) ; VAR_69 . VAR_70 = METHOD_13 ( VAR_71 ) ; VAR_72 . VAR_73 = METHOD_14 ( VAR_74 ) ; VAR_75 . VAR_76 = METHOD_15 ( VAR_77 ) ; VAR_78 . VAR_79 = METHOD_16 ( VAR_80 ) ; VAR_81 . VAR_82 = METHOD_17 ( VAR_83 ) ; VAR_84 . VAR_85 = METHOD_18 ( VAR_86 ) ; VAR_87 . VAR_88 = METHOD_19 ( VAR_89 ) ; VAR_90 = VAR_91 . VAR_92 * VAR_93 . VAR_94 ; if ( ( VAR_95 . VAR_96 != 0 ) && ( VAR_97 . VAR_98 != VAR_99 / VAR_100 . VAR_101 ) ) METHOD_20 ( VAR_102 , ""ImproperImageHeader"" ) ; if ( ( VAR_103 . VAR_104 != VAR_105 ) && ( VAR_106 . VAR_107 != VAR_108 ) && ( VAR_109 . VAR_110 != VAR_111 ) ) METHOD_21 ( VAR_112 , ""ImproperImageHeader"" ) ; if ( ( VAR_113 . VAR_114 == VAR_115 ) && ( VAR_116 . VAR_117 != 0 ) ) METHOD_22 ( VAR_118 , ""ImproperImageHeader"" ) ; if ( ( VAR_119 . VAR_120 == 0 ) || ( VAR_121 . VAR_122 > 32 ) ) METHOD_23 ( VAR_123 , ""ImproperImageHeader"" ) ; if ( ( VAR_124 . VAR_125 != VAR_126 ) && ( VAR_127 . VAR_128 != VAR_129 ) && ( VAR_130 . VAR_131 != VAR_132 ) ) METHOD_24 ( VAR_133 , ""ColormapTypeNotSupported"" ) ; VAR_134 -> VAR_135 = VAR_136 . VAR_137 ; VAR_138 -> VAR_139 = VAR_140 . VAR_141 ; VAR_142 -> VAR_143 = VAR_144 . VAR_145 <= 8 ? VAR_146 . VAR_147 : VAR_148 ; if ( VAR_149 . VAR_150 < 24 ) { TYPE_21 VAR_151 ; VAR_152 -> VAR_153 = VAR_154 ; VAR_155 -> VAR_156 = VAR_157 . VAR_158 ; VAR_159 = 1 ; if ( VAR_160 . VAR_161 == VAR_162 ) VAR_163 -> VAR_164 = VAR_165 << VAR_166 . VAR_167 ; if ( VAR_168 . VAR_169 == VAR_170 ) VAR_171 -> VAR_172 = VAR_173 . VAR_174 / 3 ; } switch ( VAR_175 . VAR_176 ) { case VAR_177 : { if ( VAR_178 . VAR_179 < 24 ) { if ( METHOD_25 ( VAR_180 , VAR_181 -> VAR_182 , VAR_183 ) == VAR_184 ) METHOD_26 ( VAR_185 , ""MemoryAllocationFailed"" ) ; } break ; } case VAR_186 : { unsigned TYPE_22 * VAR_187 ; if ( METHOD_27 ( VAR_188 , VAR_189 -> VAR_190 , VAR_191 ) == VAR_192 ) METHOD_28 ( VAR_193 , ""MemoryAllocationFailed"" ) ; VAR_194 = ( unsigned TYPE_23 * ) METHOD_29 ( VAR_195 -> VAR_196 , sizeof ( * VAR_197 ) ) ; if ( VAR_198 == ( unsigned TYPE_24 * ) VAR_199 ) METHOD_30 ( VAR_200 , ""MemoryAllocationFailed"" ) ; VAR_201 = METHOD_31 ( VAR_202 , VAR_203 -> VAR_204 , VAR_205 ) ; if ( VAR_206 != ( TYPE_25 ) VAR_207 -> VAR_208 ) METHOD_32 ( VAR_209 , ""UnexpectedEndOfFile"" ) ; for ( VAR_210 = 0 ; VAR_211 < ( TYPE_26 ) VAR_212 -> VAR_213 ; VAR_214 ++ ) VAR_215 -> VAR_216 [ VAR_217 ] . VAR_218 = ( TYPE_27 ) METHOD_33 ( VAR_219 [ VAR_220 ] ) ; VAR_221 = METHOD_34 ( VAR_222 , VAR_223 -> VAR_224 , VAR_225 ) ; if ( VAR_226 != ( TYPE_28 ) VAR_227 -> VAR_228 ) METHOD_35 ( VAR_229 , ""UnexpectedEndOfFile"" ) ; for ( VAR_230 = 0 ; VAR_231 < ( TYPE_29 ) VAR_232 -> VAR_233 ; VAR_234 ++ ) VAR_235 -> VAR_236 [ VAR_237 ] . VAR_238 = ( TYPE_30 ) METHOD_36 ( VAR_239 [ VAR_240 ] ) ; VAR_241 = METHOD_37 ( VAR_242 , VAR_243 -> VAR_244 , VAR_245 ) ; if ( VAR_246 != ( TYPE_31 ) VAR_247 -> VAR_248 ) METHOD_38 ( VAR_249 , ""UnexpectedEndOfFile"" ) ; for ( VAR_250 = 0 ; VAR_251 < ( TYPE_32 ) VAR_252 -> VAR_253 ; VAR_254 ++ ) VAR_255 -> VAR_256 [ VAR_257 ] . VAR_258 = ( TYPE_33 ) METHOD_39 ( VAR_259 [ VAR_260 ] ) ; VAR_261 = ( unsigned TYPE_34 * ) METHOD_40 ( VAR_262 ) ; break ; } case VAR_263 : { unsigned TYPE_35 * VAR_264 ; VAR_265 = ( unsigned TYPE_36 * ) METHOD_41 ( VAR_266 . VAR_267 , sizeof ( * VAR_268 ) ) ; if ( VAR_269 == ( unsigned TYPE_37 * ) VAR_270 ) METHOD_42 ( VAR_271 , ""MemoryAllocationFailed"" ) ; VAR_272 = METHOD_43 ( VAR_273 , VAR_274 . VAR_275 , VAR_276 ) ; if ( VAR_277 != ( TYPE_38 ) VAR_278 . VAR_279 ) METHOD_44 ( VAR_280 , ""UnexpectedEndOfFile"" ) ; VAR_281 = ( unsigned TYPE_39 * ) METHOD_45 ( VAR_282 ) ; break ; } default : METHOD_46 ( VAR_283 , ""ColormapTypeNotSupported"" ) ; } VAR_284 -> VAR_285 = VAR_286 . VAR_287 == 32 ? VAR_288 : VAR_289 ; VAR_290 -> VAR_291 = VAR_292 . VAR_293 ; VAR_294 -> VAR_295 = VAR_296 . VAR_297 ; if ( VAR_298 -> VAR_299 != VAR_300 ) { ( TYPE_40 ) METHOD_47 ( VAR_301 ) ; return ( METHOD_48 ( VAR_302 ) ) ; } VAR_303 = METHOD_49 ( VAR_304 , VAR_305 -> VAR_306 , VAR_307 -> VAR_308 , VAR_309 ) ; if ( VAR_310 == VAR_311 ) return ( METHOD_50 ( VAR_312 ) ) ; if ( ( VAR_313 . VAR_314 * sizeof ( * VAR_315 ) ) / sizeof ( * VAR_316 ) != VAR_317 . VAR_318 || ! VAR_319 . VAR_320 ) METHOD_51 ( VAR_321 , ""MemoryAllocationFailed"" ) ; VAR_322 = ( TYPE_41 ) VAR_323 -> VAR_324 * VAR_325 -> VAR_326 ; if ( ( VAR_327 . VAR_328 != VAR_329 ) && ( VAR_330 . VAR_331 >= 8 ) && ( ( VAR_332 * ( ( VAR_333 . VAR_334 + 7 ) / 8 ) ) > VAR_335 . VAR_336 ) ) METHOD_52 ( VAR_337 , ""ImproperImageHeader"" ) ; <S2SV_StartBug> VAR_338 = ( unsigned TYPE_42 * ) METHOD_53 ( ( TYPE_43 ) VAR_339 . VAR_340 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * VAR_341 ) ) ; <S2SV_EndBug> if ( VAR_342 == ( unsigned TYPE_44 * ) VAR_343 ) METHOD_54 ( VAR_344 , ""MemoryAllocationFailed"" ) ; VAR_345 = ( TYPE_45 ) METHOD_55 ( VAR_346 , VAR_347 . VAR_348 , VAR_349 ) ; if ( VAR_350 != ( TYPE_46 ) VAR_351 . VAR_352 ) METHOD_56 ( VAR_353 , ""UnableToReadImageData"" ) ; VAR_354 = VAR_355 ; VAR_356 = 0 ; if ( VAR_357 . VAR_358 == VAR_359 ) { TYPE_47 VAR_360 ; <S2SV_StartBug> VAR_361 = VAR_362 . VAR_363 ; <S2SV_EndBug> VAR_364 = VAR_365 . VAR_366 * VAR_367 . VAR_368 ; if ( ( VAR_369 == 0 ) || ( VAR_370 . VAR_371 == 0 ) || ( VAR_372 . VAR_373 == 0 ) || ( ( VAR_374 / VAR_375 . VAR_376 ) != VAR_377 . VAR_378 ) ) METHOD_57 ( VAR_379 , ""MemoryAllocationFailed"" ) ; VAR_380 += 15 ; VAR_381 <<= 1 ; if ( ( VAR_382 >> 1 ) != ( VAR_383 . VAR_384 * VAR_385 . VAR_386 + 15 ) ) METHOD_58 ( VAR_387 , ""MemoryAllocationFailed"" ) ; VAR_388 >>= 4 ; VAR_389 = ( unsigned TYPE_48 * ) METHOD_59 ( VAR_390 , VAR_391 * sizeof ( * VAR_392 ) ) ; if ( VAR_393 == ( unsigned TYPE_49 * ) VAR_394 ) METHOD_60 ( VAR_395 , ""MemoryAllocationFailed"" ) ; ( TYPE_50 ) METHOD_61 ( VAR_396 , VAR_397 . VAR_398 , VAR_399 , VAR_400 * VAR_401 ) ; VAR_402 = ( unsigned TYPE_51 * ) METHOD_62 ( VAR_403 ) ; } VAR_404 = VAR_405 ; if ( VAR_406 . VAR_407 == 1 ) for ( VAR_408 = 0 ; VAR_409 < ( TYPE_52 ) VAR_410 -> VAR_411 ; VAR_412 ++ ) { VAR_413 = METHOD_63 ( VAR_414 , 0 , VAR_415 , VAR_416 -> VAR_417 , 1 , VAR_418 ) ; if ( VAR_419 == ( TYPE_53 * ) VAR_420 ) break ; for ( VAR_421 = 0 ; VAR_422 < ( ( TYPE_54 ) VAR_423 -> VAR_424 - 7 ) ; VAR_425 += 8 ) { for ( VAR_426 = 7 ; VAR_427 >= 0 ; VAR_428 -- ) { METHOD_64 ( VAR_429 , ( TYPE_55 ) ( ( * VAR_430 ) & ( 0x01 << VAR_431 ) ? 0x00 : 0x01 ) , VAR_432 ) ; VAR_433 += METHOD_65 ( VAR_434 ) ; } VAR_435 ++ ; } if ( ( VAR_436 -> VAR_437 % 8 ) != 0 ) { for ( VAR_438 = 7 ; VAR_439 >= ( TYPE_56 ) ( 8 - ( VAR_440 -> VAR_441 % 8 ) ) ; VAR_442 -- ) { METHOD_66 ( VAR_443 , ( TYPE_57 ) ( ( * VAR_444 ) & ( 0x01 << VAR_445 ) ? 0x00 : 0x01 ) , VAR_446 ) ; VAR_447 += METHOD_67 ( VAR_448 ) ; } VAR_449 ++ ; } if ( ( ( ( VAR_450 -> VAR_451 / 8 ) + ( VAR_452 -> VAR_453 % 8 ? 1 : 0 ) ) % 2 ) != 0 ) VAR_454 ++ ; if ( METHOD_68 ( VAR_455 , VAR_456 ) == VAR_457 ) break ; if ( VAR_458 -> VAR_459 == ( TYPE_58 * ) VAR_460 ) { VAR_461 = METHOD_69 ( VAR_462 , VAR_463 , ( TYPE_59 ) VAR_464 , VAR_465 -> VAR_466 ) ; if ( VAR_467 == VAR_468 ) break ; } } else if ( VAR_469 -> VAR_470 == VAR_471 ) { if ( VAR_472 == 0 ) VAR_473 = VAR_474 -> VAR_475 ; VAR_476 = VAR_477 -> VAR_478 * ( VAR_479 -> VAR_480 + VAR_481 -> VAR_482 % 2 ) ; if ( ( ( VAR_483 . VAR_484 == VAR_485 ) && ( VAR_486 > ( VAR_487 * VAR_488 -> VAR_489 ) ) ) || ( ( VAR_490 . VAR_491 != VAR_492 ) && ( VAR_493 > VAR_494 . VAR_495 ) ) ) METHOD_70 ( VAR_496 , ""UnableToReadImageData"" ) ; for ( VAR_497 = 0 ; VAR_498 < ( TYPE_60 ) VAR_499 -> VAR_500 ; VAR_501 ++ ) { VAR_502 = METHOD_71 ( VAR_503 , 0 , VAR_504 , VAR_505 -> VAR_506 , 1 , VAR_507 ) ; if ( VAR_508 == ( TYPE_61 * ) VAR_509 ) break ; for ( VAR_510 = 0 ; VAR_511 < ( TYPE_62 ) VAR_512 -> VAR_513 ; VAR_514 ++ ) { METHOD_72 ( VAR_515 , * VAR_516 ++ , VAR_517 ) ; VAR_518 += METHOD_73 ( VAR_519 ) ; } if ( ( VAR_520 -> VAR_521 % 2 ) != 0 ) VAR_522 ++ ; if ( METHOD_74 ( VAR_523 , VAR_524 ) == VAR_525 ) break ; if ( VAR_526 -> VAR_527 == ( TYPE_63 * ) VAR_528 ) { VAR_529 = METHOD_75 ( VAR_530 , VAR_531 , ( TYPE_64 ) VAR_532 , VAR_533 -> VAR_534 ) ; if ( VAR_535 == VAR_536 ) break ; } } } else { TYPE_65 VAR_537 ; VAR_538 = 3 ; if ( VAR_539 -> VAR_540 != VAR_541 ) VAR_542 ++ ; if ( VAR_543 == 0 ) VAR_544 = VAR_545 * VAR_546 -> VAR_547 ; VAR_548 = VAR_549 -> VAR_550 * ( VAR_551 + VAR_552 -> VAR_553 % 2 ) ; if ( ( ( VAR_554 . VAR_555 == VAR_556 ) && ( VAR_557 > ( VAR_558 * VAR_559 -> VAR_560 ) ) ) || ( ( VAR_561 . VAR_562 != VAR_563 ) && ( VAR_564 > VAR_565 . VAR_566 ) ) ) METHOD_76 ( VAR_567 , ""UnableToReadImageData"" ) ; for ( VAR_568 = 0 ; VAR_569 < ( TYPE_66 ) VAR_570 -> VAR_571 ; VAR_572 ++ ) { VAR_573 = METHOD_77 ( VAR_574 , 0 , VAR_575 , VAR_576 -> VAR_577 , 1 , VAR_578 ) ; if ( VAR_579 == ( TYPE_67 * ) VAR_580 ) break ; for ( VAR_581 = 0 ; VAR_582 < ( TYPE_68 ) VAR_583 -> VAR_584 ; VAR_585 ++ ) { if ( VAR_586 -> VAR_587 != VAR_588 ) METHOD_78 ( VAR_589 , METHOD_79 ( * VAR_590 ++ ) , VAR_591 ) ; if ( VAR_592 . VAR_593 == VAR_594 ) { METHOD_80 ( VAR_595 , METHOD_81 ( * VAR_596 ++ ) , VAR_597 ) ; METHOD_82 ( VAR_598 , METHOD_83 ( * VAR_599 ++ ) , VAR_600 ) ; METHOD_84 ( VAR_601 , METHOD_85 ( * VAR_602 ++ ) , VAR_603 ) ; } else { METHOD_86 ( VAR_604 , METHOD_87 ( * VAR_605 ++ ) , VAR_606 ) ; METHOD_88 ( VAR_607 , METHOD_89 ( * VAR_608 ++ ) , VAR_609 ) ; METHOD_90 ( VAR_610 , METHOD_91 ( * VAR_611 ++ ) , VAR_612 ) ; } if ( VAR_613 -> VAR_614 != 0 ) { METHOD_92 ( VAR_615 , METHOD_93 ( VAR_616 -> VAR_617 [ ( TYPE_69 ) METHOD_94 ( VAR_618 , VAR_619 ) ] . VAR_620 ) , VAR_621 ) ; METHOD_95 ( VAR_622 , METHOD_96 ( VAR_623 -> VAR_624 [ ( TYPE_70 ) METHOD_97 ( VAR_625 , VAR_626 ) ] . VAR_627 ) , VAR_628 ) ; METHOD_98 ( VAR_629 , METHOD_99 ( VAR_630 -> VAR_631 [ ( TYPE_71 ) METHOD_100 ( VAR_632 , VAR_633 ) ] . VAR_634 ) , VAR_635 ) ; } VAR_636 += METHOD_101 ( VAR_637 ) ; } if ( ( ( VAR_638 * VAR_639 -> VAR_640 ) % 2 ) != 0 ) VAR_641 ++ ; if ( METHOD_102 ( VAR_642 , VAR_643 ) == VAR_644 ) break ; if ( VAR_645 -> VAR_646 == ( TYPE_72 * ) VAR_647 ) { VAR_648 = METHOD_103 ( VAR_649 , VAR_650 , ( TYPE_73 ) VAR_651 , VAR_652 -> VAR_653 ) ; if ( VAR_654 == VAR_655 ) break ; } } } if ( VAR_656 -> VAR_657 == VAR_658 ) ( TYPE_74 ) METHOD_104 ( VAR_659 , VAR_660 ) ; VAR_661 = ( unsigned TYPE_75 * ) METHOD_105 ( VAR_662 ) ; if ( METHOD_106 ( VAR_663 ) != VAR_664 ) { METHOD_107 ( VAR_665 , VAR_666 , ""UnexpectedEndOfFile"" , VAR_667 -> VAR_668 ) ; break ; } if ( VAR_669 -> VAR_670 != 0 ) if ( VAR_671 -> VAR_672 >= ( VAR_673 -> VAR_674 + VAR_675 -> VAR_676 - 1 ) ) break ; VAR_677 . VAR_678 = METHOD_108 ( VAR_679 ) ; if ( VAR_680 . VAR_681 == 0x59a66a95 ) { METHOD_109 ( VAR_682 , VAR_683 , VAR_684 ) ; if ( METHOD_110 ( VAR_685 ) == ( TYPE_76 * ) VAR_686 ) { VAR_687 = METHOD_111 ( VAR_688 ) ; return ( ( TYPE_77 * ) VAR_689 ) ; } VAR_690 = METHOD_112 ( VAR_691 ) ; VAR_692 = METHOD_113 ( VAR_693 , VAR_694 , METHOD_114 ( VAR_695 ) , METHOD_115 ( VAR_696 ) ) ; if ( VAR_697 == VAR_698 ) break ; } } while ( VAR_699 . VAR_700 == 0x59a66a95 ) ; ( TYPE_78 ) METHOD_116 ( VAR_701 ) ; return ( METHOD_117 ( VAR_702 ) ) ; }","<S2SV_ModStart> ""ImproperImageHeader"" ) ; VAR_558 = VAR_699 . VAR_384 * VAR_699 . VAR_407 ; <S2SV_ModStart> ( TYPE_65 ) METHOD_118 ( <S2SV_ModStart> . VAR_566 , VAR_558 * VAR_699 . VAR_384 ) , <S2SV_ModStart> VAR_699 . VAR_401 <S2SV_ModEnd> ; if (","CWE-119 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {   RMT_EQUAL_RGB 1   RMT_NONE 0   RMT_RAW 2   RT_STANDARD 1   RT_ENCODED 2   RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; } switch ( sun_info . maptype ) { case RMT_NONE : { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> bytes_per_line = sun_info . width * sun_info . depth ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> ( size_t ) MagickMax ( <S2SV_ModStart> . length , bytes_per_line * sun_info . width ) , <S2SV_ModStart> sun_info . height <S2SV_ModEnd> ; if ("
257,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 ( * VAR_1 ) ( TYPE_2 * VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) , TYPE_5 * VAR_5 ) { TYPE_6 VAR_6 , VAR_7 = 1 ; for ( VAR_8 -> VAR_9 = 0 ; VAR_10 ; VAR_11 -> VAR_12 ++ ) { VAR_13 = METHOD_1 ( VAR_14 , VAR_15 ) ; if ( VAR_16 ) return VAR_17 ; VAR_18 = METHOD_2 ( VAR_19 , VAR_20 , VAR_21 , & VAR_22 ) ; if ( VAR_23 ) return VAR_24 ; } VAR_25 -> VAR_26 -- ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> VAR_26 -- ; METHOD_3 ( VAR_25 ) ;,"CWE-264 static int read_exceptions ( struct pstore * ps , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) { int r , full = 1 ; for ( ps -> current_area = 0 ; full ; ps -> current_area ++ ) { r = area_io ( ps , READ ) ; if ( r ) return r ; r = insert_exceptions ( ps , callback , callback_context , & full ) ; if ( r ) return r ; } ps -> current_area -- ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> current_area -- ; skip_metadata ( ps ) ;
258,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , struct STRUCT_OR_UNION_4 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_5 * VAR_3 ; struct STRUCT_OR_UNION_6 * VAR_4 ; TYPE_3 VAR_5 ; TYPE_4 VAR_6 ; TYPE_5 VAR_7 ; TYPE_6 VAR_8 ; struct STRUCT_OR_UNION_7 VAR_9 ; METHOD_1 ( VAR_10 ) ; VAR_11 = STRUCT_OR_UNION_8 -> VAR_12 ; VAR_13 = METHOD_2 ( VAR_14 ) ; VAR_15 = 0 ; <S2SV_StartBug> VAR_16 -> VAR_17 = 0 ; <S2SV_EndBug> METHOD_3 ( VAR_18 ) ; if ( VAR_19 -> VAR_20 != VAR_21 ) { if ( METHOD_4 ( VAR_22 , VAR_23 ) ) VAR_24 = 0 ; else VAR_25 = - VAR_26 ; goto VAR_27 ; } if ( VAR_28 & VAR_29 ) { VAR_30 = - VAR_31 ; goto VAR_32 ; } if ( VAR_33 -> VAR_34 & VAR_35 ) { VAR_36 = 0 ; goto VAR_37 ; } if ( ! VAR_38 ) { VAR_39 = 0 ; goto VAR_40 ; } VAR_41 = METHOD_5 ( VAR_42 , VAR_43 & VAR_44 , VAR_45 ) ; if ( VAR_46 >= VAR_47 -> METHOD_6 ( VAR_48 ) ) { VAR_49 = - VAR_50 ; goto VAR_51 ; } VAR_52 = METHOD_7 ( VAR_53 , VAR_54 & VAR_55 ) ; VAR_56 = 0 ; VAR_57 = VAR_58 -> METHOD_8 ( VAR_59 , VAR_60 , & VAR_61 ) ; if ( VAR_62 < 0 ) goto VAR_63 ; METHOD_9 ( METHOD_10 ( VAR_64 ) , & VAR_65 , VAR_66 ) ; while ( 1 ) { TYPE_7 VAR_67 = METHOD_11 ( VAR_68 ) ; if ( VAR_69 < 0 ) { VAR_70 = - VAR_71 ; goto VAR_72 ; } else if ( VAR_73 > 0 ) { TYPE_8 VAR_74 ; VAR_75 = VAR_76 -> METHOD_12 ( VAR_77 , VAR_78 , & VAR_79 ) ; if ( VAR_80 < 0 ) break ; VAR_81 = VAR_82 -> METHOD_13 ( VAR_83 , VAR_84 -> VAR_85 , VAR_86 - VAR_87 , VAR_88 ) ; if ( VAR_89 < 0 ) { VAR_90 = - VAR_91 ; break ; } VAR_92 += VAR_93 ; VAR_94 = VAR_95 -> METHOD_14 ( VAR_96 , VAR_97 , VAR_98 , ! ( VAR_99 & VAR_100 ) , & VAR_101 ) ; if ( VAR_102 < 0 ) goto VAR_103 ; if ( VAR_104 >= VAR_105 || VAR_106 & VAR_107 ) break ; VAR_108 -= VAR_109 ; } else { if ( VAR_110 -> VAR_111 != 0 || ( VAR_112 -> VAR_113 & VAR_114 ) || ( VAR_115 -> VAR_116 & VAR_117 ) ) { break ; } if ( VAR_118 == 0 ) { VAR_119 = - VAR_120 ; break ; } VAR_121 = VAR_122 -> METHOD_15 ( VAR_123 , VAR_124 , & VAR_125 ) ; if ( VAR_126 < 0 ) break ; METHOD_16 ( VAR_127 ) ; VAR_128 = METHOD_17 ( VAR_129 ) ; METHOD_18 ( VAR_130 ) ; if ( METHOD_19 ( VAR_131 ) ) { VAR_132 = METHOD_20 ( VAR_133 ) ; break ; } else if ( VAR_134 == 0 ) { VAR_135 = - VAR_136 ; break ; } METHOD_21 ( METHOD_22 ( VAR_137 ) , & VAR_138 , VAR_139 ) ; } } if ( VAR_140 -> VAR_141 ) VAR_142 = - VAR_143 -> VAR_144 ; else if ( VAR_145 -> VAR_146 & VAR_147 ) VAR_148 = 0 ; if ( VAR_149 > 0 ) { if ( ! ( VAR_150 & VAR_151 ) ) { if ( VAR_152 -> VAR_153 & VAR_154 ) { if ( METHOD_23 ( VAR_155 ) <= 0 ) { VAR_156 -> VAR_157 = VAR_158 ; METHOD_24 ( VAR_159 , VAR_160 ) ; VAR_161 -> METHOD_25 ( VAR_162 ) ; } } } VAR_163 = VAR_164 ; } VAR_165 : METHOD_26 ( METHOD_27 ( VAR_166 ) , & VAR_167 ) ; VAR_168 : METHOD_28 ( VAR_169 ) ; return VAR_170 ; }",<S2SV_ModStart> = 0 ; <S2SV_ModEnd> METHOD_18 ( VAR_169,"CWE-20 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }",<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
259,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 TYPE_2 * VAR_0 , TYPE_3 VAR_1 , TYPE_4 * VAR_2 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = STRUCT_OR_UNION_4 -> VAR_3 ; struct STRUCT_OR_UNION_5 * STRUCT_OR_UNION_6 ; TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; if ( ( STRUCT_OR_UNION_7 -> VAR_6 & VAR_7 ) && ( STRUCT_OR_UNION_8 -> VAR_8 == 0 ) ) return - VAR_9 ; if ( ( ! VAR_10 ) || ( VAR_11 < sizeof ( struct STRUCT_OR_UNION_9 ) ) ) return - VAR_12 ; if ( ! METHOD_1 ( VAR_13 , VAR_14 , VAR_15 ) ) return - VAR_16 ; VAR_17 = METHOD_2 ( STRUCT_OR_UNION_10 -> VAR_18 , STRUCT_OR_UNION_11 -> VAR_19 ) ; if ( VAR_20 ) return VAR_21 ; METHOD_3 ( & STRUCT_OR_UNION_12 -> VAR_22 ) ; STRUCT_OR_UNION_13 = list_first_entry ( & STRUCT_OR_UNION_14 -> VAR_23 , struct STRUCT_OR_UNION_15 , VAR_24 ) ; METHOD_4 ( & STRUCT_OR_UNION_16 -> VAR_25 ) ; STRUCT_OR_UNION_17 -> VAR_26 -- ; METHOD_5 ( & STRUCT_OR_UNION_18 -> VAR_27 ) ; <S2SV_StartBug> VAR_28 = METHOD_6 ( VAR_29 , & STRUCT_OR_UNION_19 -> STRUCT_OR_UNION_20 , <S2SV_EndBug> <S2SV_StartBug> STRUCT_OR_UNION_21 -> VAR_30 ) ; <S2SV_EndBug> VAR_31 = STRUCT_OR_UNION_22 -> VAR_32 ; METHOD_7 ( STRUCT_OR_UNION_23 ) ; if ( VAR_33 ) return - VAR_34 ; return VAR_35 ; }","<S2SV_ModStart> VAR_27 ) ; VAR_35 = METHOD_8 ( VAR_15 , STRUCT_OR_UNION_23 -> VAR_32 ) ; <S2SV_ModStart> -> STRUCT_OR_UNION_20 , VAR_35 ) <S2SV_ModEnd> ; METHOD_7 (","CWE-119 static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }","<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree ("
260,"CWE-000 static VAR_0 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 ; TYPE_1 VAR_4 ; if ( ! VAR_5 || ! VAR_6 ) return 0 ; VAR_7 = METHOD_1 ( VAR_8 ) ; VAR_9 = METHOD_2 ( VAR_10 ) ; if ( METHOD_3 ( VAR_11 ) < VAR_12 || METHOD_4 ( VAR_13 ) != VAR_14 ) return - VAR_15 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> - VAR_15 ; if ( VAR_10 -> VAR_16 > VAR_10 -> VAR_17 * sizeof ( VAR_18 ) * 8 ) return - VAR_15 ;,"CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;
261,"CWE-908 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 ) { <S2SV_StartBug> TYPE_6 VAR_5 = 0 , VAR_6 = 0 , VAR_7 ; <S2SV_EndBug> unsigned TYPE_7 * VAR_8 = VAR_9 ; unsigned TYPE_8 * VAR_10 = VAR_11 ; TYPE_9 VAR_12 = 0 , VAR_13 ; TYPE_10 VAR_14 ; TYPE_11 VAR_15 ; TYPE_12 VAR_16 ; TYPE_13 VAR_17 ; VAR_18 = METHOD_1 ( VAR_19 ) ; METHOD_2 ( & VAR_20 , VAR_21 , 4 ) ; if ( ( ! METHOD_3 ( VAR_22 , ( ( TYPE_14 * ) & VAR_23 ) + 4 , sizeof ( TYPE_15 ) - 4 , & VAR_24 ) || VAR_25 != sizeof ( TYPE_16 ) - 4 ) ) { METHOD_4 ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , VAR_26 ) ; return VAR_27 ; } else if ( ! ( VAR_28 -> VAR_29 & VAR_30 ) && ! METHOD_5 ( VAR_31 , & VAR_32 , sizeof ( TYPE_17 ) ) ) { METHOD_6 ( ""%s"" , METHOD_7 ( VAR_33 ) ) ; return VAR_34 ; } METHOD_8 ( & VAR_35 , VAR_36 ) ; if ( VAR_37 . VAR_38 != 1 ) { METHOD_9 ( ""%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!"" , VAR_39 , VAR_40 . VAR_41 ) ; return VAR_42 ; } while ( 1 ) { if ( ! METHOD_10 ( VAR_43 , & VAR_44 , sizeof ( TYPE_18 ) , & VAR_45 ) || VAR_46 != sizeof ( TYPE_19 ) ) { METHOD_11 ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , VAR_47 ) ; return VAR_48 ; } else if ( ! ( VAR_49 -> VAR_50 & VAR_51 ) && ! METHOD_12 ( VAR_52 , & VAR_53 , sizeof ( TYPE_20 ) ) ) { METHOD_13 ( ""%s"" , METHOD_14 ( VAR_54 ) ) ; return VAR_55 ; } METHOD_15 ( & VAR_56 , VAR_57 ) ; if ( ! METHOD_16 ( VAR_58 . VAR_59 , ""desc"" , 4 ) ) { TYPE_21 VAR_60 = VAR_61 ; if ( VAR_62 . VAR_63 != sizeof ( TYPE_22 ) || ! METHOD_17 ( VAR_64 , & VAR_65 , ( TYPE_23 ) VAR_66 . VAR_67 , & VAR_68 ) || VAR_69 != VAR_70 . VAR_71 ) { METHOD_18 ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , VAR_72 ) ; return VAR_73 ; } else if ( ! ( VAR_74 -> VAR_75 & VAR_76 ) && ! METHOD_19 ( VAR_77 , & VAR_78 , ( TYPE_24 ) VAR_79 . VAR_80 ) ) { METHOD_20 ( ""%s"" , METHOD_21 ( VAR_81 ) ) ; return VAR_82 ; } <S2SV_StartBug> METHOD_22 ( & VAR_83 , VAR_84 ) ; <S2SV_EndBug> if ( VAR_85 ) { TYPE_25 VAR_86 [ 5 ] ; METHOD_23 ( VAR_87 , VAR_88 . VAR_89 , 4 ) ; VAR_90 [ 4 ] = 0 ; METHOD_24 ( ""format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g"" , VAR_91 , VAR_92 . VAR_93 , VAR_94 . VAR_95 ) ; METHOD_25 ( ""packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames"" , VAR_96 . VAR_97 , VAR_98 . VAR_99 ) ; METHOD_26 ( ""channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d"" , VAR_100 . VAR_101 , VAR_102 . VAR_103 ) ; } if ( METHOD_27 ( VAR_104 . VAR_105 , ""lpcm"" , 4 ) || ( VAR_106 . VAR_107 & ~ 3 ) ) VAR_108 = VAR_109 ; else if ( VAR_110 . VAR_111 < 1.0 || VAR_112 . VAR_113 > 16777215.0 || VAR_114 . VAR_115 != METHOD_28 ( VAR_116 . VAR_117 ) ) VAR_118 = VAR_119 ; else if ( ! VAR_120 . VAR_121 || VAR_122 . VAR_123 > 256 ) VAR_124 = VAR_125 ; else if ( VAR_126 . VAR_127 < 1 || VAR_128 . VAR_129 > 32 || ( ( VAR_130 . VAR_131 & VAR_132 ) && VAR_133 . VAR_134 != 32 ) ) VAR_135 = VAR_136 ; else if ( VAR_137 . VAR_138 != 1 || VAR_139 . VAR_140 / VAR_141 . VAR_142 < ( VAR_143 . VAR_144 + 7 ) / 8 || VAR_145 . VAR_146 / VAR_147 . VAR_148 > 4 || VAR_149 . VAR_150 % VAR_151 . VAR_152 ) VAR_153 = VAR_154 ; if ( ! VAR_155 ) { METHOD_29 ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!"" , VAR_156 ) ; return VAR_157 ; } VAR_158 -> VAR_159 = VAR_160 . VAR_161 / VAR_162 . VAR_163 ; VAR_164 -> VAR_165 = ( VAR_166 . VAR_167 & VAR_168 ) ? 127 : 0 ; VAR_169 -> VAR_170 = VAR_171 . VAR_172 ; VAR_173 -> VAR_174 = VAR_175 . VAR_176 ; VAR_177 -> VAR_178 = ( TYPE_26 ) VAR_179 . VAR_180 ; if ( ! ( VAR_181 . VAR_182 & VAR_183 ) && VAR_184 -> VAR_185 > 1 ) VAR_186 -> VAR_187 |= VAR_188 ; if ( VAR_189 -> VAR_190 == 1 ) VAR_191 -> VAR_192 |= VAR_193 ; if ( VAR_194 ) { if ( VAR_195 -> VAR_196 == 127 ) METHOD_30 ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point"" , ( VAR_197 -> VAR_198 & VAR_199 ) ? ""big"" : ""little"" ) ; else METHOD_31 ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , VAR_200 -> VAR_201 , ( VAR_202 -> VAR_203 & VAR_204 ) ? ""big"" : ""little"" , VAR_205 -> VAR_206 ) ; } } else if ( ! METHOD_32 ( VAR_207 . VAR_208 , ""chan"" , 4 ) ) { VAR_209 * VAR_210 ; if ( VAR_211 . VAR_212 < 0 || VAR_213 . VAR_214 > 1024 || VAR_215 . VAR_216 < sizeof ( VAR_217 ) ) { METHOD_33 ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return VAR_218 ; } if ( VAR_219 ) METHOD_34 ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( TYPE_27 ) VAR_220 . VAR_221 ) ; VAR_222 = METHOD_35 ( ( TYPE_28 ) VAR_223 . VAR_224 ) ; if ( ! METHOD_36 ( VAR_225 , VAR_226 , ( TYPE_29 ) VAR_227 . VAR_228 , & VAR_229 ) || VAR_230 != VAR_231 . VAR_232 ) { METHOD_37 ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , VAR_233 ) ; METHOD_38 ( VAR_234 ) ; return VAR_235 ; } else if ( ! ( VAR_236 -> VAR_237 & VAR_238 ) && ! METHOD_39 ( VAR_239 , VAR_240 , ( TYPE_30 ) VAR_241 . VAR_242 ) ) { METHOD_40 ( ""%s"" , METHOD_41 ( VAR_243 ) ) ; METHOD_42 ( VAR_244 ) ; return VAR_245 ; } METHOD_43 ( VAR_246 , VAR_247 ) ; VAR_248 = 1 ; if ( VAR_249 -> VAR_250 || ( VAR_251 -> VAR_252 & VAR_253 ) ) { METHOD_44 ( ""this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; METHOD_45 ( VAR_254 ) ; return VAR_255 ; } switch ( VAR_256 -> VAR_257 ) { case VAR_258 : { TYPE_31 * VAR_259 = ( TYPE_32 * ) ( VAR_260 + 1 ) ; TYPE_33 VAR_261 = VAR_262 -> VAR_263 ; TYPE_34 VAR_264 , VAR_265 = 0 , VAR_266 = 0 ; if ( VAR_267 . VAR_268 != sizeof ( VAR_269 ) + sizeof ( TYPE_35 ) * VAR_270 || VAR_271 != VAR_272 -> VAR_273 ) { METHOD_46 ( ""channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!"" ) ; METHOD_47 ( VAR_274 ) ; return VAR_275 ; } if ( VAR_276 >= 256 ) { METHOD_48 ( ""%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!"" ) ; break ; } VAR_277 = METHOD_49 ( VAR_278 ) ; METHOD_50 ( VAR_279 , - 1 , VAR_280 ) ; VAR_281 = METHOD_51 ( VAR_282 + 1 ) ; for ( VAR_283 = 0 ; VAR_284 < VAR_285 ; ++ VAR_286 ) { METHOD_52 ( VAR_287 + VAR_288 , VAR_289 ) ; if ( VAR_290 ) METHOD_53 ( ""chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d"" , VAR_291 + 1 , VAR_292 [ VAR_293 ] . VAR_294 ) ; } for ( VAR_295 = 1 ; VAR_296 <= 18 ; ++ VAR_297 ) for ( VAR_298 = 0 ; VAR_299 < VAR_300 ; ++ VAR_301 ) if ( VAR_302 [ VAR_303 ] . VAR_304 == VAR_305 ) { VAR_306 -> VAR_307 |= 1 << ( VAR_308 - 1 ) ; VAR_309 [ VAR_310 ] = VAR_311 ++ ; break ; } for ( VAR_312 = 0 ; VAR_313 < VAR_314 ; ++ VAR_315 ) if ( VAR_316 [ VAR_317 ] == ( unsigned TYPE_36 ) - 1 ) { TYPE_37 VAR_318 = VAR_319 [ VAR_320 ] . VAR_321 ; if ( VAR_322 == 0 || VAR_323 == 0xffffffff || VAR_324 == 100 ) VAR_325 [ VAR_326 ++ ] = 0xff ; else if ( ( VAR_327 >= 33 && VAR_328 <= 44 ) || ( VAR_329 >= 200 && VAR_330 <= 207 ) || ( VAR_331 >= 301 && VAR_332 <= 305 ) ) VAR_333 [ VAR_334 ++ ] = VAR_335 >= 301 ? VAR_336 - 80 : VAR_337 ; else { METHOD_54 ( ""warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d"" , VAR_338 ) ; VAR_339 [ VAR_340 ++ ] = 0xff ; } VAR_341 [ VAR_342 ] = VAR_343 ++ ; } for ( VAR_344 = 0 ; VAR_345 < VAR_346 ; ++ VAR_347 ) if ( VAR_348 [ VAR_349 ] != VAR_350 ) break ; if ( VAR_351 == VAR_352 ) { METHOD_55 ( VAR_353 ) ; VAR_354 = VAR_355 ; } else { VAR_356 -> VAR_357 |= VAR_358 ; VAR_359 = VAR_360 ; } if ( ! VAR_361 ) { METHOD_56 ( VAR_362 ) ; VAR_363 = VAR_364 ; } else VAR_365 [ VAR_366 ] = 0 ; if ( VAR_367 ) { METHOD_57 ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , VAR_368 -> VAR_369 , VAR_370 -> VAR_371 , VAR_372 -> VAR_373 , VAR_374 ) ; if ( VAR_375 && VAR_376 <= 8 ) { TYPE_38 VAR_377 [ ] = ""12345678"" ; for ( VAR_378 = 0 ; VAR_379 < VAR_380 ; ++ VAR_381 ) VAR_382 [ VAR_383 ] = VAR_384 [ VAR_385 ] + '1' ; VAR_386 [ VAR_387 ] = 0 ; METHOD_58 ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\""%s\\""\\n"" , VAR_388 ) ; } } } break ; case VAR_389 : VAR_390 -> VAR_391 = VAR_392 -> VAR_393 ; if ( VAR_394 ) METHOD_59 ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , VAR_395 -> VAR_396 , VAR_397 -> VAR_398 ) ; break ; default : for ( VAR_399 = 0 ; VAR_400 < VAR_401 ; ++ VAR_402 ) if ( VAR_403 -> VAR_404 == VAR_405 [ VAR_406 ] . VAR_407 ) { VAR_408 -> VAR_409 = VAR_410 [ VAR_411 ] . VAR_412 ; VAR_413 = VAR_414 [ VAR_415 ] . VAR_416 ; if ( VAR_417 [ VAR_418 ] . VAR_419 ) { VAR_420 = ( unsigned TYPE_39 * ) METHOD_60 ( VAR_421 [ VAR_422 ] . VAR_423 ) ; VAR_424 -> VAR_425 |= VAR_426 ; } if ( VAR_427 [ VAR_428 ] . VAR_429 ) VAR_430 = ( unsigned TYPE_40 * ) METHOD_61 ( VAR_431 [ VAR_432 ] . VAR_433 ) ; if ( VAR_434 ) METHOD_62 ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , VAR_435 , VAR_436 -> VAR_437 , VAR_438 ? ""yes"" : ""no"" , VAR_439 ? ""yes"" : ""no"" ) ; break ; } if ( VAR_440 == VAR_441 && VAR_442 ) METHOD_63 ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , VAR_443 -> VAR_444 ) ; break ; } METHOD_64 ( VAR_445 ) ; } else if ( ! METHOD_65 ( VAR_446 . VAR_447 , ""data"" , 4 ) ) { TYPE_41 VAR_448 ; <S2SV_StartBug> if ( ! METHOD_66 ( VAR_449 , & VAR_450 , sizeof ( VAR_451 ) , & VAR_452 ) || <S2SV_EndBug> VAR_453 != sizeof ( VAR_454 ) ) { METHOD_67 ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , VAR_455 ) ; return VAR_456 ; } else if ( ! ( VAR_457 -> VAR_458 & VAR_459 ) && ! METHOD_68 ( VAR_460 , & VAR_461 , sizeof ( VAR_462 ) ) ) { METHOD_69 ( ""%s"" , METHOD_70 ( VAR_463 ) ) ; return VAR_464 ; } if ( ( VAR_465 -> VAR_466 & VAR_467 ) || VAR_468 . VAR_469 == - 1 ) { VAR_470 -> VAR_471 |= VAR_472 ; if ( VAR_473 && METHOD_71 ( VAR_474 ) != - 1 ) VAR_475 = ( VAR_476 - METHOD_72 ( VAR_477 ) ) / VAR_478 . VAR_479 ; else VAR_480 = - 1 ; } else { if ( VAR_481 && VAR_482 - VAR_483 . VAR_484 > 16777216 ) { METHOD_73 ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , VAR_485 ) ; return VAR_486 ; } if ( ( VAR_487 . VAR_488 - 4 ) % VAR_489 . VAR_490 ) { METHOD_74 ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , VAR_491 ) ; return VAR_492 ; } VAR_493 = ( VAR_494 . VAR_495 - 4 ) / VAR_496 . VAR_497 ; if ( ! VAR_498 ) { METHOD_75 ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return VAR_499 ; } if ( VAR_500 > VAR_501 ) { METHOD_76 ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , VAR_502 ) ; return VAR_503 ; } } break ; } else { TYPE_42 VAR_504 = ( TYPE_43 ) VAR_505 . VAR_506 ; TYPE_44 * VAR_507 ; if ( VAR_508 . VAR_509 < 0 || VAR_510 . VAR_511 > 1048576 ) { METHOD_77 ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , VAR_512 ) ; return VAR_513 ; } VAR_514 = METHOD_78 ( VAR_515 ) ; if ( VAR_516 ) METHOD_79 ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , VAR_517 . VAR_518 [ 0 ] , VAR_519 . VAR_520 [ 1 ] , VAR_521 . VAR_522 [ 2 ] , VAR_523 . VAR_524 [ 3 ] , VAR_525 . VAR_526 ) ; if ( ! METHOD_80 ( VAR_527 , VAR_528 , VAR_529 , & VAR_530 ) || VAR_531 != VAR_532 || ( ! ( VAR_533 -> VAR_534 & VAR_535 ) && ! METHOD_81 ( VAR_536 , VAR_537 , VAR_538 ) ) ) { METHOD_82 ( ""%s"" , METHOD_83 ( VAR_539 ) ) ; METHOD_84 ( VAR_540 ) ; return VAR_541 ; } METHOD_85 ( VAR_542 ) ; } } if ( ! VAR_543 && ! VAR_544 -> VAR_545 && VAR_546 -> VAR_547 <= 2 && ! ( VAR_548 -> VAR_549 & VAR_550 ) ) VAR_551 -> VAR_552 = 0x5 - VAR_553 -> VAR_554 ; if ( ! METHOD_86 ( VAR_555 , VAR_556 , VAR_557 , VAR_558 ) ) { METHOD_87 ( ""%s"" , METHOD_88 ( VAR_559 ) ) ; return VAR_560 ; } if ( VAR_561 ) METHOD_89 ( VAR_562 ) ; if ( VAR_563 || VAR_564 ) { if ( ! METHOD_90 ( VAR_565 , VAR_566 , VAR_567 ) ) { METHOD_91 ( ""problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)"" ) ; return VAR_568 ; } if ( VAR_569 ) METHOD_92 ( VAR_570 ) ; } return VAR_571 ; }","<S2SV_ModStart> { TYPE_43 VAR_543 = 0 , VAR_574 <S2SV_ModStart> , VAR_84 ) ; VAR_574 = 1 <S2SV_ModStart> if ( ! VAR_574 || !","CWE-908 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( ""%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!"" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , ""desc"" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( ""format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g"" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( ""packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames"" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( ""channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d"" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , ""lpcm"" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point"" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""chan"" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( ""this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( ""channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( ""%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!"" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( ""chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d"" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( ""warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d"" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = ""12345678"" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\""%s\\""\\n"" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( ""problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)"" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }","<S2SV_ModStart> { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> if ( ! desc_chunk || !"
262,"CWE-285 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 ) { TYPE_2 VAR_3 ; TYPE_3 * VAR_4 = VAR_5 ; TYPE_4 VAR_6 = 0 ; TYPE_5 VAR_7 ; switch ( VAR_8 ) { case VAR_9 : VAR_10 = VAR_11 ; if ( VAR_12 ) { <S2SV_StartBug> VAR_13 = METHOD_1 ( VAR_14 , & STRUCT_OR_UNION_4 -> VAR_15 ) ; <S2SV_EndBug> if ( VAR_16 < 0 ) return VAR_17 ; <S2SV_StartBug> METHOD_2 ( STRUCT_OR_UNION_5 , STRUCT_OR_UNION_6 -> VAR_18 ) ; <S2SV_EndBug> if ( VAR_19 == 0 ) VAR_20 = VAR_21 ; } break ; case VAR_22 : VAR_23 = VAR_24 ; if ( ! METHOD_3 ( STRUCT_OR_UNION_7 -> VAR_25 ) ) return VAR_26 ? - VAR_27 : 0 ; break ; default : return - VAR_28 ; } if ( VAR_29 ) { VAR_30 = METHOD_4 ( VAR_31 , & VAR_32 ) ; if ( METHOD_5 ( VAR_33 ) ) { METHOD_6 ( STRUCT_OR_UNION_8 , VAR_34 ) ; return ( TYPE_6 ) METHOD_7 ( VAR_35 ) ; } } VAR_36 = METHOD_8 ( STRUCT_OR_UNION_9 , VAR_37 , """" , VAR_38 , VAR_39 , VAR_40 , 0 ) ; METHOD_9 ( VAR_41 ) ; if ( ! VAR_42 ) METHOD_10 ( STRUCT_OR_UNION_10 , VAR_43 , VAR_44 ) ; METHOD_11 ( STRUCT_OR_UNION_11 , VAR_45 ) ; return VAR_46 ; }","<S2SV_ModStart> { VAR_46 = METHOD_12 ( STRUCT_OR_UNION_11 <S2SV_ModEnd> , & STRUCT_OR_UNION_11 <S2SV_ModStart> STRUCT_OR_UNION_11 -> VAR_25 , & VAR_44 ) ; if ( VAR_46 <S2SV_ModEnd> ) return VAR_46 <S2SV_ModStart> -> VAR_25 ) <S2SV_ModEnd> ; } break","CWE-285 static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , """" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> ; } break"
263,"CWE-254 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; TYPE_7 * VAR_6 = ( TYPE_8 * ) ( VAR_7 + VAR_8 + VAR_9 ) ; switch ( VAR_10 -> VAR_11 ) { case VAR_12 : { TYPE_9 * VAR_13 ; VAR_14 = ( TYPE_10 * ) METHOD_1 ( sizeof ( TYPE_11 ) ) ; METHOD_2 ( VAR_15 -> VAR_16 , VAR_17 , 4 ) ; VAR_18 += 4 ; METHOD_3 ( VAR_19 -> VAR_20 , VAR_21 , 16 ) ; VAR_22 += 16 ; METHOD_4 ( VAR_23 -> VAR_24 , VAR_25 , 32 ) ; VAR_26 += 32 ; METHOD_5 ( VAR_27 -> VAR_28 , VAR_29 , 12 ) ; VAR_30 += 12 ; VAR_31 -> VAR_32 = ( ( * VAR_33 ) >> 6 ) & 0x01 ; VAR_34 -> VAR_35 = ( ( * VAR_36 ) >> 5 ) & 0x01 ; VAR_37 -> VAR_38 = ( ( * VAR_39 ) >> 4 ) & 0x01 ; VAR_40 += 1 ; VAR_41 -> VAR_42 = METHOD_6 ( ( * VAR_43 ) & 0x0F , 7 ) ; VAR_44 += 1 ; VAR_45 -> VAR_46 = METHOD_7 ( ( ( * VAR_47 ) >> 4 ) & 0x0F , 7 ) ; VAR_48 -> VAR_49 = METHOD_8 ( ( * VAR_50 ) & 0x0F , 7 ) ; VAR_51 += 1 ; VAR_52 -> VAR_53 = METHOD_9 ( ( ( * VAR_54 ) >> 4 ) & 0x0F , 7 ) ; VAR_55 -> VAR_56 = METHOD_10 ( ( * VAR_57 ) & 0x0F , 7 ) ; VAR_58 += 1 ; if ( VAR_59 -> VAR_60 != VAR_61 + 4 * ( ( TYPE_12 ) ( VAR_62 -> VAR_63 ) + ( TYPE_13 ) ( VAR_64 -> VAR_65 ) + ( TYPE_14 ) ( VAR_66 -> VAR_67 ) + ( TYPE_15 ) ( VAR_68 -> VAR_69 ) + ( TYPE_16 ) ( VAR_70 -> VAR_71 ) ) ) { METHOD_11 ( VAR_72 ) ; return VAR_73 ; } for ( VAR_74 = 0 ; VAR_75 < VAR_76 -> VAR_77 ; VAR_78 ++ ) { VAR_79 -> VAR_80 [ VAR_81 ] = METHOD_12 ( VAR_82 , VAR_83 ) ; VAR_84 += 4 ; } for ( VAR_85 = 0 ; VAR_86 < VAR_87 -> VAR_88 ; VAR_89 ++ ) { VAR_90 -> VAR_91 [ VAR_92 ] = METHOD_13 ( VAR_93 , VAR_94 ) ; VAR_95 += 4 ; } for ( VAR_96 = 0 ; VAR_97 < VAR_98 -> VAR_99 ; VAR_100 ++ ) { VAR_101 -> VAR_102 [ VAR_103 ] = METHOD_14 ( VAR_104 , VAR_105 ) ; VAR_106 += 4 ; } for ( VAR_107 = 0 ; VAR_108 < VAR_109 -> VAR_110 ; VAR_111 ++ ) { VAR_112 -> VAR_113 [ VAR_114 ] = METHOD_15 ( VAR_115 , VAR_116 ) ; VAR_117 += 4 ; } for ( VAR_118 = 0 ; VAR_119 < VAR_120 -> VAR_121 ; VAR_122 ++ ) { VAR_123 -> VAR_124 [ VAR_125 ] = METHOD_16 ( VAR_126 , VAR_127 ) ; VAR_128 += 4 ; } METHOD_17 ( VAR_129 , VAR_130 -> VAR_131 , & VAR_132 -> VAR_133 ) ; METHOD_18 ( VAR_134 , VAR_135 -> VAR_136 , & VAR_137 -> VAR_138 ) ; METHOD_19 ( VAR_139 , VAR_140 -> VAR_141 , & VAR_142 -> VAR_143 ) ; METHOD_20 ( VAR_144 , VAR_145 -> VAR_146 , & VAR_147 -> VAR_148 ) ; METHOD_21 ( VAR_149 , VAR_150 -> VAR_151 , & VAR_152 -> VAR_153 ) ; METHOD_22 ( VAR_154 -> VAR_155 , VAR_156 , 8 ) ; VAR_157 -> VAR_158 = ( TYPE_17 * ) VAR_159 ; VAR_160 -> VAR_161 = ( TYPE_18 * ) METHOD_23 ( VAR_162 * sizeof ( TYPE_19 ) ) ; METHOD_24 ( VAR_163 -> VAR_164 , VAR_165 , VAR_166 ) ; } break ; case VAR_167 : { if ( VAR_168 -> VAR_169 != VAR_170 ) { return VAR_171 ; } } break ; case VAR_172 : { TYPE_20 VAR_173 [ 32 ] ; TYPE_21 VAR_174 [ 32 ] ; TYPE_22 * VAR_175 ; TYPE_23 VAR_176 = 0 ; TYPE_24 * VAR_177 ; VAR_178 = ( TYPE_25 * ) METHOD_25 ( sizeof ( TYPE_26 ) ) ; METHOD_26 ( VAR_179 -> VAR_180 , VAR_181 , 32 ) ; VAR_182 += 32 ; if ( VAR_183 -> VAR_184 [ VAR_185 ] == VAR_186 ) { METHOD_27 ( VAR_187 ) ; return VAR_188 ; } VAR_189 = ( TYPE_27 * ) VAR_190 -> VAR_191 [ VAR_192 ] -> VAR_193 ; METHOD_28 ( VAR_194 -> VAR_195 , 32 , 32 , VAR_196 ) ; if ( METHOD_29 ( VAR_197 , VAR_198 -> VAR_199 , 32 ) != 0 ) { METHOD_30 ( VAR_200 ) ; return VAR_201 ; } METHOD_31 ( VAR_202 -> VAR_203 , 32 , VAR_204 -> VAR_205 [ VAR_206 ] -> VAR_207 + VAR_208 , VAR_209 -> VAR_210 [ VAR_211 ] -> VAR_212 - 8 , 8 , VAR_213 ) ; if ( METHOD_32 ( VAR_214 , VAR_215 -> VAR_216 , 8 ) != 0 ) { METHOD_33 ( VAR_217 ) ; return VAR_218 ; } METHOD_34 ( VAR_219 -> VAR_220 , VAR_221 , 12 ) ; VAR_222 += 12 ; VAR_223 -> VAR_224 = METHOD_35 ( VAR_225 , VAR_226 ) ; VAR_227 += 4 ; VAR_228 -> VAR_229 = METHOD_36 ( VAR_230 , VAR_231 ) ; VAR_232 += 4 ; VAR_233 -> VAR_234 = METHOD_37 ( VAR_235 , VAR_236 ) ; VAR_237 += 4 ; VAR_238 -> VAR_239 = METHOD_38 ( VAR_240 , VAR_241 ) ; VAR_242 += 4 ; switch ( VAR_243 -> VAR_244 ) { case VAR_245 : case VAR_246 : case VAR_247 : case VAR_248 : case VAR_249 : VAR_250 = 32 ; break ; case VAR_251 : VAR_252 = 24 ; break ; case VAR_253 : VAR_254 = 16 ; break ; default : METHOD_39 ( VAR_255 ) ; return VAR_256 ; } if ( VAR_257 -> VAR_258 != VAR_259 + VAR_260 ) { METHOD_40 ( VAR_261 ) ; return VAR_262 ; } VAR_263 -> VAR_264 = METHOD_41 ( VAR_265 , VAR_266 ) ; VAR_267 += 4 ; if ( ( VAR_268 -> VAR_269 == VAR_270 ) || ( VAR_271 -> VAR_272 == VAR_273 ) ) { METHOD_42 ( VAR_274 -> VAR_275 , VAR_276 , 16 ) ; VAR_277 += 16 ; if ( VAR_278 -> VAR_279 == VAR_280 ) { METHOD_43 ( VAR_281 -> VAR_282 , VAR_283 , 8 ) ; VAR_284 += 8 ; } } else { METHOD_44 ( VAR_285 -> VAR_286 , VAR_287 , 32 ) ; VAR_288 += 32 ; } METHOD_45 ( VAR_289 -> VAR_290 , VAR_291 , 8 ) ; VAR_292 -> VAR_293 = ( TYPE_28 * ) VAR_294 ; VAR_295 -> VAR_296 = ( TYPE_29 * ) METHOD_46 ( VAR_297 * sizeof ( TYPE_30 ) ) ; METHOD_47 ( VAR_298 -> VAR_299 , VAR_300 , VAR_301 ) ; } break ; case VAR_302 : case VAR_303 : { TYPE_31 * VAR_304 ; TYPE_32 VAR_305 = METHOD_48 ( VAR_306 -> VAR_307 ) ; if ( VAR_308 == 0 ) { return VAR_309 ; } if ( VAR_310 -> VAR_311 != VAR_312 + VAR_313 ) { return VAR_314 ; } VAR_315 = ( TYPE_33 * ) METHOD_49 ( sizeof ( TYPE_34 ) ) ; VAR_316 -> VAR_317 = ( TYPE_35 * ) METHOD_50 ( VAR_318 * sizeof ( TYPE_36 ) ) ; METHOD_51 ( VAR_319 -> VAR_320 , VAR_321 , 32 ) ; VAR_322 += 32 ; if ( VAR_323 -> VAR_324 == VAR_325 ) { TYPE_37 VAR_326 [ 32 ] ; TYPE_38 VAR_327 [ 32 ] ; TYPE_39 * VAR_328 ; if ( VAR_329 -> VAR_330 [ VAR_331 ] == VAR_332 ) { METHOD_52 ( VAR_333 ) ; return VAR_334 ; } VAR_335 = ( TYPE_40 * ) VAR_336 -> VAR_337 [ VAR_338 ] -> VAR_339 ; METHOD_53 ( VAR_340 -> VAR_341 , 32 , 32 , VAR_342 ) ; if ( METHOD_54 ( VAR_343 , VAR_344 -> VAR_345 , 32 ) != 0 ) { METHOD_55 ( VAR_346 ) ; return VAR_347 ; } METHOD_56 ( VAR_348 -> VAR_349 , 32 , VAR_350 -> VAR_351 [ VAR_352 ] -> VAR_353 + VAR_354 , VAR_355 -> VAR_356 [ VAR_357 ] -> VAR_358 - 8 , 8 , VAR_359 ) ; if ( METHOD_57 ( VAR_360 , VAR_361 -> VAR_362 , 8 ) != 0 ) { METHOD_58 ( VAR_363 ) ; return VAR_364 ; } <S2SV_StartBug> } else { <S2SV_EndBug> TYPE_41 VAR_365 [ 32 ] ; TYPE_42 VAR_366 [ 32 ] ; TYPE_43 VAR_367 [ 32 ] ; TYPE_44 * VAR_368 ; if ( VAR_369 -> VAR_370 [ VAR_371 ] == VAR_372 ) { METHOD_59 ( VAR_373 ) ; return VAR_374 ; } VAR_375 = ( TYPE_45 * ) VAR_376 -> VAR_377 [ VAR_378 ] -> VAR_379 ; METHOD_60 ( VAR_380 -> VAR_381 , 32 , 32 , VAR_382 ) ; METHOD_61 ( VAR_383 , 32 , 32 , VAR_384 ) ; if ( METHOD_62 ( VAR_385 , VAR_386 -> VAR_387 , 32 ) != 0 ) { METHOD_63 ( VAR_388 ) ; return VAR_389 ; } METHOD_64 ( VAR_390 , 32 , VAR_391 -> VAR_392 [ VAR_393 ] -> VAR_394 + VAR_395 , VAR_396 -> VAR_397 [ VAR_398 ] -> VAR_399 - 8 , 8 , VAR_400 ) ; if ( METHOD_65 ( VAR_401 , VAR_402 -> VAR_403 , 8 ) != 0 ) { METHOD_66 ( VAR_404 ) ; return VAR_405 ; } } METHOD_67 ( VAR_406 -> VAR_407 , VAR_408 , 8 ) ; VAR_409 += 8 ; METHOD_68 ( VAR_410 -> VAR_411 , VAR_412 , 8 ) ; VAR_413 += 8 ; METHOD_69 ( VAR_414 -> VAR_415 , VAR_416 , 8 ) ; VAR_417 += 8 ; METHOD_70 ( VAR_418 -> VAR_419 , VAR_420 , 8 ) ; VAR_421 += 8 ; METHOD_71 ( VAR_422 -> VAR_423 , VAR_424 , VAR_425 ) ; VAR_426 += VAR_427 ; METHOD_72 ( VAR_428 -> VAR_429 , VAR_430 , 8 ) ; VAR_431 -> VAR_432 = ( TYPE_46 * ) VAR_433 ; VAR_434 -> VAR_435 = ( TYPE_47 * ) METHOD_73 ( VAR_436 * sizeof ( TYPE_48 ) ) ; METHOD_74 ( VAR_437 -> VAR_438 , VAR_439 , VAR_440 ) ; } break ; case VAR_441 : case VAR_442 : { TYPE_49 * VAR_443 = VAR_444 ; TYPE_50 * VAR_445 = VAR_446 ; TYPE_51 * VAR_447 ; TYPE_52 VAR_448 ; TYPE_53 VAR_449 [ 8 ] ; TYPE_54 * VAR_450 ; TYPE_55 * VAR_451 ; if ( VAR_452 -> VAR_453 == VAR_454 ) { if ( ( VAR_455 -> VAR_456 == VAR_457 ) || ( VAR_458 -> VAR_459 == VAR_460 ) ) { return VAR_461 ; } VAR_462 = VAR_463 -> VAR_464 ; VAR_465 = VAR_466 -> VAR_467 ; } if ( VAR_468 -> VAR_469 == VAR_470 ) { if ( ( VAR_471 -> VAR_472 == VAR_473 ) || ( VAR_474 -> VAR_475 == VAR_476 ) ) { return VAR_477 ; } VAR_478 = VAR_479 -> VAR_480 ; VAR_481 = VAR_482 -> VAR_483 ; } VAR_484 = ( TYPE_56 * ) METHOD_75 ( sizeof ( TYPE_57 ) ) ; METHOD_76 ( VAR_485 -> VAR_486 , VAR_487 , 8 ) ; VAR_488 += 8 ; METHOD_77 ( VAR_489 -> VAR_490 , VAR_491 , 16 ) ; VAR_492 += 16 ; VAR_493 = VAR_494 -> VAR_495 - VAR_496 - 24 ; VAR_497 -> METHOD_78 ( VAR_498 , VAR_499 -> VAR_500 , VAR_501 , VAR_502 , 8 , VAR_503 ) ; if ( METHOD_79 ( VAR_504 , VAR_505 -> VAR_506 , 8 ) != 0 ) { METHOD_80 ( VAR_507 ) ; return VAR_508 ; } VAR_509 = ( TYPE_58 * ) METHOD_81 ( VAR_510 * sizeof ( TYPE_59 ) ) ; VAR_511 -> METHOD_82 ( VAR_512 , VAR_513 -> VAR_514 , VAR_515 , VAR_516 , VAR_517 ) ; VAR_518 = VAR_519 ; METHOD_83 ( VAR_520 -> VAR_521 , VAR_522 , 32 ) ; VAR_523 += 33 ; if ( VAR_524 -> VAR_525 == VAR_526 || VAR_527 -> VAR_528 == VAR_529 ) { TYPE_60 VAR_530 [ 32 ] ; METHOD_84 ( VAR_531 -> VAR_532 , 32 , 32 , VAR_533 ) ; if ( VAR_534 -> VAR_535 == VAR_536 ) { TYPE_61 VAR_537 [ 32 ] ; TYPE_62 VAR_538 [ 32 ] ; TYPE_63 * VAR_539 ; if ( VAR_540 -> VAR_541 [ VAR_542 ] == VAR_543 ) { METHOD_85 ( VAR_544 ) ; return VAR_545 ; } VAR_546 = ( TYPE_64 * ) VAR_547 -> VAR_548 [ VAR_549 ] -> VAR_550 ; METHOD_86 ( VAR_551 , 32 , 32 , VAR_552 ) ; if ( METHOD_87 ( VAR_553 , VAR_554 -> VAR_555 , 32 ) != 0 ) { METHOD_88 ( VAR_556 ) ; return VAR_557 ; } METHOD_89 ( VAR_558 , 32 , VAR_559 -> VAR_560 [ VAR_561 ] -> VAR_562 + VAR_563 , VAR_564 -> VAR_565 [ VAR_566 ] -> VAR_567 - 8 , 8 , VAR_568 ) ; if ( METHOD_90 ( VAR_569 , VAR_570 -> VAR_571 , 8 ) != 0 ) { METHOD_91 ( VAR_572 ) ; return VAR_573 ; } } else { TYPE_65 VAR_574 [ 32 ] ; TYPE_66 VAR_575 [ 32 ] ; TYPE_67 VAR_576 [ 32 ] ; TYPE_68 * VAR_577 ; if ( VAR_578 -> VAR_579 [ VAR_580 ] == VAR_581 ) { METHOD_92 ( VAR_582 ) ; return VAR_583 ; } VAR_584 = ( TYPE_69 * ) VAR_585 -> VAR_586 [ VAR_587 ] -> VAR_588 ; METHOD_93 ( VAR_589 , 32 , 32 , VAR_590 ) ; METHOD_94 ( VAR_591 , 32 , 32 , VAR_592 ) ; if ( METHOD_95 ( VAR_593 , VAR_594 -> VAR_595 , 32 ) != 0 ) { METHOD_96 ( VAR_596 ) ; return VAR_597 ; } METHOD_97 ( VAR_598 , 32 , VAR_599 -> VAR_600 [ VAR_601 ] -> VAR_602 + VAR_603 , VAR_604 -> VAR_605 [ VAR_606 ] -> VAR_607 - 8 , 8 , VAR_608 ) ; if ( METHOD_98 ( VAR_609 , VAR_610 -> VAR_611 , 8 ) != 0 ) { METHOD_99 ( VAR_612 ) ; return VAR_613 ; } } } else { TYPE_70 VAR_614 [ 32 ] ; TYPE_71 VAR_615 [ 32 ] ; TYPE_72 * VAR_616 ; if ( VAR_617 -> VAR_618 [ VAR_619 ] == VAR_620 ) { METHOD_100 ( VAR_621 ) ; return VAR_622 ; } VAR_623 = ( TYPE_73 * ) VAR_624 -> VAR_625 [ VAR_626 ] -> VAR_627 ; METHOD_101 ( VAR_628 -> VAR_629 , 32 , 32 , VAR_630 ) ; if ( METHOD_102 ( VAR_631 , VAR_632 -> VAR_633 , 32 ) != 0 ) { METHOD_103 ( VAR_634 ) ; return VAR_635 ; } METHOD_104 ( VAR_636 -> VAR_637 , 32 , VAR_638 -> VAR_639 [ VAR_640 ] -> VAR_641 + VAR_642 , VAR_643 -> VAR_644 [ VAR_645 ] -> VAR_646 - 8 , 8 , VAR_647 ) ; if ( METHOD_105 ( VAR_648 , VAR_649 -> VAR_650 , 8 ) != 0 ) { METHOD_106 ( VAR_651 ) ; return VAR_652 ; } } VAR_653 -> VAR_654 = ( ( TYPE_74 ) ( VAR_655 [ 0 ] & 0x01 ) ) << 8 | ( ( ( TYPE_75 ) VAR_656 [ 1 ] ) & 0x00FF ) ; VAR_657 += 2 ; VAR_658 -> VAR_659 = ( ( * VAR_660 ) & 0x08 ) >> 3 ; VAR_661 -> VAR_662 = ( ( * VAR_663 ) & 0x04 ) >> 2 ; VAR_664 -> VAR_665 = ( ( * VAR_666 ) & 0x02 ) >> 1 ; VAR_667 -> VAR_668 = ( * VAR_669 ) & 0x01 ; VAR_670 += 1 ; VAR_671 -> VAR_672 = ( ( ( TYPE_76 ) VAR_673 [ 0 ] ) << 24 ) | ( ( ( TYPE_77 ) VAR_674 [ 1 ] ) << 16 ) | ( ( ( TYPE_78 ) VAR_675 [ 2 ] ) << 8 ) | ( ( TYPE_79 ) VAR_676 [ 3 ] ) ; VAR_677 += 4 ; if ( VAR_678 -> VAR_679 > 0 ) { METHOD_107 ( VAR_680 -> VAR_681 , VAR_682 , 4 ) ; VAR_683 += 4 ; VAR_684 -> VAR_685 = ( TYPE_80 * ) METHOD_108 ( 4 * ( VAR_686 -> VAR_687 - 1 ) * sizeof ( TYPE_81 ) ) ; METHOD_109 ( VAR_688 -> VAR_689 , VAR_690 , 4 * ( VAR_691 -> VAR_692 - 1 ) ) ; } else { VAR_693 -> VAR_694 = VAR_695 ; } METHOD_110 ( VAR_696 ) ; VAR_697 -> VAR_698 = ( TYPE_82 * ) METHOD_111 ( VAR_699 * sizeof ( TYPE_83 ) ) ; METHOD_112 ( VAR_700 -> VAR_701 , VAR_702 , VAR_703 ) ; VAR_704 -> VAR_705 = ( TYPE_84 * ) VAR_706 ; } break ; case VAR_707 : break ; case VAR_708 : { TYPE_85 * VAR_709 ; VAR_710 = ( TYPE_86 * ) METHOD_113 ( sizeof ( TYPE_87 ) ) ; METHOD_114 ( VAR_711 -> VAR_712 , VAR_713 , 4 ) ; VAR_714 += 4 ; METHOD_115 ( VAR_715 -> VAR_716 , VAR_717 , 8 ) ; VAR_718 -> VAR_719 = ( TYPE_88 * ) VAR_720 ; } break ; } return 0 ; }","<S2SV_ModStart> VAR_652 ; } { TYPE_83 VAR_721 [ 32 ] ; TYPE_75 VAR_722 = VAR_643 -> VAR_723 [ VAR_606 ] -> VAR_646 ; TYPE_75 VAR_724 = VAR_718 -> VAR_646 + VAR_722 ; TYPE_83 * VAR_725 = ( TYPE_83 * ) METHOD_113 ( VAR_724 * sizeof ( TYPE_83 ) ) ; METHOD_115 ( VAR_725 , VAR_702 + VAR_642 , VAR_718 -> VAR_646 ) ; METHOD_115 ( VAR_725 + VAR_718 -> VAR_646 , VAR_643 -> VAR_723 [ VAR_606 ] -> VAR_701 + VAR_642 , VAR_722 ) ; VAR_643 -> METHOD_116 ( VAR_725 , VAR_724 , 32 , VAR_721 ) ; METHOD_110 ( VAR_725 ) ; if ( METHOD_105 ( VAR_721 , VAR_570 -> VAR_286 , 32 ) != 0 ) { METHOD_110 ( VAR_720 ) ; return VAR_726 ; } }","CWE-254 int bzrtp_packetParser ( bzrtpContext_t * zrtpContext , bzrtpChannelContext_t * zrtpChannelContext , const uint8_t * input , uint16_t inputLength , bzrtpPacket_t * zrtpPacket ) { int i ; uint8_t * messageContent = ( uint8_t * ) ( input + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH ) ; switch ( zrtpPacket -> messageType ) { case MSGTYPE_HELLO : { bzrtpHelloMessage_t * messageData ; messageData = ( bzrtpHelloMessage_t * ) malloc ( sizeof ( bzrtpHelloMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> clientIdentifier , messageContent , 16 ) ; messageContent += 16 ; memcpy ( messageData -> H3 , messageContent , 32 ) ; messageContent += 32 ; memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> S = ( ( * messageContent ) >> 6 ) & 0x01 ; messageData -> M = ( ( * messageContent ) >> 5 ) & 0x01 ; messageData -> P = ( ( * messageContent ) >> 4 ) & 0x01 ; messageContent += 1 ; messageData -> hc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> cc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> ac = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> kc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> sc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; if ( zrtpPacket -> messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4 * ( ( uint16_t ) ( messageData -> hc ) + ( uint16_t ) ( messageData -> cc ) + ( uint16_t ) ( messageData -> ac ) + ( uint16_t ) ( messageData -> kc ) + ( uint16_t ) ( messageData -> sc ) ) ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } for ( i = 0 ; i < messageData -> hc ; i ++ ) { messageData -> supportedHash [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> cc ; i ++ ) { messageData -> supportedCipher [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> ac ; i ++ ) { messageData -> supportedAuthTag [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> kc ; i ++ ) { messageData -> supportedKeyAgreement [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> sc ; i ++ ) { messageData -> supportedSas [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; } addMandatoryCryptoTypesIfNeeded ( ZRTP_HASH_TYPE , messageData -> supportedHash , & messageData -> hc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_CIPHERBLOCK_TYPE , messageData -> supportedCipher , & messageData -> cc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_AUTHTAG_TYPE , messageData -> supportedAuthTag , & messageData -> ac ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_KEYAGREEMENT_TYPE , messageData -> supportedKeyAgreement , & messageData -> kc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_SAS_TYPE , messageData -> supportedSas , & messageData -> sc ) ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_HELLOACK : { if ( zrtpPacket -> messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } } break ; case MSGTYPE_COMMIT : { uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; uint16_t variableLength = 0 ; bzrtpCommitMessage_t * messageData ; messageData = ( bzrtpCommitMessage_t * ) malloc ( sizeof ( bzrtpCommitMessage_t ) ) ; memcpy ( messageData -> H2 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> hashAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; messageData -> cipherAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; messageData -> authTagAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; messageData -> keyAgreementAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; switch ( messageData -> keyAgreementAlgo ) { case ZRTP_KEYAGREEMENT_DH2k : case ZRTP_KEYAGREEMENT_EC25 : case ZRTP_KEYAGREEMENT_DH3k : case ZRTP_KEYAGREEMENT_EC38 : case ZRTP_KEYAGREEMENT_EC52 : variableLength = 32 ; break ; case ZRTP_KEYAGREEMENT_Prsh : variableLength = 24 ; break ; case ZRTP_KEYAGREEMENT_Mult : variableLength = 16 ; break ; default : free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } if ( zrtpPacket -> messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData -> sasAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; if ( ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) || ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) ) { memcpy ( messageData -> nonce , messageContent , 16 ) ; messageContent += 16 ; if ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) { memcpy ( messageData -> keyID , messageContent , 8 ) ; messageContent += 8 ; } } else { memcpy ( messageData -> hvi , messageContent , 32 ) ; messageContent += 32 ; } memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_DHPART1 : case MSGTYPE_DHPART2 : { bzrtpDHPartMessage_t * messageData ; uint16_t pvLength = computeKeyAgreementPrivateValueLength ( zrtpChannelContext -> keyAgreementAlgo ) ; if ( pvLength == 0 ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } if ( zrtpPacket -> messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData = ( bzrtpDHPartMessage_t * ) malloc ( sizeof ( bzrtpDHPartMessage_t ) ) ; messageData -> pv = ( uint8_t * ) malloc ( pvLength * sizeof ( uint8_t ) ) ; memcpy ( messageData -> H1 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } <S2SV_StartBug> } else { <S2SV_EndBug> uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } memcpy ( messageData -> rs1ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> rs2ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> auxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pbxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pv , messageContent , pvLength ) ; messageContent += pvLength ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_CONFIRM1 : case MSGTYPE_CONFIRM2 : { uint8_t * confirmMessageKey = NULL ; uint8_t * confirmMessageMacKey = NULL ; bzrtpConfirmMessage_t * messageData ; uint16_t cipherTextLength ; uint8_t computedHmac [ 8 ] ; uint8_t * confirmPlainMessageBuffer ; uint8_t * confirmPlainMessage ; if ( zrtpChannelContext -> role == RESPONDER ) { if ( ( zrtpChannelContext -> zrtpkeyi == NULL ) || ( zrtpChannelContext -> mackeyi == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyi ; confirmMessageMacKey = zrtpChannelContext -> mackeyi ; } if ( zrtpChannelContext -> role == INITIATOR ) { if ( ( zrtpChannelContext -> zrtpkeyr == NULL ) || ( zrtpChannelContext -> mackeyr == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyr ; confirmMessageMacKey = zrtpChannelContext -> mackeyr ; } messageData = ( bzrtpConfirmMessage_t * ) malloc ( sizeof ( bzrtpConfirmMessage_t ) ) ; memcpy ( messageData -> confirm_mac , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> CFBIV , messageContent , 16 ) ; messageContent += 16 ; cipherTextLength = zrtpPacket -> messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24 ; zrtpChannelContext -> hmacFunction ( confirmMessageMacKey , zrtpChannelContext -> hashLength , messageContent , cipherTextLength , 8 , computedHmac ) ; if ( memcmp ( computedHmac , messageData -> confirm_mac , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC ; } confirmPlainMessageBuffer = ( uint8_t * ) malloc ( cipherTextLength * sizeof ( uint8_t ) ) ; zrtpChannelContext -> cipherDecryptionFunction ( confirmMessageKey , messageData -> CFBIV , messageContent , cipherTextLength , confirmPlainMessageBuffer ) ; confirmPlainMessage = confirmPlainMessageBuffer ; memcpy ( messageData -> H0 , confirmPlainMessage , 32 ) ; confirmPlainMessage += 33 ; if ( zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) { uint8_t checkH1 [ 32 ] ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } else { uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } } else { uint8_t checkH1 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpDHPartMessage_t * peerDHPartMessageData ; if ( zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerDHPartMessageData = ( bzrtpDHPartMessage_t * ) zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( memcmp ( checkH1 , peerDHPartMessageData -> H1 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H0 , 32 , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerDHPartMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } messageData -> sig_len = ( ( uint16_t ) ( confirmPlainMessage [ 0 ] & 0x01 ) ) << 8 | ( ( ( uint16_t ) confirmPlainMessage [ 1 ] ) & 0x00FF ) ; confirmPlainMessage += 2 ; messageData -> E = ( ( * confirmPlainMessage ) & 0x08 ) >> 3 ; messageData -> V = ( ( * confirmPlainMessage ) & 0x04 ) >> 2 ; messageData -> A = ( ( * confirmPlainMessage ) & 0x02 ) >> 1 ; messageData -> D = ( * confirmPlainMessage ) & 0x01 ; confirmPlainMessage += 1 ; messageData -> cacheExpirationInterval = ( ( ( uint32_t ) confirmPlainMessage [ 0 ] ) << 24 ) | ( ( ( uint32_t ) confirmPlainMessage [ 1 ] ) << 16 ) | ( ( ( uint32_t ) confirmPlainMessage [ 2 ] ) << 8 ) | ( ( uint32_t ) confirmPlainMessage [ 3 ] ) ; confirmPlainMessage += 4 ; if ( messageData -> sig_len > 0 ) { memcpy ( messageData -> signatureBlockType , confirmPlainMessage , 4 ) ; confirmPlainMessage += 4 ; messageData -> signatureBlock = ( uint8_t * ) malloc ( 4 * ( messageData -> sig_len - 1 ) * sizeof ( uint8_t ) ) ; memcpy ( messageData -> signatureBlock , confirmPlainMessage , 4 * ( messageData -> sig_len - 1 ) ) ; } else { messageData -> signatureBlock = NULL ; } free ( confirmPlainMessageBuffer ) ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; case MSGTYPE_CONF2ACK : break ; case MSGTYPE_PING : { bzrtpPingMessage_t * messageData ; messageData = ( bzrtpPingMessage_t * ) malloc ( sizeof ( bzrtpPingMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> endpointHash , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; } return 0 ; }","<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }"
264,"CWE-77 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , TYPE_2 TYPE_3 * VAR_2 ) { struct STRUCT_OR_UNION_1 VAR_3 ; struct STRUCT_OR_UNION_2 VAR_4 ; struct STRUCT_OR_UNION_3 VAR_5 ; struct STRUCT_OR_UNION_4 VAR_6 ; struct STRUCT_OR_UNION_5 * VAR_7 ; struct STRUCT_OR_UNION_6 * VAR_8 ; TYPE_4 VAR_9 ; METHOD_1 ( ""cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p"" , VAR_10 , VAR_11 ) ; switch ( VAR_12 ) { case VAR_13 : if ( ! METHOD_2 ( VAR_14 ) ) return - VAR_15 ; if ( METHOD_3 ( & VAR_16 , VAR_17 , sizeof ( VAR_18 ) ) ) return - VAR_19 ; VAR_20 = METHOD_4 ( VAR_21 . VAR_22 , & VAR_23 ) ; if ( ! VAR_24 ) return VAR_25 ; VAR_26 = METHOD_5 ( VAR_27 . VAR_28 , & VAR_29 ) ; if ( ! VAR_30 ) { METHOD_6 ( VAR_31 ) ; return VAR_32 ; <S2SV_StartBug> } <S2SV_EndBug> VAR_33 = METHOD_7 ( & VAR_34 , VAR_35 , VAR_36 ) ; if ( ! VAR_37 && METHOD_8 ( VAR_38 , & VAR_39 , sizeof ( VAR_40 ) ) ) VAR_41 = - VAR_42 ; METHOD_9 ( VAR_43 ) ; METHOD_10 ( VAR_44 ) ; return VAR_45 ; case VAR_46 : if ( ! METHOD_11 ( VAR_47 ) ) return - VAR_48 ; if ( METHOD_12 ( & VAR_49 , VAR_50 , sizeof ( VAR_51 ) ) ) return - VAR_52 ; return METHOD_13 ( & VAR_53 ) ; case VAR_54 : if ( METHOD_14 ( & VAR_55 , VAR_56 , sizeof ( VAR_57 ) ) ) return - VAR_58 ; if ( VAR_59 . VAR_60 <= 0 ) return - VAR_61 ; VAR_62 = METHOD_15 ( & VAR_63 ) ; if ( ! VAR_64 && METHOD_16 ( VAR_65 , & VAR_66 , sizeof ( VAR_67 ) ) ) return - VAR_68 ; return VAR_69 ; case VAR_70 : if ( METHOD_17 ( & VAR_71 , VAR_72 , sizeof ( VAR_73 ) ) ) return - VAR_74 ; VAR_75 = METHOD_18 ( & VAR_76 ) ; if ( ! VAR_77 && METHOD_19 ( VAR_78 , & VAR_79 , sizeof ( VAR_80 ) ) ) return - VAR_81 ; return VAR_82 ; } return - VAR_83 ; }",<S2SV_ModStart> VAR_82 ; } VAR_40 . VAR_84 [ sizeof ( VAR_40 . VAR_84 ) - 1 ] = 0 ;,"CWE-77 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( ""cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p"" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }",<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
265,"CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , unsigned VAR_0 , unsigned VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 * VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 ; struct STRUCT_OR_UNION_5 VAR_5 ; TYPE_1 VAR_6 , VAR_7 , VAR_8 = 0 ; METHOD_1 ( STRUCT_OR_UNION_6 ) ; METHOD_2 ( VAR_9 ) ; VAR_10 = 0 ; VAR_11 = - VAR_12 ; if ( VAR_13 ) { if ( VAR_14 -> VAR_15 ) return - VAR_16 ; VAR_17 = METHOD_3 ( VAR_18 , & STRUCT_OR_UNION_7 -> VAR_19 , & VAR_20 ) ; } METHOD_4 ( & VAR_21 ) ; if ( ! METHOD_5 ( VAR_22 , & STRUCT_OR_UNION_8 -> VAR_23 ) ) { METHOD_6 ( & STRUCT_OR_UNION_9 -> VAR_24 -> VAR_25 ) ; STRUCT_OR_UNION_10 -> VAR_26 = - VAR_27 ; METHOD_7 ( ) ; METHOD_8 ( VAR_28 , & STRUCT_OR_UNION_11 -> VAR_29 ) ; METHOD_9 ( VAR_30 , & STRUCT_OR_UNION_12 -> VAR_31 ) ; VAR_32 = METHOD_10 ( ) ; STRUCT_OR_UNION_13 -> VAR_33 = VAR_34 . VAR_35 + VAR_36 ; METHOD_11 ( STRUCT_OR_UNION_14 -> VAR_37 + VAR_38 ) ; if ( METHOD_12 ( VAR_39 , & STRUCT_OR_UNION_15 -> VAR_40 ) ) VAR_41 = 1 ; VAR_42 = 0 ; if ( VAR_43 && VAR_44 == 0 ) METHOD_13 ( STRUCT_OR_UNION_16 , & VAR_45 ) ; if ( VAR_46 ) METHOD_14 ( VAR_47 ) ; } METHOD_15 ( & VAR_48 ) ; <S2SV_StartBug> if ( VAR_49 ) <S2SV_EndBug> METHOD_16 ( VAR_50 , & STRUCT_OR_UNION_17 -> VAR_51 , VAR_52 ) ; if ( VAR_53 ) METHOD_17 ( & STRUCT_OR_UNION_18 -> VAR_54 , VAR_55 ) ; return VAR_56 == 0 ? VAR_57 : VAR_58 ; }",<S2SV_ModStart> if ( VAR_50 && VAR_57 == 0,"CWE-000 int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( keyring ) <S2SV_EndBug> __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }",<S2SV_ModStart> if ( keyring && link_ret == 0
266,"CWE-190 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; const TYPE_3 * VAR_2 = METHOD_1 ( VAR_3 , 1 ) ; TYPE_4 VAR_4 ; const TYPE_5 * VAR_5 = METHOD_2 ( VAR_6 , 2 , & VAR_7 ) ; <S2SV_StartBug> TYPE_6 VAR_8 = METHOD_3 ( VAR_9 , 3 , 1 ) - 1 ; <S2SV_EndBug> TYPE_7 VAR_10 = 0 ; METHOD_4 ( & VAR_11 ) ; while ( * VAR_12 ) { TYPE_8 VAR_13 = * VAR_14 ++ ; TYPE_9 VAR_15 = METHOD_5 ( VAR_16 , VAR_17 , & VAR_18 ) ; VAR_19 += METHOD_6 ( VAR_20 , & VAR_21 , VAR_22 , VAR_23 ) ; <S2SV_StartBug> METHOD_7 ( VAR_24 , VAR_25 + VAR_26 <= VAR_27 , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> METHOD_8 ( VAR_28 , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; switch ( VAR_29 ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { TYPE_10 VAR_30 = METHOD_9 ( VAR_31 ) ; TYPE_11 VAR_32 = METHOD_10 ( VAR_33 + VAR_34 , VAR_35 . VAR_36 , VAR_37 , VAR_38 ) ; METHOD_11 ( VAR_39 , VAR_40 ) ; VAR_41 ++ ; break ; } case 'x' : { break ; } case 'f' : { TYPE_12 VAR_42 ; METHOD_12 ( & VAR_43 , VAR_44 + VAR_45 , VAR_46 ) ; METHOD_13 ( ( TYPE_13 * ) & VAR_47 , sizeof ( VAR_48 ) , VAR_49 . VAR_50 ) ; METHOD_14 ( VAR_51 , VAR_52 ) ; VAR_53 ++ ; break ; } case 'd' : { TYPE_14 VAR_54 ; METHOD_15 ( & VAR_55 , VAR_56 + VAR_57 , VAR_58 ) ; METHOD_16 ( ( TYPE_15 * ) & VAR_59 , sizeof ( VAR_60 ) , VAR_61 . VAR_62 ) ; METHOD_17 ( VAR_63 , VAR_64 ) ; VAR_65 ++ ; break ; } case 'c' : { if ( VAR_66 == 0 ) { if ( VAR_67 == 0 || ! METHOD_18 ( VAR_68 , - 1 ) ) METHOD_19 ( VAR_69 , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; VAR_70 = METHOD_20 ( VAR_71 , - 1 ) ; METHOD_21 ( VAR_72 , 1 ) ; VAR_73 -- ; METHOD_22 ( VAR_74 , VAR_75 <= VAR_76 && VAR_77 <= VAR_78 - VAR_79 , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; } METHOD_23 ( VAR_80 , VAR_81 + VAR_82 , VAR_83 ) ; VAR_84 ++ ; break ; } case 's' : { const TYPE_16 * VAR_85 = ( const TYPE_17 * ) METHOD_24 ( VAR_86 + VAR_87 , '\\0' , VAR_88 - VAR_89 ) ; if ( VAR_90 == VAR_91 ) METHOD_25 ( VAR_92 , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; VAR_93 = ( VAR_94 - ( VAR_95 + VAR_96 ) ) + 1 ; METHOD_26 ( VAR_97 , VAR_98 + VAR_99 , VAR_100 - 1 ) ; VAR_101 ++ ; break ; } default : METHOD_27 ( VAR_102 , VAR_103 , & VAR_104 , & VAR_105 ) ; } VAR_106 += VAR_107 ; } METHOD_28 ( VAR_108 , VAR_109 + 1 ) ; return VAR_110 + 1 ; }","<S2SV_ModStart> , 1 ) ; METHOD_22 ( VAR_108 , VAR_109 > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; VAR_109 -- <S2SV_ModEnd> ; TYPE_10 VAR_110 <S2SV_ModStart> ( VAR_108 , <S2SV_ModEnd> VAR_107 <= VAR_88 <S2SV_ModStart> VAR_107 <= VAR_88 && VAR_109 <= VAR_88 - VAR_107 , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short""","CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; <S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }","<S2SV_ModStart> , 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> ; int n <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"""
267,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 ; struct STRUCT_OR_UNION_4 * VAR_4 ; unsigned TYPE_1 VAR_5 ; TYPE_2 VAR_6 ; METHOD_1 ( & VAR_7 -> VAR_8 ) ; VAR_9 = METHOD_2 ( VAR_10 , & VAR_11 -> VAR_12 ) ; if ( VAR_13 == VAR_14 ) { VAR_15 = - VAR_16 ; } else { VAR_17 = METHOD_3 ( VAR_18 , & VAR_19 -> VAR_20 ) ; VAR_21 = & VAR_22 -> VAR_23 [ VAR_24 ] ; if ( ! ( VAR_25 -> VAR_26 & VAR_27 ) || VAR_28 -> METHOD_4 == VAR_29 || ( VAR_30 && VAR_31 -> VAR_32 && VAR_33 -> VAR_34 != VAR_35 ) ) { VAR_36 = - VAR_37 ; } else { METHOD_5 ( & VAR_38 -> VAR_39 , VAR_40 , VAR_41 ) ; VAR_42 = VAR_43 -> METHOD_6 ( VAR_44 , VAR_45 ) ; } if ( VAR_46 > 0 ) { <S2SV_StartBug> METHOD_7 ( & VAR_47 -> VAR_48 ) ; <S2SV_EndBug> METHOD_8 ( VAR_49 , VAR_50 , <S2SV_StartBug> & VAR_51 -> VAR_52 ) ; <S2SV_EndBug> return 0 ; } } METHOD_9 ( & VAR_53 -> VAR_54 ) ; return VAR_55 ; }","<S2SV_ModStart> 0 ) { struct STRUCT_OR_UNION_5 VAR_52 = VAR_51 -> VAR_52 ; <S2SV_ModStart> , VAR_50 , & <S2SV_ModEnd> VAR_52 ) ;","CWE-000 static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) { <S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , <S2SV_StartBug> & control -> id ) ; <S2SV_EndBug> return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }","<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> , SNDRV_CTL_EVENT_MASK_VALUE , & <S2SV_ModEnd> id ) ;"
268,CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; <S2SV_StartBug> VAR_2 = VAR_3 -> VAR_4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! METHOD_1 ( VAR_5 ) ) <S2SV_EndBug> return ; METHOD_2 ( VAR_6 ) ; },"<S2SV_ModStart> TYPE_1 VAR_6 ; unsigned TYPE_2 VAR_7 ; <S2SV_ModStart> ( VAR_6 ) || ! METHOD_3 ( & VAR_3 -> VAR_8 ) ) return ; VAR_7 = VAR_3 -> VAR_9 ; if ( VAR_3 -> VAR_10 && VAR_3 -> VAR_11 == METHOD_4 ( VAR_11 , VAR_7 ) ) { METHOD_5 ( VAR_3 ) ; return ; } VAR_3 -> VAR_10 = 0 <S2SV_ModEnd> ; METHOD_2 (",CWE-400 static void xen_irq_lateeoi_locked ( struct irq_info * info ) { evtchn_port_t evtchn ; <S2SV_StartBug> evtchn = info -> evtchn ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VALID_EVTCHN ( evtchn ) ) <S2SV_EndBug> return ; unmask_evtchn ( evtchn ) ; },"<S2SV_ModStart> evtchn_port_t evtchn ; unsigned int cpu ; <S2SV_ModStart> ( evtchn ) || ! list_empty ( & info -> eoi_list ) ) return ; cpu = info -> eoi_cpu ; if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) { lateeoi_list_add ( info ) ; return ; } info -> eoi_time = 0 <S2SV_ModEnd> ; unmask_evtchn ("
269,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { unsigned TYPE_2 VAR_2 , VAR_3 , VAR_4 , VAR_5 ; unsigned TYPE_3 VAR_6 = 0 ; <S2SV_StartBug> METHOD_1 ( VAR_7 , 1 , 0 , VAR_8 , VAR_9 -> VAR_10 ) ; <S2SV_EndBug> if ( VAR_11 -> VAR_12 != VAR_13 ) { METHOD_2 ( ""\\""%s\\""<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\n"" , VAR_14 -> VAR_15 , ( unsigned TYPE_4 ) VAR_16 -> VAR_17 ) ; VAR_18 = VAR_19 -> VAR_20 ; } VAR_21 = VAR_22 -> VAR_23 [ METHOD_3 ( VAR_24 , VAR_25 ) ] ; VAR_26 = VAR_27 -> VAR_28 [ METHOD_4 ( VAR_29 , VAR_30 ) ] ; VAR_31 = METHOD_5 ( VAR_32 , VAR_33 ) ; VAR_34 = VAR_35 & VAR_36 ; METHOD_6 ( ""addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\n"" , METHOD_7 ( VAR_37 , VAR_38 ) , VAR_39 , VAR_40 , METHOD_8 ( VAR_41 , VAR_42 ) , VAR_43 ) ; if ( ! METHOD_9 ( VAR_44 , ( VAR_45 & ~ 3 ) , 4 ) ) { METHOD_10 ( ""SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\n"" , ( TYPE_5 * ) VAR_46 ) ; VAR_47 = - VAR_48 ; } else { VAR_49 = METHOD_11 ( VAR_50 , & VAR_51 , VAR_52 ) ; } if ( VAR_53 == 0 ) { VAR_54 -> VAR_55 += 4 ; VAR_56 -> VAR_57 [ VAR_58 ] = VAR_59 ; } else if ( VAR_60 == - VAR_61 ) { METHOD_12 ( VAR_62 , VAR_63 ) ; } return 0 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> VAR_62 , VAR_62","CWE-400 static int swp_handler ( struct pt_regs * regs , unsigned int instr ) { unsigned int address , destreg , data , type ; unsigned int res = 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> if ( current -> pid != previous_pid ) { pr_debug ( ""\\""%s\\""<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\n"" , current -> comm , ( unsigned long ) current -> pid ) ; previous_pid = current -> pid ; } address = regs -> uregs [ EXTRACT_REG_NUM ( instr , RN_OFFSET ) ] ; data = regs -> uregs [ EXTRACT_REG_NUM ( instr , RT2_OFFSET ) ] ; destreg = EXTRACT_REG_NUM ( instr , RT_OFFSET ) ; type = instr & TYPE_SWPB ; pr_debug ( ""addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\n"" , EXTRACT_REG_NUM ( instr , RN_OFFSET ) , address , destreg , EXTRACT_REG_NUM ( instr , RT2_OFFSET ) , data ) ; if ( ! access_ok ( VERIFY_WRITE , ( address & ~ 3 ) , 4 ) ) { pr_debug ( ""SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\n"" , ( void * ) address ) ; res = - EFAULT ; } else { res = emulate_swpX ( address , & data , type ) ; } if ( res == 0 ) { regs -> ARM_pc += 4 ; regs -> uregs [ destreg ] = data ; } else if ( res == - EFAULT ) { set_segfault ( regs , address ) ; } return 0 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs"
270,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = VAR_2 -> STRUCT_OR_UNION_4 ; TYPE_1 VAR_3 ; unsigned TYPE_2 VAR_4 ; TYPE_3 VAR_5 ; struct STRUCT_OR_UNION_5 * STRUCT_OR_UNION_6 = VAR_6 -> VAR_7 ; struct STRUCT_OR_UNION_7 * STRUCT_OR_UNION_8 = METHOD_1 ( STRUCT_OR_UNION_9 ) ; struct STRUCT_OR_UNION_10 * VAR_8 = STRUCT_OR_UNION_11 -> VAR_9 ; VAR_10 * VAR_11 ; VAR_12 * VAR_13 ; TYPE_4 VAR_14 = 0 ; METHOD_2 ( STRUCT_OR_UNION_12 -> VAR_15 ) ; <S2SV_StartBug> METHOD_3 ( VAR_16 -> VAR_17 ) ; <S2SV_EndBug> if ( METHOD_4 ( STRUCT_OR_UNION_13 -> VAR_18 , VAR_19 ) && ! METHOD_5 ( STRUCT_OR_UNION_14 ) && ! METHOD_6 ( STRUCT_OR_UNION_15 -> VAR_20 ) ) { do { VAR_21 = METHOD_7 ( VAR_22 , VAR_23 , VAR_24 ) ; } while ( VAR_25 == - VAR_26 && METHOD_8 ( STRUCT_OR_UNION_16 -> VAR_27 , & VAR_28 ) ) ; goto VAR_29 ; } METHOD_9 ( STRUCT_OR_UNION_17 ) ; VAR_30 = METHOD_10 ( STRUCT_OR_UNION_18 ) ; if ( STRUCT_OR_UNION_19 -> VAR_31 != VAR_32 || METHOD_11 ( STRUCT_OR_UNION_20 ) > VAR_33 ) { METHOD_12 ( STRUCT_OR_UNION_21 ) ; VAR_34 = VAR_35 ; goto VAR_36 ; } if ( STRUCT_OR_UNION_22 -> VAR_37 == VAR_38 >> VAR_39 ) VAR_40 = VAR_41 & ~ VAR_42 ; else VAR_43 = VAR_44 ; if ( METHOD_13 ( STRUCT_OR_UNION_23 ) ) { if ( ! METHOD_14 ( VAR_45 , METHOD_15 ( STRUCT_OR_UNION_24 ) , 0 , VAR_46 , VAR_47 , VAR_48 ) ) { METHOD_16 ( STRUCT_OR_UNION_25 ) ; VAR_49 = VAR_50 ; goto VAR_51 ; } } METHOD_17 ( STRUCT_OR_UNION_26 ) ; if ( METHOD_18 ( STRUCT_OR_UNION_27 ) ) VAR_52 = VAR_53 ; else VAR_54 = VAR_55 ; VAR_56 : VAR_57 = METHOD_19 ( STRUCT_OR_UNION_28 , VAR_58 , METHOD_20 ( STRUCT_OR_UNION_29 ) ) ; if ( METHOD_21 ( VAR_59 ) ) { VAR_60 = VAR_61 ; goto VAR_62 ; } VAR_63 = METHOD_22 ( VAR_64 , VAR_65 , VAR_66 ) ; if ( ! VAR_67 && METHOD_23 ( STRUCT_OR_UNION_30 ) ) { if ( METHOD_24 ( VAR_68 , METHOD_25 ( STRUCT_OR_UNION_31 ) , 0 , VAR_69 , VAR_70 , VAR_71 ) ) { METHOD_26 ( STRUCT_OR_UNION_32 ) ; VAR_72 = VAR_73 ; METHOD_27 ( VAR_74 ) ; goto VAR_75 ; } METHOD_28 ( STRUCT_OR_UNION_33 , VAR_76 ) ; } METHOD_29 ( VAR_77 ) ; if ( VAR_78 == - VAR_79 && METHOD_30 ( STRUCT_OR_UNION_34 -> VAR_80 , & VAR_81 ) ) goto VAR_82 ; VAR_83 : VAR_84 = METHOD_31 ( VAR_85 ) ; VAR_86 : <S2SV_StartBug> METHOD_32 ( STRUCT_OR_UNION_35 -> VAR_87 ) ; <S2SV_EndBug> return VAR_88 ; }",<S2SV_ModStart> VAR_64 -> VAR_17 ) ; down_read ( & METHOD_33 ( STRUCT_OR_UNION_35 ) -> VAR_89 <S2SV_ModStart> ; VAR_86 : METHOD_34 ( & METHOD_33 ( STRUCT_OR_UNION_35 ) -> VAR_89 ) ;,"CWE-362 int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; <S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> return ret ; }",<S2SV_ModStart> vma -> vm_file ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> ; out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
271,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { <S2SV_StartBug> TYPE_5 * const VAR_4 [ 4 ] = { VAR_5 -> VAR_6 , VAR_7 -> VAR_8 , VAR_9 -> VAR_10 , <S2SV_EndBug> VAR_11 -> VAR_12 } ; <S2SV_StartBug> const TYPE_6 VAR_13 [ 4 ] = { VAR_14 -> VAR_15 , VAR_16 -> VAR_17 , VAR_18 -> VAR_19 , <S2SV_EndBug> VAR_20 -> VAR_21 } ; TYPE_7 VAR_22 ; VAR_23 -> VAR_24 . VAR_25 = VAR_26 ; for ( VAR_27 = 0 ; VAR_28 < VAR_29 ; VAR_30 ++ ) METHOD_1 ( & VAR_31 -> VAR_32 [ VAR_33 ] . VAR_34 , VAR_35 [ VAR_36 ] , VAR_37 [ VAR_38 ] , VAR_39 , VAR_40 , VAR_41 , VAR_42 -> VAR_43 . VAR_44 [ VAR_45 ] . VAR_46 , VAR_47 -> VAR_48 . VAR_49 [ VAR_50 ] . VAR_51 ) ; }",<S2SV_ModStart> const VAR_35 [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> VAR_34 -> VAR_10 <S2SV_ModEnd> } ; const <S2SV_ModStart> TYPE_7 VAR_37 [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> VAR_34 -> VAR_19 <S2SV_ModEnd> } ; TYPE_7,"CWE-119 void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }",<S2SV_ModStart> const buffers [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int
272,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { <S2SV_StartBug> TYPE_4 * VAR_3 , * VAR_4 ; <S2SV_EndBug> TYPE_5 * VAR_5 ; <S2SV_StartBug> TYPE_6 VAR_6 = - 1 , VAR_7 = - 1 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_7 VAR_8 = 0 ; <S2SV_EndBug> TYPE_8 VAR_9 ; TYPE_9 * VAR_10 ; TYPE_10 VAR_11 ; unsigned TYPE_11 VAR_12 ; TYPE_12 * VAR_13 = ( TYPE_13 * ) VAR_14 -> VAR_15 ; TYPE_14 VAR_16 , VAR_17 ; if ( VAR_18 -> VAR_19 ) { if ( VAR_20 -> VAR_21 > VAR_22 ) { METHOD_1 ( VAR_23 , VAR_24 -> VAR_25 + VAR_26 -> VAR_27 , VAR_28 ) ; VAR_29 = VAR_30 ; VAR_31 -> VAR_32 -= VAR_33 ; VAR_34 -> VAR_35 += VAR_36 ; } else { METHOD_2 ( VAR_37 , VAR_38 -> VAR_39 + VAR_40 -> VAR_41 , VAR_42 -> VAR_43 ) ; VAR_44 = VAR_45 -> VAR_46 ; VAR_47 -> VAR_48 = 0 ; VAR_49 -> VAR_50 = 0 ; } goto VAR_51 ; } VAR_52 = VAR_53 -> VAR_54 ; VAR_55 = ( TYPE_15 * ) VAR_56 -> VAR_57 ; VAR_58 = METHOD_3 ( VAR_59 , VAR_60 , METHOD_4 ( VAR_61 ) + VAR_62 ) ; if ( VAR_63 < 2 ) { if ( - 1 == VAR_64 ) { TYPE_16 VAR_65 = VAR_66 ; METHOD_5 ( ""%s:<S2SV_blank>peek;<S2SV_blank>%m\\n"" , VAR_67 ) ; VAR_68 = VAR_69 ; <S2SV_StartBug> } else if ( 0 == VAR_70 ) { <S2SV_EndBug> VAR_71 = 0 ; } else { VAR_72 = VAR_73 ; } goto VAR_74 ; } VAR_75 = VAR_76 -> VAR_77 & 0x0f ; VAR_78 = VAR_79 -> VAR_80 & 0x7f ; if ( ! ( VAR_81 -> VAR_82 & 0x80 ) ) { METHOD_6 ( ""%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\n"" , VAR_83 , VAR_84 ) ; VAR_85 = VAR_86 ; goto VAR_87 ; } if ( VAR_88 < 126 ) { VAR_89 = 2 ; VAR_90 = VAR_91 -> VAR_92 . VAR_93 ; } else if ( VAR_94 == 126 && 4 <= VAR_95 ) { VAR_96 = METHOD_7 ( VAR_97 -> VAR_98 . VAR_99 . VAR_100 ) ; VAR_101 = 4 ; VAR_102 = VAR_103 -> VAR_104 . VAR_105 . VAR_106 ; } else if ( VAR_107 == 127 && 10 <= VAR_108 ) { VAR_109 = METHOD_8 ( VAR_110 -> VAR_111 . VAR_112 . VAR_113 ) ; VAR_114 = 10 ; VAR_115 = VAR_116 -> VAR_117 . VAR_118 . VAR_119 ; } else { METHOD_9 ( ""%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\n"" , VAR_120 , VAR_121 ) ; VAR_122 = VAR_123 ; goto VAR_124 ; } VAR_125 = VAR_126 + VAR_127 + 4 ; VAR_128 = VAR_129 + VAR_130 + 4 ; if ( - 1 == ( VAR_131 = METHOD_10 ( VAR_132 , VAR_133 , VAR_134 ) ) ) { TYPE_17 VAR_135 = VAR_136 ; METHOD_11 ( ""%s:<S2SV_blank>read;<S2SV_blank>%m"" , VAR_137 ) ; VAR_138 = VAR_139 ; return VAR_140 ; } else if ( VAR_141 < VAR_142 ) { METHOD_12 ( ""%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\n"" , VAR_143 ) ; } else { VAR_144 [ VAR_145 ] = '\\0' ; } VAR_146 = ( TYPE_18 * ) VAR_147 ; for ( VAR_148 = 0 ; VAR_149 < VAR_150 / 4 ; VAR_151 ++ ) { VAR_152 [ VAR_153 ] ^= VAR_154 . VAR_155 ; } for ( VAR_156 *= 4 ; VAR_157 < VAR_158 ; VAR_159 ++ ) { VAR_160 [ VAR_161 ] ^= VAR_162 . VAR_163 [ VAR_164 % 4 ] ; } switch ( VAR_165 ) { case VAR_166 : METHOD_13 ( ""got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\n"" , METHOD_14 ( ( ( TYPE_19 * ) VAR_167 ) [ 0 ] ) ) ; VAR_168 = VAR_169 ; break ; case VAR_170 : if ( - 1 == ( VAR_171 = METHOD_15 ( VAR_172 , ( unsigned TYPE_20 * ) VAR_173 -> VAR_174 , sizeof ( VAR_175 -> VAR_176 ) ) ) ) { METHOD_16 ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\n"" , VAR_177 ) ; break ; } VAR_178 = VAR_179 -> VAR_180 ; case VAR_181 : if ( VAR_182 > VAR_183 ) { METHOD_17 ( VAR_184 -> VAR_185 , VAR_186 + VAR_187 , VAR_188 - VAR_189 ) ; VAR_190 -> VAR_191 = 0 ; VAR_192 -> VAR_193 = VAR_194 - VAR_195 ; VAR_196 = VAR_197 ; } METHOD_18 ( VAR_198 , VAR_199 , VAR_200 ) ; VAR_201 = VAR_202 ; break ; default : METHOD_19 ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , VAR_203 , ( TYPE_21 ) VAR_204 , VAR_205 -> VAR_206 , VAR_207 -> VAR_208 ) ; } VAR_209 : return VAR_210 ; }","<S2SV_ModStart> VAR_197 ) { TYPE_21 VAR_210 <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; TYPE_13 * VAR_192 = ( TYPE_13 * ) VAR_132 -> VAR_192 ; METHOD_13 ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , VAR_203 , VAR_197 , VAR_192 -> VAR_213 , VAR_192 -> VAR_214 , VAR_192 -> VAR_215 , VAR_192 -> VAR_211 , VAR_192 -> VAR_216 , METHOD_21 ( VAR_192 ) , VAR_192 -> VAR_217 , VAR_192 -> VAR_218 , VAR_192 -> VAR_219 ) ; switch ( VAR_192 -> VAR_211 ) { case WS_HYBI_STATE_HEADER_PENDING : VAR_192 -> VAR_211 = hybiReadHeader ( VAR_132 , & VAR_210 ) ; if ( VAR_192 -> VAR_211 == VAR_212 ) { goto VAR_209 ; } if ( VAR_192 -> VAR_211 != WS_HYBI_STATE_HEADER_PENDING ) { VAR_192 -> VAR_211 = hybiReadAndDecode ( VAR_132 , VAR_198 , VAR_197 , & VAR_210 ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : VAR_192 -> VAR_211 = hybiReturnData ( VAR_198 , VAR_197 , VAR_192 , & VAR_210 ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : VAR_192 -> VAR_211 = hybiReadAndDecode ( VAR_132 , VAR_198 , VAR_197 , & VAR_210 ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : VAR_192 -> VAR_211 = hybiReadAndDecode ( VAR_132 , VAR_198 , VAR_197 , & VAR_210 ) ; break ; default : METHOD_19 ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , VAR_192 -> VAR_211 ) ; <S2SV_ModEnd> VAR_210 = - <S2SV_ModStart> - 1 ; VAR_168 = VAR_123 ; VAR_192 -> VAR_211 = VAR_212 ; } VAR_209 : if ( VAR_192 -> VAR_211 == WS_HYBI_STATE_FRAME_COMPLETE ) { METHOD_13 ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , VAR_192 -> VAR_207 . nRead , VAR_192 -> VAR_207 . headerLen , VAR_192 -> VAR_207 . payloadLen ) ; METHOD_20 ( VAR_192 ) <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( VAR_192 -> VAR_211 == VAR_212 ) { METHOD_20 ( VAR_192 ) ; } METHOD_13 ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , VAR_203 , VAR_197 , VAR_192 -> VAR_213 , VAR_192 -> VAR_214 , VAR_192 -> VAR_215 , VAR_192 -> VAR_211 , VAR_192 -> VAR_216 , METHOD_21 ( VAR_192 ) , VAR_192 -> VAR_217 , VAR_192 -> VAR_218 , VAR_192 -> VAR_219 , VAR_210 ) ; return <S2SV_ModEnd> VAR_210 ; }","CWE-787 static int webSocketsDecodeHybi ( rfbClientPtr cl , char * dst , int len ) { <S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> uint32_t * payload32 ; <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> ws_mask_t mask ; ws_header_t * header ; int i ; unsigned char opcode ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; int flength , fhlen ; if ( wsctx -> readbuflen ) { if ( wsctx -> readbuflen > len ) { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , len ) ; result = len ; wsctx -> readbuflen -= len ; wsctx -> readbufstart += len ; } else { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , wsctx -> readbuflen ) ; result = wsctx -> readbuflen ; wsctx -> readbuflen = 0 ; wsctx -> readbufstart = 0 ; } goto spor ; } buf = wsctx -> codeBufDecode ; header = ( ws_header_t * ) wsctx -> codeBufDecode ; ret = ws_peek ( cl , buf , B64LEN ( len ) + WSHLENMAX ) ; if ( ret < 2 ) { if ( - 1 == ret ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>peek;<S2SV_blank>%m\\n"" , __func__ ) ; errno = olderrno ; <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug> result = 0 ; } else { errno = EAGAIN ; } goto spor ; } opcode = header -> b0 & 0x0f ; flength = header -> b1 & 0x7f ; if ( ! ( header -> b1 & 0x80 ) ) { rfbErr ( ""%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\n"" , __func__ , ret ) ; errno = EIO ; goto spor ; } if ( flength < 126 ) { fhlen = 2 ; mask = header -> u . m ; } else if ( flength == 126 && 4 <= ret ) { flength = WS_NTOH16 ( header -> u . s16 . l16 ) ; fhlen = 4 ; mask = header -> u . s16 . m16 ; } else if ( flength == 127 && 10 <= ret ) { flength = WS_NTOH64 ( header -> u . s64 . l64 ) ; fhlen = 10 ; mask = header -> u . s64 . m64 ; } else { rfbErr ( ""%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\n"" , __func__ , ret ) ; errno = EIO ; goto spor ; } total = fhlen + flength + 4 ; payload = buf + fhlen + 4 ; if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%m"" , __func__ ) ; errno = olderrno ; return ret ; } else if ( ret < total ) { rfbLog ( ""%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\n"" , __func__ ) ; } else { buf [ ret ] = '\\0' ; } payload32 = ( uint32_t * ) payload ; for ( i = 0 ; i < flength / 4 ; i ++ ) { payload32 [ i ] ^= mask . u ; } for ( i *= 4 ; i < flength ; i ++ ) { payload [ i ] ^= mask . c [ i % 4 ] ; } switch ( opcode ) { case WS_OPCODE_CLOSE : rfbLog ( ""got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\n"" , WS_NTOH16 ( ( ( uint16_t * ) payload ) [ 0 ] ) ) ; errno = ECONNRESET ; break ; case WS_OPCODE_TEXT_FRAME : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codeBufDecode , sizeof ( wsctx -> codeBufDecode ) ) ) ) { rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\n"" , __func__ ) ; break ; } payload = wsctx -> codeBufDecode ; case WS_OPCODE_BINARY_FRAME : if ( flength > len ) { memcpy ( wsctx -> readbuf , payload + len , flength - len ) ; wsctx -> readbufstart = 0 ; wsctx -> readbuflen = flength - len ; flength = len ; } memcpy ( dst , payload , flength ) ; result = flength ; break ; default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , __func__ , ( int ) opcode , header -> b0 , header -> b1 ) ; } spor : return result ; }","<S2SV_ModStart> len ) { int result <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> result = - <S2SV_ModStart> - 1 ; errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> result ; }"
273,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 VAR_3 ; <S2SV_StartBug> TYPE_5 VAR_4 = VAR_5 -> VAR_6 ; <S2SV_EndBug> VAR_7 = VAR_8 -> VAR_9 ; VAR_10 = ( 1.0 - ( VAR_11 / 20.0 ) ) ; if ( VAR_12 < VAR_13 ) VAR_14 = VAR_15 ; { TYPE_6 VAR_16 ; TYPE_7 VAR_17 ; TYPE_8 VAR_18 ; VAR_19 = METHOD_1 ( VAR_20 -> VAR_21 * VAR_22 ) ; VAR_23 = METHOD_2 ( VAR_24 -> VAR_25 * VAR_26 ) ; VAR_27 = METHOD_3 ( ( VAR_28 * VAR_29 ) + ( VAR_30 * VAR_31 ) ) / 250.0 ; VAR_32 = ( ( VAR_33 > 1.0 ) ? 0.0 : ( 1.0 - VAR_34 ) ) ; if ( VAR_35 < VAR_36 ) VAR_37 = VAR_38 ; } return VAR_39 ; }",<S2SV_ModStart> VAR_24 -> VAR_6 ; ( TYPE_9 ) VAR_0,"CWE-119 static double get_prediction_decay_rate ( VP8_COMP * cpi , FIRSTPASS_STATS * next_frame ) { double prediction_decay_rate ; double motion_decay ; <S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug> prediction_decay_rate = next_frame -> pcnt_inter ; motion_decay = ( 1.0 - ( motion_pct / 20.0 ) ) ; if ( motion_decay < prediction_decay_rate ) prediction_decay_rate = motion_decay ; { double this_mv_rabs ; double this_mv_cabs ; double distance_factor ; this_mv_rabs = fabs ( next_frame -> mvr_abs * motion_pct ) ; this_mv_cabs = fabs ( next_frame -> mvc_abs * motion_pct ) ; distance_factor = sqrt ( ( this_mv_rabs * this_mv_rabs ) + ( this_mv_cabs * this_mv_cabs ) ) / 250.0 ; distance_factor = ( ( distance_factor > 1.0 ) ? 0.0 : ( 1.0 - distance_factor ) ) ; if ( distance_factor < prediction_decay_rate ) prediction_decay_rate = distance_factor ; } return prediction_decay_rate ; }",<S2SV_ModStart> next_frame -> pcnt_motion ; ( void ) cpi
274,"CWE-285 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_2 VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { TYPE_3 VAR_3 ; TYPE_4 * VAR_4 = VAR_5 ; TYPE_5 VAR_6 = 0 ; TYPE_6 VAR_7 ; switch ( VAR_8 ) { case VAR_9 : VAR_10 = VAR_11 ; if ( VAR_12 ) { <S2SV_StartBug> VAR_13 = METHOD_1 ( VAR_14 , & STRUCT_OR_UNION_3 -> VAR_15 ) ; <S2SV_EndBug> if ( VAR_16 < 0 ) return VAR_17 ; else { STRUCT_OR_UNION_4 -> VAR_18 = METHOD_2 ( STRUCT_OR_UNION_5 ) ; METHOD_3 ( VAR_19 , STRUCT_OR_UNION_6 ) ; <S2SV_StartBug> if ( VAR_20 == 0 ) <S2SV_EndBug> VAR_21 = VAR_22 ; } } break ; case VAR_23 : VAR_24 = VAR_25 ; if ( ! METHOD_4 ( STRUCT_OR_UNION_7 -> VAR_26 ) ) return VAR_27 ? - VAR_28 : 0 ; break ; default : return - VAR_29 ; } if ( VAR_30 ) { VAR_31 = METHOD_5 ( VAR_32 , & VAR_33 ) ; if ( METHOD_6 ( VAR_34 ) ) return ( TYPE_7 ) METHOD_7 ( VAR_35 ) ; } VAR_36 = METHOD_8 ( VAR_37 , STRUCT_OR_UNION_8 , VAR_38 , """" , VAR_39 , VAR_40 , 0 ) ; METHOD_9 ( VAR_41 ) ; if ( ! VAR_42 ) METHOD_10 ( STRUCT_OR_UNION_9 , VAR_43 , VAR_44 ) ; return VAR_45 ; }","<S2SV_ModStart> { VAR_45 = METHOD_11 ( STRUCT_OR_UNION_9 <S2SV_ModEnd> , & STRUCT_OR_UNION_9 <S2SV_ModStart> STRUCT_OR_UNION_9 -> VAR_26 , & VAR_44 ) ; if ( VAR_45 ) return VAR_45 ; <S2SV_ModEnd> STRUCT_OR_UNION_9 -> VAR_18 <S2SV_ModStart> STRUCT_OR_UNION_9 ) ; <S2SV_ModEnd> } break ;","CWE-285 static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;"
275,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 TYPE_4 * VAR_3 , TYPE_5 TYPE_6 * VAR_4 ) { struct STRUCT_OR_UNION_1 * VAR_5 = METHOD_1 ( VAR_6 ) ; TYPE_7 VAR_7 ; TYPE_8 VAR_8 ; if ( VAR_9 != VAR_10 ) return - VAR_11 ; if ( METHOD_2 ( VAR_12 ) ) return METHOD_3 ( VAR_13 , VAR_14 , VAR_15 , VAR_16 ) ; if ( METHOD_4 ( VAR_17 , VAR_18 ) ) return - VAR_19 ; if ( VAR_20 < 0 ) return - VAR_21 ; METHOD_5 ( VAR_22 ) ; switch ( VAR_23 ) { case VAR_24 : { unsigned TYPE_9 VAR_25 [ sizeof ( struct STRUCT_OR_UNION_2 ) + 40 ] ; struct STRUCT_OR_UNION_3 * VAR_26 = ( struct STRUCT_OR_UNION_4 * ) VAR_27 ; <S2SV_StartBug> VAR_28 -> VAR_29 = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_30 -> VAR_31 ) <S2SV_EndBug> METHOD_6 ( VAR_32 , VAR_33 -> VAR_34 , sizeof ( struct STRUCT_OR_UNION_5 ) + VAR_35 -> VAR_36 -> VAR_37 ) ; METHOD_7 ( VAR_38 ) ; if ( VAR_39 -> VAR_40 == 0 ) return METHOD_8 ( 0 , VAR_41 ) ; METHOD_9 ( VAR_42 ) ; VAR_43 = min_t ( unsigned TYPE_10 , VAR_44 , VAR_45 -> VAR_46 ) ; if ( METHOD_10 ( VAR_47 , VAR_48 ) ) return - VAR_49 ; if ( METHOD_11 ( VAR_50 , VAR_51 -> VAR_52 , VAR_53 ) ) return - VAR_54 ; return 0 ; } case VAR_55 : VAR_56 = ( VAR_57 -> VAR_58 & VAR_59 ) != 0 ; break ; case VAR_60 : VAR_61 = ( VAR_62 -> VAR_63 & VAR_64 ) != 0 ; break ; case VAR_65 : VAR_66 = ( VAR_67 -> VAR_68 & VAR_69 ) != 0 ; break ; case VAR_70 : VAR_71 = ( VAR_72 -> VAR_73 & VAR_74 ) != 0 ; break ; case VAR_75 : VAR_76 = ( VAR_77 -> VAR_78 & VAR_79 ) != 0 ; break ; case VAR_80 : VAR_81 = ( VAR_82 -> VAR_83 & VAR_84 ) != 0 ; break ; case VAR_85 : VAR_86 = ( VAR_87 -> VAR_88 & VAR_89 ) != 0 ; break ; case VAR_90 : VAR_91 = VAR_92 -> VAR_93 ; break ; case VAR_94 : VAR_95 = ( VAR_96 -> VAR_97 == - 1 ? VAR_98 : VAR_99 -> VAR_100 ) ; break ; case VAR_101 : VAR_102 = VAR_103 -> VAR_104 ; break ; case VAR_105 : VAR_106 = VAR_107 -> VAR_108 ; break ; case VAR_109 : VAR_110 = VAR_111 -> VAR_112 ; break ; case VAR_113 : { struct STRUCT_OR_UNION_6 * VAR_114 ; VAR_115 = 0 ; VAR_116 = METHOD_12 ( VAR_117 ) ; if ( VAR_118 ) { VAR_119 = METHOD_13 ( VAR_120 ) ; METHOD_14 ( VAR_121 ) ; } if ( ! VAR_122 ) { METHOD_15 ( VAR_123 ) ; return - VAR_124 ; } break ; } case VAR_125 : VAR_126 = VAR_127 -> VAR_128 ; break ; case VAR_129 : VAR_130 = VAR_131 -> VAR_132 ; break ; case VAR_133 : VAR_134 = VAR_135 -> VAR_136 ; break ; case VAR_137 : { struct STRUCT_OR_UNION_7 TYPE_11 ; VAR_138 = min_t ( unsigned TYPE_12 , VAR_139 , sizeof ( struct STRUCT_OR_UNION_8 ) ) ; TYPE_13 . VAR_140 = VAR_141 -> VAR_142 ; METHOD_16 ( VAR_143 ) ; if ( METHOD_17 ( VAR_144 , VAR_145 ) ) return - VAR_146 ; if ( METHOD_18 ( VAR_147 , & TYPE_14 , VAR_148 ) ) return - VAR_149 ; return 0 ; } case VAR_150 : { struct STRUCT_OR_UNION_9 VAR_151 ; TYPE_15 VAR_152 ; if ( VAR_153 < METHOD_19 ( 0 ) ) { METHOD_20 ( VAR_154 ) ; return - VAR_155 ; } if ( METHOD_21 ( & VAR_156 , VAR_157 , METHOD_22 ( 0 ) ) ) { METHOD_23 ( VAR_158 ) ; return - VAR_159 ; } VAR_160 = METHOD_24 ( VAR_161 , & VAR_162 , ( struct STRUCT_OR_UNION_10 TYPE_16 * ) VAR_163 , VAR_164 ) ; METHOD_25 ( VAR_165 ) ; return VAR_166 ; } case VAR_167 : { struct STRUCT_OR_UNION_11 VAR_168 ; TYPE_17 VAR_169 ; if ( VAR_170 < METHOD_26 ( 0 ) ) { METHOD_27 ( VAR_171 ) ; return - VAR_172 ; } if ( METHOD_28 ( & VAR_173 , VAR_174 , METHOD_29 ( 0 ) ) ) { METHOD_30 ( VAR_175 ) ; return - VAR_176 ; } VAR_177 = METHOD_31 ( VAR_178 , & VAR_179 , ( struct STRUCT_OR_UNION_12 TYPE_18 * ) VAR_180 , VAR_181 ) ; METHOD_32 ( VAR_182 ) ; return VAR_183 ; } case VAR_184 : VAR_185 = VAR_186 -> VAR_187 ; break ; case VAR_188 : { struct STRUCT_OR_UNION_13 VAR_189 ; METHOD_33 ( VAR_190 ) ; if ( VAR_191 -> VAR_192 != VAR_193 ) return - VAR_194 ; VAR_195 . VAR_196 = VAR_197 ; VAR_198 . VAR_199 = VAR_200 ; VAR_201 . VAR_202 = 0 ; if ( VAR_203 -> VAR_204 & VAR_205 ) { struct STRUCT_OR_UNION_14 VAR_206 ; VAR_207 . VAR_208 . VAR_209 = VAR_210 -> VAR_211 ; VAR_212 . VAR_213 . VAR_214 = VAR_215 -> VAR_216 ; VAR_217 . VAR_218 = VAR_219 -> VAR_220 ; METHOD_34 ( & VAR_221 , VAR_222 , VAR_223 , sizeof ( VAR_224 ) , & VAR_225 ) ; } if ( VAR_226 -> VAR_227 & VAR_228 ) { TYPE_19 VAR_229 = VAR_230 -> VAR_231 ; METHOD_35 ( & VAR_232 , VAR_233 , VAR_234 , sizeof ( VAR_235 ) , & VAR_236 ) ; } VAR_237 -= VAR_238 . VAR_239 ; return METHOD_36 ( VAR_240 , VAR_241 ) ; } case VAR_242 : VAR_243 = VAR_244 -> VAR_245 ; break ; case VAR_246 : VAR_247 = VAR_248 -> VAR_249 ; break ; case VAR_250 : VAR_251 = VAR_252 -> VAR_253 ; break ; default : METHOD_37 ( VAR_254 ) ; return - VAR_255 ; } METHOD_38 ( VAR_256 ) ; if ( VAR_257 < sizeof ( TYPE_20 ) && VAR_258 > 0 && VAR_259 >= 0 && VAR_260 <= 255 ) { unsigned TYPE_21 VAR_261 = ( unsigned TYPE_22 ) VAR_262 ; VAR_263 = 1 ; if ( METHOD_39 ( VAR_264 , VAR_265 ) ) return - VAR_266 ; if ( METHOD_40 ( VAR_267 , & VAR_268 , 1 ) ) return - VAR_269 ; } else { VAR_270 = min_t ( unsigned TYPE_23 , sizeof ( TYPE_24 ) , VAR_271 ) ; if ( METHOD_41 ( VAR_272 , VAR_273 ) ) return - VAR_274 ; if ( METHOD_42 ( VAR_275 , & VAR_276 , VAR_277 ) ) return - VAR_278 ; } return 0 ; }","<S2SV_ModStart> ) VAR_32 ; struct STRUCT_OR_UNION_15 * VAR_279 ; VAR_279 = METHOD_44 ( VAR_252 -> VAR_279 , METHOD_43 ( VAR_256 ) ) ; <S2SV_ModStart> ; if ( VAR_279 ) METHOD_6 ( VAR_32 , & VAR_279 -> VAR_51 , sizeof ( struct STRUCT_OR_UNION_5 ) + VAR_279 -> VAR_51 . <S2SV_ModEnd> VAR_273 ) ;","CWE-362 static int do_ip_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen ) { struct inet_sock * inet = inet_sk ( sk ) ; int val ; int len ; if ( level != SOL_IP ) return - EOPNOTSUPP ; if ( ip_mroute_opt ( optname ) ) return ip_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; lock_sock ( sk ) ; switch ( optname ) { case IP_OPTIONS : { unsigned char optbuf [ sizeof ( struct ip_options ) + 40 ] ; struct ip_options * opt = ( struct ip_options * ) optbuf ; <S2SV_StartBug> opt -> optlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ; release_sock ( sk ) ; if ( opt -> optlen == 0 ) return put_user ( 0 , optlen ) ; ip_options_undo ( opt ) ; len = min_t ( unsigned int , len , opt -> optlen ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , opt -> __data , len ) ) return - EFAULT ; return 0 ; } case IP_PKTINFO : val = ( inet -> cmsg_flags & IP_CMSG_PKTINFO ) != 0 ; break ; case IP_RECVTTL : val = ( inet -> cmsg_flags & IP_CMSG_TTL ) != 0 ; break ; case IP_RECVTOS : val = ( inet -> cmsg_flags & IP_CMSG_TOS ) != 0 ; break ; case IP_RECVOPTS : val = ( inet -> cmsg_flags & IP_CMSG_RECVOPTS ) != 0 ; break ; case IP_RETOPTS : val = ( inet -> cmsg_flags & IP_CMSG_RETOPTS ) != 0 ; break ; case IP_PASSSEC : val = ( inet -> cmsg_flags & IP_CMSG_PASSSEC ) != 0 ; break ; case IP_RECVORIGDSTADDR : val = ( inet -> cmsg_flags & IP_CMSG_ORIGDSTADDR ) != 0 ; break ; case IP_TOS : val = inet -> tos ; break ; case IP_TTL : val = ( inet -> uc_ttl == - 1 ? sysctl_ip_default_ttl : inet -> uc_ttl ) ; break ; case IP_HDRINCL : val = inet -> hdrincl ; break ; case IP_NODEFRAG : val = inet -> nodefrag ; break ; case IP_MTU_DISCOVER : val = inet -> pmtudisc ; break ; case IP_MTU : { struct dst_entry * dst ; val = 0 ; dst = sk_dst_get ( sk ) ; if ( dst ) { val = dst_mtu ( dst ) ; dst_release ( dst ) ; } if ( ! val ) { release_sock ( sk ) ; return - ENOTCONN ; } break ; } case IP_RECVERR : val = inet -> recverr ; break ; case IP_MULTICAST_TTL : val = inet -> mc_ttl ; break ; case IP_MULTICAST_LOOP : val = inet -> mc_loop ; break ; case IP_MULTICAST_IF : { struct in_addr addr ; len = min_t ( unsigned int , len , sizeof ( struct in_addr ) ) ; addr . s_addr = inet -> mc_addr ; release_sock ( sk ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & addr , len ) ) return - EFAULT ; return 0 ; } case IP_MSFILTER : { struct ip_msfilter msf ; int err ; if ( len < IP_MSFILTER_SIZE ( 0 ) ) { release_sock ( sk ) ; return - EINVAL ; } if ( copy_from_user ( & msf , optval , IP_MSFILTER_SIZE ( 0 ) ) ) { release_sock ( sk ) ; return - EFAULT ; } err = ip_mc_msfget ( sk , & msf , ( struct ip_msfilter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) { release_sock ( sk ) ; return - EINVAL ; } if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) { release_sock ( sk ) ; return - EFAULT ; } err = ip_mc_gsfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IP_MULTICAST_ALL : val = inet -> mc_all ; break ; case IP_PKTOPTIONS : { struct msghdr msg ; release_sock ( sk ) ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = 0 ; if ( inet -> cmsg_flags & IP_CMSG_PKTINFO ) { struct in_pktinfo info ; info . ipi_addr . s_addr = inet -> inet_rcv_saddr ; info . ipi_spec_dst . s_addr = inet -> inet_rcv_saddr ; info . ipi_ifindex = inet -> mc_index ; put_cmsg ( & msg , SOL_IP , IP_PKTINFO , sizeof ( info ) , & info ) ; } if ( inet -> cmsg_flags & IP_CMSG_TTL ) { int hlim = inet -> mc_ttl ; put_cmsg ( & msg , SOL_IP , IP_TTL , sizeof ( hlim ) , & hlim ) ; } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IP_FREEBIND : val = inet -> freebind ; break ; case IP_TRANSPARENT : val = inet -> transparent ; break ; case IP_MINTTL : val = inet -> min_ttl ; break ; default : release_sock ( sk ) ; return - ENOPROTOOPT ; } release_sock ( sk ) ; if ( len < sizeof ( int ) && len > 0 && val >= 0 && val <= 255 ) { unsigned char ucval = ( unsigned char ) val ; len = 1 ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & ucval , 1 ) ) return - EFAULT ; } else { len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; } return 0 ; }","<S2SV_ModStart> ) optbuf ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ; if ( inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . <S2SV_ModEnd> optlen ) ;"
276,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 ; TYPE_4 VAR_4 ; <S2SV_StartBug> TYPE_5 VAR_5 ; <S2SV_EndBug> <S2SV_StartBug> METHOD_1 ( VAR_6 -> VAR_7 , 28 ) ; <S2SV_EndBug> METHOD_2 ( VAR_8 -> VAR_9 , VAR_10 ) ; <S2SV_StartBug> VAR_11 = METHOD_3 ( VAR_12 , 0 , ( TYPE_6 * ) METHOD_4 ( VAR_13 -> VAR_14 ) , VAR_15 / 2 , <S2SV_EndBug> & VAR_16 , 0 , VAR_17 , VAR_18 ) ; if ( VAR_19 < 1 ) if ( ! ( VAR_20 = ( TYPE_7 * ) METHOD_5 ( 1 , 1 ) ) ) { METHOD_6 ( VAR_21 , ""calloc<S2SV_blank>failed!"" ) ; return VAR_22 ; } VAR_23 -> VAR_24 = VAR_25 -> VAR_26 -> VAR_27 ++ ; VAR_28 -> VAR_29 = METHOD_7 ( VAR_30 -> VAR_31 , VAR_32 ) ; if ( VAR_33 -> VAR_34 < 0 ) { VAR_35 -> VAR_36 = VAR_37 ; VAR_38 -> VAR_39 = 0 ; } else { if ( METHOD_8 ( VAR_40 -> VAR_41 , VAR_42 , VAR_43 ) == - 1 ) { } } METHOD_9 ( VAR_44 -> VAR_45 , VAR_46 -> VAR_47 ) ; METHOD_10 ( VAR_48 -> VAR_49 , 0 ) ; METHOD_11 ( VAR_50 ) ; return VAR_51 -> METHOD_12 ( VAR_52 ) ; }","<S2SV_ModStart> TYPE_4 VAR_19 ; TYPE_6 * VAR_53 ; <S2SV_ModStart> TYPE_5 VAR_15 ; if ( ! METHOD_13 <S2SV_ModEnd> ( VAR_52 -> <S2SV_ModStart> , 28 ) ) return VAR_54 ; if ( METHOD_14 ( VAR_52 -> VAR_14 ) < 4 ) return VAR_54 <S2SV_ModStart> VAR_15 ) ; VAR_53 = ( TYPE_6 * ) METHOD_4 ( VAR_52 -> VAR_14 ) ; if ( ! METHOD_13 ( VAR_52 -> VAR_14 , VAR_15 ) ) return VAR_54 ; <S2SV_ModStart> , 0 , VAR_53 <S2SV_ModEnd> , VAR_15 /","CWE-125 static UINT parallel_process_irp_create ( PARALLEL_DEVICE * parallel , IRP * irp ) { char * path = NULL ; int status ; <S2SV_StartBug> UINT32 PathLength ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 28 ) ; <S2SV_EndBug> Stream_Read_UINT32 ( irp -> input , PathLength ) ; <S2SV_StartBug> status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 , <S2SV_EndBug> & path , 0 , NULL , NULL ) ; if ( status < 1 ) if ( ! ( path = ( char * ) calloc ( 1 , 1 ) ) ) { WLog_ERR ( TAG , ""calloc<S2SV_blank>failed!"" ) ; return CHANNEL_RC_NO_MEMORY ; } parallel -> id = irp -> devman -> id_sequence ++ ; parallel -> file = open ( parallel -> path , O_RDWR ) ; if ( parallel -> file < 0 ) { irp -> IoStatus = STATUS_ACCESS_DENIED ; parallel -> id = 0 ; } else { if ( fcntl ( parallel -> file , F_SETFL , O_NONBLOCK ) == - 1 ) { } } Stream_Write_UINT32 ( irp -> output , parallel -> id ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; free ( path ) ; return irp -> Complete ( irp ) ; }","<S2SV_ModStart> int status ; WCHAR * ptr ; <S2SV_ModStart> UINT32 PathLength ; if ( ! Stream_SafeSeek <S2SV_ModEnd> ( irp -> <S2SV_ModStart> , 28 ) ) return ERROR_INVALID_DATA ; if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA <S2SV_ModStart> PathLength ) ; ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> , 0 , ptr <S2SV_ModEnd> , PathLength /"
277,"CWE-190 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> if ( METHOD_1 ( VAR_3 , 2 , & VAR_4 ) ) return - 1 ; * VAR_5 = VAR_6 ; return 0 ; }",<S2SV_ModStart> VAR_5 ) { TYPE_4 <S2SV_ModEnd> VAR_6 ; if,"CWE-190 static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }",<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
278,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { unsigned TYPE_1 VAR_2 ; <S2SV_StartBug> TYPE_2 * VAR_3 ; <S2SV_EndBug> VAR_4 = VAR_5 -> VAR_6 . VAR_7 * VAR_8 -> VAR_9 . VAR_10 ; if ( VAR_11 -> VAR_12 -> VAR_13 ) { VAR_14 = VAR_15 ; } else { VAR_16 = METHOD_1 ( VAR_17 , VAR_18 ) ; if ( ! VAR_19 ) return - VAR_20 ; } VAR_21 -> VAR_22 -> VAR_23 = VAR_24 -> VAR_25 . VAR_26 ; VAR_27 -> VAR_28 -> VAR_29 = VAR_30 -> VAR_31 . VAR_32 ; VAR_33 -> VAR_34 -> VAR_35 = VAR_36 ; VAR_37 -> VAR_38 -> VAR_39 = VAR_40 ; return 0 ; }",<S2SV_ModStart> TYPE_2 * VAR_36 ; if ( VAR_30 -> VAR_36 . VAR_26 == 0 || VAR_30 -> VAR_36 . VAR_32 > VAR_41 / VAR_30 -> VAR_36 . VAR_26 ) return - VAR_42,"CWE-000 static int snd_compr_allocate_buffer ( struct snd_compr_stream * stream , struct snd_compr_params * params ) { unsigned int buffer_size ; <S2SV_StartBug> void * buffer ; <S2SV_EndBug> buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ; if ( stream -> ops -> copy ) { buffer = NULL ; } else { buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM ; } stream -> runtime -> fragment_size = params -> buffer . fragment_size ; stream -> runtime -> fragments = params -> buffer . fragments ; stream -> runtime -> buffer = buffer ; stream -> runtime -> buffer_size = buffer_size ; return 0 ; }",<S2SV_ModStart> void * buffer ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL
279,"CWE-000 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 VAR_4 , VAR_5 ; TYPE_6 * VAR_6 = VAR_7 , * VAR_8 = VAR_9 , * VAR_10 = VAR_11 , * VAR_12 = VAR_13 ; TYPE_7 * VAR_14 ; TYPE_8 * VAR_15 = VAR_16 ; const TYPE_9 * VAR_17 ; const TYPE_10 * VAR_18 = VAR_19 ; TYPE_11 * VAR_20 = VAR_21 ; TYPE_12 * VAR_22 = VAR_23 ; METHOD_1 ( TYPE_13 ) * VAR_24 = VAR_25 ; METHOD_2 ( TYPE_14 ) * VAR_26 = VAR_27 ; TYPE_15 * VAR_28 = VAR_29 ; unsigned TYPE_16 * VAR_30 = VAR_31 , * VAR_32 = VAR_33 ; TYPE_17 VAR_34 = 0 , VAR_35 = 0 ; if ( VAR_36 == VAR_37 ) { METHOD_3 ( VAR_38 , VAR_39 ) ; return VAR_40 ; } if ( VAR_41 -> VAR_42 . VAR_43 == VAR_44 ) { METHOD_4 ( VAR_45 , VAR_46 ) ; return VAR_47 ; } VAR_48 = METHOD_5 ( VAR_49 -> VAR_50 ) ; VAR_51 -> VAR_52 = VAR_53 ; switch ( VAR_54 ) { case VAR_55 : VAR_56 = METHOD_6 ( VAR_57 -> VAR_58 . VAR_59 -> VAR_60 ) ; if ( ! METHOD_7 ( VAR_61 ) && VAR_62 == VAR_63 ) { METHOD_8 ( VAR_64 , VAR_65 ) ; goto VAR_66 ; } VAR_67 = VAR_68 -> VAR_69 . VAR_70 -> VAR_71 ; break ; case VAR_72 : VAR_73 = VAR_74 -> VAR_75 . VAR_76 -> VAR_77 ; VAR_78 = VAR_79 -> VAR_80 . VAR_81 -> VAR_82 ; VAR_83 = VAR_84 -> VAR_85 . VAR_86 -> VAR_87 -> VAR_88 ; VAR_89 = VAR_90 -> VAR_91 . VAR_92 -> VAR_93 -> VAR_94 ; VAR_95 = METHOD_9 ( VAR_96 -> VAR_97 ) ; if ( VAR_98 == VAR_99 ) { METHOD_10 ( VAR_100 , VAR_101 ) ; goto VAR_102 ; } break ; case VAR_103 : VAR_104 = VAR_105 -> VAR_106 . VAR_107 -> VAR_108 ; VAR_109 = VAR_110 -> VAR_111 . VAR_112 -> VAR_113 -> VAR_114 ; VAR_115 = VAR_116 -> VAR_117 . VAR_118 -> VAR_119 -> VAR_120 ; VAR_121 = METHOD_11 ( VAR_122 -> VAR_123 ) ; if ( VAR_124 == VAR_125 ) { METHOD_12 ( VAR_126 , VAR_127 ) ; goto VAR_128 ; } break ; default : METHOD_13 ( VAR_129 , VAR_130 ) ; goto VAR_131 ; } <S2SV_StartBug> if ( VAR_132 != VAR_133 ) { <S2SV_EndBug> for ( VAR_134 = 0 ; VAR_135 < METHOD_14 ( VAR_136 ) ; VAR_137 ++ ) { VAR_138 = METHOD_15 ( VAR_139 , VAR_140 ) ; if ( ( VAR_141 = METHOD_16 ( METHOD_17 ( ) ) ) == VAR_142 ) { METHOD_18 ( VAR_143 , VAR_144 ) ; goto VAR_145 ; } VAR_146 = METHOD_19 ( VAR_147 -> VAR_148 ) ; VAR_149 = METHOD_20 ( VAR_150 ) ; if ( VAR_151 == VAR_152 ) { METHOD_21 ( VAR_153 , VAR_154 ) ; goto VAR_155 ; } METHOD_22 ( VAR_156 , VAR_157 ) ; if ( VAR_158 == VAR_159 ) VAR_160 = VAR_161 ; else METHOD_23 ( VAR_162 , VAR_163 ) ; VAR_164 = VAR_165 ; } } if ( VAR_166 != VAR_167 ) { if ( ( VAR_168 = METHOD_24 ( METHOD_25 ( ) ) ) == VAR_169 ) { METHOD_26 ( VAR_170 , VAR_171 ) ; goto VAR_172 ; } if ( VAR_173 ) { for ( VAR_174 = 0 ; VAR_175 < METHOD_27 ( VAR_176 ) ; VAR_177 ++ ) { VAR_178 = METHOD_28 ( VAR_179 , VAR_180 ) ; if ( ! METHOD_29 ( VAR_181 , VAR_182 ) ) break ; VAR_183 = VAR_184 ; } if ( VAR_185 == VAR_186 ) { METHOD_30 ( VAR_187 , VAR_188 ) ; goto VAR_189 ; } } if ( VAR_190 == VAR_191 ) { for ( VAR_192 = 0 ; VAR_193 < METHOD_31 ( VAR_194 ) ; VAR_195 ++ ) { VAR_196 = METHOD_32 ( VAR_197 , VAR_198 ) ; if ( METHOD_33 ( & VAR_199 , & VAR_200 , VAR_201 , VAR_202 ) < 0 ) goto VAR_203 ; METHOD_34 ( ) ; } } else { if ( METHOD_35 ( & VAR_204 , & VAR_205 , VAR_206 , VAR_207 ) < 0 ) goto VAR_208 ; METHOD_36 ( ) ; } VAR_209 = VAR_210 ; METHOD_37 ( VAR_211 , & VAR_212 ) ; if ( METHOD_38 ( VAR_213 , VAR_214 , VAR_215 , VAR_216 , VAR_217 , 0 ) <= 0 ) goto VAR_218 ; if ( METHOD_39 ( VAR_219 , VAR_220 -> VAR_221 ) < 0 ) goto VAR_222 ; VAR_223 = METHOD_40 ( VAR_224 ) ; VAR_225 = METHOD_41 ( VAR_226 ) ; if ( ! VAR_227 ) goto VAR_228 ; if ( METHOD_42 ( VAR_229 , VAR_230 ) <= 0 ) goto VAR_231 ; if ( VAR_232 == VAR_233 ) { VAR_234 = VAR_235 ; VAR_236 = VAR_237 ; VAR_238 = VAR_239 ; } if ( VAR_240 != METHOD_43 ( VAR_241 ) ) { if ( ! METHOD_44 ( VAR_242 , VAR_243 ) ) { METHOD_45 ( VAR_244 , VAR_245 ) ; VAR_246 = VAR_247 ; VAR_248 = VAR_249 ; VAR_250 = VAR_251 ; } } METHOD_46 ( ) ; if ( METHOD_47 ( VAR_252 , VAR_253 , VAR_254 , VAR_255 , VAR_256 , 0 ) <= 0 ) goto VAR_257 ; METHOD_48 ( VAR_258 , VAR_259 ) ; VAR_260 = VAR_261 ; METHOD_49 ( VAR_262 , VAR_263 ) ; VAR_264 = VAR_265 ; if ( VAR_266 == VAR_267 ) VAR_268 = VAR_269 ; else METHOD_50 ( VAR_270 , VAR_271 ) ; VAR_272 = VAR_273 ; } <S2SV_StartBug> if ( METHOD_51 ( VAR_274 ) || ( VAR_275 != VAR_276 ) ) { <S2SV_EndBug> VAR_277 = VAR_278 ; } else { if ( VAR_279 -> VAR_280 > 0 ) VAR_281 = METHOD_52 ( VAR_282 -> VAR_283 , VAR_284 -> VAR_285 ) ; else { VAR_286 = METHOD_53 ( METHOD_54 ( ) ) ; METHOD_55 ( VAR_287 , 0 ) ; } if ( VAR_288 == VAR_289 ) goto VAR_290 ; } METHOD_56 ( VAR_291 , VAR_292 ) ; VAR_293 = VAR_294 ; return VAR_295 ; VAR_296 : METHOD_57 ( VAR_297 , VAR_298 ) ; METHOD_58 ( VAR_299 , VAR_300 ) ; METHOD_59 ( VAR_301 ) ; METHOD_60 ( VAR_302 ) ; METHOD_61 ( VAR_303 ) ; METHOD_62 ( VAR_304 ) ; return VAR_305 ; }","<S2SV_ModStart> } if ( VAR_284 == VAR_305 && VAR_278 == VAR_305 ) { METHOD_30 ( VAR_187 , VAR_46 ) ; goto VAR_296 ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> VAR_278 != VAR_305 <S2SV_ModStart> != VAR_305 ) <S2SV_ModEnd> { VAR_304 =","CWE-000 BIO * PKCS7_dataDecode ( PKCS7 * p7 , EVP_PKEY * pkey , BIO * in_bio , X509 * pcert ) { int i , j ; BIO * out = NULL , * btmp = NULL , * etmp = NULL , * bio = NULL ; X509_ALGOR * xa ; ASN1_OCTET_STRING * data_body = NULL ; const EVP_MD * evp_md ; const EVP_CIPHER * evp_cipher = NULL ; EVP_CIPHER_CTX * evp_ctx = NULL ; X509_ALGOR * enc_alg = NULL ; STACK_OF ( X509_ALGOR ) * md_sk = NULL ; STACK_OF ( PKCS7_RECIP_INFO ) * rsk = NULL ; PKCS7_RECIP_INFO * ri = NULL ; unsigned char * ek = NULL , * tkey = NULL ; int eklen = 0 , tkeylen = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; } i = OBJ_obj2nid ( p7 -> type ) ; p7 -> state = PKCS7_S_HEADER ; switch ( i ) { case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ; if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ; goto err ; } md_sk = p7 -> d . sign -> md_algs ; break ; case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ; md_sk = p7 -> d . signed_and_enveloped -> md_algs ; data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ; enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ; enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ; data_body = p7 -> d . enveloped -> enc_data -> enc_data ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } <S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> for ( i = 0 ; i < sk_X509_ALGOR_num ( md_sk ) ; i ++ ) { xa = sk_X509_ALGOR_value ( md_sk , i ) ; if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } j = OBJ_obj2nid ( xa -> algorithm ) ; evp_md = EVP_get_digestbynid ( j ) ; if ( evp_md == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ; goto err ; } BIO_set_md ( btmp , evp_md ) ; if ( out == NULL ) out = btmp ; else BIO_push ( out , btmp ) ; btmp = NULL ; } } if ( evp_cipher != NULL ) { if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } if ( pcert ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ; ri = NULL ; } if ( ri == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ; goto err ; } } if ( pcert == NULL ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } } else { if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } evp_ctx = NULL ; BIO_get_cipher_ctx ( etmp , & evp_ctx ) ; if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ; if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) { if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) { OPENSSL_clear_free ( ek , eklen ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ; OPENSSL_clear_free ( ek , eklen ) ; ek = NULL ; OPENSSL_clear_free ( tkey , tkeylen ) ; tkey = NULL ; if ( out == NULL ) out = etmp ; else BIO_push ( out , etmp ) ; etmp = NULL ; } <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> bio = in_bio ; } else { if ( data_body -> length > 0 ) bio = BIO_new_mem_buf ( data_body -> data , data_body -> length ) ; else { bio = BIO_new ( BIO_s_mem ( ) ) ; BIO_set_mem_eof_return ( bio , 0 ) ; } if ( bio == NULL ) goto err ; } BIO_push ( out , bio ) ; bio = NULL ; return out ; err : OPENSSL_clear_free ( ek , eklen ) ; OPENSSL_clear_free ( tkey , tkeylen ) ; BIO_free_all ( out ) ; BIO_free_all ( btmp ) ; BIO_free_all ( etmp ) ; BIO_free_all ( bio ) ; return NULL ; }","<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio ="
280,"CWE-000 static TYPE_0 * METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , enum VAR_1 * VAR_2 ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 ; struct STRUCT_OR_UNION_3 STRUCT_OR_UNION_4 ; TYPE_1 * VAR_3 ; TYPE_2 VAR_4 ; VAR_5 = METHOD_1 ( VAR_6 -> VAR_7 , VAR_8 , & STRUCT_OR_UNION_5 ) ; if ( VAR_9 ) return METHOD_2 ( VAR_10 ) ; STRUCT_OR_UNION_6 = METHOD_3 ( STRUCT_OR_UNION_7 . VAR_11 ) ; VAR_12 = METHOD_4 ( STRUCT_OR_UNION_8 , VAR_13 ) ; if ( VAR_14 ) goto VAR_15 ; VAR_16 = METHOD_5 ( STRUCT_OR_UNION_9 , VAR_17 ) ; if ( VAR_18 ) goto VAR_19 ; VAR_20 = METHOD_6 ( STRUCT_OR_UNION_10 -> VAR_21 , * VAR_22 ) ; <S2SV_StartBug> METHOD_7 ( & STRUCT_OR_UNION_11 ) ; <S2SV_EndBug> METHOD_8 ( & STRUCT_OR_UNION_12 ) ; return VAR_23 ; VAR_24 : METHOD_9 ( & STRUCT_OR_UNION_13 ) ; return METHOD_10 ( VAR_25 ) ; }",<S2SV_ModStart> VAR_22 ) ; if ( ! METHOD_11 ( VAR_23 ) ),"CWE-000 static void * bpf_obj_do_get ( const struct filename * pathname , enum bpf_type * type ) { struct inode * inode ; struct path path ; void * raw ; int ret ; ret = kern_path ( pathname -> name , LOOKUP_FOLLOW , & path ) ; if ( ret ) return ERR_PTR ( ret ) ; inode = d_backing_inode ( path . dentry ) ; ret = inode_permission ( inode , MAY_WRITE ) ; if ( ret ) goto out ; ret = bpf_inode_type ( inode , type ) ; if ( ret ) goto out ; raw = bpf_any_get ( inode -> i_private , * type ) ; <S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> path_put ( & path ) ; return raw ; out : path_put ( & path ) ; return ERR_PTR ( ret ) ; }",<S2SV_ModStart> type ) ; if ( ! IS_ERR ( raw ) )
281,"CWE-20 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 ) { struct STRUCT_OR_UNION_1 * VAR_2 ; TYPE_2 METHOD_1 ; TYPE_3 VAR_3 ; TYPE_4 * VAR_4 ; METHOD_2 ( ""nfsd_dispatch:<S2SV_blank>vers<S2SV_blank>%d<S2SV_blank>proc<S2SV_blank>%d\\n"" , VAR_5 -> VAR_6 , VAR_7 -> VAR_8 ) ; <S2SV_StartBug> VAR_9 = VAR_10 -> VAR_11 ; <S2SV_EndBug> VAR_12 -> VAR_13 = VAR_14 -> VAR_15 ; METHOD_3 = VAR_16 -> VAR_17 ; if ( METHOD_4 && ! METHOD_5 ( VAR_18 , ( TYPE_5 * ) VAR_19 -> VAR_20 . VAR_21 [ 0 ] . VAR_22 , VAR_23 -> VAR_24 ) ) { METHOD_6 ( ""nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>arguments!\\n"" ) ; * VAR_25 = VAR_26 ; return 1 ; } switch ( METHOD_7 ( VAR_27 ) ) { case VAR_28 : return 0 ; case VAR_29 : return 1 ; case VAR_30 : ; } VAR_31 = VAR_32 -> VAR_33 . VAR_34 [ 0 ] . VAR_35 + VAR_36 -> VAR_37 . VAR_38 [ 0 ] . VAR_39 ; VAR_40 -> VAR_41 . VAR_42 [ 0 ] . VAR_43 += sizeof ( TYPE_6 ) ; VAR_44 = VAR_45 -> METHOD_8 ( VAR_46 , VAR_47 -> VAR_48 , VAR_49 -> VAR_50 ) ; VAR_51 = METHOD_9 ( VAR_52 -> VAR_53 , VAR_54 ) ; if ( VAR_55 == VAR_56 || METHOD_10 ( VAR_57 , & VAR_58 -> VAR_59 ) ) { METHOD_11 ( ""nfsd:<S2SV_blank>Dropping<S2SV_blank>request;<S2SV_blank>may<S2SV_blank>be<S2SV_blank>revisited<S2SV_blank>later\\n"" ) ; METHOD_12 ( VAR_60 , VAR_61 , VAR_62 ) ; return 0 ; } if ( VAR_63 -> VAR_64 != 0 ) * VAR_65 ++ = VAR_66 ; if ( ! ( VAR_67 && VAR_68 -> VAR_69 == 2 ) ) { METHOD_13 = VAR_70 -> VAR_71 ; if ( METHOD_14 && ! METHOD_15 ( VAR_72 , VAR_73 , VAR_74 -> VAR_75 ) ) { METHOD_16 ( ""nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>result!\\n"" ) ; METHOD_17 ( VAR_76 , VAR_77 , VAR_78 ) ; * VAR_79 = VAR_80 ; return 1 ; } } METHOD_18 ( VAR_81 , VAR_82 -> VAR_83 , VAR_84 + 1 ) ; return 1 ; }","<S2SV_ModStart> -> VAR_11 ; if ( METHOD_19 ( VAR_82 , VAR_70 ) ) { METHOD_16 ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , VAR_82 -> VAR_69 ) ; * VAR_84 = VAR_26 ; return 1 ; }","CWE-20 int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) { struct svc_procedure * proc ; kxdrproc_t xdr ; __be32 nfserr ; __be32 * nfserrp ; dprintk ( ""nfsd_dispatch:<S2SV_blank>vers<S2SV_blank>%d<S2SV_blank>proc<S2SV_blank>%d\\n"" , rqstp -> rq_vers , rqstp -> rq_proc ) ; <S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> rqstp -> rq_cachetype = proc -> pc_cachetype ; xdr = proc -> pc_decode ; if ( xdr && ! xdr ( rqstp , ( __be32 * ) rqstp -> rq_arg . head [ 0 ] . iov_base , rqstp -> rq_argp ) ) { dprintk ( ""nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>arguments!\\n"" ) ; * statp = rpc_garbage_args ; return 1 ; } switch ( nfsd_cache_lookup ( rqstp ) ) { case RC_DROPIT : return 0 ; case RC_REPLY : return 1 ; case RC_DOIT : ; } nfserrp = rqstp -> rq_res . head [ 0 ] . iov_base + rqstp -> rq_res . head [ 0 ] . iov_len ; rqstp -> rq_res . head [ 0 ] . iov_len += sizeof ( __be32 ) ; nfserr = proc -> pc_func ( rqstp , rqstp -> rq_argp , rqstp -> rq_resp ) ; nfserr = map_new_errors ( rqstp -> rq_vers , nfserr ) ; if ( nfserr == nfserr_dropit || test_bit ( RQ_DROPME , & rqstp -> rq_flags ) ) { dprintk ( ""nfsd:<S2SV_blank>Dropping<S2SV_blank>request;<S2SV_blank>may<S2SV_blank>be<S2SV_blank>revisited<S2SV_blank>later\\n"" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; return 0 ; } if ( rqstp -> rq_proc != 0 ) * nfserrp ++ = nfserr ; if ( ! ( nfserr && rqstp -> rq_vers == 2 ) ) { xdr = proc -> pc_encode ; if ( xdr && ! xdr ( rqstp , nfserrp , rqstp -> rq_resp ) ) { dprintk ( ""nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>result!\\n"" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; * statp = rpc_system_err ; return 1 ; } } nfsd_cache_update ( rqstp , rqstp -> rq_cachetype , statp + 1 ) ; return 1 ; }","<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }"
282,"CWE-362 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = 1 ; METHOD_1 ( ""my_redel"" ) ; METHOD_2 ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , VAR_4 , VAR_5 , VAR_6 ) ) ; <S2SV_StartBug> if ( METHOD_3 ( VAR_7 , VAR_8 , VAR_9 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto VAR_10 ; <S2SV_EndBug> if ( VAR_11 & VAR_12 ) { TYPE_5 VAR_13 [ VAR_14 + 20 ] ; TYPE_6 VAR_15 [ 20 ] ; VAR_16 [ 0 ] = '-' ; METHOD_4 ( VAR_17 + 1 , 2 + 4 , ( TYPE_7 ) 0 ) ; METHOD_5 ( METHOD_6 ( VAR_18 ) , VAR_19 ) ; if ( METHOD_7 ( VAR_20 , METHOD_8 ( VAR_21 , VAR_22 , """" , VAR_23 , 2 ) , VAR_24 ) ) goto VAR_25 ; } else if ( METHOD_9 ( VAR_26 , VAR_27 ) ) goto VAR_28 ; if ( METHOD_10 ( VAR_29 , VAR_30 , VAR_31 ) ) goto VAR_32 ; VAR_33 = 0 ; VAR_34 : METHOD_11 ( VAR_35 ) ; }",<S2SV_ModStart> ; if ( ! ( VAR_31 & VAR_36 ) ) { if ( <S2SV_ModStart> goto VAR_34 ; },"CWE-362 int my_redel ( const char * org_name , const char * tmp_name , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( ""my_redel"" ) ; DBUG_PRINT ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + 20 ] ; char ext [ 20 ] ; ext [ 0 ] = '-' ; get_date ( ext + 1 , 2 + 4 , ( time_t ) 0 ) ; strmov ( strend ( ext ) , REDEL_EXT ) ; if ( my_rename ( org_name , fn_format ( name_buff , org_name , """" , ext , 2 ) , MyFlags ) ) goto end ; } else if ( my_delete_allow_opened ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }",<S2SV_ModStart> ; if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> goto end ; }
283,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 = METHOD_1 ( VAR_4 ) ; struct STRUCT_OR_UNION_4 * VAR_5 ; struct STRUCT_OR_UNION_5 * VAR_6 , * VAR_7 ; TYPE_1 VAR_8 , VAR_9 = 0 ; TYPE_2 VAR_10 = 0 , VAR_11 = VAR_12 -> VAR_13 [ 1 ] ; if ( VAR_14 -> VAR_15 ) return 0 ; VAR_16 = METHOD_2 ( VAR_17 -> VAR_18 ) ; if ( ! VAR_19 ) return 0 ; VAR_20 = METHOD_3 ( VAR_21 , VAR_22 ) ; if ( VAR_23 == VAR_24 ) return - VAR_25 ; for ( VAR_26 = 0 ; VAR_27 < VAR_28 -> VAR_29 ; VAR_30 ++ ) { struct STRUCT_OR_UNION_6 * VAR_31 ; struct STRUCT_OR_UNION_7 * VAR_32 , * * VAR_33 ; struct STRUCT_OR_UNION_8 * VAR_34 ; METHOD_4 ( VAR_35 , & VAR_36 -> VAR_37 [ VAR_38 ] , VAR_39 [ VAR_40 -> VAR_41 ] ) { if ( VAR_42 < VAR_43 ) goto VAR_44 ; VAR_45 = METHOD_5 ( VAR_46 , VAR_47 ) ; if ( VAR_48 == VAR_49 ) { VAR_50 = - VAR_51 ; goto VAR_52 ; } for ( VAR_53 = & VAR_54 -> VAR_55 ; ( VAR_56 = METHOD_6 ( * VAR_57 ) ) != VAR_58 ; VAR_59 = & VAR_60 -> VAR_61 ) { VAR_62 = VAR_63 -> VAR_64 ; if ( VAR_65 ) { struct STRUCT_OR_UNION_9 VAR_66 ; <S2SV_StartBug> VAR_67 . VAR_68 = VAR_69 -> VAR_70 -> VAR_71 ; <S2SV_EndBug> VAR_72 . VAR_73 = VAR_74 -> VAR_75 ; if ( VAR_76 -> VAR_77 . VAR_78 == METHOD_7 ( VAR_79 ) ) VAR_80 . VAR_81 . VAR_82 . VAR_83 = VAR_84 -> VAR_85 . VAR_86 . VAR_87 ; if IS_ENABLED ( VAR_88 ) if ( VAR_89 -> VAR_90 . VAR_91 == METHOD_8 ( VAR_92 ) ) VAR_93 . VAR_94 . VAR_95 . VAR_96 = VAR_97 -> VAR_98 . VAR_99 . VAR_100 ; VAR_101 . VAR_102 . VAR_103 = VAR_104 -> VAR_105 . VAR_106 ; if ( METHOD_9 ( VAR_107 , VAR_108 , sizeof ( VAR_109 ) , & VAR_110 ) ) { METHOD_10 ( VAR_111 , VAR_112 ) ; VAR_113 = - VAR_114 ; goto VAR_115 ; } } } METHOD_11 ( VAR_116 , VAR_117 ) ; VAR_118 : VAR_119 ++ ; } } VAR_120 : VAR_121 -> VAR_122 [ 1 ] = VAR_123 ; METHOD_12 ( VAR_124 , VAR_125 ) ; return VAR_126 ; }","<S2SV_ModStart> STRUCT_OR_UNION_9 VAR_110 ; METHOD_13 ( & VAR_110 , 0 , sizeof ( VAR_110 ) ) ;","CWE-399 static int br_mdb_fill_info ( struct sk_buff * skb , struct netlink_callback * cb , struct net_device * dev ) { struct net_bridge * br = netdev_priv ( dev ) ; struct net_bridge_mdb_htable * mdb ; struct nlattr * nest , * nest2 ; int i , err = 0 ; int idx = 0 , s_idx = cb -> args [ 1 ] ; if ( br -> multicast_disabled ) return 0 ; mdb = rcu_dereference ( br -> mdb ) ; if ( ! mdb ) return 0 ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) return - EMSGSIZE ; for ( i = 0 ; i < mdb -> max ; i ++ ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p , * * pp ; struct net_bridge_port * port ; hlist_for_each_entry_rcu ( mp , & mdb -> mhash [ i ] , hlist [ mdb -> ver ] ) { if ( idx < s_idx ) goto skip ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) { err = - EMSGSIZE ; goto out ; } for ( pp = & mp -> ports ; ( p = rcu_dereference ( * pp ) ) != NULL ; pp = & p -> next ) { port = p -> port ; if ( port ) { struct br_mdb_entry e ; <S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> e . state = p -> state ; if ( p -> addr . proto == htons ( ETH_P_IP ) ) e . addr . u . ip4 = p -> addr . u . ip4 ;  if IS_ENABLED ( CONFIG_IPV6 ) if ( p -> addr . proto == htons ( ETH_P_IPV6 ) ) e . addr . u . ip6 = p -> addr . u . ip6 ;   e . addr . proto = p -> addr . proto ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( e ) , & e ) ) { nla_nest_cancel ( skb , nest2 ) ; err = - EMSGSIZE ; goto out ; } } } nla_nest_end ( skb , nest2 ) ; skip : idx ++ ; } } out : cb -> args [ 1 ] = idx ; nla_nest_end ( skb , nest ) ; return err ; }","<S2SV_ModStart> br_mdb_entry e ; memset ( & e , 0 , sizeof ( e ) ) ;"
284,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 ; if ( VAR_12 < 0 ) { VAR_13 = 0 ; } VAR_14 = VAR_15 / 86400 ; <S2SV_StartBug> VAR_16 = VAR_17 % 86400 ; <S2SV_EndBug> VAR_18 = ( 4 + VAR_19 ) % 7 ; VAR_20 = VAR_21 / 3600 ; VAR_22 %= 3600 ; VAR_23 = VAR_24 / 60 ; VAR_25 %= 60 ; VAR_26 = VAR_27 - ( 31 + 28 ) + 719527 ; VAR_28 = ( VAR_29 + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; VAR_30 = VAR_31 - ( 365 * VAR_32 + VAR_33 / 4 - VAR_34 / 100 + VAR_35 / 400 ) ; if ( VAR_36 < 0 ) { VAR_37 = ( VAR_38 % 4 == 0 ) && ( VAR_39 % 100 || ( VAR_40 % 400 == 0 ) ) ; VAR_41 = 365 + VAR_42 + VAR_43 ; VAR_44 -- ; } VAR_45 = ( VAR_46 + 31 ) * 10 / 306 ; VAR_47 = VAR_48 - ( 367 * VAR_49 / 12 - 30 ) + 1 ; if ( VAR_50 >= 306 ) { VAR_51 ++ ; VAR_52 -= 10 ; } else { VAR_53 += 2 ; } VAR_54 -> VAR_55 = ( TYPE_5 ) VAR_56 ; VAR_57 -> VAR_58 = ( TYPE_6 ) VAR_59 ; VAR_60 -> VAR_61 = ( TYPE_7 ) VAR_62 ; VAR_63 -> VAR_64 = ( TYPE_8 ) VAR_65 ; VAR_66 -> VAR_67 = ( TYPE_9 ) VAR_68 ; VAR_69 -> VAR_70 = ( TYPE_10 ) VAR_71 ; VAR_72 -> VAR_73 = ( TYPE_11 ) VAR_74 ; }",<S2SV_ModStart> % 86400 ; if ( VAR_31 > 2932896 ) { VAR_31 = 2932896 ; VAR_56 = 86399 ; },"CWE-000 void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ; if ( t < 0 ) { t = 0 ; } days = t / 86400 ; <S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> wday = ( 4 + days ) % 7 ; hour = sec / 3600 ; sec %= 3600 ; min = sec / 60 ; sec %= 60 ; days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }",<S2SV_ModStart> % 86400 ; if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; }
285,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const unsigned TYPE_2 * VAR_1 , unsigned TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { <S2SV_StartBug> if ( ( VAR_5 + VAR_6 < VAR_7 ) || ( VAR_8 + VAR_9 < VAR_10 ) || ( VAR_11 + VAR_12 > VAR_13 ) || ( VAR_14 > VAR_15 ) ) { <S2SV_EndBug> <S2SV_StartBug> METHOD_1 ( VAR_16 -> VAR_17 -> VAR_18 , VAR_19 , ""ExifData"" , <S2SV_EndBug> ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , VAR_20 , VAR_21 ) ; return ; } if ( VAR_22 -> VAR_23 ) METHOD_2 ( VAR_24 -> VAR_25 -> VAR_26 , VAR_27 -> VAR_28 ) ; if ( ! ( VAR_29 -> VAR_30 = METHOD_3 ( VAR_31 , VAR_32 ) ) ) { METHOD_4 ( VAR_33 -> VAR_34 -> VAR_35 , ""ExifData"" , VAR_36 ) ; VAR_37 -> VAR_38 = 0 ; return ; } VAR_39 -> VAR_40 = VAR_41 ; METHOD_5 ( VAR_42 -> VAR_43 , VAR_44 + VAR_45 , VAR_46 ) ; }","<S2SV_ModStart> { if ( VAR_45 >= VAR_15 <S2SV_ModEnd> ) { METHOD_1 <S2SV_ModStart> , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)."" , VAR_45 ) ; return ; } if ( VAR_46 > VAR_15 - VAR_45 ) { METHOD_1 ( VAR_43 -> VAR_34 -> VAR_35 , VAR_19 , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u."" , VAR_46 , VAR_15 - VAR_45 <S2SV_ModEnd> ) ; return","CWE-787 static void exif_data_load_data_thumbnail ( ExifData * data , const unsigned char * d , unsigned int ds , ExifLong o , ExifLong s ) { <S2SV_StartBug> if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) { <S2SV_EndBug> <S2SV_StartBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , <S2SV_EndBug> ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , o , s ) ; return ; } if ( data -> data ) exif_mem_free ( data -> priv -> mem , data -> data ) ; if ( ! ( data -> data = exif_data_alloc ( data , s ) ) ) { EXIF_LOG_NO_MEMORY ( data -> priv -> log , ""ExifData"" , s ) ; data -> size = 0 ; return ; } data -> size = s ; memcpy ( data -> data , d + o , s ) ; }","<S2SV_ModStart> { if ( o >= ds <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)."" , o ) ; return ; } if ( s > ds - o ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u."" , s , ds - o <S2SV_ModEnd> ) ; return"
286,CWE-476 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; <S2SV_StartBug> if ( ! VAR_2 ) <S2SV_EndBug> return VAR_3 ; VAR_4 = ( TYPE_3 * ) ~ ( ( TYPE_4 ) VAR_5 -> VAR_6 ) ; return VAR_7 ; },<S2SV_ModStart> ( ! VAR_5 || ! METHOD_1 ( VAR_5 ),CWE-476 void * sspi_SecureHandleGetLowerPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ; return pointer ; },<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
287,"CWE-125 static const TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 TYPE_3 TYPE_4 , const struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_5 VAR_2 , const TYPE_6 * VAR_3 TYPE_7 , TYPE_8 TYPE_9 , TYPE_10 TYPE_11 TYPE_12 , TYPE_13 TYPE_14 TYPE_15 , TYPE_16 VAR_4 TYPE_17 ) { TYPE_18 1 const struct STRUCT_OR_UNION_1 * VAR_5 ; struct STRUCT_OR_UNION_2 VAR_6 ; static const TYPE_19 * VAR_7 [ ] = { ""IPv4"" , ""IPv4net"" , ""IPv6"" , ""IPv6net"" , } ; static const TYPE_20 * VAR_8 [ ] = { VAR_9 , ""IPv4"" , ""FQDN"" , ""user<S2SV_blank>FQDN"" , ""IPv4net"" , ""IPv6"" , ""IPv6net"" , ""IPv4range"" , ""IPv6range"" , ""ASN1<S2SV_blank>DN"" , ""ASN1<S2SV_blank>GN"" , ""keyid"" , } ; TYPE_21 VAR_10 ; const TYPE_22 * VAR_11 ; METHOD_1 ( ( VAR_12 , ""%s:"" , METHOD_2 ( VAR_13 ) ) ) ; VAR_14 = ( const struct STRUCT_OR_UNION_3 * ) VAR_15 ; METHOD_3 ( * VAR_16 ) ; METHOD_4 ( & VAR_17 , VAR_18 , sizeof ( VAR_19 ) ) ; if ( sizeof ( * VAR_20 ) < VAR_21 ) { VAR_22 = ( const TYPE_23 * ) ( VAR_23 + 1 ) ; VAR_24 = VAR_25 - sizeof ( * VAR_26 ) ; } else { VAR_27 = VAR_28 ; VAR_29 = 0 ; } if 0 METHOD_5 ( ( VAR_30 , ""<S2SV_blank>[phase=%d<S2SV_blank>doi=%d<S2SV_blank>proto=%d]"" , TYPE_24 , TYPE_25 , TYPE_26 ) ) ; switch ( TYPE_27 ) { TYPE_28 TYPE_29 case 1 : default : METHOD_6 ( ( VAR_31 , ""<S2SV_blank>idtype=%s"" , METHOD_7 ( VAR_32 . VAR_33 . VAR_34 , VAR_35 ) ) ) ; METHOD_8 ( ( VAR_36 , ""<S2SV_blank>doi_data=%u"" , ( TYPE_30 ) ( METHOD_9 ( VAR_37 . VAR_38 . VAR_39 ) & 0xffffff ) ) ) ; break ; TYPE_31 TYPE_32 case 1 : case 2 : { const struct STRUCT_OR_UNION_4 * VAR_40 ; struct STRUCT_OR_UNION_5 VAR_41 ; const TYPE_33 * VAR_42 ; VAR_43 = ( const struct STRUCT_OR_UNION_6 * ) VAR_44 ; METHOD_10 ( * VAR_45 ) ; METHOD_11 ( & VAR_46 , VAR_47 , sizeof ( VAR_48 ) ) ; METHOD_12 ( ( VAR_49 , ""<S2SV_blank>idtype=%s"" , METHOD_13 ( VAR_50 . VAR_51 , VAR_52 ) ) ) ; if ( ! VAR_53 -> VAR_54 && VAR_55 . VAR_56 && ( VAR_57 = METHOD_14 ( VAR_58 . VAR_59 ) ) != VAR_60 ) METHOD_15 ( ( VAR_61 , ""<S2SV_blank>protoid=%s"" , VAR_62 ) ) ; else METHOD_16 ( ( VAR_63 , ""<S2SV_blank>protoid=%u"" , VAR_64 . VAR_65 ) ) ; METHOD_17 ( ( VAR_66 , ""<S2SV_blank>port=%d"" , METHOD_18 ( VAR_67 . VAR_68 ) ) ) ; if ( ! VAR_69 ) break ; if ( VAR_70 == VAR_71 ) goto VAR_72 ; METHOD_19 ( * VAR_73 , VAR_74 ) ; switch ( VAR_75 . VAR_76 ) { case VAR_77 : if ( VAR_78 < 4 ) METHOD_20 ( ( VAR_79 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , VAR_80 ) ) ; else METHOD_21 ( ( VAR_81 , ""<S2SV_blank>len=%d<S2SV_blank>%s"" , VAR_82 , METHOD_22 ( VAR_83 , VAR_84 ) ) ) ; VAR_85 = 0 ; break ; case VAR_86 : case VAR_87 : { TYPE_34 VAR_88 ; METHOD_23 ( ( VAR_89 , ""<S2SV_blank>len=%d<S2SV_blank>"" , VAR_90 ) ) ; for ( VAR_91 = 0 ; VAR_92 < VAR_93 ; VAR_94 ++ ) METHOD_24 ( VAR_95 , VAR_96 [ VAR_97 ] ) ; VAR_98 = 0 ; break ; } case VAR_99 : { const TYPE_35 * VAR_100 ; if ( VAR_101 < 8 ) METHOD_25 ( ( VAR_102 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]"" , VAR_103 ) ) ; else { VAR_104 = VAR_105 + sizeof ( struct STRUCT_OR_UNION_7 ) ; METHOD_26 ( ( VAR_106 , ""<S2SV_blank>len=%d<S2SV_blank>%s/%u.%u.%u.%u"" , VAR_107 , METHOD_27 ( VAR_108 , VAR_109 ) , VAR_110 [ 0 ] , VAR_111 [ 1 ] , VAR_112 [ 2 ] , VAR_113 [ 3 ] ) ) ; } VAR_114 = 0 ; break ; } case VAR_115 : if ( VAR_116 < 16 ) METHOD_28 ( ( VAR_117 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>16]"" , VAR_118 ) ) ; else METHOD_29 ( ( VAR_119 , ""<S2SV_blank>len=%d<S2SV_blank>%s"" , VAR_120 , METHOD_30 ( VAR_121 , VAR_122 ) ) ) ; VAR_123 = 0 ; break ; case VAR_124 : { const TYPE_36 * VAR_125 ; <S2SV_StartBug> if ( VAR_126 < 20 ) <S2SV_EndBug> METHOD_31 ( ( VAR_127 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , VAR_128 ) ) ; else { VAR_129 = ( const TYPE_37 * ) ( VAR_130 + sizeof ( struct STRUCT_OR_UNION_8 ) ) ; METHOD_32 ( ( VAR_131 , ""<S2SV_blank>len=%d<S2SV_blank>%s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"" , VAR_132 , METHOD_33 ( VAR_133 , VAR_134 ) , VAR_135 [ 0 ] , VAR_136 [ 1 ] , VAR_137 [ 2 ] , VAR_138 [ 3 ] , VAR_139 [ 4 ] , VAR_140 [ 5 ] , VAR_141 [ 6 ] , VAR_142 [ 7 ] , VAR_143 [ 8 ] , VAR_144 [ 9 ] , VAR_145 [ 10 ] , VAR_146 [ 11 ] , VAR_147 [ 12 ] , VAR_148 [ 13 ] , VAR_149 [ 14 ] , VAR_150 [ 15 ] ) ) ; } VAR_151 = 0 ; break ; } case VAR_152 : if ( VAR_153 < 8 ) METHOD_34 ( ( VAR_154 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]"" , VAR_155 ) ) ; else { METHOD_35 ( ( VAR_156 , ""<S2SV_blank>len=%d<S2SV_blank>%s-%s"" , VAR_157 , METHOD_36 ( VAR_158 , VAR_159 ) , METHOD_37 ( VAR_160 , VAR_161 + sizeof ( struct STRUCT_OR_UNION_9 ) ) ) ) ; } VAR_162 = 0 ; break ; case VAR_163 : if ( VAR_164 < 32 ) METHOD_38 ( ( VAR_165 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , VAR_166 ) ) ; else { METHOD_39 ( ( VAR_167 , ""<S2SV_blank>len=%d<S2SV_blank>%s-%s"" , VAR_168 , METHOD_40 ( VAR_169 , VAR_170 ) , METHOD_41 ( VAR_171 , VAR_172 + sizeof ( struct STRUCT_OR_UNION_10 ) ) ) ) ; } VAR_173 = 0 ; break ; case VAR_174 : case VAR_175 : case VAR_176 : break ; } break ; } } if ( VAR_177 && VAR_178 ) { METHOD_42 ( ( VAR_179 , ""<S2SV_blank>len=%d"" , VAR_180 ) ) ; if ( 2 < VAR_181 -> VAR_182 ) { METHOD_43 ( ( VAR_183 , ""<S2SV_blank>"" ) ) ; if ( ! METHOD_44 ( VAR_184 , ( const TYPE_38 * ) VAR_185 , VAR_186 ) ) goto VAR_187 ; } } return ( const TYPE_39 * ) VAR_188 + VAR_189 ; VAR_190 : METHOD_45 ( ( VAR_191 , ""<S2SV_blank>[|%s]"" , METHOD_46 ( VAR_192 ) ) ) ; return VAR_193 ; }","<S2SV_ModStart> ( VAR_186 < 32 ) METHOD_45 ( ( VAR_191 , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> , VAR_186 )","CWE-125 static const u_char * ikev1_id_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep _U_ , uint32_t phase , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) {   USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id * p ; struct ikev1_pl_id id ; static const char * idtypestr [ ] = { ""IPv4"" , ""IPv4net"" , ""IPv6"" , ""IPv6net"" , } ; static const char * ipsecidtypestr [ ] = { NULL , ""IPv4"" , ""FQDN"" , ""user<S2SV_blank>FQDN"" , ""IPv4net"" , ""IPv6"" , ""IPv6net"" , ""IPv4range"" , ""IPv6range"" , ""ASN1<S2SV_blank>DN"" , ""ASN1<S2SV_blank>GN"" , ""keyid"" , } ; int len ; const u_char * data ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; p = ( const struct ikev1_pl_id * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; if ( sizeof ( * p ) < item_len ) { data = ( const u_char * ) ( p + 1 ) ; len = item_len - sizeof ( * p ) ; } else { data = NULL ; len = 0 ; }  if 0 ND_PRINT ( ( ndo , ""<S2SV_blank>[phase=%d<S2SV_blank>doi=%d<S2SV_blank>proto=%d]"" , phase , doi , proto ) ) ;   switch ( phase ) {  ifndef USE_IPSECDOI_IN_PHASE1 case 1 :   default : ND_PRINT ( ( ndo , ""<S2SV_blank>idtype=%s"" , STR_OR_ID ( id . d . id_type , idtypestr ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>doi_data=%u"" , ( uint32_t ) ( ntohl ( id . d . doi_data ) & 0xffffff ) ) ) ; break ;  ifdef USE_IPSECDOI_IN_PHASE1 case 1 :   case 2 : { const struct ipsecdoi_id * doi_p ; struct ipsecdoi_id doi_id ; const char * p_name ; doi_p = ( const struct ipsecdoi_id * ) ext ; ND_TCHECK ( * doi_p ) ; UNALIGNED_MEMCPY ( & doi_id , ext , sizeof ( doi_id ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>idtype=%s"" , STR_OR_ID ( doi_id . type , ipsecidtypestr ) ) ) ; if ( ! ndo -> ndo_nflag && doi_id . proto_id && ( p_name = netdb_protoname ( doi_id . proto_id ) ) != NULL ) ND_PRINT ( ( ndo , ""<S2SV_blank>protoid=%s"" , p_name ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>protoid=%u"" , doi_id . proto_id ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>port=%d"" , ntohs ( doi_id . port ) ) ) ; if ( ! len ) break ; if ( data == NULL ) goto trunc ; ND_TCHECK2 ( * data , len ) ; switch ( doi_id . type ) { case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , len ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s"" , len , ipaddr_string ( ndo , data ) ) ) ; len = 0 ; break ; case IPSECDOI_ID_FQDN : case IPSECDOI_ID_USER_FQDN : { int i ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>"" , len ) ) ; for ( i = 0 ; i < len ; i ++ ) safeputchar ( ndo , data [ i ] ) ; len = 0 ; break ; } case IPSECDOI_ID_IPV4_ADDR_SUBNET : { const u_char * mask ; if ( len < 8 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]"" , len ) ) ; else { mask = data + sizeof ( struct in_addr ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s/%u.%u.%u.%u"" , len , ipaddr_string ( ndo , data ) , mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] ) ) ; } len = 0 ; break ; } case IPSECDOI_ID_IPV6_ADDR : if ( len < 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>16]"" , len ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s"" , len , ip6addr_string ( ndo , data ) ) ) ; len = 0 ; break ; case IPSECDOI_ID_IPV6_ADDR_SUBNET : { const u_char * mask ; <S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ; else { mask = ( const u_char * ) ( data + sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"" , len , ip6addr_string ( ndo , data ) , mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] , mask [ 4 ] , mask [ 5 ] , mask [ 6 ] , mask [ 7 ] , mask [ 8 ] , mask [ 9 ] , mask [ 10 ] , mask [ 11 ] , mask [ 12 ] , mask [ 13 ] , mask [ 14 ] , mask [ 15 ] ) ) ; } len = 0 ; break ; } case IPSECDOI_ID_IPV4_ADDR_RANGE : if ( len < 8 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]"" , len ) ) ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s-%s"" , len , ipaddr_string ( ndo , data ) , ipaddr_string ( ndo , data + sizeof ( struct in_addr ) ) ) ) ; } len = 0 ; break ; case IPSECDOI_ID_IPV6_ADDR_RANGE : if ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , len ) ) ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>%s-%s"" , len , ip6addr_string ( ndo , data ) , ip6addr_string ( ndo , data + sizeof ( struct in6_addr ) ) ) ) ; } len = 0 ; break ; case IPSECDOI_ID_DER_ASN1_DN : case IPSECDOI_ID_DER_ASN1_GN : case IPSECDOI_ID_KEY_ID : break ; } break ; } } if ( data && len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , len ) ) ; if ( 2 < ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) data , len ) ) goto trunc ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; return NULL ; }","<S2SV_ModStart> ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> , len )"
288,"CWE-416 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 * VAR_3 ; VAR_4 * VAR_5 ; TYPE_5 * VAR_6 ; TYPE_6 * VAR_7 ; TYPE_7 VAR_8 ; * VAR_9 = VAR_10 ; METHOD_1 ( METHOD_2 ( VAR_11 -> VAR_12 , VAR_13 -> VAR_14 , VAR_15 , & VAR_16 ) ) ; switch ( VAR_17 -> VAR_18 ) { case VAR_19 : <S2SV_StartBug> ( ( TYPE_8 * ) VAR_20 ) -> VAR_21 = VAR_22 ; <S2SV_EndBug> break ; case VAR_23 : <S2SV_StartBug> ( ( TYPE_9 * ) VAR_24 ) -> VAR_25 = VAR_26 ; <S2SV_EndBug> break ; case VAR_27 : VAR_28 = ( TYPE_10 * ) VAR_29 ; VAR_30 = ( TYPE_11 * ) VAR_31 ; METHOD_3 ( METHOD_4 ( VAR_32 -> VAR_33 , & VAR_34 -> VAR_35 ) , METHOD_5 ( VAR_36 ) ) ; for ( VAR_37 = 0 ; VAR_38 < VAR_39 ; VAR_40 ++ ) VAR_41 -> VAR_42 [ VAR_43 ] = VAR_44 -> VAR_45 [ VAR_46 ] ; break ; case VAR_47 : VAR_48 = ( ( TYPE_12 * ) VAR_49 ) -> VAR_50 ; while ( VAR_51 != VAR_52 ) { METHOD_6 ( METHOD_7 ( VAR_53 -> VAR_54 , & VAR_55 ) , METHOD_8 ( VAR_56 ) ) ; METHOD_9 ( METHOD_10 ( VAR_57 , VAR_58 ) , METHOD_11 ( VAR_59 ) ; METHOD_12 ( VAR_60 ) ) ; VAR_61 = VAR_62 -> VAR_63 ; } break ; case VAR_64 : METHOD_13 ( ( ( TYPE_13 * ) VAR_65 ) -> VAR_66 , & VAR_67 ) ; ( ( TYPE_14 * ) VAR_68 ) -> VAR_69 = VAR_70 ; break ; case VAR_71 : METHOD_14 ( ( ( TYPE_15 * ) VAR_72 ) -> VAR_73 , & VAR_74 ) ; ( ( TYPE_16 * ) VAR_75 ) -> VAR_76 = VAR_77 ; break ; default : METHOD_15 ( VAR_78 ) ; } * VAR_79 = VAR_80 ; return VAR_81 ; }",<S2SV_ModStart> -> VAR_25 = ( ( TYPE_8 * ) VAR_72 ) -> VAR_25 <S2SV_ModEnd> ; break ; <S2SV_ModStart> case VAR_23 : if ( <S2SV_ModStart> TYPE_9 * ) VAR_72 ) -> VAR_25 != VAR_52 ) { ( ( TYPE_9 * ) VAR_80 ) -> VAR_25 = METHOD_16 ( ( ( TYPE_9 * ) VAR_72 ) -> VAR_25 ) ; } else { ( ( TYPE_9 * ) VAR_80 ) -> VAR_25 = VAR_52 ; } break ; case VAR_82 : ( ( TYPE_17 * ) VAR_80 ) -> VAR_25 = ( ( TYPE_17 * ) VAR_72 ) -> VAR_25 <S2SV_ModEnd> ; break ;,"CWE-416 int yr_object_copy ( YR_OBJECT * object , YR_OBJECT * * object_copy ) { YR_OBJECT * copy ; YR_OBJECT * o ; YR_STRUCTURE_MEMBER * structure_member ; YR_OBJECT_FUNCTION * func ; YR_OBJECT_FUNCTION * func_copy ; int i ; * object_copy = NULL ; FAIL_ON_ERROR ( yr_object_create ( object -> type , object -> identifier , NULL , & copy ) ) ; switch ( object -> type ) { case OBJECT_TYPE_INTEGER : <S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> break ; case OBJECT_TYPE_STRING : <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> break ; case OBJECT_TYPE_FUNCTION : func = ( YR_OBJECT_FUNCTION * ) object ; func_copy = ( YR_OBJECT_FUNCTION * ) copy ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( func -> return_obj , & func_copy -> return_obj ) , yr_object_destroy ( copy ) ) ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) func_copy -> prototypes [ i ] = func -> prototypes [ i ] ; break ; case OBJECT_TYPE_STRUCTURE : structure_member = ( ( YR_OBJECT_STRUCTURE * ) object ) -> members ; while ( structure_member != NULL ) { FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( structure_member -> object , & o ) , yr_object_destroy ( copy ) ) ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_structure_set_member ( copy , o ) , yr_free ( o ) ; yr_object_destroy ( copy ) ) ; structure_member = structure_member -> next ; } break ; case OBJECT_TYPE_ARRAY : yr_object_copy ( ( ( YR_OBJECT_ARRAY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_ARRAY * ) copy ) -> prototype_item = o ; break ; case OBJECT_TYPE_DICTIONARY : yr_object_copy ( ( ( YR_OBJECT_DICTIONARY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_DICTIONARY * ) copy ) -> prototype_item = o ; break ; default : assert ( FALSE ) ; } * object_copy = copy ; return ERROR_SUCCESS ; }",<S2SV_ModStart> -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> ; break ; <S2SV_ModStart> case OBJECT_TYPE_STRING : if ( <S2SV_ModStart> YR_OBJECT_STRING * ) object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> ; break ;
289,"CWE-119 static TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , TYPE_2 * VAR_2 ) { unsigned TYPE_3 VAR_3 ; for ( VAR_4 = 0 ; VAR_5 < VAR_6 ; VAR_7 ++ ) { unsigned TYPE_4 VAR_8 = VAR_9 -> VAR_10 [ VAR_11 ] ; struct STRUCT_OR_UNION_1 * VAR_12 = ( struct STRUCT_OR_UNION_2 * ) ( VAR_13 + VAR_14 ) ; if ( ! ( VAR_15 & ( 1 << VAR_16 ) ) ) continue ; VAR_17 -> VAR_18 . VAR_19 = VAR_20 ; for ( ; ; ) { const struct STRUCT_OR_UNION_3 * VAR_21 = ( TYPE_5 * ) METHOD_1 ( VAR_22 ) ; TYPE_6 VAR_23 = VAR_24 -> VAR_25 & ( 1 << VAR_26 ) ; if ( VAR_27 -> VAR_28 & ( 1 << VAR_29 ) ) { METHOD_2 ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , VAR_30 , VAR_31 , VAR_32 -> VAR_33 ) ; return 0 ; } VAR_34 -> VAR_35 |= ( ( 1 << VAR_36 ) | ( 1 << VAR_37 ) ) ; <S2SV_StartBug> if ( ( VAR_38 -> VAR_39 == sizeof ( struct STRUCT_OR_UNION_4 ) && <S2SV_EndBug> ( METHOD_3 ( VAR_40 -> VAR_41 . VAR_42 . VAR_43 . VAR_44 , VAR_45 ) == 0 ) && <S2SV_StartBug> VAR_46 -> VAR_47 < 0 && METHOD_4 ( & VAR_48 -> VAR_49 ) ) || <S2SV_EndBug> VAR_50 ) { unsigned TYPE_7 VAR_51 , VAR_52 ; if ( ( METHOD_5 ( VAR_53 -> VAR_54 . VAR_55 . VAR_56 . VAR_57 , VAR_58 ) == 0 ) && VAR_59 -> VAR_60 < - VAR_61 - 1 ) { METHOD_6 ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , VAR_62 -> VAR_63 ) ; return 0 ; } do { VAR_64 -> VAR_65 ^= ( 1 << VAR_66 ) ; TYPE_8 TYPE_9 if ( VAR_67 -> VAR_68 & ( 1 << VAR_69 ) ) { METHOD_7 ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , VAR_70 , VAR_71 ) ; } VAR_72 = VAR_73 ; VAR_74 = VAR_75 -> VAR_76 . VAR_77 ; VAR_78 -> VAR_79 . VAR_80 = 0 ; if ( VAR_81 == VAR_82 ) goto VAR_83 ; VAR_84 = ( struct STRUCT_OR_UNION_5 * ) ( VAR_85 + VAR_86 ) ; } while ( VAR_87 == VAR_88 + VAR_89 -> VAR_90 ) ; VAR_91 = VAR_92 -> VAR_93 ; VAR_94 = ( struct STRUCT_OR_UNION_6 * ) ( VAR_95 + VAR_96 + VAR_97 ) ; VAR_98 -> VAR_99 . VAR_100 = VAR_101 ; VAR_102 += VAR_103 ; } else { TYPE_10 VAR_104 = VAR_105 -> VAR_106 ; if ( METHOD_8 ( VAR_107 -> VAR_108 . VAR_109 . VAR_110 . VAR_111 , VAR_112 ) == 0 && VAR_113 >= 0 ) { if ( VAR_114 > VAR_115 -> VAR_116 - sizeof ( struct STRUCT_OR_UNION_7 ) ) { METHOD_9 ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , VAR_117 ) ; return 0 ; } METHOD_10 ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , VAR_118 , VAR_119 ) ; } else { VAR_120 = VAR_121 + VAR_122 -> VAR_123 ; } VAR_124 = ( struct STRUCT_OR_UNION_8 * ) ( VAR_125 + VAR_126 ) ; VAR_127 -> VAR_128 . VAR_129 = VAR_130 ; VAR_131 = VAR_132 ; } } VAR_133 : METHOD_11 ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , VAR_134 ) ; } return 1 ; }",<S2SV_ModStart> if ( ( METHOD_4 ( VAR_127 <S2SV_ModEnd> ) && ( <S2SV_ModStart> VAR_106 < 0 <S2SV_ModEnd> ) || VAR_50,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ;  ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; }   oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }",<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
290,"CWE-200 static VAR_0 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , struct STRUCT_OR_UNION_1 * * VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 = VAR_4 [ VAR_5 ] ; <S2SV_StartBug> if ( ( VAR_6 -> VAR_7 & VAR_8 ) && ! VAR_9 ) <S2SV_EndBug> <S2SV_StartBug> return - VAR_10 ; <S2SV_EndBug> if ( ! VAR_11 ) return 0 ; if ( VAR_12 -> VAR_13 . VAR_14 != VAR_15 ) return - VAR_16 ; if ( VAR_17 -> VAR_18 != 0 ) return - VAR_19 ; return 0 ; }",<S2SV_ModStart> VAR_5 ] ; struct STRUCT_OR_UNION_3 * VAR_20 ; if <S2SV_ModEnd> ( VAR_17 -> <S2SV_ModStart> & VAR_8 ) { if ( <S2SV_ModEnd> ! VAR_11 ) <S2SV_ModStart> - VAR_19 ; VAR_20 = METHOD_1 ( VAR_11 ) ; if ( VAR_20 -> VAR_21 > VAR_22 / sizeof ( VAR_20 -> VAR_23 [ 0 ] ) / 8 ) return - VAR_19 ; if ( METHOD_2 ( VAR_11 ) < METHOD_3 ( VAR_20 ) && METHOD_2 ( VAR_11 ) != sizeof ( * VAR_20 ) ) return - VAR_19 ; },"CWE-200 static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ XFRMA_REPLAY_ESN_VAL ] ; <S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! rt ) return 0 ; if ( p -> id . proto != IPPROTO_ESP ) return - EINVAL ; if ( p -> replay_window != 0 ) return - EINVAL ; return 0 ; }",<S2SV_ModStart> XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> ( p -> <S2SV_ModStart> & XFRM_STATE_ESN ) { if ( <S2SV_ModEnd> ! rt ) <S2SV_ModStart> - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; }
291,"CWE-59 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 VAR_2 = METHOD_1 ( ""/dev/null"" , VAR_3 ) ; while ( VAR_4 < 2 ) VAR_5 = METHOD_2 ( VAR_6 ) ; if ( VAR_7 > 2 ) METHOD_3 ( VAR_8 ) ; TYPE_4 VAR_9 = 1 ; VAR_10 = VAR_11 ; METHOD_4 ( ) ; TYPE_5 VAR_12 ; TYPE_6 VAR_13 ; TYPE_7 VAR_14 ; TYPE_8 VAR_15 ; TYPE_9 VAR_16 ; TYPE_10 VAR_17 ; { TYPE_11 * VAR_18 = METHOD_5 ( ) ; METHOD_6 ( ""CCpp.conf"" , VAR_19 ) ; const TYPE_12 * VAR_20 ; VAR_21 = METHOD_7 ( VAR_22 , ""MakeCompatCore"" ) ; VAR_23 = VAR_24 && METHOD_8 ( VAR_25 ) ; VAR_26 = METHOD_9 ( VAR_27 , ""SaveBinaryImage"" ) ; VAR_28 = VAR_29 && METHOD_10 ( VAR_30 ) ; VAR_31 = METHOD_11 ( VAR_32 , ""SaveFullCore"" ) ; VAR_33 = VAR_34 ? METHOD_12 ( VAR_35 ) : VAR_36 ; VAR_37 = METHOD_13 ( VAR_38 , ""CreateCoreBacktrace"" ) ; VAR_39 = VAR_40 ? METHOD_14 ( VAR_41 ) : VAR_42 ; VAR_43 = METHOD_15 ( VAR_44 , ""SaveContainerizedPackageData"" ) ; VAR_45 = VAR_46 && METHOD_16 ( VAR_47 ) ; if ( ! VAR_48 ) { if ( VAR_49 ) METHOD_17 ( ""Ignoring<S2SV_blank>SaveContainerizedPackageData<S2SV_blank>because<S2SV_blank>ExploreChroots<S2SV_blank>is<S2SV_blank>disabled"" ) ; VAR_50 = VAR_51 ; } VAR_52 = METHOD_18 ( VAR_53 , ""StandaloneHook"" ) ; VAR_54 = VAR_55 && METHOD_19 ( VAR_56 ) ; VAR_57 = METHOD_20 ( VAR_58 , ""VerboseLog"" ) ; if ( VAR_59 ) VAR_60 = METHOD_21 ( VAR_61 ) ; METHOD_22 ( VAR_62 ) ; } if ( VAR_63 == 2 && METHOD_23 ( VAR_64 [ 1 ] , ""--config-test"" ) ) return METHOD_24 ( VAR_65 , VAR_66 ) ; if ( VAR_67 < 8 ) { METHOD_25 ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>GLOBAL_PID<S2SV_blank>[TID]"" , VAR_68 [ 0 ] ) ; } if ( METHOD_26 ( VAR_69 [ 1 ] , '<S2SV_blank>' ) ) { TYPE_13 VAR_70 ; for ( VAR_71 = 1 ; VAR_72 [ VAR_73 ] ; VAR_74 ++ ) { METHOD_27 ( VAR_75 [ VAR_76 ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } VAR_77 = 0 ; const TYPE_14 * VAR_78 = VAR_79 [ 1 ] ; TYPE_15 VAR_80 = METHOD_28 ( VAR_81 ) ; TYPE_16 VAR_82 = METHOD_29 ( VAR_83 [ 2 ] , VAR_84 , 10 ) ; if ( VAR_85 < 0 ) { VAR_86 = ~ ( ( TYPE_17 ) 1 << ( sizeof ( TYPE_18 ) * 8 - 1 ) ) ; } const TYPE_19 * VAR_87 = VAR_88 [ 3 ] ; TYPE_20 VAR_89 = METHOD_30 ( VAR_90 [ 3 ] ) ; TYPE_21 VAR_91 = METHOD_31 ( VAR_92 [ 4 ] ) ; if ( VAR_93 || VAR_94 <= 0 ) { METHOD_32 ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , VAR_95 [ 3 ] , VAR_96 [ 2 ] ) ; } { TYPE_22 * VAR_97 = METHOD_33 ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( VAR_98 && VAR_99 [ 0 ] != '|' ) VAR_100 = VAR_101 ; else METHOD_34 ( VAR_102 ) ; } const TYPE_23 * VAR_103 = VAR_104 [ 8 ] ; TYPE_24 VAR_105 = METHOD_35 ( VAR_106 [ 8 ] ) ; TYPE_25 VAR_107 = - 1 ; const TYPE_26 * VAR_108 = VAR_109 [ 9 ] ; if ( VAR_110 ) { VAR_111 = METHOD_36 ( VAR_112 ) ; } TYPE_27 VAR_113 [ VAR_114 ] ; TYPE_28 * VAR_115 = METHOD_37 ( VAR_116 ) ; if ( VAR_117 && METHOD_38 ( VAR_118 , ""/abrt-hook-ccpp"" ) ) { METHOD_39 ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( TYPE_29 ) VAR_119 , VAR_120 ) ; } VAR_121 = METHOD_40 ( VAR_122 ) ; METHOD_41 ( ""user_pwd:\'%s\'"" , VAR_123 ) ; METHOD_42 ( VAR_124 , ""/proc/%lu/status"" , ( TYPE_30 ) VAR_125 ) ; TYPE_31 * VAR_126 = METHOD_43 ( VAR_127 , VAR_128 ) ; TYPE_32 VAR_129 = VAR_130 ; TYPE_33 VAR_131 = METHOD_44 ( VAR_132 ) ; if ( VAR_133 < 0 ) METHOD_45 ( ""Can\'t<S2SV_blank>parse<S2SV_blank>\'Uid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status"" , ( TYPE_34 ) VAR_134 ) ; const TYPE_35 VAR_135 = METHOD_46 ( VAR_136 ) ; if ( VAR_137 < 0 ) METHOD_47 ( ""Can\'t<S2SV_blank>parse<S2SV_blank>\'Gid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status"" , ( TYPE_36 ) VAR_138 ) ; TYPE_37 VAR_139 = METHOD_48 ( ) ; if ( VAR_140 != VAR_141 ) { VAR_142 = 0 ; if ( VAR_143 == VAR_144 ) VAR_145 = VAR_146 ; else { VAR_147 = VAR_148 ; VAR_149 = 1 ; } } TYPE_38 VAR_150 = - 1 ; if ( VAR_151 && VAR_152 != 0 ) VAR_153 = METHOD_49 ( VAR_154 , VAR_155 , VAR_156 , VAR_157 , & VAR_158 [ 1 ] ) ; if ( VAR_159 == VAR_160 ) { METHOD_50 ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( TYPE_39 ) VAR_161 ) ; return METHOD_51 ( VAR_162 , VAR_163 , VAR_164 ) ; } const TYPE_40 * VAR_165 = VAR_166 ; if ( ! METHOD_52 ( VAR_167 , & VAR_168 ) ) return METHOD_53 ( VAR_169 , VAR_170 , VAR_171 ) ; const TYPE_41 VAR_172 = METHOD_54 ( ) ; if ( ! VAR_173 && ! VAR_174 ) { METHOD_55 ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; return METHOD_56 ( VAR_175 , VAR_176 , VAR_177 ) ; } if ( VAR_178 ) METHOD_57 ( VAR_179 , VAR_180 , ""abrt"" ) ; if ( VAR_181 > 0 ) { if ( METHOD_58 ( VAR_182 , VAR_183 ) ) return METHOD_59 ( VAR_184 , VAR_185 , VAR_186 ) ; } METHOD_60 ( VAR_187 , sizeof ( VAR_188 ) , ""%s/last-ccpp"" , VAR_189 ) ; if ( METHOD_61 ( VAR_190 , VAR_191 ) ) { return METHOD_62 ( VAR_192 , VAR_193 , VAR_194 ) ; } const TYPE_42 * VAR_195 = METHOD_63 ( VAR_196 , '/' ) ; if ( VAR_197 && METHOD_64 ( ++ VAR_198 , ""abrt"" , 4 ) == 0 ) { if ( VAR_199 == 0 ) { METHOD_65 ( ""Ignoring<S2SV_blank>crash<S2SV_blank>of<S2SV_blank>%s<S2SV_blank>(SIG%s)."" , VAR_200 , VAR_201 ? VAR_202 : VAR_203 ) ; goto VAR_204 ; } if ( METHOD_66 ( VAR_205 , sizeof ( VAR_206 ) , ""%s/%s-coredump"" , VAR_207 , VAR_208 ) >= sizeof ( VAR_209 ) ) METHOD_67 ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path"" , VAR_210 ) ; <S2SV_StartBug> TYPE_43 VAR_211 = METHOD_68 ( VAR_212 , VAR_213 | VAR_214 | VAR_215 , 0600 ) ; <S2SV_EndBug> TYPE_44 VAR_216 = METHOD_69 ( VAR_217 , VAR_218 , VAR_219 ) ; if ( VAR_220 < 0 || METHOD_70 ( VAR_221 ) != 0 ) { METHOD_71 ( VAR_222 ) ; METHOD_72 ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , VAR_223 ) ; } METHOD_73 ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( TYPE_45 ) VAR_224 , VAR_225 , VAR_226 , ( TYPE_46 TYPE_47 ) VAR_227 ) ; VAR_228 = 0 ; goto VAR_229 ; } unsigned VAR_230 = METHOD_74 ( VAR_231 , sizeof ( VAR_232 ) , ""%s/ccpp-%s-%lu.new"" , VAR_233 , METHOD_75 ( VAR_234 ) , ( TYPE_48 ) VAR_235 ) ; if ( VAR_236 >= ( sizeof ( VAR_237 ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { return METHOD_76 ( VAR_238 , VAR_239 , VAR_240 ) ; } VAR_241 = METHOD_77 ( VAR_242 , 0 , VAR_243 ) ; if ( VAR_244 ) { TYPE_49 VAR_245 [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( TYPE_50 ) * 3 ] ; TYPE_51 VAR_246 = METHOD_78 ( VAR_247 , ""/proc/%lu/root"" , ( TYPE_52 ) VAR_248 ) ; VAR_249 -= METHOD_79 ( ""root"" ) ; TYPE_53 * VAR_250 = METHOD_80 ( VAR_251 ) ? METHOD_81 ( VAR_252 ) : VAR_253 ; if ( VAR_254 ) { METHOD_82 ( VAR_255 , VAR_256 , ( VAR_257 != VAR_258 ) ? VAR_259 : VAR_260 ) ; } else { METHOD_83 ( VAR_261 , VAR_262 , VAR_263 ) ; } TYPE_54 * VAR_264 = METHOD_84 ( VAR_265 -> VAR_266 , ""also_somewhat_longish_name"" ) ; TYPE_55 * VAR_267 = METHOD_85 ( VAR_268 , '/' ) + 1 ; METHOD_86 ( VAR_269 + VAR_270 , ""maps"" ) ; METHOD_87 ( VAR_271 , VAR_272 , VAR_273 ) ; METHOD_88 ( VAR_274 + VAR_275 , ""limits"" ) ; METHOD_89 ( VAR_276 , VAR_277 , VAR_278 ) ; METHOD_90 ( VAR_279 + VAR_280 , ""cgroup"" ) ; METHOD_91 ( VAR_281 , VAR_282 , VAR_283 ) ; METHOD_92 ( VAR_284 + VAR_285 , ""mountinfo"" ) ; METHOD_93 ( VAR_286 , VAR_287 , VAR_288 ) ; METHOD_94 ( VAR_289 , VAR_290 ) ; METHOD_95 ( VAR_291 + VAR_292 , ""fd"" ) ; METHOD_96 ( VAR_293 , VAR_294 , VAR_295 -> VAR_296 , VAR_297 -> VAR_298 ) ; METHOD_97 ( VAR_299 , VAR_300 ) ; METHOD_98 ( VAR_301 , 1 , VAR_302 , VAR_303 -> VAR_304 , VAR_305 -> VAR_306 ) ; METHOD_99 ( VAR_307 ) ; TYPE_56 * VAR_308 = VAR_309 ; METHOD_100 ( VAR_310 , ""container"" , & VAR_311 ) ; if ( VAR_312 != VAR_313 ) { METHOD_101 ( VAR_314 , VAR_315 , VAR_316 ) ; METHOD_102 ( VAR_317 ) ; VAR_318 = VAR_319 ; } METHOD_103 ( VAR_320 , ""container_uuid"" , & VAR_321 ) ; if ( VAR_322 != VAR_323 ) { METHOD_104 ( VAR_324 , VAR_325 , VAR_326 ) ; METHOD_105 ( VAR_327 ) ; } const TYPE_57 VAR_328 = ( VAR_329 != VAR_330 && METHOD_106 ( VAR_331 , ""/"" ) == 0 ) ; if ( VAR_332 ) { METHOD_107 ( ""Process<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>considered<S2SV_blank>to<S2SV_blank>be<S2SV_blank>containerized"" , VAR_333 ) ; TYPE_58 VAR_334 ; if ( METHOD_108 ( VAR_335 , & VAR_336 ) == 0 ) { TYPE_59 * VAR_337 = METHOD_109 ( VAR_338 ) ; METHOD_110 ( VAR_339 , VAR_340 , VAR_341 ) ; METHOD_111 ( VAR_342 ) ; } } METHOD_112 ( VAR_343 , VAR_344 , ""abrt-ccpp"" ) ; METHOD_113 ( VAR_345 , VAR_346 , ""CCpp"" ) ; METHOD_114 ( VAR_347 , VAR_348 , VAR_349 ) ; METHOD_115 ( VAR_350 , VAR_351 , VAR_352 ) ; METHOD_116 ( VAR_353 , VAR_354 , VAR_355 ) ; METHOD_117 ( VAR_356 , VAR_357 , VAR_358 ) ; if ( VAR_359 ) METHOD_118 ( VAR_360 , VAR_361 , VAR_362 ) ; if ( VAR_363 ) METHOD_119 ( VAR_364 , VAR_365 , VAR_366 ) ; if ( VAR_367 ) { if ( METHOD_120 ( VAR_368 , ""/"" ) != 0 ) METHOD_121 ( VAR_369 , VAR_370 , VAR_371 ) ; } METHOD_122 ( VAR_372 ) ; TYPE_60 * VAR_373 = METHOD_123 ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , VAR_374 , VAR_375 ? VAR_376 : VAR_377 ) ; METHOD_124 ( VAR_378 , VAR_379 , VAR_380 ) ; METHOD_125 ( VAR_381 ) ; TYPE_61 * VAR_382 = METHOD_126 ( VAR_383 ) ; METHOD_127 ( VAR_384 , VAR_385 , VAR_386 ? : """" ) ; METHOD_128 ( VAR_387 ) ; TYPE_62 * VAR_388 = METHOD_129 ( VAR_389 ) ; METHOD_130 ( VAR_390 , VAR_391 , VAR_392 ? : """" ) ; METHOD_131 ( VAR_393 ) ; TYPE_63 * VAR_394 = METHOD_132 ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( VAR_395 ) { if ( METHOD_133 ( VAR_396 , ""0"" ) != 0 ) METHOD_134 ( VAR_397 , ""fips_enabled"" , VAR_398 ) ; METHOD_135 ( VAR_399 ) ; } METHOD_136 ( VAR_400 , VAR_401 , VAR_402 ) ; TYPE_64 unsigned VAR_403 = VAR_404 ; const TYPE_65 * VAR_405 = METHOD_137 ( VAR_406 , ""VmLck:"" ) ; if ( VAR_407 == VAR_408 ) METHOD_138 ( ""/proc/%s/status<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>\'VmLck:\'<S2SV_blank>line"" , VAR_409 ) ; else if ( 1 != METHOD_139 ( VAR_410 + 6 , ""%lu<S2SV_blank>kB\\n"" , & VAR_411 ) ) METHOD_140 ( ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'VmLck:\'<S2SV_blank>line<S2SV_blank>in<S2SV_blank>/proc/%s/status"" , VAR_412 ) ; if ( VAR_413 ) { METHOD_141 ( ""Process<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%lu<S2SV_blank>has<S2SV_blank>locked<S2SV_blank>memory"" , VAR_414 , ( TYPE_66 unsigned ) VAR_415 ) ; METHOD_142 ( VAR_416 , ""The<S2SV_blank>process<S2SV_blank>had<S2SV_blank>locked<S2SV_blank>memory<S2SV_blank>"" ""which<S2SV_blank>usually<S2SV_blank>indicates<S2SV_blank>efforts<S2SV_blank>to<S2SV_blank>protect<S2SV_blank>sensitive<S2SV_blank>"" ""data<S2SV_blank>(passwords)<S2SV_blank>from<S2SV_blank>being<S2SV_blank>written<S2SV_blank>to<S2SV_blank>disk.\\n"" ""In<S2SV_blank>order<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>sensitive<S2SV_blank>information<S2SV_blank>leakages,<S2SV_blank>"" ""ABRT<S2SV_blank>will<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>you<S2SV_blank>to<S2SV_blank>report<S2SV_blank>this<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>"" ""bug<S2SV_blank>tracking<S2SV_blank>tools"" ) ; } if ( VAR_417 ) { if ( METHOD_143 ( VAR_418 , VAR_419 ) ) { METHOD_144 ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , VAR_420 ) ; goto VAR_421 ; } } TYPE_67 VAR_422 = 0 ; if ( VAR_423 ) { METHOD_145 ( VAR_424 + VAR_425 , ""/"" FILENAME_COREDUMP ) ; TYPE_68 VAR_426 = METHOD_146 ( VAR_427 , VAR_428 ) ; VAR_429 = METHOD_147 ( VAR_430 , VAR_431 , VAR_432 , VAR_433 ) ; METHOD_148 ( VAR_434 , VAR_435 ) ; if ( METHOD_149 ( VAR_436 ) != 0 || METHOD_150 ( VAR_437 ) != 0 || VAR_438 < 0 ) { METHOD_151 ( VAR_439 ) ; METHOD_152 ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , VAR_440 ) ; goto VAR_441 ; } } else { METHOD_153 ( VAR_442 , VAR_443 , VAR_444 ) ; } VAR_445 = - 1 ; if 0 { TYPE_69 * VAR_446 = METHOD_154 ( ""/tmp/jvm-%lu/hs_error.log"" , ( TYPE_70 ) VAR_447 ) ; TYPE_71 VAR_448 = METHOD_155 ( VAR_449 , VAR_450 ) ; METHOD_156 ( VAR_451 ) ; if ( VAR_452 < 0 ) { VAR_453 = METHOD_157 ( ""%s/hs_err_pid%lu.log"" , VAR_454 , ( TYPE_72 ) VAR_455 ) ; VAR_456 = METHOD_158 ( VAR_457 , VAR_458 ) ; METHOD_159 ( VAR_459 ) ; } if ( VAR_460 >= 0 ) { METHOD_160 ( VAR_461 + VAR_462 , ""/hs_err.log"" ) ; TYPE_73 VAR_463 = METHOD_161 ( VAR_464 , VAR_465 ) ; TYPE_74 VAR_466 = METHOD_162 ( VAR_467 , VAR_468 , VAR_469 ) ; if ( METHOD_163 ( VAR_470 ) != 0 || VAR_471 < 0 ) { METHOD_164 ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , VAR_472 ) ; goto VAR_473 ; } METHOD_165 ( VAR_474 ) ; } } if ( VAR_475 > 0 && VAR_476 ) METHOD_166 ( VAR_477 , VAR_478 , VAR_479 , VAR_480 ) ; METHOD_167 ( VAR_481 ) ; VAR_482 = VAR_483 ; VAR_484 [ VAR_485 ] = '\\0' ; if ( VAR_486 && VAR_487 && VAR_488 ) { METHOD_168 ( VAR_489 , ""/proc/%lu/root"" , ( TYPE_75 ) VAR_490 ) ; const TYPE_76 * VAR_491 [ 6 ] ; VAR_492 [ 0 ] = VAR_493 ""/abrt-action-save-package-data"" ; VAR_494 [ 1 ] = ""-d"" ; VAR_495 [ 2 ] = VAR_496 ; VAR_497 [ 3 ] = ""-r"" ; VAR_498 [ 4 ] = VAR_499 ; VAR_500 [ 5 ] = VAR_501 ; TYPE_77 VAR_502 = METHOD_169 ( 0 , ( TYPE_78 * * ) VAR_503 , VAR_504 , VAR_505 , VAR_506 , 0 ) ; TYPE_79 VAR_507 ; METHOD_170 ( VAR_508 , & VAR_509 , 0 ) ; } TYPE_80 * VAR_510 = METHOD_171 ( VAR_511 , VAR_512 - ( sizeof ( "".new"" ) - 1 ) ) ; if ( METHOD_172 ( VAR_513 , VAR_514 ) == 0 ) METHOD_173 ( VAR_515 , VAR_516 ) ; METHOD_174 ( VAR_517 ) ; if ( VAR_518 > 0 ) METHOD_175 ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( TYPE_81 ) VAR_519 , VAR_520 , VAR_521 , ( TYPE_82 TYPE_83 ) VAR_522 ) ; if ( VAR_523 ) METHOD_176 ( VAR_524 ) ; if ( VAR_525 > 0 ) { unsigned VAR_526 = VAR_527 + VAR_528 / 4 ; VAR_529 |= 63 ; METHOD_177 ( VAR_530 , VAR_531 * ( TYPE_84 ) ( 1024 * 1024 ) , VAR_532 ) ; } VAR_533 = 0 ; } else { return METHOD_178 ( VAR_534 , VAR_535 , VAR_536 ) ; } VAR_537 : if ( VAR_538 ) METHOD_179 ( VAR_539 ) ; if ( VAR_540 >= 0 ) METHOD_180 ( METHOD_181 ( VAR_541 ) , VAR_542 , 0 ) ; if ( VAR_543 != VAR_544 ) METHOD_182 ( VAR_545 ) ; return VAR_546 ; }","<S2SV_ModStart> VAR_532 ) ; METHOD_151 ( VAR_532 ) ; <S2SV_ModStart> | VAR_214 | VAR_148 <S2SV_ModEnd> , 0600 )","CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; int err = 1 ; logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; bool setting_SaveFullCore ; bool setting_CreateCoreBacktrace ; bool setting_SaveContainerizedPackageData ; bool setting_StandaloneHook ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveFullCore"" ) ; setting_SaveFullCore = value ? string_to_bool ( value ) : true ; value = get_map_string_item_or_NULL ( settings , ""CreateCoreBacktrace"" ) ; setting_CreateCoreBacktrace = value ? string_to_bool ( value ) : true ; value = get_map_string_item_or_NULL ( settings , ""SaveContainerizedPackageData"" ) ; setting_SaveContainerizedPackageData = value && string_to_bool ( value ) ; if ( ! g_settings_explorechroots ) { if ( setting_SaveContainerizedPackageData ) log_warning ( ""Ignoring<S2SV_blank>SaveContainerizedPackageData<S2SV_blank>because<S2SV_blank>ExploreChroots<S2SV_blank>is<S2SV_blank>disabled"" ) ; setting_SaveContainerizedPackageData = false ; } value = get_map_string_item_or_NULL ( settings , ""StandaloneHook"" ) ; setting_StandaloneHook = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } if ( argc == 2 && strcmp ( argv [ 1 ] , ""--config-test"" ) ) return test_configuration ( setting_SaveFullCore , setting_CreateCoreBacktrace ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>GLOBAL_PID<S2SV_blank>[TID]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t local_pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || local_pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } const char * global_pid_str = argv [ 8 ] ; pid_t pid = xatoi_positive ( argv [ 8 ] ) ; pid_t tid = - 1 ; const char * tid_str = argv [ 9 ] ; if ( tid_str ) { tid = xatoi_positive ( tid_str ) ; } char path [ PATH_MAX ] ; char * executable = get_executable ( pid ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; char * proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( proc_pid_status ) ; if ( tmp_fsuid < 0 ) perror_msg_and_die ( ""Can\'t<S2SV_blank>parse<S2SV_blank>\'Uid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status"" , ( long ) pid ) ; const int fsgid = get_fsgid ( proc_pid_status ) ; if ( fsgid < 0 ) error_msg_and_die ( ""Can\'t<S2SV_blank>parse<S2SV_blank>\'Gid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status"" , ( long ) pid ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ; else { g_user_core_flags = O_EXCL ; g_need_nonrelative = 1 ; } } int user_core_fd = - 1 ; if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , fsgid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; return create_user_core ( user_core_fd , pid , ulimit_c ) ; } const char * signame = NULL ; if ( ! signal_is_fatal ( signal_no , & signame ) ) return create_user_core ( user_core_fd , pid , ulimit_c ) ; const int abrtd_running = daemon_is_ok ( ) ; if ( ! setting_StandaloneHook && ! abrtd_running ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; return create_user_core ( user_core_fd , pid , ulimit_c ) ; } if ( setting_StandaloneHook ) ensure_writable_dir ( g_settings_dump_location , DEFAULT_DUMP_LOCATION_MODE , ""abrt"" ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) return create_user_core ( user_core_fd , pid , ulimit_c ) ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { return create_user_core ( user_core_fd , pid , ulimit_c ) ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { if ( g_settings_debug_level == 0 ) { log_warning ( ""Ignoring<S2SV_blank>crash<S2SV_blank>of<S2SV_blank>%s<S2SV_blank>(SIG%s)."" , executable , signame ? signame : signal_str ) ; goto cleanup_and_exit ; } if ( snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path"" , path ) ; <S2SV_StartBug> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <S2SV_EndBug> off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log_notice ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; err = 0 ; goto cleanup_and_exit ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { return create_user_core ( user_core_fd , pid , ulimit_c ) ; } dd = dd_create ( path , 0 , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/root"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""root"" ) ; char * rootdir = process_has_own_root ( pid ) ? get_rootdir ( pid ) : NULL ; if ( g_settings_explorechroots ) { dd_create_basic_files ( dd , fsuid , ( rootdir != NULL ) ? source_filename : NULL ) ; } else { dd_create_basic_files ( dd , fsuid , NULL ) ; } char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; dd_copy_file ( dd , FILENAME_MAPS , source_filename ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; dd_copy_file ( dd , FILENAME_LIMITS , source_filename ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; dd_copy_file ( dd , FILENAME_CGROUP , source_filename ) ; strcpy ( source_filename + source_base_ofs , ""mountinfo"" ) ; dd_copy_file ( dd , FILENAME_MOUNTINFO , source_filename ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; strcpy ( source_filename + source_base_ofs , ""fd"" ) ; dump_fd_info_ext ( dest_filename , source_filename , dd -> dd_uid , dd -> dd_gid ) ; strcpy ( dest_base , FILENAME_NAMESPACES ) ; dump_namespace_diff_ext ( dest_filename , 1 , pid , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; char * tmp = NULL ; get_env_variable ( pid , ""container"" , & tmp ) ; if ( tmp != NULL ) { dd_save_text ( dd , FILENAME_CONTAINER , tmp ) ; free ( tmp ) ; tmp = NULL ; } get_env_variable ( pid , ""container_uuid"" , & tmp ) ; if ( tmp != NULL ) { dd_save_text ( dd , FILENAME_CONTAINER_UUID , tmp ) ; free ( tmp ) ; } const int containerized = ( rootdir != NULL && strcmp ( rootdir , ""/"" ) == 0 ) ; if ( containerized ) { log_debug ( ""Process<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>considered<S2SV_blank>to<S2SV_blank>be<S2SV_blank>containerized"" , pid ) ; pid_t container_pid ; if ( get_pid_of_container ( pid , & container_pid ) == 0 ) { char * container_cmdline = get_cmdline ( container_pid ) ; dd_save_text ( dd , FILENAME_CONTAINER_CMDLINE , container_cmdline ) ; free ( container_cmdline ) ; } } dd_save_text ( dd , FILENAME_ANALYZER , ""abrt-ccpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_GLOBAL_PID , global_pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( tid_str ) dd_save_text ( dd , FILENAME_TID , tid_str ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } free ( rootdir ) ; char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; long unsigned lck_bytes = ULONG_MAX ; const char * vmlck = strstr ( proc_pid_status , ""VmLck:"" ) ; if ( vmlck == NULL ) error_msg ( ""/proc/%s/status<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>\'VmLck:\'<S2SV_blank>line"" , pid_str ) ; else if ( 1 != sscanf ( vmlck + 6 , ""%lu<S2SV_blank>kB\\n"" , & lck_bytes ) ) error_msg ( ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'VmLck:\'<S2SV_blank>line<S2SV_blank>in<S2SV_blank>/proc/%s/status"" , pid_str ) ; if ( lck_bytes ) { log_notice ( ""Process<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%lu<S2SV_blank>has<S2SV_blank>locked<S2SV_blank>memory"" , pid_str , ( long unsigned ) uid ) ; dd_mark_as_notreportable ( dd , ""The<S2SV_blank>process<S2SV_blank>had<S2SV_blank>locked<S2SV_blank>memory<S2SV_blank>"" ""which<S2SV_blank>usually<S2SV_blank>indicates<S2SV_blank>efforts<S2SV_blank>to<S2SV_blank>protect<S2SV_blank>sensitive<S2SV_blank>"" ""data<S2SV_blank>(passwords)<S2SV_blank>from<S2SV_blank>being<S2SV_blank>written<S2SV_blank>to<S2SV_blank>disk.\\n"" ""In<S2SV_blank>order<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>sensitive<S2SV_blank>information<S2SV_blank>leakages,<S2SV_blank>"" ""ABRT<S2SV_blank>will<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>you<S2SV_blank>to<S2SV_blank>report<S2SV_blank>this<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>"" ""bug<S2SV_blank>tracking<S2SV_blank>tools"" ) ; } if ( setting_SaveBinaryImage ) { if ( save_crashing_binary ( pid , dd ) ) { error_msg ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; goto cleanup_and_exit ; } } off_t core_size = 0 ; if ( setting_SaveFullCore ) { strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path , user_core_fd ) ; core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; close_user_core ( user_core_fd , core_size ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; error_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; goto cleanup_and_exit ; } } else { create_user_core ( user_core_fd , pid , ulimit_c ) ; } user_core_fd = - 1 ;  if 0 { char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path , user_core_fd ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { error_msg ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; goto cleanup_and_exit ; } close ( src_fd ) ; } }   if ( tid > 0 && setting_CreateCoreBacktrace ) create_core_backtrace ( tid , executable , signal_no , dd ) ; dd_close ( dd ) ; dd = NULL ; path [ path_len ] = '\\0' ; if ( abrtd_running && setting_SaveContainerizedPackageData && containerized ) { sprintf ( source_filename , ""/proc/%lu/root"" , ( long ) pid ) ; const char * cmd_args [ 6 ] ; cmd_args [ 0 ] = BIN_DIR ""/abrt-action-save-package-data"" ; cmd_args [ 1 ] = ""-d"" ; cmd_args [ 2 ] = path ; cmd_args [ 3 ] = ""-r"" ; cmd_args [ 4 ] = source_filename ; cmd_args [ 5 ] = NULL ; pid_t pid = fork_execv_on_steroids ( 0 , ( char * * ) cmd_args , NULL , NULL , path , 0 ) ; int stat ; safe_waitpid ( pid , & stat , 0 ) ; } char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; if ( core_size > 0 ) log_notice ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; if ( abrtd_running ) notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } err = 0 ; } else { return create_user_core ( user_core_fd , pid , ulimit_c ) ; } cleanup_and_exit : if ( dd ) dd_delete ( dd ) ; if ( user_core_fd >= 0 ) unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return err ; }","<S2SV_ModStart> path ) ; unlink ( path ) ; <S2SV_ModStart> | O_CREAT | O_EXCL <S2SV_ModEnd> , 0600 )"
292,"CWE-295 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , const TYPE_5 * VAR_4 , const TYPE_6 * VAR_5 , TYPE_7 VAR_6 , const TYPE_8 * VAR_7 , const TYPE_9 * VAR_8 , TYPE_10 VAR_9 , TYPE_11 * VAR_10 , TYPE_12 * VAR_11 , TYPE_13 VAR_12 , const TYPE_14 * VAR_13 , TYPE_15 * VAR_14 , <S2SV_StartBug> TYPE_16 VAR_15 , <S2SV_EndBug> TYPE_17 * VAR_16 , TYPE_18 VAR_17 , TYPE_19 VAR_18 , const TYPE_20 * VAR_19 , const TYPE_21 * VAR_20 , const TYPE_22 * * VAR_21 , TYPE_23 * VAR_22 ) { TYPE_24 VAR_23 ; TYPE_25 VAR_24 ; TYPE_26 VAR_25 ; TYPE_27 VAR_26 = VAR_27 -> VAR_28 ; TYPE_28 VAR_29 ; TYPE_29 VAR_30 = 0 ; METHOD_1 ( & VAR_31 , 0 , sizeof ( VAR_32 ) ) ; METHOD_2 ( & VAR_33 , 0 , sizeof ( VAR_34 ) ) ; METHOD_3 ( & VAR_35 , 0 , sizeof ( VAR_36 ) ) ; VAR_37 . VAR_38 = 5 ; VAR_39 . VAR_40 = VAR_41 ; VAR_42 . VAR_43 = VAR_44 -> VAR_45 ; METHOD_4 ( & VAR_46 -> VAR_47 ) ; VAR_48 . VAR_49 = METHOD_5 ( VAR_50 -> VAR_51 , * VAR_52 -> VAR_53 ) ; METHOD_6 ( VAR_54 . VAR_55 ) ; * VAR_56 . VAR_57 = VAR_58 ; VAR_59 = METHOD_7 ( VAR_60 , VAR_61 , VAR_62 , VAR_63 , & VAR_64 ) ; if ( VAR_65 ) goto VAR_66 ; METHOD_8 ( VAR_67 -> VAR_68 == VAR_69 ) METHOD_9 ( VAR_70 -> VAR_71 == VAR_72 ) METHOD_10 ( VAR_73 -> VAR_74 == VAR_75 ) METHOD_11 ( TYPE_30 ) 0 METHOD_12 ( TYPE_31 ) 0 VAR_76 = METHOD_13 ( VAR_77 , VAR_78 , ! VAR_79 . VAR_80 || METHOD_14 || METHOD_15 ( VAR_81 ) || ! ( ( METHOD_16 && METHOD_17 ( VAR_82 ) ) || METHOD_18 ) , & VAR_83 -> VAR_84 , & VAR_85 , METHOD_19 ( VAR_86 , VAR_87 ) , METHOD_20 ( VAR_88 , VAR_89 -> VAR_90 . VAR_91 ) , <S2SV_StartBug> METHOD_21 ( VAR_92 , VAR_93 -> VAR_94 . VAR_95 ) ) ; <S2SV_EndBug> if ( VAR_96 ) goto VAR_97 ; METHOD_22 ( & VAR_98 -> VAR_99 , & VAR_100 . VAR_101 . VAR_102 ) ; METHOD_23 ( & VAR_103 . VAR_104 . VAR_105 , VAR_106 ) ; METHOD_24 ( & VAR_107 -> VAR_108 , & VAR_109 . VAR_110 ) ; METHOD_25 ( & VAR_111 -> VAR_112 , & VAR_113 . VAR_114 ) ; VAR_115 . VAR_116 . VAR_117 = 5 ; VAR_118 . VAR_119 = VAR_120 . VAR_121 ; { TYPE_32 VAR_122 ; VAR_123 = VAR_124 . VAR_125 - * VAR_126 . VAR_127 ; if ( VAR_128 && VAR_129 -> VAR_130 . VAR_131 ) VAR_132 = METHOD_26 ( VAR_133 , * VAR_134 -> VAR_135 . VAR_136 ) ; if ( VAR_137 -> VAR_138 . VAR_139 ) VAR_140 = METHOD_27 ( VAR_141 , * VAR_142 -> VAR_143 . VAR_144 ) ; VAR_145 . VAR_146 = * VAR_147 . VAR_148 + VAR_149 ; } if ( VAR_150 . VAR_151 && VAR_152 -> VAR_153 . VAR_154 && VAR_155 . VAR_156 == VAR_157 && VAR_158 . VAR_159 < * VAR_160 -> VAR_161 && VAR_162 -> VAR_163 != VAR_164 ) { VAR_165 . VAR_166 . VAR_167 = 1 ; METHOD_28 ( VAR_168 . VAR_169 ) ; * VAR_170 . VAR_171 = * VAR_172 -> VAR_173 ; } if ( VAR_174 . VAR_175 ) { TYPE_33 VAR_176 ; VAR_177 = * VAR_178 . VAR_179 - * VAR_180 . VAR_181 ; if ( VAR_182 && VAR_183 -> VAR_184 . VAR_185 ) VAR_186 = METHOD_29 ( VAR_187 , * VAR_188 -> VAR_189 . VAR_190 ) ; if ( VAR_191 -> VAR_192 . VAR_193 ) VAR_194 = METHOD_30 ( VAR_195 , * VAR_196 -> VAR_197 . VAR_198 ) ; * VAR_199 . VAR_200 = * VAR_201 . VAR_202 + VAR_203 ; } if ( VAR_204 . VAR_205 ) { * VAR_206 . VAR_207 = METHOD_31 ( * VAR_208 . VAR_209 , * VAR_210 -> VAR_211 ) ; * VAR_212 . VAR_213 = METHOD_32 ( * VAR_214 . VAR_215 , * VAR_216 . VAR_217 ) ; VAR_218 . VAR_219 = METHOD_33 ( VAR_220 . VAR_221 , * VAR_222 . VAR_223 ) ; } * VAR_224 . VAR_225 = METHOD_34 ( * VAR_226 . VAR_227 , VAR_228 . VAR_229 ) ; if ( * VAR_230 . VAR_231 == VAR_232 . VAR_233 ) { VAR_234 = VAR_235 ; goto VAR_236 ; } if ( VAR_237 . VAR_238 && VAR_239 . VAR_240 == * VAR_241 . VAR_242 ) { METHOD_35 ( VAR_243 . VAR_244 ) ; VAR_245 . VAR_246 = VAR_247 ; VAR_248 . VAR_249 . VAR_250 = 0 ; } VAR_251 . VAR_252 . VAR_253 = VAR_254 -> VAR_255 . VAR_256 ; VAR_257 . VAR_258 . VAR_259 = VAR_260 -> VAR_261 . VAR_262 ; VAR_263 . VAR_264 . VAR_265 = VAR_266 -> VAR_267 . VAR_268 ; VAR_269 . VAR_270 . VAR_271 = VAR_272 -> VAR_273 . VAR_274 . VAR_275 ; if ( VAR_276 -> VAR_277 ) { VAR_278 = METHOD_36 ( VAR_279 , & VAR_280 , VAR_281 , VAR_282 ) ; if ( VAR_283 ) goto VAR_284 ; } if ( VAR_285 ) { unsigned TYPE_34 VAR_286 = 0 ; if ( VAR_287 . VAR_288 == VAR_289 ) { VAR_290 . VAR_291 = METHOD_37 ( 1 , sizeof ( * VAR_292 . VAR_293 ) ) ; if ( VAR_294 . VAR_295 == VAR_296 ) { VAR_297 = VAR_298 ; METHOD_38 ( VAR_299 , VAR_300 , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto VAR_301 ; } } for ( VAR_302 = 0 ; VAR_303 < VAR_304 -> VAR_305 ; VAR_306 ++ ) { VAR_307 = METHOD_39 ( VAR_308 . VAR_309 , & VAR_310 -> VAR_311 [ VAR_312 ] ) ; if ( VAR_313 ) { METHOD_40 ( VAR_314 , VAR_315 , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto VAR_316 ; } } VAR_317 = METHOD_41 ( VAR_318 , VAR_319 . VAR_320 , VAR_321 ) ; if ( VAR_322 == 0 ) { if ( VAR_323 . VAR_324 -> VAR_325 == 1 ) { METHOD_42 ( VAR_326 . VAR_327 ) ; METHOD_43 ( VAR_328 . VAR_329 ) ; VAR_330 . VAR_331 = VAR_332 ; } else { TYPE_35 * VAR_333 = VAR_334 . VAR_335 ; METHOD_44 ( & VAR_336 -> VAR_337 [ VAR_338 -> VAR_339 - 1 ] ) ; VAR_340 -> VAR_341 -- ; } } } VAR_342 = METHOD_45 ( VAR_343 , VAR_344 , & VAR_345 . VAR_346 ) ; if ( VAR_347 ) goto VAR_348 ; VAR_349 . VAR_350 = VAR_351 -> VAR_352 ; VAR_353 . VAR_354 = VAR_355 -> VAR_356 ; VAR_357 . VAR_358 = VAR_359 . VAR_360 ; VAR_361 . VAR_362 . VAR_363 = METHOD_46 ( 1 , sizeof ( * VAR_364 . VAR_365 . VAR_366 ) ) ; if ( VAR_367 . VAR_368 . VAR_369 == VAR_370 ) { VAR_371 = VAR_372 ; goto VAR_373 ; } VAR_374 . VAR_375 . VAR_376 = 1 ; VAR_377 . VAR_378 = VAR_379 -> VAR_380 ; VAR_381 . VAR_382 = VAR_383 . VAR_384 ; VAR_385 . VAR_386 = VAR_387 . VAR_388 ; VAR_389 . VAR_390 = VAR_391 . VAR_392 ; VAR_393 . VAR_394 = VAR_395 . VAR_396 ; VAR_397 . VAR_398 = VAR_399 . VAR_400 ; VAR_401 . VAR_402 = VAR_403 . VAR_404 . VAR_405 ; VAR_406 . VAR_407 = VAR_408 . VAR_409 . VAR_410 ; METHOD_47 ( VAR_411 , VAR_412 , ""TGS-REQ"" , VAR_413 . VAR_414 , VAR_415 . VAR_416 , VAR_417 . VAR_418 , VAR_419 . VAR_420 ) ; { TYPE_36 * VAR_421 = METHOD_48 ( & VAR_422 . VAR_423 ) ; if ( VAR_424 == VAR_425 || METHOD_49 ( VAR_426 , VAR_427 . VAR_428 ) == 0 ) { VAR_429 = METHOD_50 ( VAR_430 , VAR_431 , VAR_432 , VAR_433 , VAR_434 , VAR_435 , VAR_436 , & VAR_437 ) ; if ( VAR_438 ) goto VAR_439 ; } } if ( VAR_440 -> VAR_441 ) { VAR_442 . VAR_443 = METHOD_51 ( 1 , sizeof ( * VAR_444 . VAR_445 ) ) ; if ( VAR_446 . VAR_447 == VAR_448 ) { VAR_449 = VAR_450 ; goto VAR_451 ; } VAR_452 = METHOD_52 ( VAR_453 , VAR_454 . VAR_455 ) ; if ( VAR_456 ) goto VAR_457 ; } if ( METHOD_53 ( VAR_458 , VAR_459 -> VAR_460 ) != 0 && METHOD_54 ( VAR_461 -> VAR_462 . VAR_463 , VAR_464 -> VAR_465 ) ) { METHOD_55 ( VAR_466 , VAR_467 -> VAR_468 ) ; VAR_469 = 1 ; } VAR_470 = METHOD_56 ( VAR_471 , VAR_472 , VAR_473 , 0 , & VAR_474 , & VAR_475 , & VAR_476 , VAR_477 -> VAR_478 , VAR_479 , VAR_480 , 0 , VAR_481 , VAR_482 , VAR_483 , VAR_484 ) ; if ( VAR_485 ) METHOD_57 ( VAR_486 , VAR_487 -> VAR_488 ) ; VAR_489 : METHOD_58 ( & VAR_490 ) ; METHOD_59 ( & VAR_491 . VAR_492 ) ; if ( VAR_493 . VAR_494 ) METHOD_60 ( VAR_495 . VAR_496 ) ; if ( VAR_497 . VAR_498 ) METHOD_61 ( VAR_499 . VAR_500 ) ; if ( VAR_501 . VAR_502 ) { METHOD_62 ( VAR_503 . VAR_504 ) ; METHOD_63 ( VAR_505 . VAR_506 ) ; } METHOD_64 ( & VAR_507 . VAR_508 ) ; METHOD_65 ( VAR_509 . VAR_510 . VAR_511 . VAR_512 , 0 , VAR_513 . VAR_514 . VAR_515 . VAR_516 ) ; METHOD_66 ( & VAR_517 . VAR_518 ) ; return VAR_519 ; }","<S2SV_ModStart> , TYPE_16 VAR_434 , const TYPE_36 * VAR_520 <S2SV_ModStart> VAR_463 ) , VAR_520 <S2SV_ModEnd> ) ; if","CWE-295 static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , <S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) { KDC_REP rep ; EncKDCRepPart ek ; EncTicketPart et ; KDCOptions f = b -> kdc_options ; krb5_error_code ret ; int is_weak = 0 ; memset ( & rep , 0 , sizeof ( rep ) ) ; memset ( & et , 0 , sizeof ( et ) ) ; memset ( & ek , 0 , sizeof ( ek ) ) ; rep . pvno = 5 ; rep . msg_type = krb_tgs_rep ; et . authtime = tgt -> authtime ; _kdc_fix_time ( & b -> till ) ; et . endtime = min ( tgt -> endtime , * b -> till ) ; ALLOC ( et . starttime ) ; * et . starttime = kdc_time ; ret = check_tgs_flags ( context , config , b , tgt , & et ) ; if ( ret ) goto out ;   GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK )   GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL )   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST )   PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0   PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> if ( ret ) goto out ; copy_Realm ( & server_principal -> realm , & rep . ticket . realm ) ; _krb5_principal2principalname ( & rep . ticket . sname , server_principal ) ; copy_Realm ( & tgt_name -> realm , & rep . crealm ) ; copy_PrincipalName ( & tgt_name -> name , & rep . cname ) ; rep . ticket . tkt_vno = 5 ; ek . caddr = et . caddr ; { time_t life ; life = et . endtime - * et . starttime ; if ( client && client -> entry . max_life ) life = min ( life , * client -> entry . max_life ) ; if ( server -> entry . max_life ) life = min ( life , * server -> entry . max_life ) ; et . endtime = * et . starttime + life ; } if ( f . renewable_ok && tgt -> flags . renewable && et . renew_till == NULL && et . endtime < * b -> till && tgt -> renew_till != NULL ) { et . flags . renewable = 1 ; ALLOC ( et . renew_till ) ; * et . renew_till = * b -> till ; } if ( et . renew_till ) { time_t renew ; renew = * et . renew_till - * et . starttime ; if ( client && client -> entry . max_renew ) renew = min ( renew , * client -> entry . max_renew ) ; if ( server -> entry . max_renew ) renew = min ( renew , * server -> entry . max_renew ) ; * et . renew_till = * et . starttime + renew ; } if ( et . renew_till ) { * et . renew_till = min ( * et . renew_till , * tgt -> renew_till ) ; * et . starttime = min ( * et . starttime , * et . renew_till ) ; et . endtime = min ( et . endtime , * et . renew_till ) ; } * et . starttime = min ( * et . starttime , et . endtime ) ; if ( * et . starttime == et . endtime ) { ret = KRB5KDC_ERR_NEVER_VALID ; goto out ; } if ( et . renew_till && et . endtime == * et . renew_till ) { free ( et . renew_till ) ; et . renew_till = NULL ; et . flags . renewable = 0 ; } et . flags . pre_authent = tgt -> flags . pre_authent ; et . flags . hw_authent = tgt -> flags . hw_authent ; et . flags . anonymous = tgt -> flags . anonymous ; et . flags . ok_as_delegate = server -> entry . flags . ok_as_delegate ; if ( rspac -> length ) { ret = _kdc_tkt_add_if_relevant_ad ( context , & et , KRB5_AUTHDATA_WIN2K_PAC , rspac ) ; if ( ret ) goto out ; } if ( auth_data ) { unsigned int i = 0 ; if ( et . authorization_data == NULL ) { et . authorization_data = calloc ( 1 , sizeof ( * et . authorization_data ) ) ; if ( et . authorization_data == NULL ) { ret = ENOMEM ; krb5_set_error_message ( context , ret , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto out ; } } for ( i = 0 ; i < auth_data -> len ; i ++ ) { ret = add_AuthorizationData ( et . authorization_data , & auth_data -> val [ i ] ) ; if ( ret ) { krb5_set_error_message ( context , ret , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto out ; } } ret = find_KRB5SignedPath ( context , et . authorization_data , NULL ) ; if ( ret == 0 ) { if ( et . authorization_data -> len == 1 ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; et . authorization_data = NULL ; } else { AuthorizationData * ad = et . authorization_data ; free_AuthorizationDataElement ( & ad -> val [ ad -> len - 1 ] ) ; ad -> len -- ; } } } ret = krb5_copy_keyblock_contents ( context , sessionkey , & et . key ) ; if ( ret ) goto out ; et . crealm = tgt_name -> realm ; et . cname = tgt_name -> name ; ek . key = et . key ; ek . last_req . val = calloc ( 1 , sizeof ( * ek . last_req . val ) ) ; if ( ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } ek . last_req . len = 1 ; ek . nonce = b -> nonce ; ek . flags = et . flags ; ek . authtime = et . authtime ; ek . starttime = et . starttime ; ek . endtime = et . endtime ; ek . renew_till = et . renew_till ; ek . srealm = rep . ticket . realm ; ek . sname = rep . ticket . sname ; _kdc_log_timestamp ( context , config , ""TGS-REQ"" , et . authtime , et . starttime , et . endtime , et . renew_till ) ; { char * r = get_krbtgt_realm ( & ek . sname ) ; if ( r == NULL || strcmp ( r , ek . srealm ) == 0 ) { ret = _kdc_add_KRB5SignedPath ( context , config , krbtgt , krbtgt_etype , client_principal , NULL , spp , & et ) ; if ( ret ) goto out ; } } if ( enc_pa_data -> len ) { rep . padata = calloc ( 1 , sizeof ( * rep . padata ) ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( enc_pa_data , rep . padata ) ; if ( ret ) goto out ; } if ( krb5_enctype_valid ( context , serverkey -> keytype ) != 0 && _kdc_is_weak_exception ( server -> entry . principal , serverkey -> keytype ) ) { krb5_enctype_enable ( context , serverkey -> keytype ) ; is_weak = 1 ; } ret = _kdc_encode_reply ( context , config , NULL , 0 , & rep , & et , & ek , serverkey -> keytype , kvno , serverkey , 0 , replykey , rk_is_subkey , e_text , reply ) ; if ( is_weak ) krb5_enctype_disable ( context , serverkey -> keytype ) ; out : free_TGS_REP ( & rep ) ; free_TransitedEncoding ( & et . transited ) ; if ( et . starttime ) free ( et . starttime ) ; if ( et . renew_till ) free ( et . renew_till ) ; if ( et . authorization_data ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; } free_LastReq ( & ek . last_req ) ; memset ( et . key . keyvalue . data , 0 , et . key . keyvalue . length ) ; free_EncryptionKey ( & et . key ) ; return ret ; }","<S2SV_ModStart> , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> principal ) , tgt_realm <S2SV_ModEnd> ) ; if"
293,"CWE-400 <S2SV_StartBug> static TYPE_0 METHOD_0 ( unsigned VAR_0 ) <S2SV_EndBug> { <S2SV_StartBug> METHOD_1 ( VAR_1 , VAR_2 ) ; <S2SV_EndBug> }","<S2SV_ModStart> ( unsigned VAR_1 , struct STRUCT_OR_UNION_0 * VAR_3 <S2SV_ModStart> ( VAR_1 , VAR_3 <S2SV_ModEnd> ) ; }","CWE-400 <S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> { <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> }","<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ( cpu , ctrl <S2SV_ModEnd> ) ; }"
294,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; VAR_7 * VAR_8 ; VAR_9 * VAR_10 ; TYPE_8 * VAR_11 ; VAR_12 = METHOD_1 ( VAR_13 ) - VAR_14 ; for ( VAR_15 = 0 ; VAR_16 < VAR_17 ; VAR_18 ++ ) { VAR_19 = VAR_20 + VAR_21 ; if ( VAR_22 -> VAR_23 != VAR_24 ) continue ; if ( VAR_25 -> VAR_26 && VAR_27 -> VAR_28 != VAR_29 ) continue ; if ( VAR_30 == VAR_31 ) if ( VAR_32 -> VAR_33 == sizeof ( VAR_34 ) ) { if ( VAR_35 -> VAR_36 != VAR_37 -> VAR_38 . VAR_39 ) continue ; if ( VAR_40 -> VAR_41 . VAR_42 != 0 ) { if ( VAR_43 -> VAR_44 . VAR_45 != sizeof ( VAR_46 ) ) continue ; if ( VAR_47 -> VAR_48 . VAR_49 != VAR_50 -> VAR_51 . VAR_52 ) continue ; } if ( VAR_53 -> VAR_54 . VAR_55 != 0 ) { if ( VAR_56 -> VAR_57 . VAR_58 != sizeof ( VAR_59 ) ) continue ; if ( VAR_60 -> VAR_61 . VAR_62 != VAR_63 -> VAR_64 . VAR_65 ) continue ; } } else if ( VAR_66 == VAR_67 ) if ( VAR_68 -> VAR_69 == sizeof ( VAR_70 ) ) { if ( VAR_71 -> VAR_72 != VAR_73 -> VAR_74 . VAR_75 ) continue ; if ( VAR_76 -> VAR_77 . VAR_78 != 0 ) { if ( VAR_79 -> VAR_80 . VAR_81 != sizeof ( VAR_82 ) ) continue ; if ( ! METHOD_2 ( & VAR_83 -> VAR_84 . VAR_85 , & VAR_86 -> VAR_87 . VAR_88 ) ) continue ; } if ( VAR_89 -> VAR_90 . VAR_91 != 0 ) { if ( VAR_92 -> VAR_93 . VAR_94 != sizeof ( VAR_95 ) ) continue ; if ( ! METHOD_3 ( & VAR_96 -> VAR_97 . VAR_98 , & VAR_99 -> VAR_100 . VAR_101 ) ) continue ; } } else { continue ; } break ; } if ( VAR_102 >= VAR_103 ) return VAR_104 ; if ( VAR_105 -> VAR_106 == VAR_107 ) { VAR_108 = METHOD_4 ( sizeof ( VAR_109 ) + VAR_110 ) ; if ( VAR_111 != VAR_112 ) { VAR_113 = METHOD_5 ( VAR_114 , 0 ) ; VAR_115 -> VAR_116 = VAR_117 ; VAR_118 -> VAR_119 = VAR_120 ; } else { VAR_121 = VAR_122 ; } } else { VAR_123 = VAR_124 -> VAR_125 ; for ( VAR_126 = 1 ; VAR_127 -> VAR_128 ; VAR_129 ++ ) { VAR_130 = VAR_131 -> VAR_132 ; } if ( VAR_133 >= VAR_134 ) { METHOD_6 ( VAR_135 . VAR_136 [ VAR_137 -> VAR_138 ] . VAR_139 , 1 ) ; METHOD_7 ( VAR_140 [ VAR_141 -> VAR_142 ] . VAR_143 , 1 ) ; return VAR_144 ; } VAR_145 = METHOD_8 ( sizeof ( VAR_146 ) + VAR_147 ) ; if ( VAR_148 != VAR_149 ) { VAR_150 -> VAR_151 = METHOD_9 ( VAR_152 , 0 ) ; VAR_153 = VAR_154 -> VAR_155 ; VAR_156 -> VAR_157 = VAR_158 ; } else { VAR_159 = VAR_160 ; } } if ( VAR_161 == VAR_162 ) { METHOD_10 ( VAR_163 . VAR_164 [ VAR_165 -> VAR_166 ] . VAR_167 , 1 ) ; METHOD_11 ( VAR_168 [ VAR_169 -> VAR_170 ] . VAR_171 , 1 ) ; return VAR_172 ; } VAR_173 -> VAR_174 = VAR_175 ; <S2SV_StartBug> VAR_176 -> VAR_177 = 0 ; <S2SV_EndBug> if ( VAR_178 == VAR_179 ) if ( VAR_180 -> VAR_181 == sizeof ( VAR_182 ) ) { VAR_183 -> VAR_184 . VAR_185 = sizeof ( VAR_186 ) ; VAR_187 -> VAR_188 . VAR_189 = VAR_190 -> VAR_191 . VAR_192 ; VAR_193 -> VAR_194 . VAR_195 = sizeof ( VAR_196 ) ; VAR_197 -> VAR_198 . VAR_199 = VAR_200 -> VAR_201 . VAR_202 ; } if ( VAR_203 == VAR_204 ) if ( VAR_205 -> VAR_206 == sizeof ( VAR_207 ) ) { VAR_208 -> VAR_209 . VAR_210 = sizeof ( VAR_211 ) ; VAR_212 -> VAR_213 . VAR_214 = VAR_215 -> VAR_216 . VAR_217 ; VAR_218 -> VAR_219 . VAR_220 = sizeof ( VAR_221 ) ; VAR_222 -> VAR_223 . VAR_224 = VAR_225 -> VAR_226 . VAR_227 ; } VAR_228 -> VAR_229 = sizeof ( VAR_230 ) ; METHOD_12 ( VAR_231 -> VAR_232 , VAR_233 -> VAR_234 , VAR_235 , VAR_236 , VAR_237 ) ; VAR_238 -> VAR_239 = * VAR_240 ; METHOD_13 ( VAR_241 ) ; return VAR_242 ; }",<S2SV_ModStart> ; VAR_238 -> VAR_169 = VAR_169 ; VAR_238 ->,"CWE-20 error_t rawSocketProcessIpPacket ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { uint_t i ; size_t length ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_RAW_IP ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ;  if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> protocol != pseudoHeader -> ipv4Data . protocol ) continue ; if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else    if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> protocol != pseudoHeader -> ipv6Data . nextHeader ) continue ; if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else   { continue ; } break ; } if ( i >= SOCKET_MAX_COUNT ) return ERROR_PROTOCOL_UNREACHABLE ; if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= RAW_SOCKET_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug>  if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; }    if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; }   queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; rawSocketUpdateEvents ( socket ) ; return NO_ERROR ; }",<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
295,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * const VAR_1 , <S2SV_EndBug> TYPE_3 * * VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , <S2SV_StartBug> TYPE_6 VAR_5 , TYPE_7 VAR_6 ) { <S2SV_EndBug> TYPE_8 * const VAR_7 = & VAR_8 -> VAR_9 ; <S2SV_StartBug> TYPE_9 * const VAR_10 = & VAR_11 -> VAR_12 ; <S2SV_EndBug> TYPE_10 * const VAR_13 = & VAR_14 -> VAR_15 ; <S2SV_StartBug> const TYPE_11 VAR_16 = METHOD_1 ( VAR_17 ) , VAR_18 = ( 1 << VAR_19 ) / 4 ; <S2SV_EndBug> TYPE_12 VAR_20 ; TYPE_13 VAR_21 ; <S2SV_StartBug> TYPE_14 VAR_22 ; <S2SV_EndBug> if ( VAR_23 >= VAR_24 -> VAR_25 || VAR_26 >= VAR_27 -> VAR_28 ) return ; if ( VAR_29 >= VAR_30 ) { VAR_31 = METHOD_2 ( VAR_32 , VAR_33 , VAR_34 , VAR_35 ) ; <S2SV_StartBug> VAR_36 = * METHOD_3 ( VAR_37 , VAR_38 ) ; <S2SV_EndBug> } else { VAR_39 = 0 ; VAR_40 = VAR_41 ; } <S2SV_StartBug> VAR_42 = VAR_43 [ VAR_44 ] [ VAR_45 ] ; <S2SV_EndBug> switch ( VAR_46 ) { case VAR_47 : <S2SV_StartBug> if ( VAR_48 && VAR_49 >= VAR_50 ) <S2SV_EndBug> VAR_51 -> VAR_52 . VAR_53 [ VAR_54 ] [ VAR_55 ] ++ ; <S2SV_StartBug> METHOD_4 ( VAR_56 , VAR_57 , VAR_58 , VAR_59 , VAR_60 , VAR_61 , VAR_62 ) ; <S2SV_EndBug> break ; case VAR_63 : <S2SV_StartBug> if ( VAR_64 ) <S2SV_EndBug> VAR_65 -> VAR_66 . VAR_67 [ VAR_68 ] [ VAR_69 ] ++ ; * METHOD_5 ( VAR_70 , VAR_71 ) = 0 ; METHOD_6 ( VAR_72 , VAR_73 , VAR_74 , VAR_75 , VAR_76 , VAR_77 , VAR_78 ) ; <S2SV_StartBug> if ( VAR_79 + VAR_80 < VAR_81 -> VAR_82 ) { <S2SV_EndBug> * METHOD_7 ( VAR_83 , VAR_84 ) = 1 ; METHOD_8 ( VAR_85 , VAR_86 , VAR_87 , VAR_88 , VAR_89 + VAR_90 , VAR_91 , VAR_92 ) ; } break ; case VAR_93 : <S2SV_StartBug> if ( VAR_94 ) <S2SV_EndBug> VAR_95 -> VAR_96 . VAR_97 [ VAR_98 ] [ VAR_99 ] ++ ; * METHOD_9 ( VAR_100 , VAR_101 ) = 0 ; METHOD_10 ( VAR_102 , VAR_103 , VAR_104 , VAR_105 , VAR_106 , VAR_107 , VAR_108 ) ; <S2SV_StartBug> if ( VAR_109 + VAR_110 < VAR_111 -> VAR_112 ) { <S2SV_EndBug> * METHOD_11 ( VAR_113 , VAR_114 ) = 1 ; METHOD_12 ( VAR_115 , VAR_116 , VAR_117 , VAR_118 + VAR_119 , VAR_120 , VAR_121 , VAR_122 ) ; } break ; case VAR_123 : <S2SV_StartBug> VAR_124 = METHOD_13 ( VAR_125 , VAR_126 ) ; <S2SV_EndBug> if ( VAR_127 ) VAR_128 -> VAR_129 . VAR_130 [ VAR_131 ] [ VAR_132 ] ++ ; * METHOD_14 ( VAR_133 , VAR_134 ) = 0 ; <S2SV_StartBug> METHOD_15 ( VAR_135 , VAR_136 , VAR_137 , VAR_138 , VAR_139 , VAR_140 , VAR_141 ) ; <S2SV_EndBug> * METHOD_16 ( VAR_142 , VAR_143 ) = 1 ; <S2SV_StartBug> METHOD_17 ( VAR_144 , VAR_145 , VAR_146 , VAR_147 , VAR_148 + VAR_149 , VAR_150 , VAR_151 ) ; <S2SV_EndBug> * METHOD_18 ( VAR_152 , VAR_153 ) = 2 ; <S2SV_StartBug> METHOD_19 ( VAR_154 , VAR_155 , VAR_156 , VAR_157 + VAR_158 , VAR_159 , VAR_160 , VAR_161 ) ; <S2SV_EndBug> * METHOD_20 ( VAR_162 , VAR_163 ) = 3 ; METHOD_21 ( VAR_164 , VAR_165 , VAR_166 , VAR_167 + VAR_168 , VAR_169 + VAR_170 , VAR_171 , VAR_172 ) ; break ; default : <S2SV_StartBug> METHOD_22 ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> } if ( VAR_173 != VAR_174 || VAR_175 == VAR_176 ) METHOD_23 ( VAR_177 , VAR_178 , VAR_179 , VAR_180 , VAR_181 ) ; }","<S2SV_ModStart> * VAR_164 , TYPE_15 * VAR_182 , <S2SV_ModStart> , TYPE_14 VAR_181 , TYPE_16 * VAR_183 <S2SV_ModStart> VAR_162 = & VAR_182 <S2SV_ModEnd> -> VAR_12 ; <S2SV_ModStart> TYPE_12 VAR_44 = VAR_184 [ VAR_181 ] <S2SV_ModEnd> , VAR_170 = <S2SV_ModStart> ; TYPE_14 VAR_180 = VAR_181 <S2SV_ModStart> ; VAR_180 = METHOD_13 ( VAR_181 , VAR_183 -> VAR_185 <S2SV_ModEnd> ) ; } <S2SV_ModStart> [ VAR_180 ] ; if ( VAR_171 && VAR_181 != VAR_41 ) VAR_182 -> VAR_129 -> VAR_173 [ VAR_131 ] [ VAR_173 ] ++ <S2SV_ModStart> case VAR_55 : <S2SV_ModEnd> METHOD_12 ( VAR_164 <S2SV_ModStart> , VAR_165 , VAR_182 , VAR_166 , VAR_178 , VAR_179 , VAR_171 , VAR_180 , & VAR_183 -> VAR_186 <S2SV_ModEnd> ) ; break <S2SV_ModStart> case VAR_69 : METHOD_12 ( VAR_164 , VAR_165 , VAR_182 , VAR_166 , VAR_178 , VAR_179 , VAR_171 , VAR_180 , & VAR_183 -> vertical [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> VAR_128 -> VAR_82 && VAR_181 > VAR_176 ) { METHOD_12 ( VAR_164 , VAR_165 , VAR_182 , VAR_166 , VAR_178 , VAR_179 + VAR_170 , VAR_171 , VAR_180 , & VAR_183 -> vertical [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case VAR_99 : METHOD_12 ( VAR_164 , VAR_165 , VAR_182 , VAR_166 , VAR_178 , VAR_179 , VAR_171 , VAR_180 , & VAR_183 -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> VAR_128 -> VAR_112 && VAR_181 > VAR_176 ) { METHOD_12 ( VAR_164 , VAR_165 , VAR_182 , VAR_166 , VAR_178 + VAR_170 , VAR_179 , VAR_171 , VAR_180 , & VAR_183 -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case VAR_174 : if ( VAR_181 == VAR_176 ) { METHOD_12 ( VAR_164 , VAR_165 , VAR_182 , VAR_166 , VAR_178 , VAR_179 , VAR_171 , VAR_180 , VAR_183 -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> METHOD_21 ( VAR_164 <S2SV_ModStart> ( VAR_164 , VAR_182 , VAR_165 , VAR_166 , VAR_178 , VAR_179 , VAR_171 , VAR_180 , VAR_183 -> split [ 0 ] ) ; METHOD_21 ( VAR_164 , VAR_182 , VAR_165 , VAR_166 , VAR_178 , VAR_179 + VAR_170 , VAR_171 , VAR_180 , VAR_183 -> split [ 1 ] ) <S2SV_ModEnd> ; METHOD_21 ( <S2SV_ModStart> ( VAR_164 , VAR_182 , VAR_165 , VAR_166 , VAR_178 + VAR_170 , VAR_179 , VAR_171 , VAR_180 , VAR_183 -> split [ 2 ] ) <S2SV_ModEnd> ; METHOD_21 ( <S2SV_ModStart> ( VAR_164 , VAR_182 , VAR_165 , VAR_166 , VAR_178 + VAR_170 , VAR_179 + VAR_170 , VAR_171 , VAR_180 , VAR_183 -> split [ 3 ] ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> : METHOD_22 ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> ; } if","CWE-119 <S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> int ctx ; PARTITION_TYPE partition ; <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; if ( bsize >= BLOCK_8X8 ) { ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> } else { ctx = 0 ; subsize = BLOCK_4X4 ; } <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ; <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; } break ; case PARTITION_HORZ : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; } break ; case PARTITION_SPLIT : <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 3 ; encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ; break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> ; BLOCK_SIZE subsize = bsize <S2SV_ModStart> ; subsize = get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> ) ; } <S2SV_ModStart> [ subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart> case PARTITION_NONE : <S2SV_ModEnd> encode_b ( cpi <S2SV_ModStart> , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; break <S2SV_ModStart> case PARTITION_VERT : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> encode_sb ( cpi <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> : assert ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> ; } if"
296,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { struct STRUCT_OR_UNION_1 * VAR_4 ; struct STRUCT_OR_UNION_2 * VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 ; struct STRUCT_OR_UNION_5 * VAR_8 ; struct STRUCT_OR_UNION_6 * VAR_9 ; <S2SV_StartBug> METHOD_1 ( & VAR_10 . VAR_11 ) ; <S2SV_EndBug> VAR_12 = VAR_13 . VAR_14 ; if ( VAR_15 ) METHOD_2 ( VAR_16 ) ; METHOD_3 ( & VAR_17 . VAR_18 ) ; if ( VAR_19 == VAR_20 ) return - VAR_21 ; if ( ! ( VAR_22 -> VAR_23 & VAR_24 ) ) return - VAR_25 ; VAR_26 = & VAR_27 -> VAR_28 ; VAR_29 = METHOD_4 ( VAR_30 ) ; if ( VAR_31 == VAR_32 ) { VAR_33 = 0 ; goto VAR_34 ; } VAR_35 = ( struct STRUCT_OR_UNION_7 * ) VAR_36 -> VAR_37 ; VAR_38 = ( struct STRUCT_OR_UNION_8 * ) ( VAR_39 + 1 ) ; VAR_40 -> VAR_41 = sizeof ( struct STRUCT_OR_UNION_9 ) + VAR_42 ; VAR_43 -> VAR_44 = VAR_45 ; VAR_46 -> VAR_47 = VAR_48 ; VAR_49 -> VAR_50 = VAR_51 -> VAR_52 + sizeof ( struct STRUCT_OR_UNION_10 ) ; VAR_53 -> VAR_54 = VAR_55 ; if ( METHOD_5 ( VAR_56 + 1 , VAR_57 , VAR_58 ) ) goto VAR_59 ; METHOD_6 ( & VAR_60 -> VAR_61 [ VAR_62 - 1 ] ) ; VAR_63 = ( struct STRUCT_OR_UNION_11 * ) VAR_64 -> VAR_65 [ VAR_66 - 1 ] ; if ( VAR_67 ) { VAR_68 -> VAR_69 = VAR_70 -> VAR_71 ++ ; if ( VAR_72 -> VAR_73 == 0 ) VAR_74 -> VAR_75 = 1 ; METHOD_7 ( & VAR_76 -> VAR_77 ) ; if ( METHOD_8 ( VAR_78 , 0 , 0 , VAR_79 ) == 0 ) VAR_80 = VAR_81 ; METHOD_9 ( & VAR_82 -> VAR_83 ) ; } METHOD_10 ( & VAR_84 -> VAR_85 [ VAR_86 - 1 ] ) ; VAR_87 : if ( VAR_88 ) { VAR_89 = 0 ; METHOD_11 ( & VAR_90 -> VAR_91 ) ; METHOD_12 ( VAR_92 , VAR_93 ) ; METHOD_13 ( & VAR_94 -> VAR_95 ) ; } METHOD_14 ( VAR_96 ) ; return VAR_97 ; }",<S2SV_ModStart> * VAR_74 ; if ( VAR_97 > sizeof ( VAR_93 -> VAR_37 ) - sizeof ( * VAR_51 ) - sizeof ( * VAR_68 ) ) return - VAR_98 ;,"CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }",<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;
297,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = METHOD_1 ( VAR_1 ) ; struct STRUCT_OR_UNION_3 * VAR_2 ; METHOD_2 ( ""%s:<S2SV_blank>sk:%p\\n"" , VAR_3 , VAR_4 ) ; VAR_5 = METHOD_3 ( VAR_6 ) ; switch ( VAR_7 -> VAR_8 ) { case VAR_9 : VAR_10 -> VAR_11 = VAR_12 ; break ; case VAR_13 : VAR_14 -> VAR_15 = VAR_16 ; break ; default : return - VAR_17 ; } VAR_18 -> VAR_19 = 0 ; VAR_20 -> VAR_21 = 0 ; VAR_22 -> VAR_23 = 0 ; VAR_24 -> VAR_25 = 0 ; VAR_26 -> VAR_27 = 0 ; VAR_28 -> VAR_29 = 0 ; VAR_30 -> VAR_31 = STRUCT_OR_UNION_4 -> VAR_32 . VAR_33 ; VAR_34 -> VAR_35 = STRUCT_OR_UNION_5 -> VAR_36 . VAR_37 ; VAR_38 -> VAR_39 . VAR_40 = VAR_41 ; VAR_42 -> VAR_43 . VAR_44 = VAR_45 ; VAR_46 -> VAR_47 . VAR_48 = STRUCT_OR_UNION_6 -> VAR_49 . VAR_50 ; VAR_51 -> VAR_52 . VAR_53 = STRUCT_OR_UNION_7 -> VAR_54 . VAR_55 ; VAR_56 -> VAR_57 . VAR_58 = STRUCT_OR_UNION_8 -> VAR_59 . VAR_60 ; VAR_61 -> VAR_62 . VAR_63 = STRUCT_OR_UNION_9 -> VAR_64 . VAR_65 ; VAR_66 -> VAR_67 . VAR_68 = STRUCT_OR_UNION_10 -> VAR_69 . VAR_70 ; VAR_71 -> VAR_72 . VAR_73 = STRUCT_OR_UNION_11 -> VAR_74 . VAR_75 ; VAR_76 -> VAR_77 . VAR_78 = 0 ; VAR_79 -> VAR_80 . VAR_81 = 0 ; VAR_82 -> VAR_83 . VAR_84 = 0 ; VAR_85 -> VAR_86 . VAR_87 = STRUCT_OR_UNION_12 -> VAR_88 . VAR_89 ; METHOD_4 ( & VAR_90 -> VAR_91 , 0 , sizeof ( struct STRUCT_OR_UNION_13 ) ) ; VAR_92 -> VAR_93 = STRUCT_OR_UNION_14 -> VAR_94 . VAR_95 ; VAR_96 -> VAR_97 = STRUCT_OR_UNION_15 -> VAR_98 . VAR_99 ; VAR_100 -> VAR_101 = 0 ; VAR_102 -> VAR_103 = STRUCT_OR_UNION_16 -> VAR_104 . VAR_105 ; VAR_106 -> VAR_107 = 2 ; VAR_108 -> VAR_109 = VAR_110 | VAR_111 | VAR_112 ; VAR_113 -> VAR_114 = 0 ; VAR_115 -> VAR_116 = 0 ; VAR_117 -> VAR_118 = 0 ; VAR_119 -> VAR_120 = 0 ; VAR_121 -> VAR_122 = 1 ; VAR_123 -> VAR_124 = 0 ; VAR_125 -> VAR_126 = 0 ; VAR_127 -> VAR_128 = 0 ; VAR_129 -> VAR_130 = METHOD_5 ( VAR_131 -> VAR_132 ) ; METHOD_6 ( & VAR_133 -> VAR_134 , 0 ) ; METHOD_7 ( & VAR_135 -> VAR_136 ) ; VAR_137 -> VAR_138 = 0 ; VAR_139 -> VAR_140 = METHOD_8 ( VAR_141 , VAR_142 ) ; if ( ! VAR_143 -> VAR_144 ) return - VAR_145 ; VAR_146 -> VAR_147 = VAR_148 ; VAR_149 -> VAR_150 = VAR_151 ; METHOD_9 ( STRUCT_OR_UNION_17 ) ; METHOD_10 ( ) ; METHOD_11 ( & VAR_152 ) ; METHOD_12 ( STRUCT_OR_UNION_18 , VAR_153 -> VAR_154 , 1 ) ; if ( STRUCT_OR_UNION_19 -> VAR_155 . VAR_156 ) { <S2SV_StartBug> METHOD_13 ( & VAR_157 -> VAR_158 , <S2SV_EndBug> & STRUCT_OR_UNION_20 -> VAR_159 . VAR_160 ) ; <S2SV_StartBug> VAR_161 -> VAR_162 = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> VAR_163 -> VAR_164 = 0 ; <S2SV_EndBug> METHOD_14 ( ) ; return 0 ; }",<S2SV_ModStart> VAR_156 ) { METHOD_15 ( & METHOD_1 ( VAR_153 ) -> VAR_159 . VAR_165 ) ; <S2SV_ModStart> VAR_164 = 1 ; METHOD_16 ( & METHOD_1 ( VAR_153 ) -> VAR_159 . VAR_165 ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; },"CWE-362 static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( ""%s:<S2SV_blank>sk:%p\\n"" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) { <S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> & net -> sctp . auto_asconf_splist ) ; <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> local_bh_enable ( ) ; return 0 ; }",<S2SV_ModStart> default_auto_asconf ) { spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> do_auto_asconf = 1 ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; }
298,CWE-17 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { if ( METHOD_1 ( & STRUCT_OR_UNION_2 -> VAR_0 ) ) { METHOD_2 ( STRUCT_OR_UNION_3 ) ; <S2SV_StartBug> METHOD_3 ( STRUCT_OR_UNION_4 ) ; <S2SV_EndBug> METHOD_4 ( STRUCT_OR_UNION_5 ) ; } },<S2SV_ModStart> STRUCT_OR_UNION_5 ) ; <S2SV_ModEnd> METHOD_4 ( STRUCT_OR_UNION_5,CWE-17 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } },<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
299,CWE-119 TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = METHOD_1 ( ) ; if ( VAR_2 ) { VAR_3 -> VAR_4 = VAR_5 ; VAR_6 -> VAR_7 = METHOD_2 ( VAR_8 ) ; <S2SV_StartBug> } <S2SV_EndBug> return VAR_9 ; },<S2SV_ModStart> VAR_8 ) ; if ( ! VAR_9 -> VAR_7 ) { METHOD_3 ( VAR_9 ) ; return 0 ; } } <S2SV_ModEnd> return VAR_9 ;,CWE-119 cJSON * cJSON_CreateString ( const char * string ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) { item -> type = cJSON_String ; item -> valuestring = cJSON_strdup ( string ) ; <S2SV_StartBug> } <S2SV_EndBug> return item ; },<S2SV_ModStart> string ) ; if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> return item ;
300,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { TYPE_7 * VAR_6 = ( TYPE_8 * ) VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 VAR_9 = 0 ; METHOD_1 ( & VAR_10 ) ; if ( ! METHOD_2 ( VAR_11 ) ) { VAR_12 = - VAR_13 ; goto VAR_14 ; } if ( VAR_15 == VAR_16 || VAR_17 -> VAR_18 == VAR_19 ) { VAR_20 = - VAR_21 ; goto VAR_22 ; } switch ( VAR_23 ) { case VAR_24 : if ( VAR_25 == VAR_26 || * VAR_27 != sizeof ( TYPE_11 ) ) { VAR_28 = - VAR_29 ; goto VAR_30 ; } if ( VAR_31 -> VAR_32 . METHOD_3 ) * ( TYPE_12 * ) VAR_33 = VAR_34 -> VAR_35 . METHOD_4 ( VAR_36 ) ; else * ( TYPE_13 * ) VAR_37 = 0 ; break ; case VAR_38 : if ( VAR_39 == VAR_40 || VAR_41 != sizeof ( TYPE_14 ) || VAR_42 == VAR_43 || * VAR_44 != sizeof ( TYPE_15 ) ) { VAR_45 = - VAR_46 ; goto VAR_47 ; } * ( TYPE_16 * ) VAR_48 = METHOD_5 ( VAR_49 , ( TYPE_17 * ) VAR_50 ) ; break ; case VAR_51 : if ( VAR_52 == VAR_53 || * VAR_54 != sizeof ( TYPE_18 ) ) { VAR_55 = - VAR_56 ; goto VAR_57 ; } if ( ! VAR_58 -> VAR_59 ) { VAR_60 = - VAR_61 ; goto VAR_62 ; } METHOD_6 ( VAR_63 , ( TYPE_19 * ) VAR_64 ) ; break ; case VAR_65 : if ( VAR_66 -> VAR_67 . METHOD_7 ) VAR_68 -> VAR_69 . METHOD_8 ( VAR_70 ) ; break ; case VAR_71 : if ( VAR_72 == VAR_73 || * VAR_74 != sizeof ( TYPE_20 ) ) { VAR_75 = - VAR_76 ; goto VAR_77 ; } if ( VAR_78 -> VAR_79 != VAR_80 ) { VAR_81 = - VAR_82 ; goto VAR_83 ; } VAR_84 -> VAR_85 = VAR_86 ; if ( VAR_87 -> VAR_88 . METHOD_9 ) VAR_89 -> VAR_90 . METHOD_10 ( VAR_91 ) ; METHOD_11 ( ""%s<S2SV_blank>EFFECT_CMD_ENABLE"" , VAR_92 ) ; * ( TYPE_21 * ) VAR_93 = 0 ; break ; case VAR_94 : if ( VAR_95 == VAR_96 || * VAR_97 != sizeof ( TYPE_22 ) ) { VAR_98 = - VAR_99 ; goto VAR_100 ; } if ( VAR_101 -> VAR_102 != VAR_103 ) { VAR_104 = - VAR_105 ; goto VAR_106 ; } VAR_107 -> VAR_108 = VAR_109 ; if ( VAR_110 -> VAR_111 . METHOD_12 ) VAR_112 -> VAR_113 . METHOD_13 ( VAR_114 ) ; METHOD_14 ( ""%s<S2SV_blank>EFFECT_CMD_DISABLE"" , VAR_115 ) ; * ( TYPE_23 * ) VAR_116 = 0 ; break ; case VAR_117 : { if ( VAR_118 == VAR_119 || VAR_120 < ( TYPE_24 ) ( sizeof ( TYPE_25 ) + sizeof ( TYPE_26 ) ) || VAR_121 == VAR_122 || * VAR_123 < ( TYPE_27 ) ( sizeof ( TYPE_28 ) + sizeof ( TYPE_29 ) + <S2SV_StartBug> sizeof ( VAR_124 ) ) ) { <S2SV_EndBug> VAR_125 = - VAR_126 ; METHOD_15 ( ""EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , VAR_127 , * VAR_128 ) ; goto VAR_129 ; } if ( ! VAR_130 -> VAR_131 ) { VAR_132 = - VAR_133 ; goto VAR_134 ; } TYPE_30 * VAR_135 = ( TYPE_31 * ) VAR_136 ; METHOD_16 ( VAR_137 , VAR_138 , sizeof ( TYPE_32 ) + VAR_139 -> VAR_140 ) ; TYPE_33 * VAR_141 = ( TYPE_34 * ) VAR_142 ; if ( VAR_143 -> VAR_144 . METHOD_17 ) VAR_145 -> VAR_146 . METHOD_18 ( VAR_147 , VAR_148 , VAR_149 ) ; } break ; case VAR_150 : { if ( VAR_151 == VAR_152 || VAR_153 < ( TYPE_35 ) ( sizeof ( TYPE_36 ) + sizeof ( TYPE_37 ) + sizeof ( VAR_154 ) ) || VAR_155 == VAR_156 || * VAR_157 != sizeof ( TYPE_38 ) ) { VAR_158 = - VAR_159 ; METHOD_19 ( ""EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , VAR_160 , * VAR_161 ) ; goto VAR_162 ; } * ( TYPE_39 * ) VAR_163 = 0 ; TYPE_40 * VAR_164 = ( TYPE_41 * ) VAR_165 ; if ( VAR_166 -> VAR_167 . METHOD_20 ) * ( TYPE_42 * ) VAR_168 = VAR_169 -> VAR_170 . METHOD_21 ( VAR_171 , VAR_172 , * VAR_173 ) ; } break ; case VAR_174 : { TYPE_43 VAR_175 ; METHOD_22 ( ""\\t<S2SV_blank>EFFECT_CMD_SET_DEVICE<S2SV_blank>start"" ) ; if ( VAR_176 == VAR_177 || VAR_178 < sizeof ( TYPE_44 ) ) { VAR_179 = - VAR_180 ; METHOD_23 ( ""EFFECT_CMD_SET_DEVICE<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d"" , VAR_181 ) ; goto VAR_182 ; } VAR_183 = * ( TYPE_45 * ) VAR_184 ; if ( VAR_185 -> VAR_186 . METHOD_24 ) VAR_187 -> VAR_188 . METHOD_25 ( VAR_189 , VAR_190 ) ; } break ; case VAR_191 : case VAR_192 : break ; case VAR_193 : { VAR_194 * VAR_195 ; if ( VAR_196 != sizeof ( TYPE_46 ) || VAR_197 == VAR_198 || VAR_199 == VAR_200 || * VAR_201 != sizeof ( TYPE_47 ) ) { METHOD_26 ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>bad<S2SV_blank>format"" , VAR_202 ) ; VAR_203 = - VAR_204 ; break ; } TYPE_48 * VAR_205 = ( TYPE_49 * ) VAR_206 ; METHOD_27 ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>offload<S2SV_blank>%d<S2SV_blank>output<S2SV_blank>%d"" , VAR_207 , VAR_208 -> VAR_209 , VAR_210 -> VAR_211 ) ; * ( TYPE_50 * ) VAR_212 = 0 ; VAR_213 -> VAR_214 = VAR_215 -> VAR_216 ; if ( VAR_217 -> VAR_218 == VAR_219 -> VAR_220 ) break ; VAR_221 = METHOD_28 ( VAR_222 -> VAR_223 ) ; if ( VAR_224 != VAR_225 ) METHOD_29 ( VAR_226 , VAR_227 ) ; VAR_228 -> VAR_229 = VAR_230 -> VAR_231 ; VAR_232 = METHOD_30 ( VAR_233 -> VAR_234 ) ; if ( VAR_235 != VAR_236 ) METHOD_31 ( VAR_237 , VAR_238 ) ; } break ; default : if ( VAR_239 >= VAR_240 && VAR_241 -> VAR_242 . METHOD_32 ) VAR_243 = VAR_244 -> VAR_245 . METHOD_33 ( VAR_246 , VAR_247 , VAR_248 , VAR_249 , VAR_250 , VAR_251 ) ; else { METHOD_34 ( ""%s<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%d"" , VAR_252 , VAR_253 ) ; VAR_254 = - VAR_255 ; } break ; } VAR_256 : METHOD_35 ( & VAR_257 ) ; return VAR_258 ; }",<S2SV_ModStart> ( VAR_154 ) ) || ( ( TYPE_41 * ) VAR_249 ) -> VAR_140 > * VAR_250 - sizeof ( TYPE_41,"CWE-119 int effect_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { effect_context_t * context = ( effect_context_t * ) self ; int retsize ; int status = 0 ; pthread_mutex_lock ( & lock ) ; if ( ! effect_exists ( context ) ) { status = - ENOSYS ; goto exit ; } if ( context == NULL || context -> state == EFFECT_STATE_UNINITIALIZED ) { status = - ENOSYS ; goto exit ; } switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> ops . init ) * ( int * ) pReplyData = context -> ops . init ( context ) ; else * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } * ( int * ) pReplyData = set_config ( context , ( effect_config_t * ) pCmdData ) ; break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { status = - EINVAL ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } get_config ( context , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : if ( context -> ops . reset ) context -> ops . reset ( context ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_INITIALIZED ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_ACTIVE ; if ( context -> ops . enable ) context -> ops . enable ( context ) ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_ENABLE"" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_ACTIVE ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_INITIALIZED ; if ( context -> ops . disable ) context -> ops . disable ( context ) ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_DISABLE"" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + <S2SV_StartBug> sizeof ( uint16_t ) ) ) { <S2SV_EndBug> status = - EINVAL ; ALOGV ( ""EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , cmdSize , * replySize ) ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } effect_param_t * q = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + q -> psize ) ; effect_param_t * p = ( effect_param_t * ) pReplyData ; if ( context -> ops . get_parameter ) context -> ops . get_parameter ( context , p , replySize ) ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { status = - EINVAL ; ALOGV ( ""EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , cmdSize , * replySize ) ; goto exit ; } * ( int32_t * ) pReplyData = 0 ; effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( context -> ops . set_parameter ) * ( int32_t * ) pReplyData = context -> ops . set_parameter ( context , p , * replySize ) ; } break ; case EFFECT_CMD_SET_DEVICE : { uint32_t device ; ALOGV ( ""\\t<S2SV_blank>EFFECT_CMD_SET_DEVICE<S2SV_blank>start"" ) ; if ( pCmdData == NULL || cmdSize < sizeof ( uint32_t ) ) { status = - EINVAL ; ALOGV ( ""EFFECT_CMD_SET_DEVICE<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d"" , cmdSize ) ; goto exit ; } device = * ( uint32_t * ) pCmdData ; if ( context -> ops . set_device ) context -> ops . set_device ( context , device ) ; } break ; case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : break ; case EFFECT_CMD_OFFLOAD : { output_context_t * out_ctxt ; if ( cmdSize != sizeof ( effect_offload_param_t ) || pCmdData == NULL || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>bad<S2SV_blank>format"" , __func__ ) ; status = - EINVAL ; break ; } effect_offload_param_t * offload_param = ( effect_offload_param_t * ) pCmdData ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>offload<S2SV_blank>%d<S2SV_blank>output<S2SV_blank>%d"" , __func__ , offload_param -> isOffload , offload_param -> ioHandle ) ; * ( int * ) pReplyData = 0 ; context -> offload_enabled = offload_param -> isOffload ; if ( context -> out_handle == offload_param -> ioHandle ) break ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) remove_effect_from_output ( out_ctxt , context ) ; context -> out_handle = offload_param -> ioHandle ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) add_effect_to_output ( out_ctxt , context ) ; } break ; default : if ( cmdCode >= EFFECT_CMD_FIRST_PROPRIETARY && context -> ops . command ) status = context -> ops . command ( context , cmdCode , cmdSize , pCmdData , replySize , pReplyData ) ; else { ALOGW ( ""%s<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%d"" , __func__ , cmdCode ) ; status = - EINVAL ; } break ; } exit : pthread_mutex_unlock ( & lock ) ; return status ; }",<S2SV_ModStart> ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t
301,"CWE-404 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; if ( VAR_2 -> VAR_3 ) <S2SV_StartBug> return - VAR_4 ; <S2SV_EndBug> VAR_5 = METHOD_1 ( ""_pid"" , VAR_6 -> VAR_7 , VAR_8 -> VAR_9 , VAR_10 , VAR_11 | VAR_12 , VAR_13 , VAR_14 , VAR_15 ) ; if ( METHOD_2 ( VAR_16 ) ) return METHOD_3 ( VAR_17 ) ; VAR_18 -> VAR_19 = VAR_20 ; return 0 ; }",<S2SV_ModStart> VAR_19 ) return 0 <S2SV_ModEnd> ; VAR_20 =,"CWE-404 int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> process_keyring ) <S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> process_keyring = keyring ; return 0 ; }",<S2SV_ModStart> process_keyring ) return 0 <S2SV_ModEnd> ; keyring =
302,"CWE-416 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { unsigned VAR_2 = METHOD_1 ( VAR_3 -> VAR_4 . VAR_5 ) ; unsigned VAR_6 = METHOD_2 ( VAR_7 -> VAR_8 . VAR_9 ) ; METHOD_3 ( VAR_10 -> VAR_11 . VAR_12 , VAR_13 ) ; METHOD_4 ( VAR_14 -> VAR_15 . VAR_16 , VAR_17 ) ; METHOD_5 ( VAR_18 -> VAR_19 . VAR_20 , VAR_21 -> VAR_22 . VAR_23 ) ; <S2SV_StartBug> METHOD_6 ( ( TYPE_3 * ) & VAR_24 ) ; <S2SV_EndBug> return VAR_25 ; }",<S2SV_ModStart> TYPE_3 * ) <S2SV_ModEnd> VAR_24 ) ;,"CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }",<S2SV_ModStart> ParseCommon * ) <S2SV_ModEnd> append ) ;
303,"CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 , unsigned TYPE_2 VAR_3 , unsigned TYPE_3 VAR_4 , struct STRUCT_OR_UNION_2 * * VAR_5 ) { TYPE_4 VAR_6 = VAR_7 -> VAR_8 & VAR_9 ; struct STRUCT_OR_UNION_3 * VAR_10 = METHOD_1 ( VAR_11 ) ; TYPE_5 VAR_12 ; VAR_13 * VAR_14 ; TYPE_6 VAR_15 ; struct STRUCT_OR_UNION_4 * STRUCT_OR_UNION_5 ; if ( ! * VAR_16 ) { VAR_17 = - VAR_18 ; STRUCT_OR_UNION_6 = METHOD_2 ( VAR_19 , VAR_20 , 0 ) ; if ( METHOD_3 ( STRUCT_OR_UNION_7 ) ) goto VAR_21 ; VAR_22 = METHOD_4 ( STRUCT_OR_UNION_8 , ( const TYPE_7 TYPE_8 * ) VAR_23 , METHOD_5 ( VAR_24 ) , VAR_25 ) ; if ( METHOD_6 ( VAR_26 ) ) { VAR_27 = - VAR_28 ; * VAR_29 = STRUCT_OR_UNION_9 ; goto VAR_30 ; } } else { STRUCT_OR_UNION_10 = * VAR_31 ; * VAR_32 = VAR_33 ; } METHOD_7 ( STRUCT_OR_UNION_11 ) ; METHOD_8 ( STRUCT_OR_UNION_12 ) ; if ( VAR_34 ) { struct STRUCT_OR_UNION_13 * VAR_35 = VAR_36 -> VAR_37 -> VAR_38 ; TYPE_9 VAR_39 = METHOD_9 ( VAR_40 , VAR_41 , VAR_42 ) ; VAR_43 = METHOD_10 ( STRUCT_OR_UNION_14 , VAR_44 , VAR_45 ) ; if ( VAR_46 ) goto VAR_47 ; } VAR_48 = METHOD_11 ( VAR_49 , VAR_50 , VAR_51 ) ; METHOD_12 ( VAR_52 ) ; VAR_53 = - VAR_54 ; if ( ! METHOD_13 ( METHOD_14 ( VAR_55 ) ) ) goto VAR_56 ; if ( VAR_57 ) { METHOD_15 ( STRUCT_OR_UNION_15 , VAR_58 ) ; } else { METHOD_16 ( STRUCT_OR_UNION_16 ) ; METHOD_17 ( STRUCT_OR_UNION_17 , VAR_59 , VAR_60 ) ; } VAR_61 = METHOD_18 ( VAR_62 , STRUCT_OR_UNION_18 , VAR_63 -> VAR_64 & VAR_65 ) ; if ( VAR_66 -> VAR_67 & VAR_68 ) VAR_69 = METHOD_19 ( VAR_70 ) ; VAR_71 = METHOD_20 ( VAR_72 ) ; METHOD_21 ( VAR_73 , VAR_74 , VAR_75 , VAR_76 ) ; ( TYPE_10 ) METHOD_22 ( VAR_77 , VAR_78 , VAR_79 , VAR_80 , VAR_81 -> VAR_82 & VAR_83 ) ; METHOD_23 ( METHOD_24 ( VAR_84 ) , VAR_85 ) ; METHOD_25 ( VAR_86 , VAR_87 , VAR_88 ) ; METHOD_26 ( VAR_89 ) ; if ( VAR_90 ) METHOD_27 ( STRUCT_OR_UNION_19 ) ; VAR_91 = 0 ; VAR_92 : return VAR_93 ; VAR_94 : METHOD_28 ( VAR_95 ) ; <S2SV_StartBug> VAR_96 : <S2SV_EndBug> if ( VAR_97 ) METHOD_29 ( STRUCT_OR_UNION_20 ) ; METHOD_30 ( STRUCT_OR_UNION_21 ) ; goto VAR_98 ; }",<S2SV_ModStart> VAR_95 ) ; if ( VAR_97 ) METHOD_29 ( STRUCT_OR_UNION_21 ) ; VAR_96 : <S2SV_ModEnd> METHOD_30 ( STRUCT_OR_UNION_21,"CWE-000 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { int vm_shared = dst_vma -> vm_flags & VM_SHARED ; struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; if ( vm_shared ) { struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; spin_lock ( ptl ) ; ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; <S2SV_StartBug> out_release_nounlock : <S2SV_EndBug> if ( vm_shared ) unlock_page ( page ) ; put_page ( page ) ; goto out ; }",<S2SV_ModStart> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page
304,CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = VAR_2 ; TYPE_3 * VAR_3 = VAR_4 ; TYPE_4 * VAR_5 ; while ( ( VAR_6 = METHOD_1 ( VAR_7 -> VAR_8 -> VAR_9 . VAR_10 ) ) != VAR_11 ) { VAR_12 = ( TYPE_5 * ) VAR_13 -> VAR_14 ; if ( VAR_15 -> VAR_16 . VAR_17 ) { METHOD_2 ( VAR_18 -> VAR_19 . VAR_20 ) ; } METHOD_3 ( VAR_21 -> VAR_22 ) ; METHOD_4 ( VAR_23 ) ; } while ( ( VAR_24 = METHOD_5 ( VAR_25 -> VAR_26 -> VAR_27 . VAR_28 ) ) != VAR_29 ) { VAR_30 = ( TYPE_6 * ) VAR_31 -> VAR_32 ; if ( VAR_33 -> VAR_34 . VAR_35 ) { METHOD_6 ( VAR_36 -> VAR_37 . VAR_38 ) ; } METHOD_7 ( VAR_39 -> VAR_40 ) ; METHOD_8 ( VAR_41 ) ; } while ( ( VAR_42 = METHOD_9 ( VAR_43 -> VAR_44 -> VAR_45 ) ) != VAR_46 ) { VAR_47 = ( TYPE_7 * ) VAR_48 -> VAR_49 ; METHOD_10 ( VAR_50 -> VAR_51 ) ; METHOD_11 ( VAR_52 ) ; METHOD_12 ( VAR_53 ) ; } while ( ( VAR_54 = METHOD_13 ( VAR_55 -> VAR_56 -> VAR_57 ) ) != VAR_58 ) { VAR_59 = ( TYPE_8 * ) VAR_60 -> VAR_61 ; METHOD_14 ( VAR_62 -> VAR_63 ) ; METHOD_15 ( VAR_64 ) ; METHOD_16 ( VAR_65 ) ; } while ( ( VAR_66 = METHOD_17 ( VAR_67 -> VAR_68 -> VAR_69 . VAR_70 ) ) != VAR_71 ) { <S2SV_StartBug> VAR_72 = ( TYPE_9 * ) VAR_73 -> VAR_74 ; <S2SV_EndBug> METHOD_18 ( VAR_75 -> VAR_76 ) ; METHOD_19 ( VAR_77 ) ; METHOD_20 ( VAR_78 ) ; } },<S2SV_ModStart> VAR_71 ) { VAR_36 = ( TYPE_6 * ) VAR_78 -> VAR_74 ; if ( VAR_36 -> VAR_37 . VAR_38 ) { METHOD_19 ( VAR_36 -> VAR_37 . VAR_38 ) ; } METHOD_19 ( VAR_78 -> VAR_74 <S2SV_ModEnd> ) ; METHOD_20,CWE-119 static void dtls1_clear_queues ( SSL * s ) { pitem * item = NULL ; hm_fragment * frag = NULL ; DTLS1_RECORD_DATA * rdata ; while ( ( item = pqueue_pop ( s -> d1 -> unprocessed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> processed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) { <S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } },<S2SV_ModStart> NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free
305,"CWE-770 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 , struct STRUCT_OR_UNION_2 * VAR_3 , TYPE_2 * VAR_4 ) { struct STRUCT_OR_UNION_3 * VAR_5 = VAR_6 -> VAR_7 ; struct STRUCT_OR_UNION_4 * VAR_8 = VAR_9 -> VAR_10 ; struct STRUCT_OR_UNION_5 * VAR_11 = VAR_12 -> VAR_13 ; struct STRUCT_OR_UNION_6 * VAR_14 , VAR_15 ; <S2SV_StartBug> struct STRUCT_OR_UNION_7 * STRUCT_OR_UNION_8 ; <S2SV_EndBug> struct STRUCT_OR_UNION_9 * VAR_16 = VAR_17 ; <S2SV_StartBug> TYPE_3 VAR_18 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_4 VAR_19 = 500 , VAR_20 = - 1 , VAR_21 , VAR_22 , VAR_23 ; <S2SV_EndBug> TYPE_5 VAR_24 ; TYPE_6 VAR_25 [ 64 ] ; const TYPE_7 * VAR_26 = VAR_27 ; if ( VAR_28 -> VAR_29 != VAR_30 ) return METHOD_1 ( VAR_31 , VAR_32 , VAR_33 , VAR_34 ) ; <S2SV_StartBug> if ( ( STRUCT_OR_UNION_10 = METHOD_2 ( VAR_35 , VAR_36 -> VAR_37 , & VAR_38 ) ) == VAR_39 ) { <S2SV_EndBug> VAR_40 = 416 ; ( TYPE_8 ) METHOD_3 ( VAR_41 , sizeof ( VAR_42 ) , ""bytes<S2SV_blank>*/%lld"" , VAR_43 -> VAR_44 ) ; VAR_45 = VAR_46 ; goto VAR_47 ; } if ( ( VAR_48 = METHOD_4 ( VAR_49 , VAR_50 ) ) == - 1 ) goto VAR_51 ; VAR_52 = METHOD_5 ( VAR_53 , VAR_54 , VAR_55 ) ; <S2SV_StartBug> if ( ( VAR_56 = METHOD_6 ( ) ) == VAR_57 ) { <S2SV_EndBug> VAR_58 = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ; goto VAR_59 ; } if ( VAR_60 == 1 ) { <S2SV_StartBug> ( TYPE_9 ) METHOD_7 ( VAR_61 , sizeof ( VAR_62 ) , <S2SV_EndBug> ""bytes<S2SV_blank>%lld-%lld/%lld"" , STRUCT_OR_UNION_11 -> VAR_63 , STRUCT_OR_UNION_12 -> VAR_64 , VAR_65 -> VAR_66 ) ; if ( METHOD_8 ( & VAR_67 -> VAR_68 , ""Content-Range"" , VAR_69 ) == VAR_70 ) goto VAR_71 ; <S2SV_StartBug> VAR_72 = STRUCT_OR_UNION_13 -> VAR_73 - STRUCT_OR_UNION_14 -> VAR_74 + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( METHOD_9 ( VAR_75 , VAR_76 , STRUCT_OR_UNION_15 ) == 0 ) <S2SV_EndBug> goto VAR_77 ; } else { <S2SV_StartBug> VAR_78 = 0 ; <S2SV_EndBug> VAR_79 = METHOD_10 ( ) ; while ( VAR_80 -- ) { if ( ( VAR_81 = METHOD_11 ( VAR_82 , ""\\r\\n--%ud\\r\\n"" , VAR_83 ) ) == - 1 ) goto VAR_84 ; <S2SV_StartBug> VAR_85 += VAR_86 ; <S2SV_EndBug> if ( ( VAR_87 = METHOD_12 ( VAR_88 , ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" , VAR_89 -> STRUCT_OR_UNION_16 , VAR_90 -> VAR_91 ) ) == - 1 ) goto VAR_92 ; VAR_93 += VAR_94 ; if ( ( VAR_95 = METHOD_13 ( VAR_96 , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , STRUCT_OR_UNION_17 -> VAR_97 , STRUCT_OR_UNION_18 -> VAR_98 , VAR_99 -> VAR_100 ) ) == - 1 ) goto VAR_101 ; VAR_102 += VAR_103 ; if ( METHOD_14 ( VAR_104 , VAR_105 , STRUCT_OR_UNION_19 ) == 0 ) goto VAR_106 ; VAR_107 += STRUCT_OR_UNION_20 -> VAR_108 - STRUCT_OR_UNION_21 -> VAR_109 + 1 ; <S2SV_StartBug> STRUCT_OR_UNION_22 ++ ; <S2SV_EndBug> } <S2SV_StartBug> if ( ( VAR_110 = METHOD_15 ( VAR_111 , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> VAR_112 ) ) == - 1 ) goto VAR_113 ; <S2SV_StartBug> VAR_114 += VAR_115 ; <S2SV_EndBug> ( TYPE_10 ) METHOD_16 ( VAR_116 . STRUCT_OR_UNION_23 , ""multipart"" , sizeof ( VAR_117 . STRUCT_OR_UNION_24 ) ) ; ( TYPE_11 ) METHOD_17 ( VAR_118 . VAR_119 , sizeof ( VAR_120 . VAR_121 ) , <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , VAR_122 ) ; <S2SV_EndBug> VAR_123 = & VAR_124 ; } <S2SV_StartBug> METHOD_18 ( VAR_125 ) ; <S2SV_EndBug> VAR_126 = - 1 ; VAR_127 = METHOD_19 ( VAR_128 , 206 , VAR_129 , VAR_130 , METHOD_20 ( METHOD_21 ( VAR_131 ) , VAR_132 -> VAR_133 . VAR_134 ) ) ; switch ( VAR_135 ) { case - 1 : goto VAR_136 ; case 0 : <S2SV_StartBug> goto VAR_137 ; <S2SV_EndBug> default : break ; } <S2SV_StartBug> if ( METHOD_22 ( VAR_138 , VAR_139 ) == - 1 ) <S2SV_EndBug> goto VAR_140 ; <S2SV_StartBug> METHOD_23 ( VAR_141 -> VAR_142 , VAR_143 | VAR_144 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_145 -> VAR_146 ) <S2SV_EndBug> VAR_147 -> VAR_148 = VAR_149 ; else VAR_150 -> VAR_151 = VAR_152 ; VAR_153 -> VAR_154 = 0 ; VAR_155 : METHOD_24 ( VAR_156 ) ; METHOD_25 ( VAR_157 ) ; return ( 0 ) ; VAR_158 : METHOD_26 ( VAR_159 -> VAR_160 , VAR_161 | VAR_162 ) ; METHOD_27 ( VAR_163 -> VAR_164 ) ; VAR_165 -> VAR_166 = VAR_167 ; VAR_168 : <S2SV_StartBug> if ( VAR_169 != VAR_170 ) <S2SV_EndBug> METHOD_28 ( VAR_171 ) ; if ( VAR_172 != - 1 ) METHOD_29 ( VAR_173 ) ; if ( VAR_174 == VAR_175 ) VAR_176 = METHOD_30 ( VAR_177 ) ; METHOD_31 ( VAR_178 , VAR_179 , VAR_180 ) ; return ( - 1 ) ; }","<S2SV_ModStart> VAR_124 ; struct STRUCT_OR_UNION_25 * VAR_181 = & VAR_178 -> VAR_182 ; struct STRUCT_OR_UNION_22 * STRUCT_OR_UNION_22 <S2SV_ModEnd> ; TYPE_3 VAR_130 <S2SV_ModStart> ; TYPE_3 VAR_130 = 0 <S2SV_ModStart> VAR_80 , VAR_135 <S2SV_ModEnd> ; TYPE_7 VAR_69 <S2SV_ModStart> if ( ( VAR_80 = METHOD_32 ( VAR_178 , <S2SV_ModEnd> VAR_35 , VAR_132 <S2SV_ModStart> VAR_132 -> VAR_100 ) ) < 1 <S2SV_ModEnd> ) { VAR_179 <S2SV_ModStart> VAR_55 ) ; VAR_181 -> VAR_183 = VAR_129 ; <S2SV_ModEnd> if ( VAR_80 <S2SV_ModStart> 1 ) { STRUCT_OR_UNION_22 = & VAR_181 -> STRUCT_OR_UNION_22 [ 0 ] ; <S2SV_ModStart> goto VAR_168 ; STRUCT_OR_UNION_22 = & VAR_181 -> STRUCT_OR_UNION_22 [ 0 ] ; VAR_130 += <S2SV_ModEnd> STRUCT_OR_UNION_22 -> VAR_108 <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & VAR_178 -> VAR_184 , sizeof ( VAR_178 -> VAR_184 ) ) ; for ( VAR_115 = 0 ; VAR_115 < VAR_80 ; VAR_115 ++ ) { STRUCT_OR_UNION_22 = & VAR_181 -> STRUCT_OR_UNION_22 [ VAR_115 ] ; if ( ( VAR_135 = METHOD_17 ( VAR_175 , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , VAR_178 -> VAR_184 , VAR_129 -> STRUCT_OR_UNION_24 , VAR_129 -> VAR_121 , STRUCT_OR_UNION_22 -> VAR_109 , STRUCT_OR_UNION_22 -> VAR_108 , VAR_132 -> VAR_100 ) ) < 0 <S2SV_ModEnd> ) goto VAR_168 <S2SV_ModStart> ; VAR_130 += VAR_135 + <S2SV_ModEnd> STRUCT_OR_UNION_22 -> VAR_108 <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( VAR_135 = METHOD_17 ( VAR_175 , 0 , ""\\r\\n--%llu--\\r\\n"" , VAR_178 -> VAR_184 ) ) < 0 <S2SV_ModEnd> ) goto VAR_168 <S2SV_ModStart> ; VAR_130 += VAR_135 <S2SV_ModEnd> ; ( TYPE_11 <S2SV_ModStart> VAR_121 ) , ""byteranges;<S2SV_blank>boundary=%llu"" , VAR_178 -> VAR_184 <S2SV_ModEnd> ) ; VAR_129 <S2SV_ModStart> VAR_124 ; } VAR_181 -> VAR_185 = VAR_186 <S2SV_ModEnd> ; VAR_135 = <S2SV_ModStart> case 0 : METHOD_29 ( VAR_173 ) ; <S2SV_ModStart> break ; } VAR_178 -> VAR_187 = VAR_173 ; if ( VAR_178 -> VAR_188 != VAR_175 ) METHOD_27 ( VAR_178 -> VAR_188 ) ; VAR_178 -> VAR_189 = 0 ; VAR_178 -> VAR_188 = METHOD_33 ( VAR_178 -> VAR_187 , VAR_190 , VAR_191 , VAR_192 , VAR_178 ) ; if ( VAR_178 -> VAR_188 == VAR_175 ) { VAR_180 = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> goto VAR_158 ; <S2SV_ModStart> goto VAR_158 ; } METHOD_34 ( VAR_178 -> VAR_188 , VAR_161 , 0 , VAR_178 -> VAR_193 ) ; METHOD_35 ( VAR_178 -> VAR_188 , VAR_54 -> VAR_194 . VAR_134 , VAR_54 -> VAR_194 . VAR_134 ) ; METHOD_23 ( VAR_178 -> VAR_188 , VAR_161 ) ; METHOD_26 ( VAR_178 -> VAR_166 , VAR_161 ) ; VAR_155 : METHOD_25 ( VAR_178 ) ; return ( 0 ) ; VAR_158 : METHOD_26 <S2SV_ModEnd> ( VAR_178 -> <S2SV_ModStart> VAR_162 ) ; <S2SV_ModEnd> METHOD_27 ( VAR_178 <S2SV_ModStart> ; VAR_168 : <S2SV_ModEnd> if ( VAR_173","CWE-770 int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ; <S2SV_StartBug> struct range * range ; <S2SV_EndBug> struct evbuffer * evb = NULL ; <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ; <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>*/%lld"" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ; <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ; goto abort ; } if ( nranges == 1 ) { <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , ""Content-Range"" , content_range ) == NULL ) goto abort ; <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> goto abort ; } else { <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> boundary = arc4random ( ) ; while ( nranges -- ) { if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud\\r\\n"" , boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" , media -> media_type , media -> media_subtype ) ) == - 1 ) goto abort ; content_length += i ; if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , range -> start , range -> end , st -> st_size ) ) == - 1 ) goto abort ; content_length += i ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; content_length += range -> end - range -> start + 1 ; <S2SV_StartBug> range ++ ; <S2SV_EndBug> } <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> ( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ; ( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> media = & multipart_media ; } <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> fd = - 1 ; ret = server_response_http ( clt , 206 , media , content_length , MINIMUM ( time ( NULL ) , st -> st_mtim . tv_sec ) ) ; switch ( ret ) { case - 1 : goto fail ; case 0 : <S2SV_StartBug> goto done ; <S2SV_EndBug> default : break ; } <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> clt -> clt_toread = TOREAD_HTTP_HEADER ; else clt -> clt_toread = TOREAD_HTTP_NONE ; clt -> clt_done = 0 ; done : evbuffer_free ( evb ) ; server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; bufferevent_free ( clt -> clt_bev ) ; clt -> clt_bev = NULL ; abort : <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> evbuffer_free ( evb ) ; if ( fd != - 1 ) close ( fd ) ; if ( errstr == NULL ) errstr = strerror ( errno ) ; server_abort_http ( clt , code , errstr ) ; return ( - 1 ) ; }","<S2SV_ModStart> multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> ; size_t content_length <S2SV_ModStart> ; size_t content_length = 0 <S2SV_ModStart> nranges , ret <S2SV_ModEnd> ; char content_range <S2SV_ModStart> if ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , st <S2SV_ModStart> st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code <S2SV_ModStart> path ) ; r -> range_media = media ; <S2SV_ModEnd> if ( nranges <S2SV_ModStart> 1 ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret + <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret <S2SV_ModEnd> ; ( void <S2SV_ModStart> media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> ) ; media <S2SV_ModStart> multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = <S2SV_ModStart> case 0 : close ( fd ) ; <S2SV_ModStart> break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> <S2SV_ModStart> EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt <S2SV_ModStart> ; abort : <S2SV_ModEnd> if ( fd"
306,"CWE-416 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { unsigned TYPE_1 VAR_1 = VAR_2 -> VAR_3 ; TYPE_2 VAR_4 ; if ( ! VAR_5 ) return - VAR_6 ; <S2SV_StartBug> VAR_7 -> VAR_8 = VAR_9 ; <S2SV_EndBug> switch ( VAR_10 -> VAR_11 ) { case 1 : VAR_12 -> VAR_13 = VAR_14 ; VAR_15 -> VAR_16 = VAR_17 ; break ; case 2 : VAR_18 -> VAR_19 = VAR_20 ; VAR_21 -> VAR_22 = VAR_23 ; break ; case 4 : VAR_24 -> VAR_25 = VAR_26 ; VAR_27 -> VAR_28 = VAR_29 ; break ; default : METHOD_1 ( VAR_30 -> VAR_31 , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , VAR_32 -> VAR_33 ) ; return - VAR_34 ; } for ( VAR_35 = 0 ; VAR_36 < VAR_37 -> VAR_38 ; VAR_39 ++ ) { if ( METHOD_2 ( VAR_40 + VAR_41 * VAR_42 -> VAR_43 , VAR_44 -> VAR_45 , VAR_46 ) == VAR_47 ) { while ( VAR_48 -- ) METHOD_3 ( VAR_49 + VAR_50 * VAR_51 -> VAR_52 , VAR_53 -> VAR_54 ) ; return - VAR_55 ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> - VAR_6 ; <S2SV_ModEnd> switch ( VAR_53 <S2SV_ModStart> ; } } VAR_53 -> VAR_8 = VAR_9 ;,"CWE-416 int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> ; } } io -> io_cleanup = port_cleanup ;
307,"CWE-79 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , const TYPE_4 * VAR_3 , const TYPE_5 * VAR_4 ) { METHOD_1 ( VAR_5 , ""enter"" ) ; const TYPE_6 * VAR_6 = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; TYPE_7 * VAR_7 = METHOD_2 ( VAR_8 -> VAR_9 , VAR_10 ) ; TYPE_8 VAR_11 ; METHOD_3 ( VAR_12 -> VAR_13 , VAR_14 , & VAR_15 ) ; TYPE_9 * VAR_16 = METHOD_4 ( VAR_17 , VAR_18 . VAR_19 ) ; * VAR_20 = '\\0' ; const TYPE_10 * VAR_21 = ""openidc-op"" ; const TYPE_11 * VAR_22 = METHOD_5 ( VAR_23 , VAR_24 ) ; if ( VAR_25 == VAR_26 ) { METHOD_6 ( VAR_27 , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return VAR_28 ; } TYPE_12 * VAR_29 = VAR_30 ; METHOD_7 ( VAR_31 , ""poll"" , & VAR_32 ) ; <S2SV_StartBug> if ( VAR_33 == VAR_34 ) <S2SV_EndBug> VAR_35 = ""3000"" ; const TYPE_13 * VAR_36 = METHOD_8 ( VAR_37 , VAR_38 ) ; VAR_39 = METHOD_9 ( VAR_40 -> VAR_41 , VAR_42 , VAR_43 , VAR_44 , <S2SV_StartBug> VAR_45 , VAR_46 , VAR_47 , VAR_48 , <S2SV_EndBug> VAR_49 ) ; return METHOD_10 ( VAR_50 , VAR_51 , VAR_52 , ""setTimer"" , VAR_53 , VAR_54 ) ; }","<S2SV_ModStart> ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" <S2SV_ModStart> VAR_47 ) ; TYPE_0 VAR_57 = VAR_47 ? METHOD_11 ( VAR_47 , VAR_53 , 10 ) : 0 ; if ( ( VAR_57 <= 0 ) || ( VAR_57 > 3600 * 24 ) ) VAR_57 = 3000 <S2SV_ModEnd> ; const TYPE_13 <S2SV_ModStart> , VAR_46 , VAR_57 <S2SV_ModEnd> , VAR_49 ,","CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }","<S2SV_ModStart> ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,"
308,"CWE-399 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 TYPE_4 , VAR_3 * VAR_4 , VAR_5 * VAR_6 TYPE_5 , TYPE_6 * * VAR_7 , TYPE_7 VAR_8 ) { TYPE_8 VAR_9 , VAR_10 ; TYPE_9 * VAR_11 ; if ( VAR_12 % 2 ) VAR_13 += 2 - ( VAR_14 % 2 ) ; <S2SV_StartBug> VAR_15 = METHOD_1 ( VAR_16 , VAR_17 ) ; <S2SV_EndBug> if ( VAR_18 <= 0 ) { if ( VAR_19 ) * VAR_20 = METHOD_2 ( """" ) ; return VAR_21 ; } VAR_22 = METHOD_3 ( VAR_23 , VAR_24 , VAR_25 , VAR_26 , VAR_27 | VAR_28 ) ; VAR_29 = ( TYPE_10 ) METHOD_4 ( VAR_30 ) ; METHOD_5 ( VAR_31 , VAR_32 , VAR_33 , VAR_34 , VAR_35 * 2 , VAR_36 ) ; if ( VAR_37 ) * VAR_38 = VAR_39 ; else METHOD_6 ( VAR_40 ) ; return VAR_41 + ( VAR_42 + 1 ) * 2 ; }","<S2SV_ModStart> ; VAR_26 = METHOD_7 <S2SV_ModEnd> ( VAR_33 ,","CWE-399 static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ; <S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( """" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }","<S2SV_ModStart> ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb ,"
309,"CWE-190 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 TYPE_3 * VAR_2 ) { const struct STRUCT_OR_UNION_1 * VAR_3 = METHOD_1 ( VAR_4 ) ; struct STRUCT_OR_UNION_2 * VAR_5 ; TYPE_4 VAR_6 , VAR_7 ; TYPE_5 VAR_8 = VAR_9 ; if ( ! VAR_10 ) return - VAR_11 ; if ( ! VAR_12 -> METHOD_2 ) return - VAR_13 ; VAR_14 = METHOD_3 ( ) ; if ( METHOD_4 ( ! VAR_15 ) ) return - VAR_16 ; METHOD_5 ( & VAR_17 -> VAR_18 ) ; VAR_19 = METHOD_6 ( VAR_20 ) ; if ( VAR_21 < 0 ) { VAR_22 = VAR_23 ; goto VAR_24 ; } VAR_25 = VAR_26 ; VAR_27 -> VAR_28 = ( TYPE_6 ) VAR_29 ; VAR_30 -> VAR_31 = VAR_32 ; VAR_33 -> VAR_34 = VAR_35 ; <S2SV_StartBug> VAR_36 -> VAR_37 = - 1 ; <S2SV_EndBug> if ( VAR_38 ) { METHOD_7 ( ) ; VAR_39 -> VAR_40 = METHOD_8 ( METHOD_9 ( VAR_41 ) ) ; METHOD_10 ( ) ; if ( ! VAR_42 -> VAR_43 ) { VAR_44 = - VAR_45 ; goto VAR_46 ; } VAR_47 -> VAR_48 = VAR_49 -> VAR_50 ; VAR_51 -> VAR_52 -> VAR_53 . VAR_54 = VAR_55 -> VAR_56 ; VAR_57 -> VAR_58 -> VAR_59 . VAR_60 = VAR_61 -> VAR_62 ; } else { VAR_63 -> VAR_64 = VAR_65 ; VAR_66 -> VAR_67 -> VAR_68 . VAR_69 = VAR_70 ; METHOD_11 ( & VAR_71 -> VAR_72 -> VAR_73 . VAR_74 , 0 , sizeof ( VAR_75 ) ) ; VAR_76 -> VAR_77 -> VAR_78 . VAR_79 . VAR_80 = VAR_81 -> VAR_82 ; VAR_83 -> VAR_84 = METHOD_12 ( METHOD_13 ( VAR_85 ) ) ; } VAR_86 -> VAR_87 -> VAR_88 . VAR_89 = VAR_90 -> VAR_91 ; VAR_92 -> VAR_93 -> VAR_94 . VAR_95 = VAR_96 ; if ( METHOD_14 ( VAR_97 , & VAR_98 , sizeof ( VAR_99 ) ) ) { VAR_100 = - VAR_101 ; goto VAR_102 ; } VAR_103 = VAR_104 -> METHOD_15 ( VAR_105 ) ; if ( VAR_106 ) goto VAR_107 ; METHOD_16 ( & VAR_108 -> VAR_109 -> VAR_110 ) ; VAR_111 -> VAR_112 = VAR_113 -> VAR_114 ; METHOD_17 ( & VAR_115 -> VAR_116 , & VAR_117 -> VAR_118 -> VAR_119 ) ; METHOD_18 ( & VAR_120 -> VAR_121 -> VAR_122 ) ; return 0 ; VAR_123 : METHOD_19 ( VAR_124 , VAR_125 ) ; return VAR_126 ; }",<S2SV_ModStart> VAR_37 = - 1LL <S2SV_ModEnd> ; if (,"CWE-190 static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }",<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
310,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 -> VAR_4 ; TYPE_4 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_5 * VAR_8 = VAR_9 -> VAR_10 [ 0 ] ; TYPE_6 * VAR_11 ; TYPE_7 * VAR_12 , * VAR_13 , * VAR_14 , * VAR_15 ; TYPE_8 VAR_16 , VAR_17 , VAR_18 , VAR_19 = 0 ; if ( METHOD_1 ( VAR_20 ) ) { VAR_21 = 1 ; VAR_22 = VAR_23 ; } else { VAR_24 = METHOD_2 ( VAR_25 , VAR_26 -> VAR_27 , VAR_28 -> VAR_29 ) ; if ( ! VAR_30 ) { METHOD_3 ( & VAR_31 ) ; return METHOD_4 ( VAR_32 ) ; } METHOD_5 ( VAR_33 , VAR_34 ) ; } if ( VAR_35 -> VAR_36 ) { VAR_37 = VAR_38 -> VAR_39 [ 0 ] ; VAR_40 = VAR_41 -> VAR_42 [ 0 ] ; for ( VAR_43 = 0 ; VAR_44 < VAR_45 -> VAR_46 ; VAR_47 ++ ) { TYPE_9 VAR_48 = VAR_49 -> VAR_50 ; const TYPE_10 ( * VAR_51 ) [ 256 ] = ( const TYPE_11 ( * ) [ 256 ] ) VAR_52 -> VAR_53 ; VAR_54 = VAR_55 ; VAR_56 = VAR_57 ; for ( VAR_58 = 0 ; VAR_59 < VAR_60 ; VAR_61 ++ ) { switch ( VAR_62 -> VAR_63 ) { case 4 : VAR_64 [ 3 ] = VAR_65 [ 3 ] [ VAR_66 [ 3 ] ] ; case 3 : VAR_67 [ 2 ] = VAR_68 [ 2 ] [ VAR_69 [ 2 ] ] ; case 2 : VAR_70 [ 1 ] = VAR_71 [ 1 ] [ VAR_72 [ 1 ] ] ; default : VAR_73 [ 0 ] = VAR_74 [ 0 ] [ VAR_75 [ 0 ] ] ; } VAR_76 += VAR_77 -> VAR_78 ; VAR_79 += VAR_80 -> VAR_81 ; } VAR_82 += VAR_83 -> VAR_84 [ 0 ] ; VAR_85 += VAR_86 -> VAR_87 [ 0 ] ; } } else { <S2SV_StartBug> for ( VAR_88 = 0 ; VAR_89 < 4 && VAR_90 -> VAR_91 [ VAR_92 ] ; VAR_93 ++ ) { <S2SV_EndBug> TYPE_12 VAR_94 = VAR_95 == 1 || VAR_96 == 2 ? VAR_97 -> VAR_98 : 0 ; TYPE_13 VAR_99 = VAR_100 == 1 || VAR_101 == 2 ? VAR_102 -> VAR_103 : 0 ; TYPE_14 VAR_104 = METHOD_6 ( VAR_105 -> VAR_106 , VAR_107 ) ; TYPE_15 VAR_108 = METHOD_7 ( VAR_109 -> VAR_110 , VAR_111 ) ; VAR_112 = VAR_113 -> VAR_114 [ VAR_115 ] ; VAR_116 = VAR_117 -> VAR_118 [ VAR_119 ] ; for ( VAR_120 = 0 ; VAR_121 < VAR_122 ; VAR_123 ++ ) { const TYPE_16 * VAR_124 = VAR_125 -> VAR_126 [ VAR_127 ] ; for ( VAR_128 = 0 ; VAR_129 < VAR_130 ; VAR_131 ++ ) VAR_132 [ VAR_133 ] = VAR_134 [ VAR_135 [ VAR_136 ] ] ; VAR_137 += VAR_138 -> VAR_139 [ VAR_140 ] ; VAR_141 += VAR_142 -> VAR_143 [ VAR_144 ] ; } } } if ( ! VAR_145 ) METHOD_8 ( & VAR_146 ) ; return METHOD_9 ( VAR_147 , VAR_148 ) ; }",<S2SV_ModStart> [ VAR_144 ] && VAR_146 -> VAR_143 [ VAR_144 ],"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; LutContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow , * inrow0 , * outrow0 ; int i , j , plane , direct = 0 ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } if ( s -> is_rgb ) { inrow0 = in -> data [ 0 ] ; outrow0 = out -> data [ 0 ] ; for ( i = 0 ; i < in -> height ; i ++ ) { int w = inlink -> w ; const uint8_t ( * tab ) [ 256 ] = ( const uint8_t ( * ) [ 256 ] ) s -> lut ; inrow = inrow0 ; outrow = outrow0 ; for ( j = 0 ; j < w ; j ++ ) { switch ( s -> step ) { case 4 : outrow [ 3 ] = tab [ 3 ] [ inrow [ 3 ] ] ; case 3 : outrow [ 2 ] = tab [ 2 ] [ inrow [ 2 ] ] ; case 2 : outrow [ 1 ] = tab [ 1 ] [ inrow [ 1 ] ] ; default : outrow [ 0 ] = tab [ 0 ] [ inrow [ 0 ] ] ; } outrow += s -> step ; inrow += s -> step ; } inrow0 += in -> linesize [ 0 ] ; outrow0 += out -> linesize [ 0 ] ; } } else { <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ; int hsub = plane == 1 || plane == 2 ? s -> hsub : 0 ; int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; inrow = in -> data [ plane ] ; outrow = out -> data [ plane ] ; for ( i = 0 ; i < h ; i ++ ) { const uint8_t * tab = s -> lut [ plane ] ; for ( j = 0 ; j < w ; j ++ ) outrow [ j ] = tab [ inrow [ j ] ] ; inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }",<S2SV_ModStart> [ plane ] && in -> linesize [ plane ]
311,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 = METHOD_1 ( VAR_4 ) ; <S2SV_StartBug> struct STRUCT_OR_UNION_2 * VAR_5 = METHOD_2 ( VAR_6 ) ; <S2SV_EndBug> unsigned TYPE_3 VAR_7 ; TYPE_4 * VAR_8 = ( TYPE_5 * ) VAR_9 ; TYPE_6 VAR_10 ; VAR_11 = METHOD_3 ( VAR_12 , & VAR_13 , 0 ) ; if ( ! VAR_14 || ( * VAR_15 && ( * VAR_16 != '\\n' ) ) ) return - VAR_17 ; VAR_18 = ! ! VAR_19 ; if ( ! METHOD_4 ( VAR_20 , & VAR_21 -> VAR_22 ) || ! METHOD_5 ( VAR_23 , & VAR_24 -> VAR_25 ) || ! METHOD_6 ( VAR_26 , & VAR_27 -> VAR_28 ) ) return - VAR_29 ; <S2SV_StartBug> if ( VAR_30 && VAR_31 == VAR_32 -> VAR_33 && <S2SV_EndBug> VAR_34 -> VAR_35 != VAR_36 -> VAR_37 ) <S2SV_StartBug> return - VAR_38 ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_39 && ! VAR_40 -> VAR_41 ) { <S2SV_EndBug> VAR_42 = METHOD_7 ( VAR_43 ) ; if ( VAR_44 ) <S2SV_StartBug> return VAR_45 ; <S2SV_EndBug> } if ( ! VAR_46 && VAR_47 -> VAR_48 && VAR_49 -> VAR_50 == VAR_51 -> VAR_52 ) { METHOD_8 ( VAR_53 ) ; VAR_54 -> VAR_55 = VAR_56 ; } VAR_57 -> VAR_58 = VAR_59 ; if ( VAR_60 -> VAR_61 ) { VAR_62 -> VAR_63 = VAR_64 ; VAR_65 -> VAR_66 = VAR_67 -> VAR_68 ; } <S2SV_StartBug> return VAR_69 ; <S2SV_EndBug> }",<S2SV_ModStart> STRUCT_OR_UNION_2 * VAR_65 <S2SV_ModEnd> ; unsigned TYPE_3 <S2SV_ModStart> - VAR_29 ; METHOD_9 ( ) ; VAR_65 = METHOD_2 ( VAR_67 ) ; if ( ! VAR_65 ) { VAR_45 = - VAR_29 ; goto VAR_70 ; } <S2SV_ModStart> -> VAR_68 ) { VAR_45 = <S2SV_ModEnd> - VAR_38 ; <S2SV_ModStart> - VAR_38 ; goto VAR_70 ; } <S2SV_ModStart> ( VAR_45 ) goto VAR_70 <S2SV_ModEnd> ; } if <S2SV_ModStart> VAR_68 ; } VAR_45 = VAR_69 ; VAR_70 : METHOD_10 ( ) ; return VAR_45 <S2SV_ModEnd> ; } <S2SV_null>,"CWE-476 static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }",<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
312,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> if ( ! VAR_1 -> VAR_2 . VAR_3 ) <S2SV_EndBug> return - VAR_4 ; VAR_5 -> VAR_6 . VAR_7 = VAR_8 ; METHOD_1 ( VAR_9 , VAR_10 ) ; return 0 ; }",<S2SV_ModStart> -> VAR_6 . VAR_11 <S2SV_ModEnd> ) return -,"CWE-399 static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }",<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
313,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , const unsigned TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { const unsigned TYPE_3 * VAR_3 = VAR_4 ; METHOD_1 ( VAR_5 , VAR_6 ) ; TYPE_4 VAR_7 ; TYPE_5 VAR_8 = 0 ; if ( METHOD_2 ( VAR_9 ) && STRUCT_OR_UNION_3 -> VAR_10 -> METHOD_3 != VAR_11 ) { VAR_12 = METHOD_4 ( VAR_13 ) ; if ( VAR_14 ) return VAR_15 ; } METHOD_5 ( & VAR_16 -> VAR_17 ) ; METHOD_6 ( VAR_18 ) ; METHOD_7 ( & VAR_19 -> VAR_20 , & VAR_21 ) ; while ( 1 ) { METHOD_8 ( VAR_22 ) ; if ( METHOD_9 ( VAR_23 ) ) { VAR_24 = - VAR_25 ; break ; } if ( METHOD_10 ( STRUCT_OR_UNION_4 ) || ( VAR_26 -> VAR_27 && ! VAR_28 -> VAR_29 -> VAR_30 ) ) { VAR_31 = - VAR_32 ; break ; } if ( METHOD_11 ( VAR_33 ) ) { while ( VAR_34 > 0 ) { TYPE_6 VAR_35 = METHOD_12 ( VAR_36 , VAR_37 , VAR_38 ) ; if ( VAR_39 < 0 ) { if ( VAR_40 == - VAR_41 ) break ; VAR_42 = VAR_43 ; goto VAR_44 ; } VAR_45 += VAR_46 ; VAR_47 -= VAR_48 ; if ( VAR_49 == 0 ) break ; VAR_50 = * VAR_51 ; if ( METHOD_13 ( VAR_52 , VAR_53 ) < 0 ) break ; VAR_54 ++ ; VAR_55 -- ; } if ( VAR_56 -> VAR_57 -> METHOD_14 ) VAR_58 -> VAR_59 -> METHOD_15 ( VAR_60 ) ; } else { <S2SV_StartBug> while ( VAR_61 > 0 ) { <S2SV_EndBug> <S2SV_StartBug> VAR_62 = VAR_63 -> VAR_64 -> METHOD_16 ( VAR_65 , VAR_66 , VAR_67 ) ; <S2SV_EndBug> if ( VAR_68 < 0 ) { VAR_69 = VAR_70 ; goto VAR_71 ; } if ( ! VAR_72 ) break ; VAR_73 += VAR_74 ; VAR_75 -= VAR_76 ; } } if ( ! VAR_77 ) break ; if ( STRUCT_OR_UNION_5 -> VAR_78 & VAR_79 ) { VAR_80 = - VAR_81 ; break ; } METHOD_17 ( & VAR_82 -> VAR_83 ) ; METHOD_18 ( ) ; METHOD_19 ( & VAR_84 -> VAR_85 ) ; } VAR_86 : METHOD_20 ( VAR_87 ) ; METHOD_21 ( & VAR_88 -> VAR_89 , & VAR_90 ) ; if ( VAR_91 - VAR_92 != VAR_93 && VAR_94 -> VAR_95 ) METHOD_22 ( VAR_96 , & VAR_97 -> VAR_98 ) ; METHOD_23 ( & VAR_99 -> VAR_100 ) ; return ( VAR_101 - VAR_102 ) ? VAR_103 - VAR_104 : VAR_105 ; }","<S2SV_ModStart> } else { struct STRUCT_OR_UNION_6 * VAR_106 = VAR_99 -> VAR_107 ; <S2SV_ModStart> 0 ) { METHOD_24 ( & VAR_106 -> VAR_108 ) ; <S2SV_ModStart> VAR_103 , VAR_93 ) ; METHOD_25 ( & VAR_106 -> VAR_108","CWE-362 static ssize_t n_tty_write ( struct tty_struct * tty , struct file * file , const unsigned char * buf , size_t nr ) { const unsigned char * b = buf ; DECLARE_WAITQUEUE ( wait , current ) ; int c ; ssize_t retval = 0 ; if ( L_TOSTOP ( tty ) && file -> f_op -> write != redirected_tty_write ) { retval = tty_check_change ( tty ) ; if ( retval ) return retval ; } down_read ( & tty -> termios_rwsem ) ; process_echoes ( tty ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; while ( 1 ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( signal_pending ( current ) ) { retval = - ERESTARTSYS ; break ; } if ( tty_hung_up_p ( file ) || ( tty -> link && ! tty -> link -> count ) ) { retval = - EIO ; break ; } if ( O_OPOST ( tty ) ) { while ( nr > 0 ) { ssize_t num = process_output_block ( tty , b , nr ) ; if ( num < 0 ) { if ( num == - EAGAIN ) break ; retval = num ; goto break_out ; } b += num ; nr -= num ; if ( nr == 0 ) break ; c = * b ; if ( process_output ( c , tty ) < 0 ) break ; b ++ ; nr -- ; } if ( tty -> ops -> flush_chars ) tty -> ops -> flush_chars ( tty ) ; } else { <S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> if ( c < 0 ) { retval = c ; goto break_out ; } if ( ! c ) break ; b += c ; nr -= c ; } } if ( ! nr ) break ; if ( file -> f_flags & O_NONBLOCK ) { retval = - EAGAIN ; break ; } up_read ( & tty -> termios_rwsem ) ; schedule ( ) ; down_read ( & tty -> termios_rwsem ) ; } break_out : __set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( b - buf != nr && tty -> fasync ) set_bit ( TTY_DO_WRITE_WAKEUP , & tty -> flags ) ; up_read ( & tty -> termios_rwsem ) ; return ( b - buf ) ? b - buf : retval ; }","<S2SV_ModStart> } else { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> 0 ) { mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> b , nr ) ; mutex_unlock ( & ldata -> output_lock"
314,CWE-404 static TYPE_0 METHOD_0 ( TYPE_1 ) { struct STRUCT_OR_UNION_0 * VAR_0 ; TYPE_2 VAR_1 ; VAR_2 = METHOD_1 ( ) ; if ( ! VAR_3 ) <S2SV_StartBug> return - VAR_4 ; <S2SV_EndBug> METHOD_2 ( VAR_5 -> VAR_6 ) ; VAR_7 = METHOD_3 ( VAR_8 ) ; if ( VAR_9 < 0 ) { METHOD_4 ( VAR_10 ) ; return VAR_11 ; } return METHOD_5 ( VAR_12 ) ; },<S2SV_ModStart> return - VAR_4 <S2SV_ModEnd> ; VAR_11 =,CWE-404 static int install_thread_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> BUG_ON ( new -> thread_keyring ) ; ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; return ret ; } return commit_creds ( new ) ; },<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =
315,"CWE-20 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 = VAR_5 ; TYPE_6 VAR_6 , VAR_7 ; union { TYPE_7 VAR_8 ; TYPE_8 VAR_9 ; } VAR_10 ; while ( VAR_11 > 0 && VAR_12 == VAR_13 ) { <S2SV_StartBug> VAR_14 = METHOD_1 ( VAR_15 + VAR_16 ) ; <S2SV_EndBug> VAR_17 = METHOD_2 ( VAR_18 + VAR_19 + 1 ) ; METHOD_3 ( ( VAR_20 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u"" , METHOD_4 ( VAR_21 , ""Unknown"" , VAR_22 ) , VAR_23 , VAR_24 ) ) ; if ( VAR_25 < 4 ) { METHOD_5 ( ( VAR_26 , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; break ; } if ( ( VAR_27 % 4 ) != 0 ) { METHOD_6 ( ( VAR_28 , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; break ; } if ( VAR_29 < VAR_30 ) { METHOD_7 ( ( VAR_31 , ""<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)"" ) ) ; break ; } switch ( VAR_32 ) { case VAR_33 : <S2SV_StartBug> METHOD_8 ( ( VAR_34 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> METHOD_9 ( VAR_35 , ""Unknown"" , METHOD_10 ( VAR_36 + VAR_37 + 2 ) ) , <S2SV_StartBug> METHOD_11 ( VAR_38 + VAR_39 + 2 ) ) ) ; <S2SV_EndBug> METHOD_12 ( ( VAR_40 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , METHOD_13 ( VAR_41 , ""Unknown"" , METHOD_14 ( VAR_42 + VAR_43 + 3 ) ) , METHOD_15 ( VAR_44 + VAR_45 + 3 ) ) ) ; METHOD_16 ( VAR_46 + VAR_47 + 4 ) ; VAR_48 . VAR_49 = METHOD_17 ( VAR_50 + VAR_51 + 4 ) ; METHOD_18 ( ( VAR_52 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , VAR_53 . VAR_54 * 8 / 1000000 ) ) ; <S2SV_StartBug> VAR_55 . VAR_56 = METHOD_19 ( VAR_57 + VAR_58 + 8 ) ; <S2SV_EndBug> METHOD_20 ( ( VAR_59 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , VAR_60 . VAR_61 * 8 / 1000000 ) ) ; break ; case VAR_62 : <S2SV_StartBug> METHOD_21 ( ( VAR_63 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug> METHOD_22 ( VAR_64 + VAR_65 + 4 ) ) ) ; break ; default : VAR_66 = VAR_67 ; break ; } VAR_68 -= VAR_69 ; VAR_70 += VAR_71 ; } return ( VAR_72 ) ; VAR_73 : return - 1 ; }",<S2SV_ModStart> VAR_13 ) { METHOD_23 ( VAR_64 + VAR_70 ) ; <S2SV_ModStart> case VAR_33 : METHOD_24 ( VAR_64 + VAR_70 + 2 ) ; <S2SV_ModStart> 2 ) ) ) ; METHOD_24 ( VAR_64 + VAR_70 + 3 <S2SV_ModStart> ) ) ; METHOD_16 ( VAR_64 + VAR_70 + 8 ) ; <S2SV_ModStart> case VAR_62 : METHOD_16 ( VAR_64 + VAR_70 + 4 ) ;,"CWE-20 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u"" , tok2str ( lmp_data_link_subobj , ""Unknown"" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)"" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( gmpls_encoding_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }",<S2SV_ModStart> FALSE ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> 2 ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
316,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , <S2SV_EndBug> TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <S2SV_StartBug> unsigned TYPE_4 VAR_3 = METHOD_1 ( VAR_4 , & VAR_5 -> VAR_6 , <S2SV_EndBug> VAR_7 , VAR_8 , VAR_9 ) ; if ( VAR_10 < 8 ) return VAR_11 ; else if ( VAR_12 < 128 ) return VAR_13 ; else if ( VAR_14 < 2048 ) return VAR_15 ; else return VAR_16 ; }","<S2SV_ModStart> TYPE_1 * VAR_5 , TYPE_5 * VAR_17 <S2SV_ModStart> VAR_5 , & VAR_17 -> VAR_18 [ 0 ] . VAR_19 <S2SV_ModEnd> , VAR_7 ,","CWE-119 <S2SV_StartBug> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , <S2SV_EndBug> int mi_row , int mi_col ) { <S2SV_StartBug> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb , <S2SV_EndBug> mi_row , mi_col , BLOCK_64X64 ) ; if ( var < 8 ) return BLOCK_64X64 ; else if ( var < 128 ) return BLOCK_32X32 ; else if ( var < 2048 ) return BLOCK_16X16 ; else return BLOCK_8X8 ; }","<S2SV_ModStart> VP9_COMP * cpi , MACROBLOCK * x <S2SV_ModStart> cpi , & x -> plane [ 0 ] . src <S2SV_ModEnd> , mi_row ,"
317,"CWE-119 static TYPE_0 * METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 ) { VAR_3 -> VAR_4 = METHOD_1 ( * ( ( TYPE_2 * ) VAR_5 ) ) ; VAR_6 += 2 ; <S2SV_StartBug> VAR_7 -> VAR_8 = * VAR_9 ++ ; <S2SV_EndBug> METHOD_2 ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\n"" , VAR_10 -> VAR_11 , VAR_12 -> VAR_13 ) ; METHOD_3 ( VAR_14 -> VAR_15 , VAR_16 , VAR_17 -> VAR_18 ) ; VAR_19 += VAR_20 -> VAR_21 ; VAR_22 -> VAR_23 = * VAR_24 ++ ; if ( VAR_25 -> VAR_26 != 0 ) VAR_27 -> VAR_28 = * VAR_29 ++ ; METHOD_4 ( ""sel_res_len<S2SV_blank>%d,<S2SV_blank>sel_res<S2SV_blank>0x%x\\n"" , VAR_30 -> VAR_31 , VAR_32 -> VAR_33 ) ; return VAR_34 ; }","<S2SV_ModStart> -> VAR_21 = METHOD_5 ( TYPE_1 , <S2SV_ModStart> * VAR_34 ++ , VAR_35 )","CWE-119 static __u8 * nci_extract_rf_params_nfca_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfca_poll * nfca_poll , __u8 * data ) { nfca_poll -> sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ) ; data += 2 ; <S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\n"" , nfca_poll -> sens_res , nfca_poll -> nfcid1_len ) ; memcpy ( nfca_poll -> nfcid1 , data , nfca_poll -> nfcid1_len ) ; data += nfca_poll -> nfcid1_len ; nfca_poll -> sel_res_len = * data ++ ; if ( nfca_poll -> sel_res_len != 0 ) nfca_poll -> sel_res = * data ++ ; pr_debug ( ""sel_res_len<S2SV_blank>%d,<S2SV_blank>sel_res<S2SV_blank>0x%x\\n"" , nfca_poll -> sel_res_len , nfca_poll -> sel_res ) ; return data ; }","<S2SV_ModStart> -> nfcid1_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_NFCID1_MAXSIZE )"
318,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * const VAR_1 , <S2SV_StartBug> TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { <S2SV_EndBug> <S2SV_StartBug> TYPE_6 * const VAR_5 = & VAR_6 -> VAR_7 ; <S2SV_EndBug> TYPE_7 * const VAR_8 = & VAR_9 -> VAR_10 ; TYPE_8 * const VAR_11 = & VAR_12 -> VAR_13 ; VAR_14 * VAR_15 ; const TYPE_9 VAR_16 = VAR_17 [ VAR_18 ] ; const TYPE_10 VAR_19 = VAR_20 [ VAR_21 ] ; <S2SV_StartBug> const TYPE_11 VAR_22 = VAR_23 >> 1 ; <S2SV_EndBug> const TYPE_12 VAR_24 = VAR_25 >> 1 ; const TYPE_13 VAR_26 = VAR_27 * VAR_28 -> VAR_29 + VAR_30 ; const struct STRUCT_OR_UNION_0 * const VAR_31 = & VAR_32 -> VAR_33 ; METHOD_1 ( VAR_34 , VAR_35 , VAR_36 ) ; <S2SV_StartBug> VAR_37 -> VAR_38 = & VAR_39 -> VAR_40 [ VAR_41 ] ; <S2SV_EndBug> VAR_42 -> VAR_43 = METHOD_2 ( VAR_44 , VAR_45 , VAR_46 , VAR_47 , VAR_48 ) ; METHOD_3 ( VAR_49 , VAR_50 , VAR_51 , VAR_52 ) ; VAR_53 = & VAR_54 -> VAR_55 [ 0 ] -> VAR_56 ; <S2SV_StartBug> METHOD_4 ( VAR_57 , METHOD_5 ( VAR_58 ) , VAR_59 , VAR_60 ) ; <S2SV_EndBug> VAR_61 -> VAR_62 = - ( ( ( VAR_63 + VAR_64 ) * VAR_65 ) + VAR_66 ) ; VAR_67 -> VAR_68 = - ( ( ( VAR_69 + VAR_70 ) * VAR_71 ) + VAR_72 ) ; VAR_73 -> VAR_74 = ( VAR_75 -> VAR_76 - VAR_77 ) * VAR_78 + VAR_79 ; VAR_80 -> VAR_81 = ( VAR_82 -> VAR_83 - VAR_84 ) * VAR_85 + VAR_86 ; METHOD_6 ( ! ( VAR_87 & ( VAR_88 - 1 ) ) && ! ( VAR_89 & ( VAR_90 - 1 ) ) ) ; METHOD_7 ( VAR_91 , VAR_92 , VAR_93 , VAR_94 , VAR_95 , VAR_96 , VAR_97 -> VAR_98 , VAR_99 -> VAR_100 ) ; METHOD_8 ( VAR_101 , VAR_102 -> VAR_103 , VAR_104 , VAR_105 ) ; <S2SV_StartBug> VAR_106 -> VAR_107 = VAR_108 -> VAR_109 ; <S2SV_EndBug> <S2SV_StartBug> VAR_110 -> VAR_111 = VAR_112 -> VAR_113 ; <S2SV_EndBug> if ( VAR_114 -> VAR_115 ) { if ( VAR_116 -> VAR_117 . VAR_118 != VAR_119 ) { const TYPE_14 * const VAR_120 = VAR_121 -> VAR_122 ? VAR_123 -> VAR_124 : VAR_125 -> VAR_126 ; <S2SV_StartBug> VAR_127 -> VAR_128 = METHOD_9 ( VAR_129 , VAR_130 , VAR_131 , VAR_132 , VAR_133 ) ; <S2SV_EndBug> } METHOD_10 ( VAR_134 , VAR_135 ) ; VAR_136 -> VAR_137 = VAR_138 -> VAR_139 [ VAR_140 -> VAR_141 ] ; } else { VAR_142 -> VAR_143 = 0 ; VAR_144 -> VAR_145 = VAR_146 -> VAR_147 ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> const VAR_92 , TYPE_6 * const VAR_144 , <S2SV_ModStart> VAR_131 ) { <S2SV_ModEnd> TYPE_7 * const <S2SV_ModStart> ] ; const <S2SV_ModEnd> struct STRUCT_OR_UNION_0 * <S2SV_ModStart> VAR_133 ) ; set_mode_info_offsets ( VAR_129 , VAR_144 <S2SV_ModEnd> , VAR_91 , <S2SV_ModStart> METHOD_4 ( VAR_91 -> VAR_148 <S2SV_ModStart> = VAR_146 -> VAR_149 . <S2SV_ModStart> = VAR_146 -> VAR_149 . <S2SV_ModStart> -> VAR_143 = METHOD_11 <S2SV_ModEnd> ( VAR_129 , <S2SV_ModStart> VAR_147 ; } VAR_91 -> VAR_92 = * VAR_92 ;","CWE-119 static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> const int mb_col = mi_col >> 1 ; const int idx_map = mb_row * cm -> mb_cols + mb_col ; const struct segmentation * const seg = & cm -> seg ; set_skip_context ( xd , mi_row , mi_col ) ; <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ; x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ; assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ; set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , cm -> mi_rows , cm -> mi_cols ) ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> if ( seg -> enabled ) { if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> } vp9_init_plane_quantizers ( cpi , x ) ; x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ; } else { mbmi -> segment_id = 0 ; x -> encode_breakout = cpi -> encode_breakout ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> const tile , MACROBLOCK * const x , <S2SV_ModStart> bsize ) { <S2SV_ModEnd> VP9_COMMON * const <S2SV_ModStart> ] ; const <S2SV_ModEnd> struct segmentation * <S2SV_ModStart> mi_col ) ; set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> vp9_setup_dst_planes ( xd -> plane <S2SV_ModStart> = cpi -> rd . <S2SV_ModStart> = cpi -> rd . <S2SV_ModStart> -> segment_id = get_segment_id <S2SV_ModEnd> ( cm , <S2SV_ModStart> encode_breakout ; } xd -> tile = * tile ;"
319,"CWE-264 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 ( * VAR_2 ) [ 2 ] , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; if ( VAR_7 -> VAR_8 & VAR_9 ) METHOD_1 ( ) ; for ( VAR_10 = 0 ; VAR_11 < VAR_12 ; VAR_13 ++ ) { VAR_14 = VAR_15 [ VAR_16 ] [ 0 ] ; VAR_17 = VAR_18 [ VAR_19 ] [ 1 ] ; if ( VAR_20 < 0 ) { if ( VAR_21 >= 3 ) continue ; else { VAR_22 = METHOD_2 ( ""/dev/null"" , VAR_23 == 0 ? VAR_24 : VAR_25 ) ; VAR_26 = VAR_27 ; if ( VAR_28 == - 1 ) { METHOD_3 ( VAR_29 , - VAR_30 ) ; METHOD_4 ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio"" ) ; METHOD_5 ( 127 ) ; } } } if ( VAR_31 == VAR_32 ) METHOD_6 ( VAR_33 , 0 ) ; else METHOD_7 ( VAR_34 , VAR_35 ) ; if ( VAR_36 <= 2 ) METHOD_8 ( VAR_37 , 0 ) ; if ( VAR_38 != - 1 ) METHOD_9 ( VAR_39 ) ; } for ( VAR_40 = 0 ; VAR_41 < VAR_42 ; VAR_43 ++ ) { VAR_44 = VAR_45 [ VAR_46 ] [ 1 ] ; if ( VAR_47 >= 0 && VAR_48 != VAR_49 ) METHOD_10 ( VAR_50 ) ; } if ( VAR_51 -> VAR_52 != VAR_53 && METHOD_11 ( VAR_54 -> VAR_55 ) ) { METHOD_12 ( VAR_56 , - VAR_57 ) ; METHOD_13 ( ""chdir()"" ) ; METHOD_14 ( 127 ) ; } <S2SV_StartBug> if ( ( VAR_58 -> VAR_59 & VAR_60 ) && METHOD_15 ( VAR_61 -> VAR_62 ) ) { <S2SV_EndBug> METHOD_16 ( VAR_63 , - VAR_64 ) ; METHOD_17 ( ""setgid()"" ) ; METHOD_18 ( 127 ) ; } if ( ( VAR_65 -> VAR_66 & VAR_67 ) && METHOD_19 ( VAR_68 -> VAR_69 ) ) { METHOD_20 ( VAR_70 , - VAR_71 ) ; METHOD_21 ( ""setuid()"" ) ; METHOD_22 ( 127 ) ; } if ( VAR_72 -> VAR_73 != VAR_74 ) { VAR_75 = VAR_76 -> VAR_77 ; } METHOD_23 ( VAR_78 -> VAR_79 , VAR_80 -> VAR_81 ) ; METHOD_24 ( VAR_82 , - VAR_83 ) ; METHOD_25 ( ""execvp()"" ) ; METHOD_26 ( 127 ) ; }","<S2SV_ModStart> } if ( VAR_80 -> VAR_66 & ( VAR_67 | VAR_60 ) ) { METHOD_28 ( METHOD_27 ( 0 , VAR_74 ) ) ; } if (","CWE-264 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( ""/dev/null"" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio"" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""chdir()"" ) ; _exit ( 127 ) ; } <S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> uv__write_int ( error_fd , - errno ) ; perror ( ""setgid()"" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""setuid()"" ) ; _exit ( 127 ) ; } if ( options -> env != NULL ) { environ = options -> env ; } execvp ( options -> file , options -> args ) ; uv__write_int ( error_fd , - errno ) ; perror ( ""execvp()"" ) ; _exit ( 127 ) ; }","<S2SV_ModStart> } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if ("
320,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , TYPE_7 VAR_6 , TYPE_8 VAR_7 , TYPE_9 VAR_8 ) { TYPE_10 VAR_9 = ( TYPE_11 ) VAR_10 ; VAR_11 * VAR_12 ; VAR_13 * VAR_14 ; TYPE_12 VAR_15 ; TYPE_13 VAR_16 , VAR_17 ; TYPE_14 VAR_18 ; TYPE_15 * VAR_19 = & VAR_20 -> VAR_21 . VAR_22 ; TYPE_16 VAR_23 ; TYPE_17 VAR_24 ; TYPE_18 VAR_25 ; TYPE_19 * VAR_26 = & VAR_27 -> VAR_28 . VAR_29 ; VAR_30 = VAR_31 -> VAR_32 . VAR_33 . VAR_34 ; VAR_35 = VAR_36 -> VAR_37 . VAR_38 ; VAR_39 = VAR_40 -> VAR_41 . VAR_42 ; VAR_43 = VAR_44 -> VAR_45 . VAR_46 . VAR_47 ; { VAR_48 = 0 ; if ( ( VAR_49 <= VAR_50 -> VAR_51 ) && ( VAR_52 > VAR_53 -> VAR_54 ) && ( VAR_55 < VAR_56 ) && ! ( VAR_57 && ( VAR_58 == 0 ) ) ) { VAR_59 = VAR_60 + ( 5 - VAR_61 ) ; METHOD_1 ( ""split_transform_flag"" , VAR_62 -> VAR_63 , VAR_64 ) ; VAR_65 = METHOD_2 ( VAR_66 , VAR_67 , VAR_68 ) ; METHOD_3 ( ""split_transform_flag"" , VAR_69 , VAR_70 -> VAR_71 ) ; } else { TYPE_20 VAR_72 = 0 ; if ( ( 0 == VAR_73 -> VAR_74 ) && ( VAR_75 == VAR_76 -> VAR_77 . VAR_78 . VAR_79 ) && ( VAR_80 != VAR_81 -> VAR_82 . VAR_83 . VAR_84 ) && ( 0 == VAR_85 ) ) { VAR_86 = 1 ; } if ( ( VAR_87 > VAR_88 -> VAR_89 ) || ( ( 1 == VAR_90 ) && ( 0 == VAR_91 ) ) || ( 1 == VAR_92 ) ) { VAR_93 = 1 ; } } if ( 0 == VAR_94 ) { VAR_95 -> VAR_96 . VAR_97 . VAR_98 [ VAR_99 ] = 0 ; VAR_100 -> VAR_101 . VAR_102 . VAR_103 [ VAR_104 ] = 0 ; } else { VAR_105 -> VAR_106 . VAR_107 . VAR_108 [ VAR_109 ] = VAR_110 -> VAR_111 . VAR_112 . VAR_113 [ VAR_114 - 1 ] ; VAR_115 -> VAR_116 . VAR_117 . VAR_118 [ VAR_119 ] = VAR_120 -> VAR_121 . VAR_122 . VAR_123 [ VAR_124 - 1 ] ; } if ( VAR_125 == 0 || VAR_126 > 2 ) { VAR_127 = VAR_128 + VAR_129 ; if ( ( VAR_130 == 0 ) || VAR_131 -> VAR_132 . VAR_133 . VAR_134 [ VAR_135 - 1 ] ) { METHOD_4 ( ""cbf_cb"" , VAR_136 -> VAR_137 , VAR_138 ) ; VAR_139 = METHOD_5 ( VAR_140 , VAR_141 , VAR_142 ) ; METHOD_6 ( ""cbf_cb"" , VAR_143 , VAR_144 -> VAR_145 ) ; VAR_146 -> VAR_147 . VAR_148 . VAR_149 [ VAR_150 ] = VAR_151 ; } if ( ( VAR_152 == 0 ) || VAR_153 -> VAR_154 . VAR_155 . VAR_156 [ VAR_157 - 1 ] ) { METHOD_7 ( ""cbf_cr"" , VAR_158 -> VAR_159 , VAR_160 ) ; VAR_161 = METHOD_8 ( VAR_162 , VAR_163 , VAR_164 ) ; METHOD_9 ( ""cbf_cr"" , VAR_165 , VAR_166 -> VAR_167 ) ; VAR_168 -> VAR_169 . VAR_170 . VAR_171 [ VAR_172 ] = VAR_173 ; } } if ( VAR_174 ) { TYPE_21 VAR_175 ; VAR_176 = VAR_177 + ( ( 1 << VAR_178 ) >> 1 ) ; VAR_179 = VAR_180 + ( ( 1 << VAR_181 ) >> 1 ) ; VAR_182 = VAR_183 ? VAR_184 : VAR_185 -> VAR_186 . VAR_187 . VAR_188 [ 0 ] ; METHOD_10 ( VAR_189 , VAR_190 , VAR_191 , VAR_192 , VAR_193 , VAR_194 - 1 , VAR_195 + 1 , 0 , VAR_196 ) ; VAR_197 = VAR_198 ? VAR_199 : VAR_200 -> VAR_201 . VAR_202 . VAR_203 [ 1 ] ; METHOD_11 ( VAR_204 , VAR_205 , VAR_206 , VAR_207 , VAR_208 , VAR_209 - 1 , VAR_210 + 1 , 1 , VAR_211 ) ; VAR_212 = VAR_213 ? VAR_214 : VAR_215 -> VAR_216 . VAR_217 . VAR_218 [ 2 ] ; METHOD_12 ( VAR_219 , VAR_220 , VAR_221 , VAR_222 , VAR_223 , VAR_224 - 1 , VAR_225 + 1 , 2 , VAR_226 ) ; VAR_227 = VAR_228 ? VAR_229 : VAR_230 -> VAR_231 . VAR_232 . VAR_233 [ 3 ] ; METHOD_13 ( VAR_234 , VAR_235 , VAR_236 , VAR_237 , VAR_238 , VAR_239 - 1 , VAR_240 + 1 , 3 , VAR_241 ) ; } else { TYPE_22 VAR_242 ; TYPE_23 VAR_243 ; TYPE_24 VAR_244 ; TYPE_25 * VAR_245 = VAR_246 -> VAR_247 . VAR_248 ; VAR_249 = 0 ; VAR_250 = VAR_251 -> VAR_252 . VAR_253 << VAR_254 -> VAR_255 ; VAR_256 = VAR_257 -> VAR_258 . VAR_259 << VAR_260 -> VAR_261 ; if ( ( VAR_262 -> VAR_263 . VAR_264 . VAR_265 == VAR_266 ) || ( VAR_267 != 0 ) || ( VAR_268 -> VAR_269 . VAR_270 . VAR_271 [ VAR_272 ] ) || ( VAR_273 -> VAR_274 . VAR_275 . VAR_276 [ VAR_277 ] ) ) { VAR_278 = VAR_279 ; VAR_280 += ( VAR_281 == 0 ) ? 1 : 0 ; METHOD_14 ( ""cbf_luma"" , VAR_282 -> VAR_283 , VAR_284 ) ; VAR_285 = METHOD_15 ( VAR_286 , VAR_287 , VAR_288 ) ; METHOD_16 ( ""cbf_luma"" , VAR_289 , VAR_290 -> VAR_291 ) ; VAR_292 -> VAR_293 . VAR_294 . VAR_295 = VAR_296 ; } else { VAR_297 -> VAR_298 . VAR_299 . VAR_300 = 1 ; } VAR_301 -> VAR_302 = 0 ; VAR_303 -> VAR_304 = 0 ; VAR_305 -> VAR_306 = 0 ; VAR_307 -> VAR_308 = ( ( VAR_309 - VAR_310 ) >> 2 ) ; VAR_311 -> VAR_312 = ( ( VAR_313 - VAR_314 ) >> 2 ) ; VAR_315 -> VAR_316 = VAR_317 -> VAR_318 . VAR_319 . VAR_320 ; VAR_321 -> VAR_322 = ( VAR_323 - 2 ) ; VAR_324 -> VAR_325 = VAR_326 -> VAR_327 . VAR_328 ; VAR_329 -> VAR_330 = VAR_331 ; VAR_332 -> VAR_333 = VAR_334 -> VAR_335 . VAR_336 . VAR_337 ; if ( VAR_338 -> VAR_339 . VAR_340 . VAR_341 || VAR_342 -> VAR_343 . VAR_344 . VAR_345 [ VAR_346 ] || VAR_347 -> VAR_348 . VAR_349 . VAR_350 [ VAR_351 ] ) { TYPE_26 VAR_352 ; if ( VAR_353 -> VAR_354 && ! VAR_355 -> VAR_356 . VAR_357 ) { TYPE_27 VAR_358 = VAR_359 ; TYPE_28 VAR_360 = VAR_361 ; TYPE_29 VAR_362 = VAR_363 ; METHOD_17 ( ""cu_qp_delta_abs"" , VAR_364 -> VAR_365 , VAR_366 ) ; VAR_367 = METHOD_18 ( VAR_368 , VAR_369 , VAR_370 , VAR_371 , 0 , VAR_372 ) ; if ( VAR_373 >= VAR_374 ) { VAR_375 = METHOD_19 ( VAR_376 , VAR_377 , 0 ) ; VAR_378 += VAR_379 ; } METHOD_20 ( ""cu_qp_delta_abs"" , VAR_380 , VAR_381 -> VAR_382 ) ; VAR_383 -> VAR_384 . VAR_385 = 1 ; if ( VAR_386 ) { VAR_387 = METHOD_21 ( VAR_388 , VAR_389 ) ; METHOD_22 ( ""cu_qp_delta_sign"" , VAR_390 , VAR_391 -> VAR_392 ) ; if ( VAR_393 ) VAR_394 = - VAR_395 ; } <S2SV_StartBug> VAR_396 -> VAR_397 . VAR_398 . VAR_399 = VAR_400 ; <S2SV_EndBug> } if ( VAR_401 -> VAR_402 . VAR_403 . VAR_404 ) { VAR_405 -> VAR_406 = 1 ; METHOD_23 ( VAR_407 , VAR_408 , VAR_409 , VAR_410 , 0 , VAR_411 ) ; } if ( 4 == VAR_412 -> VAR_413 . VAR_414 . VAR_415 ) VAR_416 = VAR_417 -> VAR_418 . VAR_419 . VAR_420 [ 0 ] ; else { VAR_421 = VAR_422 [ VAR_423 -> VAR_424 . VAR_425 . VAR_426 ] ; if ( VAR_427 == VAR_428 -> VAR_429 . VAR_430 . VAR_431 [ 0 ] ) { VAR_432 = METHOD_24 ( 34 ) ; } } if ( VAR_433 > 2 ) { if ( VAR_434 -> VAR_435 . VAR_436 . VAR_437 [ VAR_438 ] ) { VAR_439 -> VAR_440 = 1 ; METHOD_25 ( VAR_441 , VAR_442 , VAR_443 , VAR_444 - 1 , 1 , VAR_445 ) ; } if ( VAR_446 -> VAR_447 . VAR_448 . VAR_449 [ VAR_450 ] ) { VAR_451 -> VAR_452 = 1 ; METHOD_26 ( VAR_453 , VAR_454 , VAR_455 , VAR_456 - 1 , 2 , VAR_457 ) ; } } else if ( VAR_458 == 3 ) { if ( VAR_459 -> VAR_460 . VAR_461 . VAR_462 [ VAR_463 ] ) { VAR_464 -> VAR_465 = 1 ; METHOD_27 ( VAR_466 , VAR_467 , VAR_468 , VAR_469 , 1 , VAR_470 ) ; } if ( VAR_471 -> VAR_472 . VAR_473 . VAR_474 [ VAR_475 ] ) { VAR_476 -> VAR_477 = 1 ; METHOD_28 ( VAR_478 , VAR_479 , VAR_480 , VAR_481 , 2 , VAR_482 ) ; } } else { VAR_483 -> VAR_484 = VAR_485 ; } } else { if ( ( 3 != VAR_486 ) && ( 2 == VAR_487 ) ) { VAR_488 -> VAR_489 = VAR_490 ; } } { if ( ( VAR_491 -> VAR_492 . VAR_493 . VAR_494 << 3 ) == ( VAR_495 -> VAR_496 << 2 ) && ( VAR_497 -> VAR_498 . VAR_499 . VAR_500 << 3 ) == ( VAR_501 -> VAR_502 << 2 ) ) { VAR_503 -> VAR_504 = 1 ; } else { VAR_505 -> VAR_506 = 0 ; } } VAR_507 -> VAR_508 . VAR_509 ++ ; VAR_510 -> VAR_511 . VAR_512 . VAR_513 ++ ; VAR_514 -> VAR_515 . VAR_516 ++ ; } } return VAR_517 ; }",<S2SV_ModStart> VAR_400 ; } if ( VAR_400 < METHOD_29 ( VAR_260 -> VAR_518 ) || VAR_400 > METHOD_30 ( VAR_260 -> VAR_518 ) ) { return VAR_519 ; },"CWE-119 WORD32 ihevcd_parse_transform_tree ( codec_t * ps_codec , WORD32 x0 , WORD32 y0 , WORD32 cu_x_base , WORD32 cu_y_base , WORD32 log2_trafo_size , WORD32 trafo_depth , WORD32 blk_idx , WORD32 intra_pred_mode ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; sps_t * ps_sps ; pps_t * ps_pps ; WORD32 value ; WORD32 x1 , y1 ; WORD32 max_trafo_depth ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 intra_split_flag ; WORD32 split_transform_flag ; WORD32 ctxt_idx ; cab_ctxt_t * ps_cabac = & ps_codec -> s_parse . s_cabac ; max_trafo_depth = ps_codec -> s_parse . s_cu . i4_max_trafo_depth ; ps_sps = ps_codec -> s_parse . ps_sps ; ps_pps = ps_codec -> s_parse . ps_pps ; intra_split_flag = ps_codec -> s_parse . s_cu . i4_intra_split_flag ; { split_transform_flag = 0 ; if ( ( log2_trafo_size <= ps_sps -> i1_log2_max_transform_block_size ) && ( log2_trafo_size > ps_sps -> i1_log2_min_transform_block_size ) && ( trafo_depth < max_trafo_depth ) && ! ( intra_split_flag && ( trafo_depth == 0 ) ) ) { ctxt_idx = IHEVC_CAB_SPLIT_TFM + ( 5 - log2_trafo_size ) ; TRACE_CABAC_CTXT ( ""split_transform_flag"" , ps_cabac -> u4_range , ctxt_idx ) ; split_transform_flag = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""split_transform_flag"" , split_transform_flag , ps_cabac -> u4_range ) ; } else { WORD32 inter_split_flag = 0 ; if ( ( 0 == ps_sps -> i1_max_transform_hierarchy_depth_inter ) && ( PRED_MODE_INTER == ps_codec -> s_parse . s_cu . i4_pred_mode ) && ( PART_2Nx2N != ps_codec -> s_parse . s_cu . i4_part_mode ) && ( 0 == trafo_depth ) ) { inter_split_flag = 1 ; } if ( ( log2_trafo_size > ps_sps -> i1_log2_max_transform_block_size ) || ( ( 1 == intra_split_flag ) && ( 0 == trafo_depth ) ) || ( 1 == inter_split_flag ) ) { split_transform_flag = 1 ; } } if ( 0 == trafo_depth ) { ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = 0 ; ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = 0 ; } else { ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth - 1 ] ; ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth - 1 ] ; } if ( trafo_depth == 0 || log2_trafo_size > 2 ) { ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth ; if ( ( trafo_depth == 0 ) || ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth - 1 ] ) { TRACE_CABAC_CTXT ( ""cbf_cb"" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""cbf_cb"" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = value ; } if ( ( trafo_depth == 0 ) || ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth - 1 ] ) { TRACE_CABAC_CTXT ( ""cbf_cr"" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""cbf_cr"" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = value ; } } if ( split_transform_flag ) { WORD32 intra_pred_mode_tmp ; x1 = x0 + ( ( 1 << log2_trafo_size ) >> 1 ) ; y1 = y0 + ( ( 1 << log2_trafo_size ) >> 1 ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ; ihevcd_parse_transform_tree ( ps_codec , x0 , y0 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 0 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 1 ] ; ihevcd_parse_transform_tree ( ps_codec , x1 , y0 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 1 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 2 ] ; ihevcd_parse_transform_tree ( ps_codec , x0 , y1 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 2 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 3 ] ; ihevcd_parse_transform_tree ( ps_codec , x1 , y1 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 3 , intra_pred_mode_tmp ) ; } else { WORD32 ctb_x_base ; WORD32 ctb_y_base ; WORD32 cu_qp_delta_abs ; tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; cu_qp_delta_abs = 0 ; ctb_x_base = ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ; ctb_y_base = ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ; if ( ( ps_codec -> s_parse . s_cu . i4_pred_mode == PRED_MODE_INTRA ) || ( trafo_depth != 0 ) || ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) || ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) ) { ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX ; ctxt_idx += ( trafo_depth == 0 ) ? 1 : 0 ; TRACE_CABAC_CTXT ( ""cbf_luma"" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( ""cbf_luma"" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . i1_cbf_luma = value ; } else { ps_codec -> s_parse . s_cu . i1_cbf_luma = 1 ; } ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = ( ( x0 - ctb_x_base ) >> 2 ) ; ps_tu -> b4_pos_y = ( ( y0 - ctb_y_base ) >> 2 ) ; ps_tu -> b1_transquant_bypass = ps_codec -> s_parse . s_cu . i4_cu_transquant_bypass ; ps_tu -> b3_size = ( log2_trafo_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b6_luma_intra_mode = intra_pred_mode ; ps_tu -> b3_chroma_intra_mode_idx = ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ; if ( ps_codec -> s_parse . s_cu . i1_cbf_luma || ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] || ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { WORD32 intra_pred_mode_chroma ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag && ! ps_codec -> s_parse . i4_is_cu_qp_delta_coded ) { WORD32 c_max = TU_MAX_QP_DELTA_ABS ; WORD32 ctxt_inc = IHEVC_CAB_QP_DELTA_ABS ; WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS ; TRACE_CABAC_CTXT ( ""cu_qp_delta_abs"" , ps_cabac -> u4_range , ctxt_inc ) ; cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary ( ps_cabac , ps_bitstrm , c_max , ctxt_inc , 0 , ctxt_inc_max ) ; if ( cu_qp_delta_abs >= c_max ) { value = ihevcd_cabac_decode_bypass_bins_egk ( ps_cabac , ps_bitstrm , 0 ) ; cu_qp_delta_abs += value ; } AEV_TRACE ( ""cu_qp_delta_abs"" , cu_qp_delta_abs , ps_cabac -> u4_range ) ; ps_codec -> s_parse . i4_is_cu_qp_delta_coded = 1 ; if ( cu_qp_delta_abs ) { value = ihevcd_cabac_decode_bypass_bin ( ps_cabac , ps_bitstrm ) ; AEV_TRACE ( ""cu_qp_delta_sign"" , value , ps_cabac -> u4_range ) ; if ( value ) cu_qp_delta_abs = - cu_qp_delta_abs ; } <S2SV_StartBug> ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ; <S2SV_EndBug> } if ( ps_codec -> s_parse . s_cu . i1_cbf_luma ) { ps_tu -> b1_y_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size , 0 , intra_pred_mode ) ; } if ( 4 == ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ) intra_pred_mode_chroma = ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ; else { intra_pred_mode_chroma = gau1_intra_pred_chroma_modes [ ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ] ; if ( intra_pred_mode_chroma == ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ) { intra_pred_mode_chroma = INTRA_ANGULAR ( 34 ) ; } } if ( log2_trafo_size > 2 ) { if ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) { ps_tu -> b1_cb_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size - 1 , 1 , intra_pred_mode_chroma ) ; } if ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { ps_tu -> b1_cr_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size - 1 , 2 , intra_pred_mode_chroma ) ; } } else if ( blk_idx == 3 ) { if ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) { ps_tu -> b1_cb_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , cu_x_base , cu_y_base , log2_trafo_size , 1 , intra_pred_mode_chroma ) ; } if ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { ps_tu -> b1_cr_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , cu_x_base , cu_y_base , log2_trafo_size , 2 , intra_pred_mode_chroma ) ; } } else { ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; } } else { if ( ( 3 != blk_idx ) && ( 2 == log2_trafo_size ) ) { ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; } } { if ( ( ps_codec -> s_parse . s_cu . i4_pos_x << 3 ) == ( ps_tu -> b4_pos_x << 2 ) && ( ps_codec -> s_parse . s_cu . i4_pos_y << 3 ) == ( ps_tu -> b4_pos_y << 2 ) ) { ps_tu -> b1_first_tu_in_cu = 1 ; } else { ps_tu -> b1_first_tu_in_cu = 0 ; } } ps_codec -> s_parse . ps_tu ++ ; ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; } } return ret ; }",<S2SV_ModStart> cu_qp_delta_abs ; } if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; }
321,"CWE-20 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 ) { TYPE_2 VAR_1 ; VAR_2 = METHOD_1 ( & STRUCT_OR_UNION_2 -> VAR_3 , VAR_4 , VAR_5 ? VAR_6 : VAR_7 ) ; if ( VAR_8 ) return - VAR_9 ; <S2SV_StartBug> if ( METHOD_2 ( VAR_10 , & STRUCT_OR_UNION_3 -> VAR_11 ) ) { <S2SV_EndBug> METHOD_3 ( ) ; return STRUCT_OR_UNION_4 -> VAR_12 ; } return METHOD_4 ( STRUCT_OR_UNION_5 ) ; }",<S2SV_ModStart> - VAR_9 ; VAR_8 = METHOD_5 ( STRUCT_OR_UNION_5 ) ; if ( VAR_8 < 0 ) return VAR_8 ; <S2SV_ModEnd> return METHOD_4 (,"CWE-20 int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }",<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
322,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { const struct STRUCT_OR_UNION_2 * VAR_3 = METHOD_1 ( VAR_4 ) ; if ( VAR_5 & ( 1 << ( VAR_6 - 1 ) ) ) { struct STRUCT_OR_UNION_3 VAR_7 = { . VAR_8 = 1 , . VAR_9 = VAR_10 -> VAR_11 , . VAR_12 = VAR_13 -> VAR_14 , } ; <S2SV_StartBug> TYPE_2 VAR_15 = VAR_16 -> VAR_17 ; <S2SV_EndBug> <S2SV_StartBug> METHOD_2 ( VAR_18 , VAR_19 -> VAR_20 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_21 . VAR_22 = VAR_23 ; <S2SV_EndBug> METHOD_3 ( VAR_24 , VAR_25 , sizeof ( VAR_26 ) , & VAR_27 ) ; } }","<S2SV_ModStart> , } ; if ( VAR_27 . VAR_9 > 0 ) { <S2SV_ModStart> ( VAR_23 , VAR_27 . VAR_9 <S2SV_ModEnd> ) ; VAR_27 <S2SV_ModStart> = VAR_23 ; }","CWE-189 static void tcp_illinois_info ( struct sock * sk , u32 ext , struct sk_buff * skb ) { const struct illinois * ca = inet_csk_ca ( sk ) ; if ( ext & ( 1 << ( INET_DIAG_VEGASINFO - 1 ) ) ) { struct tcpvegas_info info = { . tcpv_enabled = 1 , . tcpv_rttcnt = ca -> cnt_rtt , . tcpv_minrtt = ca -> base_rtt , } ; <S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ; } }","<S2SV_ModStart> , } ; if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> ( t , info . tcpv_rttcnt <S2SV_ModEnd> ) ; info <S2SV_ModStart> = t ; }"
323,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; struct STRUCT_OR_UNION_2 * VAR_2 ; unsigned TYPE_1 VAR_3 ; TYPE_2 VAR_4 ; VAR_5 = METHOD_1 ( & VAR_6 -> VAR_7 , sizeof ( * VAR_8 ) , VAR_9 ) ; if ( ! VAR_10 ) return - VAR_11 ; VAR_12 -> VAR_13 = & VAR_14 -> VAR_15 ; VAR_16 -> VAR_17 = METHOD_2 ( VAR_18 -> VAR_19 . VAR_20 -> VAR_21 ) ; if ( METHOD_3 ( VAR_22 -> VAR_23 ) ) return METHOD_4 ( VAR_24 -> VAR_25 ) ; <S2SV_StartBug> for ( VAR_26 = 0 ; VAR_27 <= VAR_28 ; VAR_29 ++ ) { <S2SV_EndBug> VAR_30 = METHOD_5 ( VAR_31 , VAR_32 , & VAR_33 -> VAR_34 [ VAR_35 ] ) ; if ( VAR_36 ) return VAR_37 ; } METHOD_6 ( & VAR_38 -> VAR_39 , VAR_40 ) ; VAR_41 = METHOD_7 ( VAR_42 -> VAR_43 , VAR_44 ) ; return METHOD_8 ( VAR_45 ) ; }",<S2SV_ModStart> 0 ; VAR_35 < <S2SV_ModEnd> VAR_28 ; VAR_35,"CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }",<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
324,"CWE-200 static TYPE_0 STRUCT_OR_UNION_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 ) { struct STRUCT_OR_UNION_3 VAR_2 ; <S2SV_StartBug> METHOD_0 ( VAR_3 . VAR_4 , ""acomp"" , sizeof ( VAR_5 . VAR_6 ) ) ; <S2SV_EndBug> if ( METHOD_1 ( VAR_7 , VAR_8 , sizeof ( struct STRUCT_OR_UNION_4 ) , & VAR_9 ) ) goto VAR_10 ; return 0 ; VAR_11 : return - VAR_12 ; }",<S2SV_ModStart> STRUCT_OR_UNION_4 VAR_9 ; METHOD_2 <S2SV_ModEnd> ( VAR_9 .,"CWE-200 static int crypto_report_acomp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_acomp racomp ; <S2SV_StartBug> strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }",<S2SV_ModStart> crypto_report_acomp racomp ; strncpy <S2SV_ModEnd> ( racomp .
325,CWE-119 <S2SV_StartBug> TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 ) { <S2SV_EndBug> <S2SV_StartBug> return METHOD_1 ( VAR_1 ) ; <S2SV_EndBug> },"<S2SV_ModStart> ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 > VAR_3 / VAR_2 ) { METHOD_2 ( ""can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , VAR_1 , VAR_2 ) ; METHOD_3 ( 0x534e4554 , ""27855419"" ) ; return VAR_4 ; } <S2SV_ModEnd> return METHOD_1 ( <S2SV_ModStart> METHOD_1 ( VAR_1 * VAR_2",CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> },"<S2SV_ModStart> ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( ""can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ; android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ; return NULL ; } <S2SV_ModEnd> return malloc ( <S2SV_ModStart> malloc ( size * num"
326,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 * VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 ; struct STRUCT_OR_UNION_5 * VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 ; union { struct STRUCT_OR_UNION_7 * VAR_7 ; struct STRUCT_OR_UNION_8 * VAR_8 ; TYPE_1 * VAR_9 ; } VAR_10 ; TYPE_2 * VAR_11 = VAR_12 -> VAR_13 ; TYPE_3 VAR_14 = VAR_15 -> VAR_16 ; unsigned TYPE_4 VAR_17 , VAR_18 ; unsigned TYPE_5 VAR_19 = VAR_20 | VAR_21 ; unsigned TYPE_6 VAR_22 , VAR_23 , VAR_24 ; struct STRUCT_OR_UNION_9 * VAR_25 = VAR_26 ; struct STRUCT_OR_UNION_10 VAR_27 ; struct STRUCT_OR_UNION_11 VAR_28 ; struct STRUCT_OR_UNION_12 * VAR_29 = METHOD_1 ( VAR_30 ) ; if ( VAR_31 -> VAR_32 == VAR_33 ) goto VAR_34 ; VAR_35 = VAR_36 -> VAR_37 ; VAR_38 = METHOD_2 ( VAR_39 ) ; if ( ! METHOD_3 ( METHOD_4 ( VAR_40 ) , METHOD_5 ( VAR_41 ) ) ) goto VAR_42 ; if ( VAR_43 -> VAR_44 ) { if ( VAR_45 -> VAR_46 != VAR_47 ) METHOD_6 ( VAR_48 , VAR_49 -> VAR_50 - METHOD_7 ( VAR_51 ) ) ; else if ( VAR_52 -> VAR_53 == VAR_54 ) { METHOD_8 ( VAR_55 , METHOD_9 ( VAR_56 ) ) ; } } if ( VAR_57 -> VAR_58 == VAR_59 ) VAR_60 |= VAR_61 ; VAR_62 = VAR_63 -> VAR_64 ; VAR_65 = METHOD_10 ( VAR_66 , VAR_67 , VAR_68 ) ; if ( ! VAR_69 ) goto VAR_70 ; if ( VAR_71 > VAR_72 ) VAR_73 = VAR_74 ; if ( VAR_75 -> VAR_76 == VAR_77 ) { VAR_78 = VAR_79 = METHOD_11 ( VAR_80 -> VAR_81 ) + 16 + VAR_82 -> VAR_83 ; } else { unsigned VAR_84 = METHOD_12 ( VAR_85 ) ; VAR_86 = METHOD_13 ( VAR_87 -> VAR_88 + ( VAR_89 < 16 ? 16 : VAR_90 ) ) + VAR_91 -> VAR_92 ; VAR_93 = VAR_94 - VAR_95 ; } if ( VAR_96 + VAR_97 > VAR_98 -> VAR_99 . VAR_100 ) { if ( VAR_101 -> VAR_102 && METHOD_14 ( & VAR_103 -> VAR_104 ) + VAR_105 -> VAR_106 < ( unsigned ) VAR_107 -> VAR_108 ) { if ( METHOD_15 ( VAR_109 ) ) { VAR_110 = METHOD_16 ( VAR_111 , VAR_112 ) ; } else { VAR_113 = METHOD_17 ( VAR_114 ) ; VAR_115 = VAR_116 -> VAR_117 ; } if ( VAR_118 ) METHOD_18 ( VAR_119 , VAR_120 ) ; } VAR_121 = VAR_122 -> VAR_123 . VAR_124 - VAR_125 ; if ( ( TYPE_7 ) VAR_126 < 0 ) VAR_127 = 0 ; } METHOD_19 ( & VAR_128 -> VAR_129 . VAR_130 ) ; VAR_131 . VAR_132 = METHOD_20 ( VAR_133 , & VAR_134 -> VAR_135 , VAR_136 ) ; if ( ! VAR_137 . VAR_138 ) goto VAR_139 ; METHOD_21 ( & VAR_140 -> VAR_141 ) ; VAR_142 -> VAR_143 . VAR_144 ++ ; if ( VAR_145 ) { VAR_146 |= VAR_147 ; METHOD_22 ( & VAR_148 -> VAR_149 , VAR_150 ) ; } if ( ! VAR_151 -> VAR_152 . VAR_153 ) VAR_154 &= ~ VAR_155 ; METHOD_23 ( & VAR_156 -> VAR_157 . VAR_158 ) ; METHOD_24 ( VAR_159 , 0 , VAR_160 . VAR_161 + VAR_162 , VAR_163 ) ; switch ( VAR_164 -> VAR_165 ) { case VAR_166 : VAR_167 . VAR_168 -> VAR_169 = VAR_170 -> VAR_171 ; VAR_172 . VAR_173 -> VAR_174 = VAR_175 ; VAR_176 . VAR_177 -> VAR_178 = VAR_179 ; VAR_180 . VAR_181 -> VAR_182 = VAR_183 ; if ( ( VAR_184 -> VAR_185 & VAR_186 ) && VAR_187 -> VAR_188 . VAR_189 ) VAR_190 = METHOD_25 ( VAR_191 -> VAR_192 ) ; else if ( ( VAR_193 -> VAR_194 & VAR_195 ) && VAR_196 -> VAR_197 . VAR_198 ) VAR_199 = METHOD_26 ( VAR_200 -> VAR_201 ) ; else if ( VAR_202 -> VAR_203 . VAR_204 ) VAR_205 = METHOD_27 ( VAR_206 -> VAR_207 ) ; else METHOD_28 ( & VAR_208 ) ; VAR_209 . VAR_210 -> VAR_211 = VAR_212 . VAR_213 ; VAR_214 . VAR_215 -> VAR_216 = VAR_217 . VAR_218 ; VAR_219 = sizeof ( * VAR_220 . VAR_221 ) ; break ; case VAR_222 : VAR_223 . VAR_224 -> VAR_225 = VAR_226 -> VAR_227 ; VAR_228 . VAR_229 -> VAR_230 = VAR_231 ; VAR_232 . VAR_233 -> VAR_234 = VAR_235 ; VAR_236 . VAR_237 -> VAR_238 = VAR_239 ; if ( ( VAR_240 -> VAR_241 & VAR_242 ) && VAR_243 -> VAR_244 . VAR_245 ) VAR_246 = METHOD_29 ( VAR_247 -> VAR_248 ) ; else if ( ( VAR_249 -> VAR_250 & VAR_251 ) && VAR_252 -> VAR_253 . VAR_254 ) VAR_255 = METHOD_30 ( VAR_256 -> VAR_257 ) ; else if ( VAR_258 -> VAR_259 . VAR_260 ) VAR_261 = METHOD_31 ( VAR_262 -> VAR_263 ) ; else METHOD_32 ( & VAR_264 ) ; VAR_265 . VAR_266 -> VAR_267 = VAR_268 . VAR_269 ; VAR_270 . VAR_271 -> VAR_272 = VAR_273 . VAR_274 ; if ( METHOD_33 ( VAR_275 ) ) { VAR_276 . VAR_277 -> VAR_278 = METHOD_34 ( VAR_279 ) ; VAR_280 |= VAR_281 ; } else { VAR_282 . VAR_283 -> VAR_284 = 0 ; } <S2SV_StartBug> VAR_285 = sizeof ( * VAR_286 . VAR_287 ) ; <S2SV_EndBug> break ; default : METHOD_35 ( ) ; } VAR_288 = VAR_289 . VAR_290 + METHOD_36 ( VAR_291 ) ; VAR_292 -> VAR_293 = METHOD_37 ( VAR_294 , VAR_295 -> VAR_296 ) ; VAR_297 -> VAR_298 = VAR_299 ; VAR_300 -> VAR_301 = VAR_302 -> VAR_303 ; VAR_304 -> VAR_305 = VAR_306 -> VAR_307 ; VAR_308 -> VAR_309 = VAR_310 -> VAR_311 ; if ( METHOD_38 ( VAR_312 -> VAR_313 ) ) VAR_314 -> VAR_315 = VAR_316 -> VAR_317 ; else VAR_318 -> VAR_319 = VAR_320 -> VAR_321 ; METHOD_39 ( VAR_322 , VAR_323 . VAR_324 , VAR_325 ) ; METHOD_40 ( ) ; if VAR_326 == 1 { TYPE_8 * VAR_327 , * VAR_328 ; VAR_329 = ( TYPE_9 * ) METHOD_41 ( ( unsigned TYPE_10 ) VAR_330 . VAR_331 + VAR_332 + VAR_333 ) ; for ( VAR_334 = VAR_335 . VAR_336 ; VAR_337 < VAR_338 ; VAR_339 += VAR_340 ) METHOD_42 ( METHOD_43 ( VAR_341 ) ) ; } VAR_342 -> METHOD_44 ( VAR_343 , 0 ) ; VAR_344 : if ( VAR_345 != VAR_346 -> VAR_347 && METHOD_45 ( VAR_348 ) ) { VAR_349 -> VAR_350 = VAR_351 ; VAR_352 -> VAR_353 = VAR_354 ; } VAR_355 : METHOD_46 ( VAR_356 ) ; return 0 ; VAR_357 : VAR_358 -> VAR_359 . VAR_360 ++ ; METHOD_47 ( & VAR_361 -> VAR_362 . VAR_363 ) ; VAR_364 -> METHOD_48 ( VAR_365 , 0 ) ; METHOD_49 ( VAR_366 ) ; goto VAR_367 ; }",<S2SV_ModStart> 0 ; } VAR_335 . VAR_287 -> VAR_368 = 0 ;,"CWE-264 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union { struct tpacket_hdr * h1 ; struct tpacket2_hdr * h2 ; void * raw ; } h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_LOSING | TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timeval tv ; struct timespec ts ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; macoff = netoff - maclen ; } if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize < ( unsigned ) sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) snaplen = 0 ; } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_frame ( po , & po -> rx_ring , TP_STATUS_KERNEL ) ; if ( ! h . raw ) goto ring_is_full ; packet_increment_head ( & po -> rx_ring ) ; po -> stats . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } if ( ! po -> stats . tp_drops ) status &= ~ TP_STATUS_LOSING ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) tv = ktime_to_timeval ( skb -> tstamp ) ; else do_gettimeofday ( & tv ) ; h . h1 -> tp_sec = tv . tv_sec ; h . h1 -> tp_usec = tv . tv_usec ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) ts = ktime_to_timespec ( skb -> tstamp ) ; else getnstimeofday ( & ts ) ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( vlan_tx_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = vlan_tx_tag_get ( skb ) ; status |= TP_STATUS_VLAN_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; } <S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; __packet_set_status ( po , h . raw , status ) ; smp_mb ( ) ;  if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; }   sk -> sk_data_ready ( sk , 0 ) ; drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : kfree_skb ( skb ) ; return 0 ; ring_is_full : po -> stats . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk , 0 ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }",<S2SV_ModStart> 0 ; } h . h2 -> tp_padding = 0 ;
327,CWE-415 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; VAR_2 = METHOD_1 ( VAR_3 ) ; METHOD_2 ( & VAR_4 -> VAR_5 ) ; <S2SV_StartBug> METHOD_3 ( VAR_6 -> VAR_7 ) ; <S2SV_EndBug> return 0 ; },<S2SV_ModStart> VAR_5 ) ; <S2SV_ModEnd> return 0 ;,CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; },<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
328,"CWE-119 TYPE_0 * METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 ) { const struct STRUCT_OR_UNION_1 * VAR_2 ; TYPE_2 * VAR_3 , * VAR_4 ; TYPE_3 VAR_5 = METHOD_1 ( VAR_6 ) ; TYPE_4 VAR_7 = VAR_8 + 1 ; for ( VAR_9 = VAR_10 ; VAR_11 ; VAR_12 = VAR_13 -> VAR_14 ) { if ( VAR_15 -> VAR_16 ) VAR_17 += VAR_18 -> VAR_19 + 1 ; } VAR_20 = METHOD_2 ( VAR_21 ) ; VAR_22 = VAR_23 + VAR_24 - ( VAR_25 + 1 ) ; <S2SV_StartBug> METHOD_3 ( VAR_26 , VAR_27 ) ; <S2SV_EndBug> for ( VAR_28 = VAR_29 ; VAR_30 ; VAR_31 = VAR_32 -> VAR_33 ) { if ( VAR_34 -> VAR_35 ) { VAR_36 -= VAR_37 -> VAR_38 + 1 ; METHOD_4 ( VAR_39 , VAR_40 -> VAR_41 , VAR_42 -> VAR_43 ) ; VAR_44 [ VAR_45 -> VAR_46 ] = '/' ; } } return VAR_47 ; }","<S2SV_ModStart> 1 ) ; METHOD_4 <S2SV_ModEnd> ( VAR_44 , <S2SV_ModStart> VAR_44 , VAR_27 , VAR_25 + 1","CWE-119 char * path_name ( const struct name_path * path , const char * name ) { const struct name_path * p ; char * n , * m ; int nlen = strlen ( name ) ; int len = nlen + 1 ; for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) len += p -> elem_len + 1 ; } n = xmalloc ( len ) ; m = n + len - ( nlen + 1 ) ; <S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) { m -= p -> elem_len + 1 ; memcpy ( m , p -> elem , p -> elem_len ) ; m [ p -> elem_len ] = '/' ; } } return n ; }","<S2SV_ModStart> 1 ) ; memcpy <S2SV_ModEnd> ( m , <S2SV_ModStart> m , name , nlen + 1"
329,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 , VAR_3 ; <S2SV_StartBug> TYPE_4 * VAR_4 = & VAR_5 -> VAR_6 . VAR_7 ; <S2SV_EndBug> const TYPE_5 * VAR_8 = & VAR_9 -> VAR_10 [ VAR_11 -> VAR_12 ] . VAR_13 ; const TYPE_6 * VAR_14 = & VAR_15 -> VAR_16 . VAR_17 ; <S2SV_StartBug> METHOD_1 ( VAR_18 , VAR_19 -> VAR_20 , VAR_21 -> VAR_22 , VAR_23 -> VAR_24 ) ; <S2SV_EndBug> for ( VAR_25 = 0 ; VAR_26 < 2 ; ++ VAR_27 ) { TYPE_7 * VAR_28 = & VAR_29 -> VAR_30 [ VAR_31 ] ; const TYPE_8 * VAR_32 = & VAR_33 -> VAR_34 [ VAR_35 ] ; const TYPE_9 * VAR_36 = & VAR_37 -> VAR_38 [ VAR_39 ] ; <S2SV_StartBug> VAR_40 -> VAR_41 = METHOD_2 ( VAR_42 -> VAR_43 , VAR_44 -> VAR_45 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_3 ( VAR_46 , VAR_47 -> VAR_48 , VAR_49 -> VAR_50 , <S2SV_EndBug> VAR_51 -> VAR_52 ) ; <S2SV_StartBug> METHOD_4 ( VAR_53 , VAR_54 -> VAR_55 , VAR_56 -> VAR_57 , VAR_58 -> VAR_59 ) ; <S2SV_EndBug> for ( VAR_60 = 0 ; VAR_61 < VAR_62 ; ++ VAR_63 ) <S2SV_StartBug> VAR_64 -> VAR_65 [ VAR_66 ] = METHOD_5 ( VAR_67 -> VAR_68 [ VAR_69 ] , VAR_70 -> VAR_71 [ VAR_72 ] ) ; <S2SV_EndBug> for ( VAR_73 = 0 ; VAR_74 < VAR_75 ; ++ VAR_76 ) <S2SV_StartBug> METHOD_6 ( VAR_77 , VAR_78 -> VAR_79 [ VAR_80 ] , VAR_81 -> VAR_82 [ VAR_83 ] , <S2SV_EndBug> VAR_84 -> VAR_85 [ VAR_86 ] ) ; <S2SV_StartBug> METHOD_7 ( VAR_87 , VAR_88 -> VAR_89 , VAR_90 -> VAR_91 , VAR_92 -> VAR_93 ) ; <S2SV_EndBug> if ( VAR_94 ) { <S2SV_StartBug> VAR_95 -> VAR_96 = METHOD_8 ( VAR_97 -> VAR_98 , VAR_99 -> VAR_100 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_101 -> VAR_102 = METHOD_9 ( VAR_103 -> VAR_104 , VAR_105 -> VAR_106 ) ; <S2SV_EndBug> } } }","<S2SV_ModStart> VAR_15 -> VAR_29 -> <S2SV_ModEnd> VAR_13 ; const <S2SV_ModStart> . VAR_17 ; METHOD_10 <S2SV_ModEnd> ( VAR_18 , <S2SV_ModStart> -> VAR_45 = METHOD_11 <S2SV_ModEnd> ( VAR_103 -> <S2SV_ModStart> VAR_45 ) ; METHOD_10 <S2SV_ModEnd> ( VAR_46 , <S2SV_ModStart> VAR_52 ) ; METHOD_10 <S2SV_ModEnd> ( VAR_53 , <S2SV_ModStart> VAR_86 ] = METHOD_11 <S2SV_ModEnd> ( VAR_103 -> <S2SV_ModStart> ++ VAR_86 ) METHOD_10 <S2SV_ModEnd> ( VAR_87 , <S2SV_ModStart> ] ) ; METHOD_10 <S2SV_ModEnd> ( VAR_87 , <S2SV_ModStart> -> VAR_100 = METHOD_11 <S2SV_ModEnd> ( VAR_103 -> <S2SV_ModStart> -> VAR_106 = METHOD_11 <S2SV_ModEnd> ( VAR_103 ->","CWE-119 void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { int i , j ; <S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; const nmv_context_counts * counts = & cm -> counts . mv ; <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & fc -> comps [ i ] ; const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; const nmv_component_counts * c = & counts -> comps [ i ] ; <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> comp -> classes ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> comp -> class0_fp [ j ] ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> if ( allow_hp ) { <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> } } }","<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> nmvc ; const <S2SV_ModStart> . mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree , <S2SV_ModStart> -> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> sign ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree , <S2SV_ModStart> classes ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree , <S2SV_ModStart> j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> ++ j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> ] ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> -> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> -> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp ->"
330,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 TYPE_3 * VAR_2 , unsigned TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; unsigned TYPE_6 VAR_5 [ VAR_6 ] ; struct STRUCT_OR_UNION_1 * VAR_7 ; struct STRUCT_OR_UNION_2 VAR_8 ; struct STRUCT_OR_UNION_3 * VAR_9 ; struct STRUCT_OR_UNION_4 * VAR_10 ; struct STRUCT_OR_UNION_5 VAR_11 ; if ( ! METHOD_1 ( VAR_12 ) ) return - VAR_13 ; <S2SV_StartBug> if ( VAR_14 != VAR_15 [ METHOD_2 ( VAR_16 ) ] ) { <S2SV_EndBug> METHOD_3 ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , VAR_17 , VAR_18 [ METHOD_4 ( VAR_19 ) ] ) ; return - VAR_20 ; } if ( METHOD_5 ( VAR_21 , VAR_22 , VAR_23 ) != 0 ) return - VAR_24 ; METHOD_6 ( ) ; if ( METHOD_7 ( & VAR_25 ) ) { VAR_26 = - VAR_27 ; goto VAR_28 ; } if ( VAR_29 == VAR_30 ) { VAR_31 = METHOD_8 ( ) ; goto VAR_32 ; } else if ( VAR_33 == VAR_34 ) { VAR_35 = METHOD_9 ( ( struct STRUCT_OR_UNION_6 * ) VAR_36 ) ; goto VAR_37 ; } else if ( VAR_38 == VAR_39 ) { struct STRUCT_OR_UNION_7 * VAR_40 = ( struct STRUCT_OR_UNION_8 * ) VAR_41 ; VAR_42 = METHOD_10 ( VAR_43 -> VAR_44 , VAR_45 -> VAR_46 , VAR_47 -> VAR_48 ) ; goto VAR_49 ; } else if ( VAR_50 == VAR_51 ) { struct STRUCT_OR_UNION_9 * VAR_52 = ( struct STRUCT_OR_UNION_10 * ) VAR_53 ; VAR_54 = METHOD_11 ( VAR_55 -> VAR_56 ) ; goto VAR_57 ; } VAR_58 = ( struct STRUCT_OR_UNION_11 * ) VAR_59 ; VAR_60 = ( struct STRUCT_OR_UNION_12 * ) ( VAR_61 + 1 ) ; METHOD_12 ( & VAR_62 , VAR_63 ) ; METHOD_13 ( & VAR_64 , VAR_65 ) ; if ( VAR_66 == VAR_67 ) { if ( ! VAR_68 . VAR_69 && ! VAR_70 . VAR_71 . VAR_72 && ! VAR_73 . VAR_74 ) { VAR_75 = METHOD_14 ( ) ; goto VAR_76 ; } } if ( VAR_77 . VAR_78 != VAR_79 && VAR_80 . VAR_81 != VAR_82 ) { METHOD_15 ( ""set_ctl:<S2SV_blank>invalid<S2SV_blank>protocol:<S2SV_blank>%d<S2SV_blank>%pI4:%d<S2SV_blank>%s\\n"" , VAR_83 . VAR_84 , & VAR_85 . VAR_86 . VAR_87 , METHOD_16 ( VAR_88 . VAR_89 ) , VAR_90 . VAR_91 ) ; VAR_92 = - VAR_93 ; goto VAR_94 ; } if ( VAR_95 . VAR_96 == 0 ) VAR_97 = METHOD_17 ( VAR_98 . VAR_99 , VAR_100 . VAR_101 , & VAR_102 . VAR_103 , VAR_104 . VAR_105 ) ; else VAR_106 = METHOD_18 ( VAR_107 . VAR_108 , VAR_109 . VAR_110 ) ; if ( VAR_111 != VAR_112 && ( VAR_113 == VAR_114 || VAR_115 -> VAR_116 != VAR_117 . VAR_118 ) ) { VAR_119 = - VAR_120 ; goto VAR_121 ; } switch ( VAR_122 ) { case VAR_123 : if ( VAR_124 != VAR_125 ) VAR_126 = - VAR_127 ; else VAR_128 = METHOD_19 ( & VAR_129 , & VAR_130 ) ; break ; case VAR_131 : VAR_132 = METHOD_20 ( VAR_133 , & VAR_134 ) ; break ; case VAR_135 : VAR_136 = METHOD_21 ( VAR_137 ) ; if ( ! VAR_138 ) goto VAR_139 ; break ; case VAR_140 : VAR_141 = METHOD_22 ( VAR_142 ) ; break ; case VAR_143 : VAR_144 = METHOD_23 ( VAR_145 , & VAR_146 ) ; break ; case VAR_147 : VAR_148 = METHOD_24 ( VAR_149 , & VAR_150 ) ; break ; case VAR_151 : VAR_152 = METHOD_25 ( VAR_153 , & VAR_154 ) ; break ; default : VAR_155 = - VAR_156 ; } if ( VAR_157 ) METHOD_26 ( VAR_158 ) ; VAR_159 : METHOD_27 ( & VAR_160 ) ; VAR_161 : METHOD_28 ( ) ; return VAR_162 ; }",<S2SV_ModStart> ; if ( VAR_122 < VAR_163 || VAR_122 > VAR_164 ) return - VAR_156 ; if ( VAR_23 < 0 || VAR_23 > VAR_6 ) return - VAR_156 ; if (,"CWE-119 static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user * ) arg ; udest_compat = ( struct ip_vs_dest_user * ) ( usvc_compat + 1 ) ; ip_vs_copy_usvc_compat ( & usvc , usvc_compat ) ; ip_vs_copy_udest_compat ( & udest , udest_compat ) ; if ( cmd == IP_VS_SO_SET_ZERO ) { if ( ! usvc . fwmark && ! usvc . addr . ip && ! usvc . port ) { ret = ip_vs_zero_all ( ) ; goto out_unlock ; } } if ( usvc . protocol != IPPROTO_TCP && usvc . protocol != IPPROTO_UDP ) { pr_err ( ""set_ctl:<S2SV_blank>invalid<S2SV_blank>protocol:<S2SV_blank>%d<S2SV_blank>%pI4:%d<S2SV_blank>%s\\n"" , usvc . protocol , & usvc . addr . ip , ntohs ( usvc . port ) , usvc . sched_name ) ; ret = - EFAULT ; goto out_unlock ; } if ( usvc . fwmark == 0 ) svc = __ip_vs_service_get ( usvc . af , usvc . protocol , & usvc . addr , usvc . port ) ; else svc = __ip_vs_svc_fwm_get ( usvc . af , usvc . fwmark ) ; if ( cmd != IP_VS_SO_SET_ADD && ( svc == NULL || svc -> protocol != usvc . protocol ) ) { ret = - ESRCH ; goto out_unlock ; } switch ( cmd ) { case IP_VS_SO_SET_ADD : if ( svc != NULL ) ret = - EEXIST ; else ret = ip_vs_add_service ( & usvc , & svc ) ; break ; case IP_VS_SO_SET_EDIT : ret = ip_vs_edit_service ( svc , & usvc ) ; break ; case IP_VS_SO_SET_DEL : ret = ip_vs_del_service ( svc ) ; if ( ! ret ) goto out_unlock ; break ; case IP_VS_SO_SET_ZERO : ret = ip_vs_zero_service ( svc ) ; break ; case IP_VS_SO_SET_ADDDEST : ret = ip_vs_add_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_EDITDEST : ret = ip_vs_edit_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_DELDEST : ret = ip_vs_del_dest ( svc , & udest ) ; break ; default : ret = - EINVAL ; } if ( svc ) ip_vs_service_put ( svc ) ; out_unlock : mutex_unlock ( & __ip_vs_mutex ) ; out_dec : ip_vs_use_count_dec ( ) ; return ret ; }",<S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (
331,"CWE-835 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , const TYPE_1 * VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_2 VAR_4 ; METHOD_1 ( & VAR_5 , VAR_6 , VAR_7 ) ; const TYPE_3 * VAR_8 = METHOD_2 ( & VAR_9 -> VAR_10 , ""content-type"" ) ; METHOD_3 ( & VAR_11 , VAR_12 , VAR_13 ? METHOD_4 ( VAR_14 ) : 0 ) ; if ( METHOD_5 ( & VAR_15 , ""application/x-www-form-urlencoded"" ) ) { METHOD_6 ( & VAR_16 -> VAR_17 , VAR_18 , VAR_19 ) ; } else if ( METHOD_7 ( & VAR_20 , ""multipart/form-data"" ) ) { const TYPE_4 * VAR_21 = METHOD_8 ( & VAR_22 , ""boundary"" ) ; if ( VAR_23 && * VAR_24 ) { const TYPE_5 * VAR_25 = VAR_26 ; for ( const TYPE_6 * VAR_27 = VAR_28 ; VAR_29 > 0 ; ) { const TYPE_7 * VAR_30 ; if ( ( VAR_31 == VAR_32 && ( VAR_33 = METHOD_9 ( VAR_34 , VAR_35 , ""--"" ) ) != VAR_36 ) || ( VAR_37 = METHOD_10 ( VAR_38 , VAR_39 , ""\\r\\n--"" ) ) != VAR_40 ) { VAR_41 -= VAR_42 - VAR_43 + ( VAR_44 == VAR_45 ? 2 : 4 ) ; VAR_46 = VAR_47 + ( VAR_48 == VAR_49 ? 2 : 4 ) ; if ( ! METHOD_11 ( VAR_50 , VAR_51 , VAR_52 ) ) { TYPE_8 VAR_53 = METHOD_12 ( VAR_54 ) ; VAR_55 -= VAR_56 ; VAR_57 += VAR_58 ; if ( ! METHOD_13 ( VAR_59 , VAR_60 , ""\\r\\n"" ) ) { VAR_61 -= 2 ; VAR_62 += 2 ; if ( VAR_63 ) { METHOD_14 ( VAR_64 , VAR_65 , VAR_66 - VAR_67 ) ; } else { if ( VAR_68 != VAR_69 ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>prologue<S2SV_blank>before<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } VAR_70 = VAR_71 ; } else if ( ! METHOD_15 ( VAR_72 , VAR_73 , ""--\\r\\n"" ) ) { VAR_74 -= 4 ; VAR_75 += 4 ; METHOD_16 ( VAR_76 , VAR_77 , VAR_78 - VAR_79 ) ; VAR_80 = VAR_81 ; if ( VAR_82 > 0 ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>epilogue<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>\\""multipart/"" ""form-data\\""!"" ) ; } } } } <S2SV_StartBug> } <S2SV_EndBug> if ( VAR_83 ) { <S2SV_StartBug> METHOD_17 ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\""boundary\\""<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; <S2SV_EndBug> } } else { METHOD_18 ( ""[http]<S2SV_blank>Missing<S2SV_blank>\\""boundary\\""<S2SV_blank>information<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } METHOD_19 ( & VAR_84 ) ; }","<S2SV_ModStart> } } } else <S2SV_ModEnd> { METHOD_18 ( <S2SV_ModStart> { METHOD_18 ( ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ; break ; } } if ( VAR_83 ) { METHOD_18 (","CWE-835 static void urlParsePostBody ( struct URL * url , const struct HttpConnection * http , const char * buf , int len ) { struct HashMap contentType ; initHashMap ( & contentType , urlDestroyHashMapEntry , NULL ) ; const char * ctHeader = getFromHashMap ( & http -> header , ""content-type"" ) ; urlParseHeaderLine ( & contentType , ctHeader , ctHeader ? strlen ( ctHeader ) : 0 ) ; if ( getRefFromHashMap ( & contentType , ""application/x-www-form-urlencoded"" ) ) { urlParseQueryString ( & url -> args , buf , len ) ; } else if ( getRefFromHashMap ( & contentType , ""multipart/form-data"" ) ) { const char * boundary = getFromHashMap ( & contentType , ""boundary"" ) ; if ( boundary && * boundary ) { const char * lastPart = NULL ; for ( const char * part = buf ; len > 0 ; ) { const char * ptr ; if ( ( part == buf && ( ptr = urlMemstr ( part , len , ""--"" ) ) != NULL ) || ( ptr = urlMemstr ( part , len , ""\\r\\n--"" ) ) != NULL ) { len -= ptr - part + ( part == buf ? 2 : 4 ) ; part = ptr + ( part == buf ? 2 : 4 ) ; if ( ! urlMemcmp ( part , len , boundary ) ) { int i = strlen ( boundary ) ; len -= i ; part += i ; if ( ! urlMemcmp ( part , len , ""\\r\\n"" ) ) { len -= 2 ; part += 2 ; if ( lastPart ) { urlParsePart ( url , lastPart , ptr - lastPart ) ; } else { if ( ptr != buf ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>prologue<S2SV_blank>before<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } lastPart = part ; } else if ( ! urlMemcmp ( part , len , ""--\\r\\n"" ) ) { len -= 4 ; part += 4 ; urlParsePart ( url , lastPart , ptr - lastPart ) ; lastPart = NULL ; if ( len > 0 ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>epilogue<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>\\""multipart/"" ""form-data\\""!"" ) ; } } } } <S2SV_StartBug> } <S2SV_EndBug> if ( lastPart ) { <S2SV_StartBug> warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\""boundary\\""<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; <S2SV_EndBug> } } else { warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>\\""boundary\\""<S2SV_blank>information<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } destroyHashMap ( & contentType ) ; }","<S2SV_ModStart> } } } else <S2SV_ModEnd> { warn ( <S2SV_ModStart> { warn ( ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ; break ; } } if ( lastPart ) { warn ("
332,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; VAR_5 * VAR_6 ; VAR_7 * VAR_8 ; TYPE_6 VAR_9 ; TYPE_7 VAR_10 ; <S2SV_StartBug> VAR_11 = VAR_12 -> VAR_13 ; <S2SV_EndBug> VAR_14 = METHOD_1 ( 0 , & VAR_15 ) ; if ( VAR_16 == VAR_17 ) return VAR_18 ; do { VAR_19 = METHOD_2 ( VAR_20 , VAR_21 -> VAR_22 , VAR_23 -> VAR_24 ) ; if ( VAR_25 ) break ; if ( VAR_26 == VAR_27 ) if ( VAR_28 -> VAR_29 . VAR_30 == sizeof ( TYPE_8 ) ) { TYPE_9 VAR_31 ; VAR_32 = METHOD_3 ( & VAR_33 , VAR_34 -> VAR_35 . VAR_36 , & VAR_37 ) ; if ( VAR_38 ) break ; VAR_39 . VAR_40 = sizeof ( VAR_41 ) ; VAR_42 . VAR_43 . VAR_44 = VAR_45 ; VAR_46 . VAR_47 . VAR_48 = VAR_49 -> VAR_50 . VAR_51 ; VAR_52 . VAR_53 . VAR_54 = 0 ; VAR_55 . VAR_56 . VAR_57 = VAR_58 -> VAR_59 ; VAR_60 . VAR_61 . VAR_62 = METHOD_4 ( VAR_63 -> VAR_64 ) ; } else if ( VAR_65 == VAR_66 ) if ( VAR_67 -> VAR_68 . VAR_69 == sizeof ( VAR_70 ) ) { VAR_71 = METHOD_5 ( & VAR_72 , & VAR_73 -> VAR_74 . VAR_75 , & VAR_76 . VAR_77 . VAR_78 ) ; if ( VAR_79 ) break ; VAR_80 . VAR_81 = sizeof ( VAR_82 ) ; VAR_83 . VAR_84 . VAR_85 = VAR_86 -> VAR_87 . VAR_88 ; VAR_89 . VAR_90 . VAR_91 = METHOD_6 ( VAR_92 -> VAR_93 ) ; VAR_94 . VAR_95 . VAR_96 [ 0 ] = 0 ; VAR_97 . VAR_98 . VAR_99 [ 1 ] = 0 ; VAR_100 . VAR_101 . VAR_102 [ 2 ] = 0 ; VAR_103 . VAR_104 . VAR_105 = VAR_106 -> VAR_107 ; } else { VAR_108 = VAR_109 ; break ; } VAR_110 = VAR_111 ; if ( VAR_112 -> VAR_113 != 0 ) { VAR_114 . VAR_115 = VAR_116 -> VAR_117 ; } else if ( METHOD_7 ( & VAR_118 -> VAR_119 ) ) { VAR_120 . VAR_121 = VAR_122 -> VAR_123 ; } else { VAR_124 . VAR_125 = VAR_126 -> VAR_127 ; } if ( VAR_128 & VAR_129 ) { VAR_130 . VAR_131 = VAR_132 ; } if ( VAR_133 == VAR_134 ) VAR_135 . VAR_136 = VAR_137 -> VAR_138 ; if ( VAR_139 == VAR_140 ) VAR_141 . VAR_142 = VAR_143 -> VAR_144 ; VAR_145 . VAR_146 = VAR_147 -> VAR_148 ; if ( VAR_149 == VAR_150 ) VAR_151 . VAR_152 = VAR_153 -> VAR_154 ; VAR_155 . VAR_156 = VAR_157 -> VAR_158 ; if ( VAR_159 == VAR_160 ) VAR_161 . VAR_162 = VAR_163 -> VAR_164 ; VAR_165 . VAR_166 = VAR_167 -> VAR_168 ; if ( VAR_169 == VAR_170 ) VAR_171 . VAR_172 = VAR_173 -> VAR_174 ; if ( VAR_175 == VAR_176 ) VAR_177 . VAR_178 = VAR_179 -> VAR_180 ; VAR_181 = METHOD_8 ( VAR_182 , & VAR_183 , VAR_184 , VAR_185 , & VAR_186 ) ; if ( VAR_187 ) break ; } while ( 0 ) ; METHOD_9 ( VAR_188 ) ; return VAR_189 ; }",<S2SV_ModStart> TYPE_7 VAR_186 ; if ( VAR_179 -> VAR_182 != VAR_17 ) { VAR_182 = VAR_179 -> VAR_182 ; } else { VAR_182 = VAR_167 -> VAR_182 ; } <S2SV_ModEnd> VAR_188 = METHOD_1,"CWE-20 error_t rawSocketSendIpPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; NetInterface * interface ; IpPseudoHeader pseudoHeader ; NetTxAncillary ancillary ; <S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> buffer = ipAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; do { error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( error ) break ;  if ( IPV4_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv4Addr ) ) { Ipv4Addr srcIpAddr ; error = ipv4SelectSourceAddr ( & interface , message -> destIpAddr . ipv4Addr , & srcIpAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader . ipv4Data . srcAddr = srcIpAddr ; pseudoHeader . ipv4Data . destAddr = message -> destIpAddr . ipv4Addr ; pseudoHeader . ipv4Data . reserved = 0 ; pseudoHeader . ipv4Data . protocol = socket -> protocol ; pseudoHeader . ipv4Data . length = htons ( message -> length ) ; } else    if ( IPV6_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv6Addr ) ) { error = ipv6SelectSourceAddr ( & interface , & message -> destIpAddr . ipv6Addr , & pseudoHeader . ipv6Data . srcAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader . ipv6Data . destAddr = message -> destIpAddr . ipv6Addr ; pseudoHeader . ipv6Data . length = htonl ( message -> length ) ; pseudoHeader . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader . ipv6Data . nextHeader = socket -> protocol ; } else   { error = ERROR_FAILURE ; break ; } ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; }  if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ;    if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ;    if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ;    if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ;    if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ;    if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ;   error = ipSendDatagram ( interface , & pseudoHeader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netBufferFree ( buffer ) ; return error ; }",<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer
333,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> METHOD_1 ( VAR_3 , VAR_4 , & VAR_5 ) ; METHOD_2 ( VAR_6 . VAR_7 [ 0 ] , VAR_8 . VAR_9 [ 1 ] , & VAR_10 . VAR_11 -> VAR_12 [ 0 ] ) ; METHOD_3 ( VAR_13 . VAR_14 [ 2 ] , VAR_15 . VAR_16 [ 3 ] , & VAR_17 . VAR_18 -> VAR_19 [ 1 ] ) ; METHOD_4 ( VAR_20 . VAR_21 [ 0 ] , VAR_22 . VAR_23 [ 2 ] , & VAR_24 . VAR_25 -> VAR_26 [ 0 ] ) ; METHOD_5 ( VAR_27 . VAR_28 [ 1 ] , VAR_29 . VAR_30 [ 3 ] , & VAR_31 . VAR_32 -> VAR_33 [ 1 ] ) ; METHOD_6 ( & VAR_34 . VAR_35 -> VAR_36 [ 0 ] , & VAR_37 . VAR_38 -> VAR_39 [ 1 ] , & VAR_40 . VAR_41 -> VAR_42 ) ; }","<S2SV_ModStart> { TYPE_3 VAR_40 ; METHOD_7 ( & VAR_40 , 0 , sizeof ( VAR_40 ) )","CWE-119 static void fill_variance_tree ( void * data , BLOCK_SIZE bsize ) { <S2SV_StartBug> variance_node node ; <S2SV_EndBug> tree_to_node ( data , bsize , & node ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 1 ] , & node . part_variances -> horz [ 0 ] ) ; sum_2_variances ( node . split [ 2 ] , node . split [ 3 ] , & node . part_variances -> horz [ 1 ] ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 2 ] , & node . part_variances -> vert [ 0 ] ) ; sum_2_variances ( node . split [ 1 ] , node . split [ 3 ] , & node . part_variances -> vert [ 1 ] ) ; sum_2_variances ( & node . part_variances -> vert [ 0 ] , & node . part_variances -> vert [ 1 ] , & node . part_variances -> none ) ; }","<S2SV_ModStart> { variance_node node ; memset ( & node , 0 , sizeof ( node ) )"
334,"CWE-119 TYPE_0 METHOD_0 ( const unsigned TYPE_1 * VAR_0 , <S2SV_StartBug> const TYPE_2 * VAR_1 , <S2SV_EndBug> TYPE_3 * VAR_2 , <S2SV_StartBug> TYPE_4 VAR_3 ) { <S2SV_EndBug> TYPE_5 VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 ; TYPE_6 VAR_11 ; <S2SV_StartBug> TYPE_7 VAR_12 , VAR_13 [ VAR_14 ] , VAR_15 [ VAR_16 ] ; <S2SV_EndBug> METHOD_1 ( VAR_17 , VAR_18 ) ; <S2SV_StartBug> METHOD_2 ( VAR_19 , VAR_20 , sizeof ( TYPE_8 ) * VAR_21 ) ; <S2SV_EndBug> for ( VAR_22 = VAR_23 , VAR_24 = 0 ; VAR_25 < VAR_26 ; ++ VAR_27 ) VAR_28 += METHOD_3 ( VAR_29 + 2 * VAR_30 , VAR_31 [ VAR_32 ] ) ; VAR_33 += METHOD_4 ( VAR_34 + 2 * VAR_35 , VAR_36 [ VAR_37 ] ) ; VAR_38 = 0 ; VAR_39 = VAR_40 [ VAR_41 ] ; <S2SV_StartBug> VAR_42 = ( * VAR_43 > VAR_44 [ VAR_45 ] ? - 1 : 1 ) ; <S2SV_EndBug> for ( VAR_46 = * VAR_47 ; VAR_48 != VAR_49 [ VAR_50 ] ; VAR_51 += VAR_52 ) { if ( VAR_53 < 1 || VAR_54 > 255 ) continue ; VAR_55 [ VAR_56 ] = VAR_57 ; METHOD_5 ( VAR_58 , VAR_59 ) ; for ( VAR_60 = VAR_61 , VAR_62 = 0 ; VAR_63 < VAR_64 ; ++ VAR_65 ) VAR_66 += METHOD_6 ( VAR_67 + 2 * VAR_68 , VAR_69 [ VAR_70 ] ) ; VAR_71 += METHOD_7 ( VAR_72 + 2 * VAR_73 , VAR_74 [ VAR_75 ] ) ; VAR_76 = METHOD_8 ( VAR_77 , VAR_78 [ VAR_79 ] ) + VAR_80 ; VAR_81 = VAR_82 - VAR_83 - VAR_84 ; if ( VAR_85 > VAR_86 ) { VAR_87 = VAR_88 ; VAR_89 = VAR_90 ; } } <S2SV_StartBug> * VAR_91 = VAR_92 ; <S2SV_EndBug> return VAR_93 ; }","<S2SV_ModStart> VAR_72 , const TYPE_9 * VAR_78 , TYPE_9 <S2SV_ModEnd> * VAR_91 , <S2SV_ModStart> * VAR_91 , TYPE_9 VAR_3 , TYPE_6 VAR_94 ) { TYPE_6 <S2SV_ModEnd> VAR_70 , VAR_82 <S2SV_ModStart> TYPE_6 VAR_90 ; TYPE_9 <S2SV_ModEnd> VAR_92 , VAR_74 <S2SV_ModStart> VAR_36 ) ; METHOD_9 <S2SV_ModEnd> ( VAR_74 , <S2SV_ModStart> , sizeof ( TYPE_9 <S2SV_ModEnd> ) * VAR_61 <S2SV_ModStart> VAR_79 ] ; if ( * VAR_91 > VAR_78 [ VAR_79 ] ) { VAR_52 = - VAR_94 ; for ( VAR_90 = * VAR_91 ; VAR_90 > <S2SV_ModEnd> VAR_78 [ VAR_79 <S2SV_ModStart> ; } } } else { VAR_52 = VAR_94 ; for ( VAR_90 = * VAR_91 ; VAR_90 < VAR_78 [ VAR_79 ] ; VAR_90 += VAR_52 ) { if ( VAR_90 < 1 || VAR_90 > 255 ) continue ; VAR_74 [ VAR_79 ] = VAR_90 ; METHOD_5 ( VAR_74 , VAR_74 ) ; for ( VAR_70 = VAR_61 , VAR_83 = 0 ; VAR_70 < VAR_64 ; ++ VAR_70 ) VAR_83 += METHOD_7 ( VAR_72 + 2 * VAR_70 , VAR_74 [ VAR_70 ] ) ; VAR_83 += METHOD_7 ( VAR_72 + 2 * VAR_79 , VAR_74 [ VAR_79 ] ) ; VAR_84 = METHOD_8 ( VAR_90 , VAR_78 [ VAR_79 ] ) + VAR_80 ; VAR_88 = VAR_82 - VAR_83 - VAR_84 ; if ( VAR_88 > VAR_93 ) { VAR_93 = VAR_88 ; VAR_92 = VAR_90 ; } } } * VAR_91 = VAR_92 <S2SV_ModEnd> ; return VAR_93","CWE-119 int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , <S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> vp9_prob * bestp , <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> int i , old_b , new_b , update_b , savings , bestsavings , step ; int newp ; <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> vp9_model_to_full_probs ( oldp , oldplist ) ; <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> for ( i = UNCONSTRAINED_NODES , old_b = 0 ; i < ENTROPY_NODES ; ++ i ) old_b += cost_branch256 ( ct + 2 * i , oldplist [ i ] ) ; old_b += cost_branch256 ( ct + 2 * PIVOT_NODE , oldplist [ PIVOT_NODE ] ) ; bestsavings = 0 ; bestnewp = oldp [ PIVOT_NODE ] ; <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> for ( newp = * bestp ; newp != oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug> return bestsavings ; }","<S2SV_ModStart> ct , const vpx_prob * oldp , vpx_prob <S2SV_ModEnd> * bestp , <S2SV_ModStart> * bestp , vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> i , old_b <S2SV_ModStart> int newp ; vpx_prob <S2SV_ModEnd> bestnewp , newplist <S2SV_ModStart> oldplist ) ; memcpy <S2SV_ModEnd> ( newplist , <S2SV_ModStart> , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES <S2SV_ModStart> PIVOT_NODE ] ; if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> oldp [ PIVOT_NODE <S2SV_ModStart> ; } } } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> ; return bestsavings"
335,"CWE-22 <S2SV_StartBug> static TYPE_0 METHOD_0 ( const unsigned TYPE_1 * VAR_0 , <S2SV_EndBug> <S2SV_StartBug> struct STRUCT_OR_UNION_0 * * VAR_1 ) <S2SV_EndBug> { <S2SV_StartBug> struct STRUCT_OR_UNION_1 VAR_2 ; <S2SV_EndBug> TYPE_2 VAR_3 ; METHOD_1 ( & VAR_4 , 0 , sizeof ( VAR_5 ) ) ; VAR_6 . VAR_7 = VAR_8 ; VAR_9 = METHOD_2 ( METHOD_3 , & VAR_10 ) ; if ( VAR_11 == 1 ) { * VAR_12 = VAR_13 . VAR_14 ; return 0 ; <S2SV_StartBug> } else { <S2SV_EndBug> METHOD_4 ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" ) ; return - VAR_15 ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> TYPE_2 METHOD_0 ( struct STRUCT_OR_UNION_2 * VAR_16 , <S2SV_ModStart> STRUCT_OR_UNION_0 * * VAR_17 , struct STRUCT_OR_UNION_3 * * VAR_18 <S2SV_ModEnd> ) { struct <S2SV_ModStart> ) { struct STRUCT_OR_UNION_4 * VAR_19 ; struct STRUCT_OR_UNION_5 * VAR_20 ; struct STRUCT_OR_UNION_6 * VAR_21 = VAR_22 ; struct STRUCT_OR_UNION_0 * VAR_14 = VAR_22 ; if ( ! VAR_16 ) goto VAR_23 ; METHOD_5 ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n"" , VAR_24 , VAR_8 ) ; VAR_20 = VAR_16 -> STRUCT_OR_UNION_5 ; METHOD_6 ( ) ; METHOD_7 ( VAR_19 , & VAR_20 -> VAR_25 , VAR_26 ) { struct STRUCT_OR_UNION_0 * VAR_27 ; TYPE_2 VAR_28 ; VAR_21 = METHOD_8 ( VAR_19 -> STRUCT_OR_UNION_6 ) ; VAR_27 = METHOD_9 ( VAR_21 -> VAR_29 ) ; VAR_28 = METHOD_3 ( VAR_27 , VAR_8 ) ; if ( VAR_28 ) { if ( METHOD_10 ( & VAR_21 -> VAR_30 ) ) VAR_14 = VAR_27 ; break ; } } METHOD_11 ( ) ; if ( VAR_14 == VAR_22 ) goto VAR_23 ; METHOD_5 ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , VAR_14 , & VAR_14 -> VAR_31 ) ; * VAR_17 = VAR_14 ; * VAR_18 = & VAR_21 -> VAR_30 <S2SV_ModEnd> ; return 0 <S2SV_ModStart> return 0 ; VAR_23 : <S2SV_ModEnd> METHOD_4 ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" <S2SV_ModStart> VAR_15 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>","CWE-22 <S2SV_StartBug> static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn , <S2SV_EndBug> <S2SV_StartBug> struct se_device * * found_dev ) <S2SV_EndBug> { <S2SV_StartBug> struct xcopy_dev_search_info info ; <S2SV_EndBug> int ret ; memset ( & info , 0 , sizeof ( info ) ) ; info . dev_wwn = dev_wwn ; ret = target_for_each_device ( target_xcopy_locate_se_dev_e4_iter , & info ) ; if ( ret == 1 ) { * found_dev = info . found_dev ; return 0 ; <S2SV_StartBug> } else { <S2SV_EndBug> pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> int target_xcopy_locate_se_dev_e4 ( struct se_session * sess , <S2SV_ModStart> se_device * * _found_dev , struct percpu_ref * * _found_lun_ref <S2SV_ModEnd> ) { struct <S2SV_ModStart> ) { struct se_dev_entry * deve ; struct se_node_acl * nacl ; struct se_lun * this_lun = NULL ; struct se_device * found_dev = NULL ; if ( ! sess ) goto err_out ; pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , dev_wwn ) ; nacl = sess -> se_node_acl ; rcu_read_lock ( ) ; hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) { struct se_device * this_dev ; int rc ; this_lun = rcu_dereference ( deve -> se_lun ) ; this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ; rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ; if ( rc ) { if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ; break ; } } rcu_read_unlock ( ) ; if ( found_dev == NULL ) goto err_out ; pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , found_dev , & found_dev -> dev_group ) ; * _found_dev = found_dev ; * _found_lun_ref = & this_lun -> lun_ref <S2SV_ModEnd> ; return 0 <S2SV_ModStart> return 0 ; err_out : <S2SV_ModEnd> pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n"" <S2SV_ModStart> EINVAL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
336,"CWE-772 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 VAR_2 = { 0 } ; const TYPE_1 * VAR_3 = VAR_4 ; TYPE_2 VAR_5 ; VAR_6 . VAR_7 = VAR_8 -> VAR_9 [ VAR_10 ] ; VAR_11 . VAR_12 = VAR_13 -> VAR_14 [ VAR_15 ] ; VAR_16 . VAR_17 = VAR_18 ; VAR_19 . VAR_20 = VAR_21 -> VAR_22 [ VAR_23 ] ; if ( VAR_24 -> VAR_25 [ VAR_26 ] ) VAR_27 . VAR_28 = METHOD_1 ( VAR_29 -> VAR_30 [ VAR_31 ] ) ; if ( VAR_32 -> VAR_33 [ VAR_34 ] ) VAR_35 . VAR_36 = VAR_37 ; if ( VAR_38 -> VAR_39 [ VAR_40 ] ) { VAR_41 = METHOD_2 ( VAR_42 , ""%.*s"" , METHOD_3 ( VAR_43 -> VAR_44 [ VAR_45 ] ) , ( TYPE_3 * ) METHOD_4 ( VAR_46 -> VAR_47 [ VAR_48 ] ) ) ; if ( ! VAR_49 ) return - VAR_50 ; VAR_51 . VAR_52 = VAR_53 ; } if ( VAR_54 -> VAR_55 [ VAR_56 ] ) VAR_57 . VAR_58 = VAR_59 ; else VAR_60 . VAR_61 = ( VAR_62 . VAR_63 > 1 ) ; if ( VAR_64 -> VAR_65 [ VAR_66 ] ) VAR_67 . VAR_68 = METHOD_5 ( VAR_69 -> VAR_70 [ VAR_71 ] ) ; if ( VAR_72 -> VAR_73 [ VAR_74 ] ) { TYPE_4 VAR_75 = METHOD_6 ( VAR_76 -> VAR_77 [ VAR_78 ] ) ; <S2SV_StartBug> if ( VAR_79 >= METHOD_7 ( VAR_80 ) ) <S2SV_EndBug> return - VAR_81 ; <S2SV_StartBug> VAR_82 . VAR_83 = VAR_84 [ VAR_85 ] ; <S2SV_EndBug> } VAR_86 = METHOD_8 ( VAR_87 , & VAR_88 ) ; METHOD_9 ( VAR_89 ) ; return VAR_90 ; }",<S2SV_ModStart> VAR_84 ) ) { METHOD_9 ( VAR_89 ) ; <S2SV_ModStart> - VAR_81 ; },"CWE-772 static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , ""%.*s"" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }",<S2SV_ModStart> hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }
337,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 * VAR_2 ; if ( ! METHOD_1 ( VAR_3 , ( TYPE_4 * ) & VAR_4 , 4 ) ) return ; VAR_5 = METHOD_2 ( VAR_6 ) ; <S2SV_StartBug> VAR_7 = METHOD_3 ( ( TYPE_5 ) VAR_8 + 1 ) ; <S2SV_EndBug> if ( ! METHOD_4 ( VAR_9 , VAR_10 , VAR_11 ) ) { METHOD_5 ( VAR_12 ) ; return ; } VAR_13 [ VAR_14 ] = 0 ; METHOD_6 ( ""VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n"" , VAR_15 ) ; METHOD_7 ( VAR_16 ) ; }","<S2SV_ModStart> VAR_14 ) ; if ( VAR_14 > 1 << 20 ) { METHOD_6 ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned TYPE_6 ) VAR_14 ) ; return ; } <S2SV_ModStart> = METHOD_3 ( <S2SV_ModEnd> VAR_14 + 1","CWE-787 static void ReadReason ( rfbClient * client ) { uint32_t reasonLen ; char * reason ; if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; <S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return ; } reason [ reasonLen ] = 0 ; rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n"" , reason ) ; free ( reason ) ; }","<S2SV_ModStart> reasonLen ) ; if ( reasonLen > 1 << 20 ) { rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> reasonLen + 1"
338,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = METHOD_1 ( VAR_2 ) ; METHOD_2 ( VAR_3 , METHOD_3 ( VAR_4 ) ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ) ) ; if ( METHOD_4 ( ) ) { if ( METHOD_5 ( VAR_2 ) ) METHOD_6 ( VAR_5 , VAR_6 | VAR_7 ) ; else METHOD_7 ( VAR_5 , VAR_6 | VAR_7 ) ; } if ( METHOD_8 ( ) ) METHOD_9 ( VAR_2 ) ;","CWE-264 static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;"
339,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 , TYPE_2 * VAR_3 ) { TYPE_3 * VAR_4 = VAR_5 ; <S2SV_StartBug> TYPE_4 * VAR_6 ; <S2SV_EndBug> TYPE_5 * VAR_7 ; TYPE_6 VAR_8 ; TYPE_7 VAR_9 ; <S2SV_StartBug> TYPE_8 VAR_10 ; <S2SV_EndBug> VAR_11 = METHOD_1 ( VAR_12 , VAR_13 ) ; if ( ! VAR_14 ) return - VAR_15 ; VAR_16 = - VAR_17 ; VAR_18 = METHOD_2 ( VAR_19 , VAR_20 ) ; if ( ! VAR_21 ) goto VAR_22 ; METHOD_3 ( & VAR_23 , VAR_24 , VAR_25 , VAR_26 ) ; if ( VAR_27 != 1 ) return - VAR_28 ; METHOD_4 ( & VAR_29 , VAR_30 , VAR_31 , VAR_32 ) ; METHOD_5 ( ""%d<S2SV_blank>tickets\\n"" , VAR_33 ) ; while ( VAR_34 -- ) { <S2SV_StartBug> VAR_35 = METHOD_6 ( VAR_36 , VAR_37 , & VAR_38 , VAR_39 , <S2SV_EndBug> VAR_40 , VAR_41 ) ; if ( VAR_42 ) <S2SV_StartBug> goto VAR_43 ; <S2SV_EndBug> } VAR_44 = 0 ; VAR_45 : METHOD_7 ( VAR_46 ) ; VAR_47 : METHOD_8 ( VAR_48 ) ; return VAR_49 ; VAR_50 : <S2SV_StartBug> VAR_51 = - VAR_52 ; <S2SV_EndBug> <S2SV_StartBug> goto VAR_53 ; <S2SV_EndBug> }","<S2SV_ModStart> = VAR_5 ; <S2SV_ModEnd> TYPE_6 VAR_27 ; <S2SV_ModStart> ; TYPE_8 VAR_51 <S2SV_ModEnd> ; METHOD_3 ( <S2SV_ModStart> VAR_38 , VAR_39 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( VAR_51 ) return VAR_51 ; } return 0 <S2SV_ModEnd> ; VAR_50 : <S2SV_ModStart> ; VAR_50 : return <S2SV_ModEnd> - VAR_52 ; <S2SV_ModStart> - VAR_52 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>","CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( ""%d<S2SV_blank>tickets\\n"" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }","<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
340,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 = METHOD_1 ( VAR_2 ) ; TYPE_3 VAR_3 = METHOD_2 ( VAR_4 ) ; VAR_5 * VAR_6 ; VAR_7 * VAR_8 ; TYPE_4 VAR_9 , VAR_10 ; METHOD_3 ( METHOD_4 ( VAR_11 ) ) ; VAR_12 -= VAR_13 ; if ( VAR_14 >= VAR_15 . VAR_16 ) { METHOD_5 ( VAR_17 , ""Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d."" , METHOD_6 ( VAR_18 ) ) ; return 0 ; } VAR_19 = & VAR_20 . VAR_21 [ VAR_22 ] ; METHOD_7 ( VAR_23 , VAR_24 -> VAR_25 ) ; VAR_26 = & VAR_27 -> VAR_28 [ VAR_29 -> VAR_30 ] ; for ( VAR_31 = 0 ; VAR_32 < VAR_33 ; ++ VAR_34 ) { TYPE_5 * VAR_35 = METHOD_8 ( VAR_36 , VAR_37 ) ; TYPE_6 VAR_38 = METHOD_9 ( VAR_39 ) ; <S2SV_StartBug> for ( VAR_40 = 0 ; VAR_41 < VAR_42 -> VAR_43 ; ++ VAR_44 ) { <S2SV_EndBug> TYPE_7 VAR_45 = VAR_46 -> VAR_47 [ VAR_48 ] . VAR_49 ; METHOD_10 ( VAR_50 < VAR_51 . VAR_52 . VAR_53 ) ; if ( VAR_54 . VAR_55 . VAR_56 [ VAR_57 ] . VAR_58 == VAR_59 ) { if ( METHOD_11 ( VAR_60 ) && ! METHOD_12 ( VAR_61 ) ) return 0 ; VAR_62 = & VAR_63 -> VAR_64 [ VAR_65 -> VAR_66 [ VAR_67 ] . VAR_68 ] ; goto VAR_69 ; } } { TYPE_8 VAR_70 = VAR_71 -> VAR_72 -> VAR_73 ; TYPE_9 VAR_74 ; if ( ! VAR_75 ) goto VAR_76 ; VAR_77 = VAR_78 . VAR_79 . VAR_80 [ VAR_81 ] . VAR_82 ; if ( METHOD_13 ( VAR_83 ) ) METHOD_14 ( VAR_84 , ""Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d."" , VAR_85 , VAR_86 ) ; else METHOD_15 ( VAR_87 , ""Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s."" , VAR_88 [ VAR_89 ] ) ; return 0 ; } VAR_90 : continue ; } for ( VAR_91 = 0 ; VAR_92 < VAR_93 -> VAR_94 ; ++ VAR_95 ) { if ( ! VAR_96 -> VAR_97 [ VAR_98 ] . VAR_99 ) { return 1 ; } } VAR_100 : METHOD_16 ( VAR_101 , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node."" , VAR_102 -> VAR_103 ) ; return 0 ; }",<S2SV_ModStart> VAR_61 ) ; if ( VAR_86 == VAR_104 && METHOD_9 ( VAR_36 ) == VAR_105 ) { VAR_86 = VAR_106 ; },"CWE-125 static int validate_node ( node * tree ) { int type = TYPE ( tree ) ; int nch = NCH ( tree ) ; dfa * nt_dfa ; state * dfa_state ; int pos , arc ; assert ( ISNONTERMINAL ( type ) ) ; type -= NT_OFFSET ; if ( type >= _PyParser_Grammar . g_ndfas ) { PyErr_Format ( parser_error , ""Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d."" , TYPE ( tree ) ) ; return 0 ; } nt_dfa = & _PyParser_Grammar . g_dfa [ type ] ; REQ ( tree , nt_dfa -> d_type ) ; dfa_state = & nt_dfa -> d_state [ nt_dfa -> d_initial ] ; for ( pos = 0 ; pos < nch ; ++ pos ) { node * ch = CHILD ( tree , pos ) ; int ch_type = TYPE ( ch ) ; <S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> short a_label = dfa_state -> s_arc [ arc ] . a_lbl ; assert ( a_label < _PyParser_Grammar . g_ll . ll_nlabels ) ; if ( _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type == ch_type ) { if ( ISNONTERMINAL ( ch_type ) && ! validate_node ( ch ) ) return 0 ; dfa_state = & nt_dfa -> d_state [ dfa_state -> s_arc [ arc ] . a_arrow ] ; goto arc_found ; } } { short a_label = dfa_state -> s_arc -> a_lbl ; int next_type ; if ( ! a_label ) goto illegal_num_children ; next_type = _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type ; if ( ISNONTERMINAL ( next_type ) ) PyErr_Format ( parser_error , ""Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d."" , next_type , ch_type ) ; else PyErr_Format ( parser_error , ""Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s."" , _PyParser_TokenNames [ next_type ] ) ; return 0 ; } arc_found : continue ; } for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { if ( ! dfa_state -> s_arc [ arc ] . a_lbl ) { return 1 ; } } illegal_num_children : PyErr_Format ( parser_error , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node."" , nt_dfa -> d_name ) ; return 0 ; }",<S2SV_ModStart> ch ) ; if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; }
341,"CWE-189 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ; VAR_8 * VAR_9 , * VAR_10 ; VAR_11 = METHOD_1 ( VAR_12 ) ; <S2SV_StartBug> VAR_13 = METHOD_2 ( VAR_14 ) ; <S2SV_EndBug> VAR_15 = METHOD_3 ( VAR_16 + VAR_17 ) ; VAR_18 = ( TYPE_5 * ) METHOD_4 ( VAR_19 ) ; METHOD_5 ( VAR_20 , VAR_21 ) ; METHOD_6 ( VAR_22 ) = VAR_23 + VAR_24 ; METHOD_7 ( METHOD_8 ( VAR_25 ) , METHOD_9 ( VAR_26 ) , METHOD_10 ( VAR_27 ) ) ; VAR_28 = METHOD_11 ( VAR_29 ) ; if ( VAR_30 == 0 ) { METHOD_12 ( METHOD_13 ( VAR_31 ) + METHOD_14 ( VAR_32 ) , METHOD_15 ( VAR_33 ) , METHOD_16 ( VAR_34 ) ) ; } else if ( VAR_35 > 0 ) { VAR_36 = VAR_37 - VAR_38 ; VAR_39 = METHOD_17 ( VAR_40 ) + METHOD_18 ( VAR_41 ) - 1 ; for ( VAR_42 = METHOD_19 ( VAR_43 ) ; VAR_44 < METHOD_20 ( VAR_45 ) ; VAR_46 ++ ) { * VAR_47 |= ( ( * VAR_48 >> VAR_49 ) & VAR_50 ) ; VAR_51 ++ ; if ( VAR_52 < METHOD_21 ( VAR_53 ) ) * VAR_54 = ( * VAR_55 << VAR_56 ) & VAR_57 ; } } return VAR_58 ; }","<S2SV_ModStart> METHOD_6 ( VAR_45 ) ; if ( VAR_23 > VAR_59 - VAR_35 ) METHOD_24 ( VAR_60 , ( METHOD_22 ( VAR_61 ) , METHOD_23 ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VAR_59 ) )","CWE-189 static VarBit * bit_catenate ( VarBit * arg1 , VarBit * arg2 ) { VarBit * result ; int bitlen1 , bitlen2 , bytelen , bit1pad , bit2shift ; bits8 * pr , * pa ; bitlen1 = VARBITLEN ( arg1 ) ; <S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug> bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ; result = ( VarBit * ) palloc ( bytelen ) ; SET_VARSIZE ( result , bytelen ) ; VARBITLEN ( result ) = bitlen1 + bitlen2 ; memcpy ( VARBITS ( result ) , VARBITS ( arg1 ) , VARBITBYTES ( arg1 ) ) ; bit1pad = VARBITPAD ( arg1 ) ; if ( bit1pad == 0 ) { memcpy ( VARBITS ( result ) + VARBITBYTES ( arg1 ) , VARBITS ( arg2 ) , VARBITBYTES ( arg2 ) ) ; } else if ( bitlen2 > 0 ) { bit2shift = BITS_PER_BYTE - bit1pad ; pr = VARBITS ( result ) + VARBITBYTES ( arg1 ) - 1 ; for ( pa = VARBITS ( arg2 ) ; pa < VARBITEND ( arg2 ) ; pa ++ ) { * pr |= ( ( * pa >> bit2shift ) & BITMASK ) ; pr ++ ; if ( pr < VARBITEND ( result ) ) * pr = ( * pa << bit1pad ) & BITMASK ; } } return result ; }","<S2SV_ModStart> VARBITLEN ( arg2 ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) )"
342,"CWE-476 static unsigned TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = container_of ( VAR_2 , struct STRUCT_OR_UNION_2 , VAR_3 ) ; <S2SV_StartBug> return VAR_4 -> VAR_5 . VAR_6 ? <S2SV_EndBug> VAR_7 -> VAR_8 . METHOD_1 : VAR_9 -> METHOD_2 ; }",<S2SV_ModStart> ) ; return <S2SV_ModEnd> VAR_9 -> METHOD_2,"CWE-476 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }",<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
343,"CWE-119 <S2SV_StartBug> static TYPE_0 <S2SV_EndBug> METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = METHOD_1 ( VAR_4 ) -> VAR_5 ; TYPE_5 * VAR_6 = ( TYPE_6 * ) VAR_7 ; TYPE_7 VAR_8 = VAR_9 / 4 ; <S2SV_StartBug> METHOD_2 ( ( VAR_10 % ( 4 * VAR_11 ) ) == 0 ) ; <S2SV_EndBug> if ( VAR_12 > VAR_13 ) { VAR_14 -= VAR_15 ; do { REPEAT4 ( VAR_16 , VAR_17 [ VAR_18 ] += VAR_19 [ 0 ] ; VAR_20 ++ ) VAR_21 -= VAR_22 ; } while ( VAR_23 > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static TYPE_8 <S2SV_ModEnd> METHOD_0 ( TYPE_1 <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( VAR_10 <S2SV_ModStart> VAR_22 ) ) != 0 ) { METHOD_3 ( VAR_4 -> VAR_24 , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( VAR_23 <S2SV_ModStart> ) ; } return 1 ;","CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] += wp [ 0 ] ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;"
344,"CWE-287 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , struct STRUCT_OR_UNION_4 * VAR_0 , TYPE_1 VAR_1 ) { struct STRUCT_OR_UNION_5 * VAR_2 = METHOD_1 ( STRUCT_OR_UNION_6 ) ; struct STRUCT_OR_UNION_7 * VAR_3 = STRUCT_OR_UNION_8 -> VAR_4 ; struct STRUCT_OR_UNION_9 * STRUCT_OR_UNION_10 = METHOD_2 ( VAR_5 ) ; struct STRUCT_OR_UNION_11 * VAR_6 = METHOD_3 ( VAR_7 ) ; struct STRUCT_OR_UNION_12 * VAR_8 = VAR_9 -> VAR_10 ; struct STRUCT_OR_UNION_13 * VAR_11 = VAR_12 ; TYPE_2 VAR_13 = 0 ; TYPE_3 VAR_14 ; unsigned TYPE_4 VAR_15 ; struct STRUCT_OR_UNION_14 * VAR_16 ; TYPE_5 VAR_17 ; struct STRUCT_OR_UNION_15 VAR_18 ; TYPE_6 VAR_19 ; TYPE_7 VAR_20 = 0 ; if ( VAR_21 == VAR_22 -> VAR_23 ) VAR_24 -> VAR_25 = & VAR_26 ; METHOD_4 ( ) ; <S2SV_StartBug> VAR_27 = METHOD_5 ( STRUCT_OR_UNION_16 , VAR_28 , VAR_29 -> VAR_30 ) ; <S2SV_EndBug> if ( VAR_31 < 0 ) return VAR_32 ; VAR_33 = - VAR_34 ; if ( VAR_35 -> VAR_36 & VAR_37 ) goto VAR_38 ; if ( VAR_39 -> VAR_40 ) { VAR_41 = METHOD_6 ( VAR_42 , VAR_43 -> VAR_44 , & VAR_45 ) ; if ( VAR_46 < 0 ) goto VAR_47 ; VAR_48 = VAR_49 ; } else { VAR_50 = VAR_51 ; VAR_52 = - VAR_53 ; VAR_54 = METHOD_7 ( VAR_55 ) ; if ( ! VAR_56 ) goto VAR_57 ; } if ( METHOD_8 ( VAR_58 , & STRUCT_OR_UNION_17 -> VAR_59 ) && ! VAR_60 -> VAR_61 && ( VAR_62 = METHOD_9 ( STRUCT_OR_UNION_18 ) ) != 0 ) goto VAR_63 ; VAR_64 = - VAR_65 ; if ( VAR_66 > VAR_67 -> VAR_68 - 32 ) goto VAR_69 ; if ( VAR_70 > VAR_71 ) VAR_72 = METHOD_10 ( TYPE_8 , VAR_73 - VAR_74 , VAR_75 * VAR_76 ) ; VAR_77 = METHOD_11 ( VAR_78 , VAR_79 - VAR_80 , VAR_81 , VAR_82 -> VAR_83 & VAR_84 , & VAR_85 ) ; if ( VAR_86 == VAR_87 ) goto VAR_88 ; VAR_89 = METHOD_12 ( VAR_90 -> VAR_91 , VAR_92 , VAR_93 ) ; if ( VAR_94 < 0 ) goto VAR_95 ; VAR_96 = VAR_97 + 1 ; METHOD_13 ( VAR_98 -> VAR_99 , VAR_100 ) ; METHOD_14 ( VAR_101 , VAR_102 - VAR_103 ) ; VAR_104 -> VAR_105 = VAR_106 ; VAR_107 -> VAR_108 = VAR_109 ; VAR_110 = METHOD_15 ( VAR_111 , 0 , VAR_112 -> VAR_113 , 0 , VAR_114 ) ; if ( VAR_115 ) goto VAR_116 ; VAR_117 = METHOD_16 ( VAR_118 , VAR_119 -> VAR_120 & VAR_121 ) ; VAR_122 : if ( ! VAR_123 ) { VAR_124 = - VAR_125 ; if ( VAR_126 == VAR_127 ) goto VAR_128 ; VAR_129 = METHOD_17 ( STRUCT_OR_UNION_19 , VAR_130 , VAR_131 , VAR_132 -> VAR_133 , VAR_134 , & VAR_135 ) ; if ( VAR_136 == VAR_137 ) goto VAR_138 ; } if ( METHOD_18 ( VAR_139 , VAR_140 ) < 0 ) { VAR_141 = VAR_142 ; goto VAR_143 ; } METHOD_19 ( VAR_144 ) ; VAR_145 = - VAR_146 ; if ( ! METHOD_20 ( VAR_147 , VAR_148 ) ) goto VAR_149 ; if ( METHOD_21 ( VAR_150 , VAR_151 ) ) { METHOD_22 ( VAR_152 ) ; METHOD_23 ( VAR_153 ) ; VAR_154 = 0 ; METHOD_24 ( VAR_155 ) ; if ( METHOD_25 ( VAR_156 ) == VAR_157 ) { METHOD_26 ( VAR_158 ) = VAR_159 ; METHOD_27 ( VAR_160 ) ; METHOD_28 ( VAR_161 , VAR_162 ) ; METHOD_29 ( VAR_163 ) ; VAR_164 = - VAR_165 ; } else { METHOD_30 ( VAR_166 ) ; } VAR_167 = VAR_168 ; if ( VAR_169 ) goto VAR_170 ; goto VAR_171 ; } VAR_172 = - VAR_173 ; if ( VAR_174 -> VAR_175 & VAR_176 ) goto VAR_177 ; if ( VAR_178 -> VAR_179 != VAR_180 ) { VAR_181 = METHOD_31 ( VAR_182 -> VAR_183 , VAR_184 -> VAR_185 ) ; if ( VAR_186 ) goto VAR_187 ; } if ( METHOD_32 ( VAR_188 ) != VAR_189 && METHOD_33 ( VAR_190 ) ) { if ( ! VAR_191 ) { VAR_192 = - VAR_193 ; goto VAR_194 ; } VAR_195 = METHOD_34 ( VAR_196 , VAR_197 ) ; VAR_198 = METHOD_35 ( VAR_199 ) ; if ( METHOD_36 ( VAR_200 ) ) goto VAR_201 ; goto VAR_202 ; } if ( METHOD_37 ( VAR_203 , VAR_204 ) ) METHOD_38 ( VAR_205 ) ; METHOD_39 ( VAR_206 , STRUCT_OR_UNION_20 , VAR_207 ) ; METHOD_40 ( & VAR_208 -> VAR_209 , VAR_210 ) ; if ( VAR_211 > METHOD_41 ( VAR_212 ) -> VAR_213 ) METHOD_42 ( VAR_214 ) -> VAR_215 = VAR_216 ; METHOD_43 ( VAR_217 ) ; VAR_218 -> METHOD_44 ( VAR_219 , VAR_220 ) ; METHOD_45 ( VAR_221 ) ; METHOD_46 ( VAR_222 -> VAR_223 ) ; return VAR_224 ; VAR_225 : METHOD_47 ( VAR_226 ) ; VAR_227 : METHOD_48 ( VAR_228 ) ; VAR_229 : if ( VAR_230 ) METHOD_49 ( VAR_231 ) ; METHOD_50 ( VAR_232 -> VAR_233 ) ; return VAR_234 ; }","<S2SV_ModStart> VAR_232 -> VAR_233 , VAR_235","CWE-287 static int unix_dgram_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie tmp_scm ; int max_level ; int data_len = 0 ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( siocb -> scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; unix_get_secdata ( siocb -> scm , skb ) ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iovec ( skb , 0 , msg -> msg_iov , 0 , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } unix_state_lock ( other ) ; err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = 0 ; unix_state_lock ( sk ) ; if ( unix_peer ( sk ) == other ) { unix_peer ( sk ) = NULL ; unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { if ( ! timeo ) { err = - EAGAIN ; goto out_unlock ; } timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , len ) ; sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return len ; out_unlock : unix_state_unlock ( other ) ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return err ; }","<S2SV_ModStart> siocb -> scm , false"
345,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { enum VAR_1 VAR_2 = VAR_3 ; TYPE_1 VAR_4 ; do { METHOD_1 ( & VAR_5 ) ; VAR_6 = METHOD_2 ( ) ; if ( VAR_7 > 0 ) { if ( METHOD_3 ( ) ) VAR_8 = METHOD_4 ( VAR_9 ) ; else VAR_10 = METHOD_5 ( ) ; } <S2SV_StartBug> if ( VAR_11 < 0 ) <S2SV_EndBug> <S2SV_StartBug> VAR_12 = METHOD_6 ( - VAR_13 , VAR_14 ) ; <S2SV_EndBug> VAR_15 = METHOD_7 ( VAR_16 ) ; METHOD_8 ( & VAR_17 ) ; METHOD_9 ( ) ; } while ( VAR_18 && VAR_19 == VAR_20 ) ; if ( VAR_21 == VAR_22 ) METHOD_10 ( & VAR_23 , VAR_24 . VAR_25 * VAR_26 ) ; }","<S2SV_ModStart> < 0 ) { TYPE_1 VAR_27 ; VAR_27 = METHOD_12 ( - VAR_18 , METHOD_11 ( ) ) ; <S2SV_ModStart> = METHOD_6 ( VAR_27 <S2SV_ModEnd> , VAR_14 ) <S2SV_ModStart> VAR_14 ) ; if ( VAR_21 == VAR_20 && VAR_27 != - VAR_18 && VAR_27 < VAR_28 ) VAR_21 = VAR_22 ; }","CWE-400 static void balloon_process ( struct work_struct * work ) { enum bp_state state = BP_DONE ; long credit ; do { mutex_lock ( & balloon_mutex ) ; credit = current_credit ( ) ; if ( credit > 0 ) { if ( balloon_is_inflated ( ) ) state = increase_reservation ( credit ) ; else state = reserve_additional_memory ( ) ; } <S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> state = update_schedule ( state ) ; mutex_unlock ( & balloon_mutex ) ; cond_resched ( ) ; } while ( credit && state == BP_DONE ) ; if ( state == BP_EAGAIN ) schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; }","<S2SV_ModStart> < 0 ) { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; <S2SV_ModStart> = decrease_reservation ( n_pages <S2SV_ModEnd> , GFP_BALLOON ) <S2SV_ModStart> GFP_BALLOON ) ; if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; }"
346,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 * VAR_3 = VAR_4 ; TYPE_5 VAR_5 , VAR_6 , VAR_7 ; TYPE_6 VAR_8 ; TYPE_7 * VAR_9 = VAR_10 -> VAR_11 ; TYPE_8 * VAR_12 = & VAR_13 -> VAR_14 ; TYPE_9 VAR_15 , VAR_16 , VAR_17 ; TYPE_10 VAR_18 ; TYPE_11 VAR_19 = 0 ; TYPE_12 VAR_20 = 0 ; TYPE_13 VAR_21 = 0 ; TYPE_14 VAR_22 = 0 ; TYPE_15 VAR_23 = 0 ; TYPE_16 VAR_24 = 0 ; TYPE_17 VAR_25 = 0 ; TYPE_18 VAR_26 = 0 ; TYPE_19 VAR_27 = 0 ; TYPE_20 VAR_28 ; TYPE_21 VAR_29 ; TYPE_22 VAR_30 , VAR_31 , VAR_32 , VAR_33 , VAR_34 ; VAR_35 ; VAR_36 = METHOD_1 ( VAR_37 , 8 ) ; METHOD_2 ( ""SPS:<S2SV_blank>profile_idc"" , VAR_38 ) ; VAR_39 = METHOD_3 ( VAR_40 ) ; VAR_41 = METHOD_4 ( VAR_42 ) ; METHOD_5 ( VAR_43 ) ; METHOD_6 ( VAR_44 , 5 ) ; if ( ( VAR_45 != VAR_46 ) && ( VAR_47 != VAR_48 ) && ( VAR_49 != VAR_50 ) ) { if ( ( VAR_51 != VAR_52 ) || ( ( VAR_53 != 1 ) && ( VAR_54 != 1 ) ) ) { return ( VAR_55 ) ; } } VAR_56 = METHOD_7 ( VAR_57 , 8 ) ; METHOD_8 ( ""SPS:<S2SV_blank>u4_level_idc"" , VAR_58 ) ; VAR_59 = METHOD_9 ( VAR_60 , VAR_61 ) ; if ( VAR_62 & VAR_63 ) return VAR_64 ; VAR_65 = VAR_66 ; METHOD_10 ( ""SPS:<S2SV_blank>seq_parameter_set_id"" , VAR_67 ) ; VAR_68 = VAR_69 -> VAR_70 ; * VAR_71 = VAR_72 -> VAR_73 [ VAR_74 ] ; if ( VAR_75 == VAR_76 -> VAR_77 ) VAR_78 -> VAR_79 = VAR_80 ; VAR_81 -> VAR_82 = VAR_83 ; VAR_84 -> VAR_85 = VAR_86 ; VAR_87 -> VAR_88 = VAR_89 ; VAR_90 -> VAR_91 = 1 ; VAR_92 -> VAR_93 = 0 ; VAR_94 -> VAR_95 = 0 ; VAR_96 -> VAR_97 = 0 ; VAR_98 -> VAR_99 = 0 ; if ( VAR_100 == VAR_101 ) { VAR_102 -> VAR_103 = METHOD_11 ( VAR_104 , VAR_105 ) ; if ( VAR_106 -> VAR_107 != 1 ) { return VAR_108 ; } VAR_109 -> VAR_110 = METHOD_12 ( VAR_111 , VAR_112 ) ; if ( VAR_113 -> VAR_114 != 0 ) { return VAR_115 ; } VAR_116 -> VAR_117 = METHOD_13 ( VAR_118 , VAR_119 ) ; if ( VAR_120 -> VAR_121 != 0 ) { return VAR_122 ; } VAR_123 -> VAR_124 = ( TYPE_23 ) METHOD_14 ( VAR_125 ) ; if ( VAR_126 -> VAR_127 != 0 ) { return VAR_128 ; } VAR_129 -> VAR_130 = ( TYPE_24 ) METHOD_15 ( VAR_131 ) ; if ( VAR_132 -> VAR_133 ) { for ( VAR_134 = 0 ; VAR_135 < 8 ; VAR_136 ++ ) { VAR_137 -> VAR_138 [ VAR_139 ] = METHOD_16 ( VAR_140 ) ; VAR_141 -> VAR_142 [ VAR_143 ] = 0 ; if ( VAR_144 -> VAR_145 [ VAR_146 ] ) { if ( VAR_147 < 6 ) { METHOD_17 ( VAR_148 -> VAR_149 [ VAR_150 ] , 16 , & VAR_151 -> VAR_152 [ VAR_153 ] , VAR_154 ) ; } else { METHOD_18 ( VAR_155 -> VAR_156 [ VAR_157 - 6 ] , 64 , & VAR_158 -> VAR_159 [ VAR_160 ] , VAR_161 ) ; } } } } } VAR_162 = 4 + METHOD_19 ( VAR_163 , VAR_164 ) ; if ( VAR_165 > VAR_166 ) { return VAR_167 ; } VAR_168 -> VAR_169 = VAR_170 ; METHOD_20 ( ""SPS:<S2SV_blank>log2_max_frame_num_minus4"" , ( VAR_171 -> VAR_172 - 4 ) ) ; VAR_173 = ( 1 << ( VAR_174 -> VAR_175 ) ) ; VAR_176 -> VAR_177 = VAR_178 - 1 ; VAR_179 = METHOD_21 ( VAR_180 , VAR_181 ) ; if ( VAR_182 > VAR_183 ) { return VAR_184 ; } VAR_185 -> VAR_186 = VAR_187 ; METHOD_22 ( ""SPS:<S2SV_blank>pic_order_cnt_type"" , VAR_188 -> VAR_189 ) ; VAR_190 -> VAR_191 = 1 ; if ( VAR_192 -> VAR_193 == 0 ) { VAR_194 = 4 + METHOD_23 ( VAR_195 , VAR_196 ) ; if ( VAR_197 > VAR_198 ) { return VAR_199 ; } VAR_200 -> VAR_201 = VAR_202 ; VAR_203 -> VAR_204 = ( 1 << VAR_205 ) ; METHOD_24 ( ""SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4"" , ( VAR_206 - 4 ) ) ; } else if ( VAR_207 -> VAR_208 == 1 ) { VAR_209 -> VAR_210 = METHOD_25 ( VAR_211 ) ; METHOD_26 ( ""SPS:<S2SV_blank>delta_pic_order_always_zero_flag"" , VAR_212 -> VAR_213 ) ; VAR_214 -> VAR_215 = METHOD_27 ( VAR_216 , VAR_217 ) ; METHOD_28 ( ""SPS:<S2SV_blank>offset_for_non_ref_pic"" , VAR_218 -> VAR_219 ) ; VAR_220 -> VAR_221 = METHOD_29 ( VAR_222 , VAR_223 ) ; METHOD_30 ( ""SPS:<S2SV_blank>offset_for_top_to_bottom_field"" , VAR_224 -> VAR_225 ) ; VAR_226 = METHOD_31 ( VAR_227 , VAR_228 ) ; if ( VAR_229 > 255 ) return VAR_230 ; VAR_231 -> VAR_232 = VAR_233 ; METHOD_32 ( ""SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle"" , VAR_234 -> VAR_235 ) ; for ( VAR_236 = 0 ; VAR_237 < VAR_238 -> VAR_239 ; VAR_240 ++ ) { VAR_241 -> VAR_242 [ VAR_243 ] = METHOD_33 ( VAR_244 , VAR_245 ) ; METHOD_34 ( ""SPS:<S2SV_blank>offset_for_ref_frame"" , VAR_246 -> VAR_247 [ VAR_248 ] ) ; } } VAR_249 = METHOD_35 ( VAR_250 , VAR_251 ) ; if ( ( VAR_252 > VAR_253 ) ) { return VAR_254 ; } VAR_255 -> VAR_256 = VAR_257 ; METHOD_36 ( ""SPS:<S2SV_blank>num_ref_frames"" , VAR_258 -> VAR_259 ) ; VAR_260 -> VAR_261 = METHOD_37 ( VAR_262 ) ; METHOD_38 ( ""SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag"" , VAR_263 -> VAR_264 ) ; VAR_265 -> VAR_266 = 1 + METHOD_39 ( VAR_267 , VAR_268 ) ; METHOD_40 ( ""SPS:<S2SV_blank>pic_width_in_mbs_minus1"" , VAR_269 -> VAR_270 - 1 ) ; VAR_271 = ( VAR_272 -> VAR_273 << 4 ) ; VAR_274 = METHOD_41 ( VAR_275 , VAR_276 ) ; VAR_277 -> VAR_278 = 1 + VAR_279 ; VAR_280 = ( VAR_281 -> VAR_282 << 4 ) ; VAR_283 -> VAR_284 = ( VAR_285 -> VAR_286 * VAR_287 -> VAR_288 ) - 1 ; VAR_289 -> VAR_290 = VAR_291 -> VAR_292 + 1 ; VAR_293 -> VAR_294 = METHOD_42 ( VAR_295 , VAR_296 -> VAR_297 ) ; VAR_298 = METHOD_43 ( VAR_299 ) ; VAR_300 -> VAR_301 = VAR_302 ; METHOD_44 ( ""SPS:<S2SV_blank>frame_mbs_only_flag"" , VAR_303 ) ; if ( ! VAR_304 ) { VAR_305 <<= 1 ; VAR_306 -> VAR_307 = METHOD_45 ( VAR_308 ) ; METHOD_46 ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , VAR_309 -> VAR_310 ) ; } else VAR_311 -> VAR_312 = 0 ; VAR_313 -> VAR_314 = METHOD_47 ( VAR_315 ) ; METHOD_48 ( ""SPS:<S2SV_blank>direct_8x8_inference_flag"" , VAR_316 -> VAR_317 ) ; VAR_318 = METHOD_49 ( VAR_319 ) ; METHOD_50 ( ""SPS:<S2SV_blank>frame_cropping_flag"" , VAR_320 ) ; if ( VAR_321 ) { VAR_322 = METHOD_51 ( VAR_323 , VAR_324 ) ; METHOD_52 ( ""SPS:<S2SV_blank>frame_cropping_rect_left_offset"" , VAR_325 ) ; VAR_326 = METHOD_53 ( VAR_327 , VAR_328 ) ; METHOD_54 ( ""SPS:<S2SV_blank>frame_cropping_rect_right_offset"" , VAR_329 ) ; VAR_330 = METHOD_55 ( VAR_331 , VAR_332 ) ; METHOD_56 ( ""SPS:<S2SV_blank>frame_cropping_rect_top_offset"" , VAR_333 ) ; VAR_334 = METHOD_57 ( VAR_335 , VAR_336 ) ; METHOD_58 ( ""SPS:<S2SV_blank>frame_cropping_rect_bottom_offset"" , VAR_337 ) ; } VAR_338 -> VAR_339 = METHOD_59 ( VAR_340 ) ; METHOD_60 ( ""SPS:<S2SV_blank>vui_parameters_present_flag"" , VAR_341 -> VAR_342 ) ; VAR_343 = VAR_344 + ( TYPE_25 ) ( VAR_345 << 1 ) ; if ( 1 == VAR_346 -> VAR_347 ) { if ( VAR_348 -> VAR_349 > VAR_350 ) VAR_351 = VAR_352 -> VAR_353 ; } VAR_354 = VAR_355 + ( TYPE_26 ) ( VAR_356 << 2 ) ; VAR_357 = VAR_358 + ( TYPE_27 ) ( VAR_359 << 2 ) ; VAR_360 = METHOD_61 ( VAR_361 , VAR_362 ) ; VAR_363 = ( VAR_364 >> 1 ) + ( TYPE_28 ) ( VAR_365 << 2 ) ; VAR_366 = METHOD_62 ( VAR_367 , ( VAR_368 >> 1 ) ) ; { TYPE_29 VAR_369 = 0 ; TYPE_30 VAR_370 = 0 ; TYPE_31 VAR_371 = 0 ; TYPE_32 VAR_372 = 0 ; TYPE_33 VAR_373 ; TYPE_34 VAR_374 ; TYPE_35 VAR_375 , VAR_376 ; if ( VAR_377 ) { VAR_378 = VAR_379 << 1 ; VAR_380 = VAR_381 << 1 ; VAR_382 = ( 1 == VAR_383 -> VAR_384 ) ; VAR_385 = ( 2 - VAR_386 ) ; VAR_387 = ( VAR_388 << VAR_389 ) ; VAR_390 = ( VAR_391 << VAR_392 ) ; } VAR_393 = ( VAR_394 * VAR_395 ) + ( VAR_396 ) ; VAR_397 = ( VAR_398 * ( VAR_399 >> 1 ) ) + ( VAR_400 >> 1 ) * VAR_401 ; VAR_402 = VAR_403 - ( VAR_404 + VAR_405 ) ; VAR_406 = VAR_407 - ( VAR_408 + VAR_409 ) ; if ( ( VAR_410 < VAR_411 ) || ( VAR_412 < VAR_413 ) ) { return VAR_414 ; } if ( ( 3 == VAR_415 -> VAR_416 ) && ( VAR_417 -> VAR_418 != VAR_419 ) ) { VAR_420 -> VAR_421 = 1 ; return VAR_422 ; } if ( ( 3 == VAR_423 -> VAR_424 ) && ( VAR_425 -> VAR_426 != VAR_427 ) ) { VAR_428 -> VAR_429 = 1 ; return VAR_430 ; } if ( ( VAR_431 > VAR_432 ) || ( VAR_433 > VAR_434 ) ) { return VAR_435 ; } <S2SV_StartBug> VAR_436 -> VAR_437 = VAR_438 ; <S2SV_EndBug> VAR_439 -> VAR_440 = VAR_441 ; } if ( 1 == VAR_442 -> VAR_443 ) { VAR_444 = METHOD_63 ( & VAR_445 -> VAR_446 , VAR_447 ) ; if ( VAR_448 != VAR_449 ) return VAR_450 ; } VAR_451 -> VAR_452 = VAR_453 ; VAR_454 -> VAR_455 = VAR_456 ; VAR_457 -> VAR_458 = VAR_459 ; VAR_460 -> VAR_461 = VAR_462 ; VAR_463 -> VAR_464 = VAR_465 ; VAR_466 -> VAR_467 = VAR_468 ; VAR_469 -> VAR_470 . VAR_471 = ( TYPE_36 ) ( VAR_472 << ( 1 - VAR_473 ) ) ; VAR_474 -> VAR_475 . VAR_476 = ( TYPE_37 ) ( VAR_477 << ( 1 - VAR_478 ) ) ; VAR_479 -> VAR_480 = VAR_481 -> VAR_482 ; VAR_483 -> VAR_484 = VAR_485 -> VAR_486 ; VAR_487 -> VAR_488 = VAR_489 ; VAR_490 -> VAR_491 = VAR_492 ; if ( VAR_493 -> VAR_494 > VAR_495 -> VAR_496 ) { return VAR_497 ; } VAR_498 -> VAR_499 = VAR_500 ; VAR_501 -> VAR_502 [ VAR_503 ] = * VAR_504 ; return VAR_505 ; }",<S2SV_ModStart> VAR_435 ; } if ( ( VAR_453 << VAR_504 -> VAR_312 ) > VAR_432 ) { return VAR_435 ; },"CWE-000 WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>profile_idc"" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>u4_level_idc"" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>seq_parameter_set_id"" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; * ps_seq = ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; if ( NULL == ps_dec -> ps_cur_sps ) ps_dec -> ps_cur_sps = ps_seq ; ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_frame_num_minus4"" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_order_cnt_type"" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4"" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>delta_pic_order_always_zero_flag"" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_non_ref_pic"" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_top_to_bottom_field"" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle"" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_ref_frame"" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames"" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag"" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_width_in_mbs_minus1"" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_mbs_only_flag"" , u1_frm ) ; if ( ! u1_frm ) { u2_pic_ht <<= 1 ; ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>direct_8x8_inference_flag"" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_flag"" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_left_offset"" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_right_offset"" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_top_offset"" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_bottom_offset"" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>vui_parameters_present_flag"" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; WORD32 i4_cropped_ht , i4_cropped_wd ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } <S2SV_StartBug> ps_dec -> u2_disp_height = i4_cropped_ht ; <S2SV_EndBug> ps_dec -> u2_disp_width = i4_cropped_wd ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; return OK ; }",<S2SV_ModStart> IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
347,"CWE-416 <S2SV_StartBug> TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) <S2SV_EndBug> { <S2SV_StartBug> METHOD_1 ( VAR_2 -> VAR_3 ) ; <S2SV_EndBug> }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> TYPE_1 <S2SV_ModEnd> METHOD_0 ( struct <S2SV_ModStart> VAR_2 ) { return METHOD_2 <S2SV_ModEnd> ( VAR_2 ->,"CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
348,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 * VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; TYPE_12 VAR_11 ; TYPE_13 VAR_12 ; VAR_13 * VAR_14 ; VAR_15 * VAR_16 ; if ( VAR_17 < 2 ) { METHOD_1 ( ""Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n"" , VAR_18 [ 0 ] ) ; return - 1 ; } VAR_19 = METHOD_2 ( ""out.yuv"" , ""wb"" ) ; if ( VAR_20 == VAR_21 ) { METHOD_3 ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } VAR_22 = METHOD_4 ( VAR_23 [ VAR_24 - 1 ] , ""rb"" ) ; if ( VAR_25 == VAR_26 ) { METHOD_5 ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } METHOD_6 ( VAR_27 , 0L , VAR_28 ) ; VAR_29 = ( TYPE_14 ) METHOD_7 ( VAR_30 ) ; METHOD_8 ( VAR_31 ) ; <S2SV_StartBug> VAR_32 = VAR_33 = ( TYPE_15 * ) METHOD_9 ( sizeof ( TYPE_16 ) * VAR_34 ) ; <S2SV_EndBug> if ( VAR_35 == VAR_36 ) { METHOD_10 ( ""UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n"" ) ; return - 1 ; } METHOD_11 ( VAR_37 , sizeof ( TYPE_17 ) , VAR_38 , VAR_39 ) ; METHOD_12 ( VAR_40 ) ; VAR_41 = METHOD_13 ( & VAR_42 , 0 ) ; if ( VAR_43 != VAR_44 ) { METHOD_14 ( ""DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n"" ) ; return - 1 ; } VAR_45 . VAR_46 = VAR_47 ; VAR_48 . VAR_49 = VAR_50 ; VAR_51 . VAR_52 = 0 ; VAR_53 = 0 ; do { VAR_54 = METHOD_15 ( VAR_55 , & VAR_56 , & VAR_57 ) ; switch ( VAR_58 ) { case VAR_59 : VAR_60 = METHOD_16 ( VAR_61 , & VAR_62 ) ; if ( VAR_63 != VAR_64 ) return - 1 ; VAR_65 = VAR_66 . VAR_67 * VAR_68 . VAR_69 ; VAR_70 = ( 3 * VAR_71 ) / 2 ; METHOD_17 ( ""Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n"" , VAR_72 . VAR_73 , VAR_74 . VAR_75 ) ; VAR_76 . VAR_77 -= ( TYPE_18 ) ( VAR_78 . VAR_79 - VAR_80 . VAR_81 ) ; VAR_82 . VAR_83 = VAR_84 . VAR_85 ; break ; case VAR_86 : case VAR_87 : VAR_88 . VAR_89 -= ( TYPE_19 ) ( VAR_90 . VAR_91 - VAR_92 . VAR_93 ) ; VAR_94 . VAR_95 = VAR_96 . VAR_97 ; while ( METHOD_18 ( VAR_98 , & VAR_99 , 0 ) == VAR_100 ) { VAR_101 ++ ; METHOD_19 ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , VAR_102 , VAR_103 . VAR_104 ? ""IDR"" : ""NON-IDR"" , VAR_105 . VAR_106 ) ; METHOD_20 ( VAR_107 ) ; METHOD_21 ( VAR_108 , ( TYPE_20 * ) VAR_109 . VAR_110 , VAR_111 ) ; } break ; case VAR_112 : METHOD_22 ( ""EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n"" ) ; goto VAR_113 ; default : METHOD_23 ( ""UNRECOVERABLE<S2SV_blank>ERROR\\n"" ) ; return - 1 ; } } while ( VAR_114 . VAR_115 > 0 ) ; VAR_116 : while ( METHOD_24 ( VAR_117 , & VAR_118 , 1 ) == VAR_119 ) { VAR_120 ++ ; METHOD_25 ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , VAR_121 , VAR_122 . VAR_123 ? ""IDR"" : ""NON-IDR"" , VAR_124 . VAR_125 ) ; METHOD_26 ( VAR_126 ) ; METHOD_27 ( VAR_127 , ( TYPE_21 * ) VAR_128 . VAR_129 , VAR_130 ) ; } METHOD_28 ( VAR_131 ) ; METHOD_29 ( VAR_132 ) ; METHOD_30 ( VAR_133 ) ; return 0 ; }","<S2SV_ModStart> ( TYPE_21 ) , <S2SV_ModEnd> VAR_50 ) ;","CWE-119 int main ( int argc , char * * argv ) { u8 * byteStrmStart ; u8 * byteStrm ; u32 strmLen ; u32 picSize ; H264SwDecInst decInst ; H264SwDecRet ret ; H264SwDecInput decInput ; H264SwDecOutput decOutput ; H264SwDecPicture decPicture ; H264SwDecInfo decInfo ; u32 picNumber ; FILE * finput ; FILE * foutput ; if ( argc < 2 ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n"" , argv [ 0 ] ) ; return - 1 ; } foutput = fopen ( ""out.yuv"" , ""wb"" ) ; if ( foutput == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } finput = fopen ( argv [ argc - 1 ] , ""rb"" ) ; if ( finput == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } fseek ( finput , 0L , SEEK_END ) ; strmLen = ( u32 ) ftell ( finput ) ; rewind ( finput ) ; <S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> if ( byteStrm == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n"" ) ; return - 1 ; } fread ( byteStrm , sizeof ( u8 ) , strmLen , finput ) ; fclose ( finput ) ; ret = H264SwDecInit ( & decInst , 0 ) ; if ( ret != H264SWDEC_OK ) { printf ( ""DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n"" ) ; return - 1 ; } decInput . pStream = byteStrmStart ; decInput . dataLen = strmLen ; decInput . intraConcealmentMethod = 0 ; picNumber = 0 ; do { ret = H264SwDecDecode ( decInst , & decInput , & decOutput ) ; switch ( ret ) { case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY : ret = H264SwDecGetInfo ( decInst , & decInfo ) ; if ( ret != H264SWDEC_OK ) return - 1 ; picSize = decInfo . picWidth * decInfo . picHeight ; picSize = ( 3 * picSize ) / 2 ; printf ( ""Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n"" , decInfo . picWidth , decInfo . picHeight ) ; decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; break ; case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY : case H264SWDEC_PIC_RDY : decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; while ( H264SwDecNextPicture ( decInst , & decPicture , 0 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , picNumber , decPicture . isIdrPicture ? ""IDR"" : ""NON-IDR"" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } break ; case H264SWDEC_EVALUATION_LIMIT_EXCEEDED : printf ( ""EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n"" ) ; goto end ; default : printf ( ""UNRECOVERABLE<S2SV_blank>ERROR\\n"" ) ; return - 1 ; } } while ( decInput . dataLen > 0 ) ; end : while ( H264SwDecNextPicture ( decInst , & decPicture , 1 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , picNumber , decPicture . isIdrPicture ? ""IDR"" : ""NON-IDR"" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } H264SwDecRelease ( decInst ) ; fclose ( foutput ) ; free ( byteStrmStart ) ; return 0 ; }","<S2SV_ModStart> ( u8 ) , <S2SV_ModEnd> strmLen ) ;"
349,"CWE-119 <S2SV_StartBug> static TYPE_0 TYPE_1 METHOD_0 ( TYPE_2 * * VAR_0 , const TYPE_3 * VAR_1 , <S2SV_EndBug> <S2SV_StartBug> TYPE_4 VAR_2 , TYPE_5 VAR_3 , <S2SV_EndBug> TYPE_6 VAR_4 , unsigned TYPE_7 * VAR_5 ) { ( * VAR_6 ) -> VAR_7 = VAR_8 ; ( * VAR_9 ) -> VAR_10 = VAR_11 ; ( * VAR_12 ) -> VAR_13 = VAR_14 ; ( * VAR_15 ) -> VAR_16 = VAR_17 ; ( * VAR_18 ) ++ ; ++ VAR_19 [ VAR_20 ] ; }","<S2SV_ModStart> VAR_18 , const TYPE_8 <S2SV_ModEnd> * VAR_14 , <S2SV_ModStart> * VAR_14 , int32_t <S2SV_ModEnd> VAR_11 , TYPE_6","CWE-119 <S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }","<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree , <S2SV_ModStart> * context_tree , int32_t <S2SV_ModEnd> extra , uint8_t"
350,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> TYPE_4 VAR_3 ; TYPE_5 * VAR_4 ; <S2SV_StartBug> TYPE_6 VAR_5 ; <S2SV_EndBug> TYPE_7 * VAR_6 ; if ( METHOD_1 ( VAR_7 ) > 0 && METHOD_2 ( VAR_8 ) > 0 ) { METHOD_3 ( VAR_9 -> VAR_10 ) ; VAR_11 = METHOD_4 ( VAR_12 ) ; for ( VAR_13 = VAR_14 -> VAR_15 , VAR_16 = VAR_17 -> VAR_18 [ 0 ] ; VAR_19 > 0 ; -- VAR_20 , VAR_21 += VAR_22 ) { for ( VAR_23 = VAR_24 -> VAR_25 , VAR_26 = VAR_27 ; VAR_28 > 0 ; -- VAR_29 , ++ VAR_30 ) { * VAR_31 = VAR_32 ; } } } }",<S2SV_ModStart> VAR_32 ) { TYPE_8 VAR_20 ; TYPE_8 <S2SV_ModEnd> VAR_29 ; TYPE_7 <S2SV_ModStart> * VAR_27 ; TYPE_8 <S2SV_ModEnd> VAR_22 ; TYPE_7,"CWE-190 void jas_matrix_setall ( jas_matrix_t * matrix , jas_seqent_t val ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = val ; } } } }",<S2SV_ModStart> val ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
351,"CWE-399 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_0 VAR_3 ; <S2SV_EndBug> VAR_4 . VAR_5 = VAR_6 ; VAR_7 . VAR_8 = 0 ; VAR_9 . VAR_10 = VAR_11 ; VAR_12 . VAR_13 = METHOD_1 ( VAR_14 ) ; VAR_15 . VAR_16 = METHOD_2 ( METHOD_3 ( ) , METHOD_4 ( ) ) ; return METHOD_5 ( VAR_17 , VAR_18 , VAR_19 , & VAR_20 ) ; }",<S2SV_ModStart> struct STRUCT_OR_UNION_0 VAR_20 = { },"CWE-399 static int do_tkill ( pid_t tgid , pid_t pid , int sig ) { <S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> info . si_signo = sig ; info . si_errno = 0 ; info . si_code = SI_TKILL ; info . si_pid = task_tgid_vnr ( current ) ; info . si_uid = from_kuid_munged ( current_user_ns ( ) , current_uid ( ) ) ; return do_send_specific ( tgid , pid , sig , & info ) ; }",<S2SV_ModStart> struct siginfo info = { }
352,"CWE-17 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; METHOD_1 ( & VAR_2 -> VAR_3 ) ; METHOD_2 ( & VAR_4 -> VAR_5 ) ; <S2SV_StartBug> TYPE_2 TYPE_3 <S2SV_EndBug> TYPE_4 ( VAR_6 -> s_files ) ; for ( VAR_7 = 0 ; VAR_8 < VAR_9 ; VAR_10 ++ ) METHOD_3 ( & VAR_11 -> VAR_12 . VAR_13 [ VAR_14 ] ) ; METHOD_4 ( VAR_15 ) ; METHOD_5 ( ! METHOD_6 ( & VAR_16 -> VAR_17 ) ) ; METHOD_7 ( VAR_18 -> VAR_19 ) ; METHOD_8 ( VAR_20 -> VAR_21 ) ; METHOD_9 ( VAR_22 , VAR_23 ) ; }",<S2SV_ModStart> VAR_5 ) ; <S2SV_ModEnd> for ( VAR_14,"CWE-17 static void destroy_super ( struct super_block * s ) { int i ; list_lru_destroy ( & s -> s_dentry_lru ) ; list_lru_destroy ( & s -> s_inode_lru ) ; <S2SV_StartBug>  ifdef CONFIG_SMP <S2SV_EndBug> free_percpu ( s -> s_files ) ;   for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) percpu_counter_destroy ( & s -> s_writers . counter [ i ] ) ; security_sb_free ( s ) ; WARN_ON ( ! list_empty ( & s -> s_mounts ) ) ; kfree ( s -> s_subtype ) ; kfree ( s -> s_options ) ; kfree_rcu ( s , rcu ) ; }",<S2SV_ModStart> s_inode_lru ) ; <S2SV_ModEnd> for ( i
353,"CWE-59 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 * VAR_5 , TYPE_7 * VAR_6 ) { TYPE_8 VAR_7 = 0 ; TYPE_9 VAR_8 = METHOD_1 ( VAR_9 ) ; if ( VAR_10 > 1 ) { if ( * VAR_11 < 0 ) { * VAR_12 = METHOD_2 ( VAR_13 ) ; <S2SV_StartBug> VAR_14 = METHOD_3 ( VAR_15 , VAR_16 , VAR_17 , VAR_18 , 1 ) ; <S2SV_EndBug> } else { TYPE_10 * VAR_19 = METHOD_4 ( VAR_20 , * VAR_21 ) ; VAR_22 = METHOD_5 ( VAR_23 , VAR_24 ) ; if ( VAR_25 < 0 ) { VAR_26 = VAR_27 ; } METHOD_6 ( VAR_28 ) ; } } if ( VAR_29 <= 1 ) { if ( ! VAR_30 ) <S2SV_StartBug> VAR_31 = METHOD_7 ( VAR_32 , VAR_33 , VAR_34 , VAR_35 , 0 ) ; <S2SV_EndBug> } else if ( METHOD_8 ( VAR_36 ) ) { if ( ! VAR_37 ) <S2SV_StartBug> VAR_38 = METHOD_9 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 , 0 ) ; <S2SV_EndBug> * VAR_43 = - 1 ; } else { * VAR_44 = 0 ; } return VAR_45 ; }","<S2SV_ModStart> , VAR_41 , 1 , <S2SV_ModStart> , VAR_41 , 1 , <S2SV_ModStart> , VAR_41 , 0 ,","CWE-59 static int fsmMkfile ( rpmfi fi , const char * dest , rpmfiles files , rpmpsm psm , int nodigest , int * setmeta , int * firsthardlink ) { int rc = 0 ; int numHardlinks = rpmfiFNlink ( fi ) ; if ( numHardlinks > 1 ) { if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ; rc = link ( fn , dest ) ; if ( rc < 0 ) { rc = RPMERR_LINK_FAILED ; } free ( fn ) ; } } if ( numHardlinks <= 1 ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> } else if ( rpmfiArchiveHasContent ( fi ) ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> * firsthardlink = - 1 ; } else { * setmeta = 0 ; } return rc ; }","<S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 0 ,"
354,"CWE-399 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 * VAR_3 ; TYPE_5 VAR_4 ; register TYPE_6 * VAR_5 ; register TYPE_7 VAR_6 ; register TYPE_8 * VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 VAR_9 , VAR_10 , VAR_11 ; unsigned TYPE_11 * VAR_12 , * VAR_13 ; METHOD_1 ( VAR_14 != ( const TYPE_12 * ) VAR_15 ) ; METHOD_2 ( VAR_16 -> VAR_17 == VAR_18 ) ; if ( VAR_19 -> VAR_20 != VAR_21 ) ( TYPE_13 ) METHOD_3 ( VAR_22 , METHOD_4 ( ) , ""%s"" , VAR_23 -> VAR_24 ) ; METHOD_5 ( VAR_25 != ( TYPE_14 * ) VAR_26 ) ; METHOD_6 ( VAR_27 -> VAR_28 == VAR_29 ) ; VAR_30 = METHOD_7 ( VAR_31 , VAR_32 ) ; VAR_33 = METHOD_8 ( VAR_34 , VAR_35 , VAR_36 , VAR_37 ) ; if ( VAR_38 == VAR_39 ) { VAR_40 = METHOD_9 ( VAR_41 ) ; return ( ( TYPE_15 * ) VAR_42 ) ; } VAR_43 = VAR_44 ; VAR_45 = ( TYPE_16 * ) METHOD_10 ( ( TYPE_17 ) VAR_46 + VAR_47 , sizeof ( * VAR_48 ) ) ; VAR_49 = VAR_50 ; if ( VAR_51 != ( TYPE_18 * ) VAR_52 ) while ( METHOD_11 ( VAR_53 , VAR_54 ) != ( TYPE_19 * ) VAR_55 ) { if ( ( * VAR_56 == '' ) && ( ( VAR_57 == VAR_58 ) || ( * ( VAR_59 - 1 ) == '\\n' ) ) ) continue ; if ( ( * VAR_60 == '}' ) && ( * ( VAR_61 + 1 ) == ';' ) ) break ; VAR_62 += METHOD_12 ( VAR_63 ) ; if ( ( TYPE_20 ) ( VAR_64 - VAR_65 + VAR_66 + 1 ) < VAR_67 ) continue ; VAR_68 <<= 1 ; VAR_69 = ( TYPE_21 * ) METHOD_13 ( VAR_70 , VAR_71 + VAR_72 + 1 , sizeof ( * VAR_73 ) ) ; if ( VAR_74 == ( TYPE_22 * ) VAR_75 ) break ; VAR_76 = VAR_77 + METHOD_14 ( VAR_78 ) ; } if ( VAR_79 == ( TYPE_23 * ) VAR_80 ) METHOD_15 ( VAR_81 , ""MemoryAllocationFailed"" ) ; VAR_82 [ VAR_83 ] = '\\0' ; if ( METHOD_16 ( VAR_84 , ( unsigned TYPE_24 * ) VAR_85 , & VAR_86 , & VAR_87 -> VAR_88 , & VAR_89 -> VAR_90 , & VAR_91 , & VAR_92 -> VAR_93 , VAR_94 ) == VAR_95 ) { <S2SV_StartBug> VAR_96 = ( TYPE_25 * ) METHOD_17 ( VAR_97 ) ; <S2SV_EndBug> METHOD_18 ( VAR_98 , ""CorruptImage"" ) ; } VAR_99 = ( TYPE_26 * ) METHOD_19 ( VAR_100 ) ; VAR_101 -> VAR_102 = 24 ; VAR_103 -> VAR_104 = VAR_105 ; VAR_106 = METHOD_20 ( VAR_107 , VAR_108 -> VAR_109 , VAR_110 -> VAR_111 , VAR_112 ) ; if ( VAR_113 == VAR_114 ) { VAR_115 = ( unsigned TYPE_27 * ) METHOD_21 ( VAR_116 ) ; VAR_117 = ( unsigned TYPE_28 * ) METHOD_22 ( VAR_118 ) ; return ( METHOD_23 ( VAR_119 ) ) ; } if ( METHOD_24 ( VAR_120 , VAR_121 -> VAR_122 , VAR_123 ) == VAR_124 ) { VAR_125 = ( unsigned TYPE_29 * ) METHOD_25 ( VAR_126 ) ; VAR_127 = ( unsigned TYPE_30 * ) METHOD_26 ( VAR_128 ) ; METHOD_27 ( VAR_129 , ""MemoryAllocationFailed"" ) ; } for ( VAR_130 = 0 ; VAR_131 < ( TYPE_31 ) VAR_132 -> VAR_133 ; ++ VAR_134 ) { VAR_135 -> VAR_136 [ VAR_137 ] . VAR_138 = METHOD_28 ( VAR_139 [ VAR_140 * 4 + 0 ] ) ; VAR_141 -> VAR_142 [ VAR_143 ] . VAR_144 = METHOD_29 ( VAR_145 [ VAR_146 * 4 + 1 ] ) ; VAR_147 -> VAR_148 [ VAR_149 ] . VAR_150 = METHOD_30 ( VAR_151 [ VAR_152 * 4 + 2 ] ) ; } VAR_153 = 0 ; if ( VAR_154 -> VAR_155 == VAR_156 ) { for ( VAR_157 = 0 ; VAR_158 < ( TYPE_32 ) VAR_159 -> VAR_160 ; VAR_161 ++ ) { VAR_162 = METHOD_31 ( VAR_163 , 0 , VAR_164 , VAR_165 -> VAR_166 , 1 , VAR_167 ) ; if ( VAR_168 == ( TYPE_33 * ) VAR_169 ) break ; for ( VAR_170 = 0 ; VAR_171 < ( TYPE_34 ) VAR_172 -> VAR_173 ; VAR_174 ++ ) { VAR_175 = ( TYPE_35 ) VAR_176 [ VAR_177 * VAR_178 -> VAR_179 + VAR_180 ] ; METHOD_32 ( VAR_181 , VAR_182 , VAR_183 ) ; VAR_184 += METHOD_33 ( VAR_185 ) ; } if ( METHOD_34 ( VAR_186 , VAR_187 ) == VAR_188 ) break ; } if ( VAR_189 < ( TYPE_36 ) VAR_190 -> VAR_191 ) { VAR_192 = ( unsigned TYPE_37 * ) METHOD_35 ( VAR_193 ) ; VAR_194 = ( unsigned TYPE_38 * ) METHOD_36 ( VAR_195 ) ; METHOD_37 ( VAR_196 , ""NotEnoughPixelData"" ) ; } } VAR_197 = ( unsigned TYPE_39 * ) METHOD_38 ( VAR_198 ) ; VAR_199 = ( unsigned TYPE_40 * ) METHOD_39 ( VAR_200 ) ; ( TYPE_41 ) METHOD_40 ( VAR_201 ) ; return ( METHOD_41 ( VAR_202 ) ) ; }",<S2SV_ModStart> METHOD_39 ( VAR_100 ) ; VAR_198 = ( unsigned TYPE_40 * ) METHOD_39 ( VAR_198,"CWE-399 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
355,"CWE-362 struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 , const TYPE_0 * VAR_3 ) { TYPE_1 VAR_4 ; struct STRUCT_OR_UNION_4 * STRUCT_OR_UNION_5 = VAR_5 , * VAR_6 ; <S2SV_StartBug> const TYPE_2 * VAR_7 ; <S2SV_EndBug> VAR_8 = METHOD_1 ( VAR_9 , VAR_10 ) ; if ( METHOD_2 ( VAR_11 ) || METHOD_3 ( VAR_12 ) ) goto VAR_13 ; if ( METHOD_4 ( VAR_14 ) || VAR_15 == VAR_16 || METHOD_5 ( VAR_17 ) ) goto VAR_18 ; STRUCT_OR_UNION_6 = METHOD_6 ( VAR_19 , VAR_20 , METHOD_7 ( VAR_21 ) ) ; if ( METHOD_8 ( STRUCT_OR_UNION_7 ) || STRUCT_OR_UNION_8 == VAR_22 || METHOD_9 ( STRUCT_OR_UNION_9 ) ) goto VAR_23 ; <S2SV_StartBug> VAR_24 = METHOD_10 ( VAR_25 -> VAR_26 . VAR_27 ) ; <S2SV_EndBug> VAR_28 = METHOD_11 ( METHOD_12 ( VAR_29 ) , VAR_30 , METHOD_13 ( VAR_31 ) , STRUCT_OR_UNION_10 , 0 ) ; if ( VAR_32 ) { METHOD_14 ( VAR_33 ) ; goto VAR_34 ; } METHOD_15 ( VAR_35 , STRUCT_OR_UNION_11 ) ; METHOD_16 ( METHOD_17 ( VAR_36 ) , METHOD_18 ( VAR_37 ) , VAR_38 , METHOD_19 ( VAR_39 ) , VAR_40 , VAR_41 ) ; <S2SV_StartBug> METHOD_20 ( VAR_42 ) ; <S2SV_EndBug> METHOD_21 ( VAR_43 , VAR_44 ) ; METHOD_22 ( STRUCT_OR_UNION_12 ) ; return VAR_45 ; VAR_46 : if ( STRUCT_OR_UNION_13 && ! METHOD_23 ( STRUCT_OR_UNION_14 ) ) METHOD_24 ( STRUCT_OR_UNION_15 ) ; METHOD_25 ( VAR_47 , VAR_48 ) ; return VAR_49 ; }","<S2SV_ModStart> * VAR_22 ; struct STRUCT_OR_UNION_16 <S2SV_ModEnd> VAR_42 ; VAR_22 <S2SV_ModStart> goto VAR_46 ; METHOD_26 ( & VAR_42 , VAR_45 ) ; VAR_32 = METHOD_11 ( METHOD_18 ( VAR_48 ) , VAR_45 , METHOD_18 ( VAR_47 ) , STRUCT_OR_UNION_15 , 0 ) ; if ( VAR_32 ) { METHOD_27 ( & VAR_42 ) ; goto VAR_46 ; } METHOD_15 ( VAR_45 , STRUCT_OR_UNION_15 ) ; METHOD_16 ( METHOD_18 ( VAR_48 ) , METHOD_18 ( VAR_47 ) , VAR_42 . VAR_27 <S2SV_ModEnd> , METHOD_19 ( <S2SV_ModStart> VAR_45 ) ; METHOD_27 ( & <S2SV_ModEnd> VAR_42 ) ;","CWE-362 struct dentry * debugfs_rename ( struct dentry * old_dir , struct dentry * old_dentry , struct dentry * new_dir , const char * new_name ) { int error ; struct dentry * dentry = NULL , * trap ; <S2SV_StartBug> const char * old_name ; <S2SV_EndBug> trap = lock_rename ( new_dir , old_dir ) ; if ( d_really_is_negative ( old_dir ) || d_really_is_negative ( new_dir ) ) goto exit ; if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ; dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ; if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ; <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { fsnotify_oldname_free ( old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ; <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> unlock_rename ( new_dir , old_dir ) ; dput ( dentry ) ; return old_dentry ; exit : if ( dentry && ! IS_ERR ( dentry ) ) dput ( dentry ) ; unlock_rename ( new_dir , old_dir ) ; return NULL ; }","<S2SV_ModStart> * trap ; struct name_snapshot <S2SV_ModEnd> old_name ; trap <S2SV_ModStart> goto exit ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> , d_is_dir ( <S2SV_ModStart> old_dentry ) ; release_dentry_name_snapshot ( & <S2SV_ModEnd> old_name ) ;"
356,"CWE-20 static TYPE_0 * * METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 TYPE_5 VAR_3 ) { TYPE_6 * VAR_4 = ( TYPE_7 * ) VAR_5 ( VAR_6 TSRMLS_CC ) ; TYPE_8 * * VAR_7 ; TYPE_9 * VAR_8 ; TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; TYPE_12 * VAR_11 = spl_array_get_hash_table ( VAR_12 , 0 TSRMLS_CC ) ; <S2SV_StartBug> if ( ! VAR_13 ) { <S2SV_EndBug> return & METHOD_1 ( VAR_14 ) ; } if ( ( TYPE_13 == VAR_15 || TYPE_14 == VAR_16 ) && ( VAR_17 -> VAR_18 > 0 ) ) { METHOD_2 ( VAR_19 , ""Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited"" ) ; return & METHOD_3 ( VAR_20 ) ; ; } switch ( METHOD_4 ( VAR_21 ) ) { case VAR_22 : VAR_23 = METHOD_5 ( VAR_24 ) ; VAR_25 = METHOD_6 ( VAR_26 ) + 1 ; VAR_27 : if ( METHOD_7 ( VAR_28 , VAR_29 , VAR_30 , ( TYPE_15 * * ) & VAR_31 ) == VAR_32 ) { switch ( TYPE_16 ) { case VAR_33 : METHOD_8 ( VAR_34 , ""Und<S2SV_blank>index:<S2SV_blank>%s"" , VAR_35 ) ; case VAR_36 : case VAR_37 : VAR_38 = & METHOD_9 ( VAR_39 ) ; break ; case VAR_40 : METHOD_10 ( VAR_41 , ""Und<S2SV_blank>index:<S2SV_blank>%s"" , VAR_42 ) ; case VAR_43 : { TYPE_17 * VAR_44 ; METHOD_11 ( VAR_45 ) ; METHOD_12 ( VAR_46 , VAR_47 , VAR_48 , ( TYPE_18 * * ) & VAR_49 , sizeof ( TYPE_19 * ) , ( TYPE_20 * * ) & VAR_50 ) ; } } } return VAR_51 ; case VAR_52 : VAR_53 = """" ; VAR_54 = 1 ; goto VAR_55 ; case VAR_56 : METHOD_13 ( VAR_57 , ""Resource<S2SV_blank>ID%ld<S2SV_blank>used<S2SV_blank>as<S2SV_blank>offset,<S2SV_blank>casting<S2SV_blank>to<S2SV_blank>integer<S2SV_blank>(%ld)"" , METHOD_14 ( VAR_58 ) , METHOD_15 ( VAR_59 ) ) ; case VAR_60 : case VAR_61 : case VAR_62 : if ( VAR_63 -> TYPE_21 == VAR_64 ) { VAR_65 = ( TYPE_22 ) METHOD_16 ( VAR_66 ) ; } else { VAR_67 = METHOD_17 ( VAR_68 ) ; } if ( METHOD_18 ( VAR_69 , VAR_70 , ( TYPE_23 * * ) & VAR_71 ) == VAR_72 ) { switch ( TYPE_24 ) { case VAR_73 : METHOD_19 ( VAR_74 , ""Und<S2SV_blank>offset:<S2SV_blank>%ld"" , VAR_75 ) ; case VAR_76 : case VAR_77 : VAR_78 = & METHOD_20 ( VAR_79 ) ; break ; case VAR_80 : METHOD_21 ( VAR_81 , ""Und<S2SV_blank>offset:<S2SV_blank>%ld"" , VAR_82 ) ; case VAR_83 : { TYPE_25 * VAR_84 ; METHOD_22 ( VAR_85 ) ; METHOD_23 ( VAR_86 , VAR_87 , ( TYPE_26 * * ) & VAR_88 , sizeof ( TYPE_27 * ) , ( TYPE_28 * * ) & VAR_89 ) ; } } } return VAR_90 ; default : METHOD_24 ( VAR_91 , ""Illegal<S2SV_blank>offset<S2SV_blank>type"" ) ; return ( TYPE_29 == VAR_92 || TYPE_30 == VAR_93 ) ? & METHOD_25 ( VAR_94 ) : & METHOD_26 ( VAR_95 ) ; } }",<S2SV_ModStart> ( ! VAR_68 || ! VAR_86,"CWE-20 static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , ""Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited"" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , ""Und<S2SV_blank>index:<S2SV_blank>%s"" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , ""Und<S2SV_blank>index:<S2SV_blank>%s"" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; case IS_NULL : key = """" ; len = 1 ; goto string_offest ; case IS_RESOURCE : zend_error ( E_STRICT , ""Resource<S2SV_blank>ID%ld<S2SV_blank>used<S2SV_blank>as<S2SV_blank>offset,<S2SV_blank>casting<S2SV_blank>to<S2SV_blank>integer<S2SV_blank>(%ld)"" , Z_LVAL_P ( offset ) , Z_LVAL_P ( offset ) ) ; case IS_DOUBLE : case IS_BOOL : case IS_LONG : if ( offset -> type == IS_DOUBLE ) { index = ( long ) Z_DVAL_P ( offset ) ; } else { index = Z_LVAL_P ( offset ) ; } if ( zend_hash_index_find ( ht , index , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , ""Und<S2SV_blank>offset:<S2SV_blank>%ld"" , index ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , ""Und<S2SV_blank>offset:<S2SV_blank>%ld"" , index ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_hash_index_update ( ht , index , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; default : zend_error ( E_WARNING , ""Illegal<S2SV_blank>offset<S2SV_blank>type"" ) ; return ( type == BP_VAR_W || type == BP_VAR_RW ) ? & EG ( error_zval_ptr ) : & EG ( uninitialized_zval_ptr ) ; } }",<S2SV_ModStart> ( ! offset || ! ht
357,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , unsigned TYPE_1 VAR_2 , unsigned TYPE_2 * VAR_3 , TYPE_3 * VAR_4 ) { unsigned TYPE_4 VAR_5 = 0 ; TYPE_5 VAR_6 ; if ( ( * VAR_7 & ( VAR_8 | VAR_9 ) ) == VAR_10 ) return - VAR_11 ; if ( ( * VAR_12 & VAR_13 ) && ( METHOD_1 ( VAR_14 , VAR_15 ) || METHOD_2 ( VAR_16 , VAR_17 + VAR_18 ) ) ) return - VAR_19 ; if ( * VAR_20 & VAR_21 ) VAR_22 |= VAR_23 ; if ( * VAR_24 & VAR_25 ) VAR_26 |= VAR_27 ; if ( VAR_28 ) VAR_29 |= VAR_30 ; if ( * VAR_31 & VAR_32 ) VAR_33 |= VAR_34 | VAR_35 ; if ( * VAR_36 & VAR_37 ) { METHOD_3 ( VAR_38 & VAR_39 ) ; VAR_40 |= VAR_41 ; } VAR_42 = METHOD_4 ( VAR_43 , VAR_44 , VAR_45 ) ; if ( VAR_46 & VAR_47 ) { if ( VAR_48 & VAR_49 ) return - VAR_50 ; if ( VAR_51 & ( VAR_52 | VAR_53 ) ) return * VAR_54 & VAR_55 ? - VAR_56 : - VAR_57 ; if ( VAR_58 & ( VAR_59 | VAR_60 ) ) return - VAR_61 ; METHOD_5 ( ) ; } if ( VAR_62 ) { if ( VAR_63 & VAR_64 ) VAR_65 -> VAR_66 ++ ; else VAR_67 -> VAR_68 ++ ; } if ( VAR_69 & VAR_70 ) { if ( VAR_71 ) * VAR_72 = 0 ; return - VAR_73 ; } if ( ( VAR_74 & VAR_75 ) && ! ( VAR_76 -> VAR_77 & VAR_78 ) ) <S2SV_StartBug> * VAR_79 &= ~ VAR_80 ; <S2SV_EndBug> return 0 ; }",<S2SV_ModStart> ) * VAR_79 |= VAR_81 <S2SV_ModEnd> ; return 0,"CWE-362 static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) <S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> return 0 ; }",<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
358,"CWE-787 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 * VAR_3 = ( TYPE_5 * ) VAR_4 ; METHOD_1 ( VAR_5 , 3 ) ; METHOD_2 ( VAR_6 ) ; if ( ! VAR_7 -> VAR_8 ) { METHOD_3 ( VAR_9 ) ; } else { VAR_10 -> VAR_11 = METHOD_4 ( VAR_12 , 4 ) ; VAR_13 -> VAR_14 = METHOD_5 ( VAR_15 , 4 ) ; } VAR_16 -> VAR_17 = METHOD_6 ( VAR_18 ) ; METHOD_7 ( VAR_19 , 17 ) ; VAR_20 -> VAR_21 [ 0 ] = 0 ; VAR_22 -> VAR_23 [ 1 ] = 0 ; VAR_24 -> VAR_25 [ 2 ] = 0 ; VAR_26 -> VAR_27 [ 3 ] = VAR_28 = METHOD_8 ( VAR_29 ) ; METHOD_9 ( VAR_30 , VAR_31 -> VAR_32 + 4 , 16 ) ; if ( ! VAR_33 && VAR_34 -> VAR_35 ) { METHOD_10 ( VAR_36 , 1 ) ; VAR_37 = VAR_38 -> VAR_39 [ 20 ] = METHOD_11 ( VAR_40 ) ; METHOD_12 ( VAR_41 , VAR_42 -> VAR_43 [ 20 ] ) ; <S2SV_StartBug> METHOD_13 ( VAR_44 , VAR_45 -> VAR_46 + 21 , VAR_47 ) ; <S2SV_EndBug> } <S2SV_StartBug> return VAR_48 ; <S2SV_EndBug> }","<S2SV_ModStart> ] ) ; if ( ( VAR_47 != 8 ) && ( VAR_47 != 16 ) ) { METHOD_14 ( VAR_49 , VAR_50 , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( TYPE_6 ) VAR_47 ) ) ; VAR_45 -> VAR_46 [ 20 ] = 16 ; return VAR_51 ; } <S2SV_ModStart> ) ; } else if ( ( VAR_47 != 0 ) && ( VAR_47 != 8 ) && ( VAR_47 != 16 ) ) { METHOD_14 ( VAR_49 , VAR_50 , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( TYPE_6 ) VAR_47 ) ) ; return VAR_51 ; }","CWE-787 GF_Err tenc_box_read ( GF_Box * s , GF_BitStream * bs ) { u8 iv_size ; GF_TrackEncryptionBox * ptr = ( GF_TrackEncryptionBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isProtected = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isProtected ) { ISOM_DECREASE_SIZE ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , ptr -> key_info [ 20 ] ) ; <S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> } <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> }","<S2SV_ModStart> ] ) ; if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> ) ; } else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; }"
359,"CWE-310 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , const TYPE_1 * VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 ) { TYPE_5 VAR_6 = 0 ; struct STRUCT_OR_UNION_4 VAR_7 ; struct STRUCT_OR_UNION_5 * VAR_8 = METHOD_1 ( VAR_9 ) -> VAR_10 ; TYPE_6 VAR_11 = METHOD_2 ( STRUCT_OR_UNION_6 ) ; TYPE_7 VAR_12 = METHOD_3 ( VAR_13 ) ; if ( METHOD_4 ( VAR_14 == VAR_15 ) ) { METHOD_5 ( & VAR_16 , & METHOD_6 ( STRUCT_OR_UNION_7 ) -> VAR_17 -> VAR_18 , sizeof ( VAR_19 ) ) ; } else { VAR_20 . VAR_21 = VAR_22 ; METHOD_7 ( & VAR_23 , VAR_24 ) ; VAR_25 . VAR_26 = 0 ; } if ( METHOD_8 ( VAR_27 == VAR_28 ) ) { VAR_29 = METHOD_9 ( VAR_30 , VAR_31 -> VAR_32 -> VAR_33 , VAR_34 . VAR_35 , VAR_36 -> VAR_37 . VAR_38 , VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; } else if ( VAR_43 ) { VAR_44 = METHOD_10 ( VAR_45 , VAR_46 , VAR_47 , VAR_48 , VAR_49 , VAR_50 , VAR_51 ) ; } if ( VAR_52 ) return VAR_53 ; VAR_54 = METHOD_11 ( VAR_55 , VAR_56 , VAR_57 , VAR_58 , VAR_59 , & VAR_60 , METHOD_12 ( STRUCT_OR_UNION_8 ) , VAR_61 ) ; <S2SV_StartBug> if ( VAR_62 == - VAR_63 ) <S2SV_EndBug> goto VAR_64 ; else if ( VAR_65 ) { METHOD_13 ( VAR_66 , VAR_67 , VAR_68 ) ; return VAR_69 ; } METHOD_14 ( VAR_70 , VAR_71 -> VAR_72 + VAR_73 * 2 ) ; METHOD_15 ( VAR_74 ) ; VAR_75 -> VAR_76 = VAR_77 -> VAR_78 = VAR_79 ; VAR_80 = METHOD_16 ( VAR_81 , VAR_82 , VAR_83 ) ; if ( VAR_84 ) METHOD_17 ( VAR_85 , VAR_86 , VAR_87 ) ; return VAR_88 ; VAR_89 : if ( METHOD_18 ( VAR_90 == VAR_91 ) ) { TYPE_8 VAR_92 ; TYPE_9 VAR_93 ; VAR_94 = METHOD_19 ( VAR_95 , VAR_96 -> VAR_97 -> VAR_98 , VAR_99 . VAR_100 , VAR_101 -> VAR_102 . VAR_103 , VAR_104 , & VAR_105 , VAR_106 , VAR_107 ) ; } else if ( VAR_108 ) { TYPE_10 VAR_109 ; TYPE_11 VAR_110 ; VAR_111 = METHOD_20 ( VAR_112 , VAR_113 , VAR_114 , VAR_115 , VAR_116 , VAR_117 , & VAR_118 ) ; } return VAR_119 ; }",<S2SV_ModStart> == - VAR_63 || VAR_119 == - VAR_120,"CWE-310 int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len * 2 ) ; inode_inc_iversion ( parent_inode ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode ( trans , root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; return ret ; fail_dir_item : if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { u64 local_index ; int err ; err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , & local_index , name , name_len ) ; } else if ( add_backref ) { u64 local_index ; int err ; err = btrfs_del_inode_ref ( trans , root , name , name_len , ino , parent_ino , & local_index ) ; } return ret ; }",<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
360,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 VAR_2 ; TYPE_4 * VAR_3 = VAR_4 -> VAR_5 [ 0 ] ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; TYPE_7 VAR_8 ; TYPE_8 VAR_9 ; TYPE_9 VAR_10 ; VAR_11 = VAR_12 -> VAR_13 ; VAR_14 = - 1 ; VAR_15 -> VAR_16 [ 0 ] -> VAR_17 = 0 ; VAR_18 -> VAR_19 [ 1 ] -> VAR_20 = - 1 ; VAR_21 -> VAR_22 [ 2 ] -> VAR_23 = - 1 ; VAR_24 -> VAR_25 [ 3 ] -> VAR_26 = - 1 ; VAR_27 -> VAR_28 [ 0 ] -> VAR_29 = VAR_30 -> VAR_31 ; VAR_32 -> VAR_33 [ 1 ] -> VAR_34 = - 1 ; VAR_35 -> VAR_36 [ 2 ] -> VAR_37 = - 1 ; VAR_38 -> VAR_39 [ 3 ] -> VAR_40 = - 1 ; if ( VAR_41 -> VAR_42 == 1 ) return 0 ; METHOD_1 ( ( TYPE_10 * ) VAR_43 -> VAR_44 ) ; VAR_45 = - 1 ; VAR_46 = 0 ; while ( 1 ) { TYPE_11 VAR_47 ; if ( VAR_48 . VAR_49 + VAR_50 >= VAR_51 . VAR_52 ) { break ; } VAR_53 = METHOD_2 ( & VAR_54 , VAR_55 ) ; VAR_56 = VAR_57 & 0xFF ; VAR_58 = ( ( ( VAR_59 >> 8 ) == 0x01 ) && ( VAR_60 ) && ( VAR_61 <= VAR_62 -> VAR_63 ) ) ; if ( ! VAR_64 ) break ; VAR_65 -= 1 ; <S2SV_StartBug> if ( VAR_66 != VAR_67 ) <S2SV_EndBug> { if ( VAR_68 != - 1 ) { TYPE_12 VAR_69 ; TYPE_13 VAR_70 ; VAR_71 . VAR_72 = VAR_73 ; VAR_74 . VAR_75 = VAR_76 ; VAR_77 . VAR_78 = VAR_79 ; VAR_80 . VAR_81 = VAR_82 ; VAR_83 = METHOD_3 ( VAR_84 -> VAR_85 , & VAR_86 , sizeof ( VAR_87 ) , 1 , 0 ) ; if ( VAR_88 != VAR_89 ) return VAR_90 ; } VAR_91 = VAR_92 . VAR_93 >> 3 ; VAR_94 -= ( TYPE_14 ) VAR_95 . VAR_96 & 3 ; VAR_97 = VAR_98 ; VAR_99 = VAR_100 ; <S2SV_StartBug> } <S2SV_EndBug> METHOD_4 ( & VAR_101 , VAR_102 ) ; while ( METHOD_5 ( & VAR_103 , 24 ) != VAR_104 ) { METHOD_6 ( & VAR_105 , 8 ) ; if ( VAR_106 . VAR_107 >= VAR_108 . VAR_109 ) { break ; } } } { TYPE_15 VAR_110 ; TYPE_16 VAR_111 ; VAR_112 . VAR_113 = VAR_114 ; VAR_115 . VAR_116 = VAR_117 -> VAR_118 ; VAR_119 . VAR_120 = VAR_121 ; VAR_122 . VAR_123 = VAR_124 ; VAR_125 = METHOD_7 ( VAR_126 -> VAR_127 , & VAR_128 , sizeof ( VAR_129 ) , 1 , 0 ) ; if ( VAR_130 != VAR_131 ) return VAR_132 ; } if ( ( VAR_133 != VAR_134 -> VAR_135 ) && ( ( 0 == VAR_136 -> VAR_137 ) || ( VAR_138 != VAR_139 -> VAR_140 ) ) ) { for ( VAR_141 = 0 ; VAR_142 < VAR_143 -> VAR_144 ; VAR_145 += 64 ) { TYPE_17 VAR_146 ; TYPE_18 VAR_147 ; VAR_148 . VAR_149 = VAR_150 ; VAR_151 . VAR_152 >>= 4 ; VAR_153 . VAR_154 = ( VAR_155 + 64 ) ; VAR_156 . VAR_157 >>= 4 ; VAR_158 . VAR_159 = VAR_160 ; VAR_161 . VAR_162 = 0 ; VAR_163 = METHOD_8 ( VAR_164 -> VAR_165 , & VAR_166 , sizeof ( VAR_167 ) , 1 , 0 ) ; if ( VAR_168 != VAR_169 ) return VAR_170 ; } } METHOD_9 ( VAR_171 -> VAR_172 ) ; VAR_173 -> VAR_174 = VAR_175 . VAR_176 >> 3 ; VAR_177 -> VAR_178 -= ( ( TYPE_19 ) VAR_179 . VAR_180 & 3 ) ; return 0 ; }","<S2SV_ModStart> if ( VAR_97 < <S2SV_ModEnd> VAR_100 ) { <S2SV_ModStart> VAR_100 ; } else if ( VAR_97 > VAR_100 ) { METHOD_10 ( 0x534e4554 , ""26070014"" ) ; }","CWE-119 WORD32 impeg2d_get_slice_pos ( dec_state_multi_core_t * ps_dec_state_multi_core ) { WORD32 u4_bits ; WORD32 i4_row ; dec_state_t * ps_dec = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; WORD32 i4_prev_row ; stream_t s_bitstrm ; WORD32 i4_start_row ; WORD32 i4_slice_bistream_ofst ; WORD32 i ; s_bitstrm = ps_dec -> s_bit_stream ; i4_prev_row = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_start_mb_y = 0 ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_end_mb_y = ps_dec -> u2_num_vert_mb ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_end_mb_y = - 1 ; if ( ps_dec -> i4_num_cores == 1 ) return 0 ; impeg2_jobq_reset ( ( jobq_t * ) ps_dec -> pv_jobq ) ; i4_start_row = - 1 ; i4_slice_bistream_ofst = 0 ; while ( 1 ) { WORD32 i4_is_slice ; if ( s_bitstrm . u4_offset + START_CODE_LEN >= s_bitstrm . u4_max_offset ) { break ; } u4_bits = impeg2d_bit_stream_nxt ( & s_bitstrm , START_CODE_LEN ) ; i4_row = u4_bits & 0xFF ; i4_is_slice = ( ( ( u4_bits >> 8 ) == 0x01 ) && ( i4_row ) && ( i4_row <= ps_dec -> u2_num_vert_mb ) ) ; if ( ! i4_is_slice ) break ; i4_row -= 1 ; <S2SV_StartBug> if ( i4_prev_row != i4_row ) <S2SV_EndBug> { if ( i4_start_row != - 1 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = i4_row ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } i4_slice_bistream_ofst = s_bitstrm . u4_offset >> 3 ; i4_slice_bistream_ofst -= ( size_t ) s_bitstrm . pv_bs_buf & 3 ; i4_prev_row = i4_row ; i4_start_row = i4_row ; <S2SV_StartBug> } <S2SV_EndBug> impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( & s_bitstrm , 24 ) != START_CODE_PREFIX ) { impeg2d_bit_stream_get ( & s_bitstrm , 8 ) ; if ( s_bitstrm . u4_offset >= s_bitstrm . u4_max_offset ) { break ; } } } { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = ps_dec -> u2_num_vert_mb ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; e_ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( e_ret != IV_SUCCESS ) return e_ret ; } if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) { for ( i = 0 ; i < ps_dec -> u2_vertical_size ; i += 64 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i ; s_job . i2_start_mb_y >>= 4 ; s_job . i2_end_mb_y = ( i + 64 ) ; s_job . i2_end_mb_y >>= 4 ; s_job . i4_cmd = CMD_FMTCONV ; s_job . i4_bistream_ofst = 0 ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } } impeg2_jobq_terminate ( ps_dec -> pv_jobq ) ; ps_dec -> i4_bytes_consumed = s_bitstrm . u4_offset >> 3 ; ps_dec -> i4_bytes_consumed -= ( ( size_t ) s_bitstrm . pv_bs_buf & 3 ) ; return 0 ; }","<S2SV_ModStart> if ( i4_prev_row < <S2SV_ModEnd> i4_row ) { <S2SV_ModStart> i4_row ; } else if ( i4_prev_row > i4_row ) { android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; }"
361,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 VAR_1 ; TYPE_1 VAR_2 = VAR_3 -> VAR_4 . VAR_5 . VAR_6 [ VAR_7 ] ; TYPE_2 VAR_8 = ( VAR_9 -> VAR_10 . VAR_11 . VAR_12 [ VAR_13 ] & - 1u ) | ( ( TYPE_3 ) ( VAR_14 -> VAR_15 . VAR_16 . VAR_17 [ VAR_18 ] & - 1u ) << 32 ) ; VAR_19 . VAR_20 = VAR_21 ; VAR_22 . VAR_23 = VAR_24 ; VAR_25 . VAR_26 = VAR_27 ; VAR_28 -> VAR_29 = METHOD_1 ( & VAR_30 -> VAR_31 ) + 2 ; <S2SV_StartBug> if ( METHOD_2 ( & VAR_32 -> VAR_33 , & VAR_34 ) ) { <S2SV_EndBug> METHOD_3 ( VAR_35 , VAR_36 ) ; METHOD_4 ( & VAR_37 -> VAR_38 , 0 ) ; } else { METHOD_5 ( VAR_39 , VAR_40 ) ; METHOD_6 ( & VAR_41 -> VAR_42 ) ; } return 1 ; }",<S2SV_ModStart> ; if ( METHOD_7 <S2SV_ModEnd> ( & VAR_41,"CWE-000 static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; <S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }",<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
362,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; <S2SV_StartBug> VAR_5 * VAR_6 ; <S2SV_EndBug> VAR_7 = VAR_8 ; for ( VAR_9 = 0 ; VAR_10 < VAR_11 ; VAR_12 += 16 ) { METHOD_1 ( VAR_13 , ""%04zx:"" , VAR_14 ) ; for ( VAR_15 = 0 ; VAR_16 < 16 ; ++ VAR_17 ) { if ( VAR_18 + VAR_19 < VAR_20 ) { METHOD_2 ( VAR_21 , ""<S2SV_blank>%02x"" , VAR_22 [ VAR_23 + VAR_24 ] ) ; } } METHOD_3 ( VAR_25 , ""\\n"" ) ; } return 0 ; }",<S2SV_ModStart> TYPE_5 VAR_24 ; VAR_26 <S2SV_ModEnd> * VAR_22 ;,"CWE-190 int jas_memdump ( FILE * out , void * data , size_t len ) { size_t i ; size_t j ; <S2SV_StartBug> uchar * dp ; <S2SV_EndBug> dp = data ; for ( i = 0 ; i < len ; i += 16 ) { fprintf ( out , ""%04zx:"" , i ) ; for ( j = 0 ; j < 16 ; ++ j ) { if ( i + j < len ) { fprintf ( out , ""<S2SV_blank>%02x"" , dp [ i + j ] ) ; } } fprintf ( out , ""\\n"" ) ; } return 0 ; }",<S2SV_ModStart> size_t j ; jas_uchar <S2SV_ModEnd> * dp ;
363,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 = METHOD_1 ( TYPE_6 , VAR_5 ) ; switch ( VAR_6 ) { case VAR_7 : VAR_8 -> VAR_9 = 0 ; VAR_10 -> VAR_11 = 0 ; VAR_12 -> VAR_13 = 8 ; VAR_14 -> VAR_15 = 12 ; VAR_16 -> VAR_17 = 0 ; VAR_18 -> VAR_19 = 0 ; VAR_20 -> VAR_21 = - 1 ; return 1 ; case VAR_22 : if ( VAR_23 != VAR_24 ) return 0 ; METHOD_2 ( METHOD_3 ( VAR_25 ) , VAR_26 , VAR_27 ) ; VAR_28 -> VAR_29 = VAR_30 ; { TYPE_7 VAR_31 = METHOD_4 ( VAR_32 ) [ VAR_33 - 2 ] << 8 | METHOD_5 ( VAR_34 ) [ VAR_35 - 1 ] ; <S2SV_StartBug> VAR_36 -= VAR_37 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! METHOD_6 ( VAR_38 ) ) <S2SV_EndBug> <S2SV_StartBug> VAR_39 -= VAR_40 -> VAR_41 ; <S2SV_EndBug> METHOD_7 ( VAR_42 ) [ VAR_43 - 2 ] = VAR_44 >> 8 ; METHOD_8 ( VAR_45 ) [ VAR_46 - 1 ] = VAR_47 & 0xff ; } return VAR_48 -> VAR_49 ; case VAR_50 : if ( VAR_51 != VAR_52 ) return 0 ; METHOD_9 ( METHOD_10 ( VAR_53 ) , VAR_54 , VAR_55 ) ; return 1 ; case VAR_56 : VAR_57 = 15 - VAR_58 ; case VAR_59 : if ( VAR_60 < 2 || VAR_61 > 8 ) return 0 ; VAR_62 -> VAR_63 = VAR_64 ; return 1 ; case VAR_65 : if ( ( VAR_66 & 1 ) || VAR_67 < 4 || VAR_68 > 16 ) return 0 ; if ( METHOD_11 ( VAR_69 ) && VAR_70 ) return 0 ; if ( VAR_71 ) { VAR_72 -> VAR_73 = 1 ; METHOD_12 ( METHOD_13 ( VAR_74 ) , VAR_75 , VAR_76 ) ; } VAR_77 -> VAR_78 = VAR_79 ; return 1 ; case VAR_80 : if ( ! METHOD_14 ( VAR_81 ) || ! VAR_82 -> VAR_83 ) return 0 ; if ( ! METHOD_15 ( & VAR_84 -> VAR_85 , VAR_86 , ( TYPE_8 ) VAR_87 ) ) return 0 ; VAR_88 -> VAR_89 = 0 ; VAR_90 -> VAR_91 = 0 ; VAR_92 -> VAR_93 = 0 ; return 1 ; case VAR_94 : { TYPE_9 * VAR_95 = VAR_96 ; TYPE_10 * VAR_97 = METHOD_16 ( TYPE_11 , VAR_98 ) ; if ( VAR_99 -> VAR_100 . VAR_101 ) { if ( VAR_102 -> VAR_103 . VAR_104 != & VAR_105 -> VAR_106 ) return 0 ; VAR_107 -> VAR_108 . VAR_109 = & VAR_110 -> VAR_111 ; } return 1 ; } default : return - 1 ; } }",<S2SV_ModStart> 1 ] ; if ( VAR_47 < VAR_37 ) return 0 ; <S2SV_ModStart> VAR_81 ) ) { if ( VAR_47 < VAR_105 -> VAR_78 ) return 0 ; <S2SV_ModStart> -> VAR_78 ; },"CWE-125 static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : cctx -> key_set = 0 ; cctx -> iv_set = 0 ; cctx -> L = 8 ; cctx -> M = 12 ; cctx -> tag_set = 0 ; cctx -> len_set = 0 ; cctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; cctx -> tls_aad_len = arg ; { uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; <S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return cctx -> M ; case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ; case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ; cctx -> L = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ; if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ; if ( ptr ) { cctx -> tag_set = 1 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; } cctx -> M = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ; if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ; cctx -> tag_set = 0 ; cctx -> iv_set = 0 ; cctx -> len_set = 0 ; return 1 ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; if ( cctx -> ccm . key ) { if ( cctx -> ccm . key != & cctx -> ks ) return 0 ; cctx_out -> ccm . key = & cctx_out -> ks ; } return 1 ; } default : return - 1 ; } }",<S2SV_ModStart> 1 ] ; if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> -> M ; }
364,"CWE-772 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 , * VAR_3 = VAR_4 , * VAR_5 ; TYPE_4 * VAR_6 ; unsigned TYPE_5 VAR_7 ; TYPE_6 VAR_8 ; TYPE_7 VAR_9 ; TYPE_8 VAR_10 ; TYPE_9 * VAR_11 ; TYPE_10 * VAR_12 ; TYPE_11 VAR_13 ; TYPE_12 VAR_14 ; unsigned TYPE_13 * VAR_15 = VAR_16 ; TYPE_14 VAR_17 , VAR_18 ; TYPE_15 VAR_19 ; unsigned VAR_20 , VAR_21 ; unsigned VAR_22 ; TYPE_16 VAR_23 ; TYPE_17 VAR_24 ; TYPE_18 VAR_25 = 0x80 ; VAR_26 * VAR_27 ; TYPE_19 VAR_28 ; unsigned TYPE_20 ( * METHOD_1 ) ( TYPE_21 * VAR_29 ) ; unsigned TYPE_22 ( * METHOD_2 ) ( TYPE_23 * VAR_30 ) ; TYPE_24 ( * METHOD_3 ) ( TYPE_25 * VAR_31 , TYPE_26 VAR_32 , TYPE_27 * VAR_33 ) ; TYPE_28 ( * METHOD_4 ) ( TYPE_29 * VAR_34 , TYPE_30 VAR_35 , TYPE_31 * VAR_36 ) ; METHOD_5 ( VAR_37 != ( const TYPE_32 * ) VAR_38 ) ; METHOD_6 ( VAR_39 -> VAR_40 == VAR_41 ) ; METHOD_7 ( VAR_42 != ( TYPE_33 * ) VAR_43 ) ; METHOD_8 ( VAR_44 -> VAR_45 == VAR_46 ) ; VAR_47 = METHOD_9 ( VAR_48 , METHOD_10 ( ) , ""enter"" ) ; VAR_49 = ( TYPE_34 * ) VAR_50 ; VAR_51 = METHOD_11 ( VAR_52 ) ; VAR_53 = METHOD_12 ( VAR_54 , VAR_55 , VAR_56 , VAR_57 ) ; if ( VAR_58 == VAR_59 ) { VAR_60 = METHOD_13 ( VAR_61 ) ; return ( ( TYPE_35 * ) VAR_62 ) ; } VAR_63 = ( TYPE_36 * ) VAR_64 ; if ( METHOD_14 ( VAR_65 , 124 , ( unsigned TYPE_37 * ) & VAR_66 . VAR_67 ) != 124 ) METHOD_15 ( VAR_68 , ""ImproperImageHeader"" ) ; if ( METHOD_16 ( VAR_69 . VAR_70 , ""MATLAB"" , 6 ) != 0 ) { VAR_71 = METHOD_17 ( VAR_72 , VAR_73 , VAR_74 ) ; if ( VAR_75 == VAR_76 ) goto VAR_77 ; VAR_78 = VAR_79 ; goto VAR_80 ; } VAR_81 . VAR_82 = METHOD_18 ( VAR_83 ) ; if ( METHOD_19 ( VAR_84 , 2 , ( unsigned TYPE_38 * ) & VAR_85 . VAR_86 ) != 2 ) METHOD_20 ( VAR_87 , ""ImproperImageHeader"" ) ; if ( VAR_88 ) ( TYPE_39 ) METHOD_21 ( VAR_89 , METHOD_22 ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , VAR_90 . VAR_91 [ 0 ] , VAR_92 . VAR_93 [ 1 ] ) ; if ( ! METHOD_23 ( VAR_94 . VAR_95 , ""IM"" , 2 ) ) { METHOD_24 = VAR_96 ; METHOD_25 = METHOD_26 ; METHOD_27 = VAR_97 ; METHOD_28 = VAR_98 ; VAR_99 -> VAR_100 = VAR_101 ; } else if ( ! METHOD_29 ( VAR_102 . VAR_103 , ""MI"" , 2 ) ) { METHOD_30 = VAR_104 ; METHOD_31 = VAR_105 ; METHOD_32 = VAR_106 ; METHOD_33 = VAR_107 ; VAR_108 -> VAR_109 = VAR_110 ; } else goto VAR_111 ; if ( METHOD_34 ( VAR_112 . VAR_113 , ""MATLAB"" , 6 ) ) <S2SV_StartBug> VAR_114 : METHOD_35 ( VAR_115 , ""ImproperImageHeader"" ) ; <S2SV_EndBug> VAR_116 = METHOD_36 ( VAR_117 ) ; while ( ! METHOD_37 ( VAR_118 ) ) { VAR_119 = 1 ; ( TYPE_40 ) METHOD_38 ( VAR_120 , VAR_121 , VAR_122 ) ; VAR_123 . VAR_124 = METHOD_39 ( VAR_125 ) ; if ( METHOD_40 ( VAR_126 ) ) break ; VAR_127 . VAR_128 = METHOD_41 ( VAR_129 ) ; if ( METHOD_42 ( VAR_130 ) ) break ; if ( VAR_131 . VAR_132 + VAR_133 > METHOD_43 ( VAR_134 ) ) goto VAR_135 ; VAR_136 += VAR_137 . VAR_138 + 4 + 4 ; VAR_139 = METHOD_44 ( VAR_140 ) ; VAR_141 = VAR_142 ; if d ( VAR_143 ) if ( VAR_144 . VAR_145 == VAR_146 ) { VAR_147 = METHOD_45 ( VAR_148 , & VAR_149 . VAR_150 , VAR_151 , VAR_152 ) ; if ( VAR_153 == VAR_154 ) continue ; VAR_155 . VAR_156 = METHOD_46 ( VAR_157 ) ; } if ( VAR_158 . VAR_159 != VAR_160 ) continue ; VAR_161 . VAR_162 = METHOD_47 ( VAR_163 ) ; VAR_164 . VAR_165 = METHOD_48 ( VAR_166 ) ; VAR_167 . VAR_168 = METHOD_49 ( VAR_169 ) ; VAR_170 . VAR_171 = VAR_172 . VAR_173 & 0xFF ; VAR_174 . VAR_175 = ( VAR_176 . VAR_177 >> 8 ) & 0xFF ; VAR_178 . VAR_179 = METHOD_50 ( VAR_180 ) ; if ( VAR_181 != VAR_182 ) VAR_183 . VAR_184 = METHOD_51 ( VAR_185 ) ; VAR_186 . VAR_187 = METHOD_52 ( VAR_188 ) ; VAR_189 . VAR_190 = METHOD_53 ( VAR_191 ) ; VAR_192 . VAR_193 = METHOD_54 ( VAR_194 ) ; VAR_195 . VAR_196 = METHOD_55 ( VAR_197 ) ; switch ( VAR_198 . VAR_199 ) { case 8 : VAR_200 = VAR_201 = 1 ; break ; case 12 : VAR_202 = VAR_203 = METHOD_56 ( VAR_204 ) ; VAR_205 = METHOD_57 ( VAR_206 ) ; ( TYPE_41 ) VAR_207 ; if ( VAR_208 != 3 ) METHOD_58 ( VAR_209 , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : VAR_210 = VAR_211 = METHOD_59 ( VAR_212 ) ; if ( VAR_213 != 3 && VAR_214 != 1 ) METHOD_60 ( VAR_215 , ""MultidimensionalMatricesAreNotSupported"" ) ; VAR_216 = METHOD_61 ( VAR_217 ) ; if ( VAR_218 == 0 ) METHOD_62 ( VAR_219 , ""ImproperImageHeader"" ) ; break ; default : METHOD_63 ( VAR_220 , ""MultidimensionalMatricesAreNotSupported"" ) ; } VAR_221 . VAR_222 = METHOD_64 ( VAR_223 ) ; VAR_224 . VAR_225 = METHOD_65 ( VAR_226 ) ; if ( VAR_227 ) ( TYPE_42 ) METHOD_66 ( VAR_228 , METHOD_67 ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , VAR_229 . VAR_230 ) ; if ( VAR_231 . VAR_232 != VAR_233 && VAR_234 . VAR_235 != VAR_236 && VAR_237 . VAR_238 != VAR_239 && VAR_240 . VAR_241 != VAR_242 && VAR_243 . VAR_244 != VAR_245 && VAR_246 . VAR_247 != VAR_248 && VAR_249 . VAR_250 != VAR_251 && VAR_252 . VAR_253 != VAR_254 && VAR_255 . VAR_256 != VAR_257 && VAR_258 . VAR_259 != VAR_260 && VAR_261 . VAR_262 != VAR_263 ) METHOD_68 ( VAR_264 , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( VAR_265 . VAR_266 ) { case 0 : VAR_267 = METHOD_69 ( VAR_268 ) ; VAR_269 = 4 * ( TYPE_43 ) ( ( VAR_270 + 3 + 1 ) / 4 ) ; ( TYPE_44 ) METHOD_70 ( VAR_271 , VAR_272 , VAR_273 ) ; break ; case 1 : case 2 : case 3 : case 4 : ( TYPE_45 ) METHOD_71 ( VAR_274 , 4 , ( unsigned TYPE_46 * ) & VAR_275 ) ; break ; default : goto VAR_276 ; } VAR_277 = METHOD_72 ( VAR_278 ) ; if ( VAR_279 ) ( TYPE_47 ) METHOD_73 ( VAR_280 , METHOD_74 ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( TYPE_48 ) VAR_281 ) ; ( TYPE_49 ) METHOD_75 ( VAR_282 , 4 , ( unsigned TYPE_50 * ) & VAR_283 ) ; VAR_284 : switch ( VAR_285 ) { case VAR_286 : case VAR_287 : VAR_288 = 8 ; if ( VAR_289 . VAR_290 & VAR_291 ) VAR_292 -> VAR_293 = 1 ; else VAR_294 -> VAR_295 = 8 ; VAR_296 = ( TYPE_51 ) VAR_297 . VAR_298 ; break ; case VAR_299 : case VAR_300 : VAR_301 = 16 ; VAR_302 -> VAR_303 = 16 ; VAR_304 = ( TYPE_52 ) ( 2 * VAR_305 . VAR_306 ) ; break ; case VAR_307 : case VAR_308 : VAR_309 = 32 ; VAR_310 -> VAR_311 = 32 ; VAR_312 = ( TYPE_53 ) ( 4 * VAR_313 . VAR_314 ) ; break ; case VAR_315 : case VAR_316 : VAR_317 = 64 ; VAR_318 -> VAR_319 = 64 ; VAR_320 = ( TYPE_54 ) ( 8 * VAR_321 . VAR_322 ) ; break ; case VAR_323 : VAR_324 = 32 ; VAR_325 -> VAR_326 = 32 ; ( TYPE_55 ) METHOD_76 ( VAR_327 , ""quantum:format"" , ""floating-point"" ) ; if ( VAR_328 . VAR_329 & VAR_330 ) { } VAR_331 = ( TYPE_56 ) ( 4 * VAR_332 . VAR_333 ) ; break ; case VAR_334 : VAR_335 = 64 ; VAR_336 -> VAR_337 = 64 ; ( TYPE_57 ) METHOD_77 ( VAR_338 , ""quantum:format"" , ""floating-point"" ) ; METHOD_78 ( 4127 ) if ( sizeof ( TYPE_58 ) != 8 ) TYPE_59 METHOD_79 ( VAR_339 , ""IncompatibleSizeOfDouble"" ) ; if ( VAR_340 . VAR_341 & VAR_342 ) { } VAR_343 = ( TYPE_60 ) ( 8 * VAR_344 . VAR_345 ) ; break ; default : METHOD_80 ( VAR_346 , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( TYPE_61 ) VAR_347 ; VAR_348 -> VAR_349 = VAR_350 . VAR_351 ; VAR_352 -> VAR_353 = VAR_354 . VAR_355 ; VAR_356 = 1 ; VAR_357 -> VAR_358 = VAR_359 << VAR_360 -> VAR_361 ; if ( VAR_362 -> VAR_363 == 0 || VAR_364 -> VAR_365 == 0 ) goto VAR_366 ; if ( ( unsigned TYPE_62 ) VAR_367 * VAR_368 . VAR_369 > VAR_370 . VAR_371 ) goto VAR_372 ; if ( ( VAR_373 . VAR_374 == 8 ) && ( ( VAR_375 . VAR_376 & VAR_377 ) == 0 ) ) { METHOD_81 ( VAR_378 , VAR_379 ) ; VAR_380 -> VAR_381 = VAR_382 ; } if ( VAR_383 -> VAR_384 ) { TYPE_63 VAR_385 = VAR_386 -> VAR_387 ; VAR_388 -> VAR_389 = VAR_390 -> VAR_391 ; VAR_392 -> VAR_393 = VAR_394 ; goto VAR_395 ; } VAR_396 = METHOD_82 ( VAR_397 , VAR_398 -> VAR_399 , VAR_400 -> VAR_401 ) ; if ( VAR_402 == VAR_403 ) { METHOD_83 ( VAR_404 , & VAR_405 -> VAR_406 ) ; return ( METHOD_84 ( VAR_407 ) ) ; } VAR_408 = METHOD_85 ( VAR_409 , VAR_410 ) ; if ( VAR_411 == ( TYPE_64 * ) VAR_412 ) METHOD_86 ( VAR_413 , ""MemoryAllocationFailed"" ) ; VAR_414 = ( unsigned TYPE_65 * ) METHOD_87 ( ( TYPE_66 ) ( VAR_415 ) , sizeof ( TYPE_67 ) ) ; if ( VAR_416 == VAR_417 ) METHOD_88 ( VAR_418 , ""MemoryAllocationFailed"" ) ; ( TYPE_68 ) METHOD_89 ( VAR_419 , 0 , VAR_420 * sizeof ( TYPE_69 ) ) ; VAR_421 = 0 ; VAR_422 = 0 ; if ( VAR_423 == VAR_424 || VAR_425 == VAR_426 ) { METHOD_90 ( VAR_427 , VAR_428 -> VAR_429 , VAR_430 . VAR_431 , VAR_432 . VAR_433 , VAR_434 , VAR_435 , VAR_436 , & VAR_437 -> VAR_438 , & VAR_439 -> VAR_440 ) ; } if ( VAR_441 == 1 ) VAR_442 = 0 ; do { for ( VAR_443 = 0 ; VAR_444 < ( TYPE_70 ) VAR_445 . VAR_446 ; VAR_447 ++ ) { VAR_448 = METHOD_91 ( VAR_449 , 0 , VAR_450 . VAR_451 - VAR_452 - 1 , VAR_453 -> VAR_454 , 1 , VAR_455 ) ; if ( VAR_456 == ( TYPE_71 * ) VAR_457 ) { if ( VAR_458 ) ( TYPE_72 ) METHOD_92 ( VAR_459 , METHOD_93 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( VAR_460 . VAR_461 - VAR_462 - 1 ) ) ; goto VAR_463 ; } if ( METHOD_94 ( VAR_464 , VAR_465 , ( unsigned TYPE_73 * ) VAR_466 ) != ( TYPE_74 ) VAR_467 ) { if ( VAR_468 ) ( TYPE_75 ) METHOD_95 ( VAR_469 , METHOD_96 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( VAR_470 . VAR_471 - VAR_472 - 1 ) ) ; goto VAR_473 ; } if ( ( VAR_474 == VAR_475 || VAR_476 == VAR_477 ) && ( VAR_478 . VAR_479 & VAR_480 ) ) { METHOD_97 ( ( unsigned TYPE_76 * ) VAR_481 , VAR_482 ) ; if ( METHOD_98 ( VAR_483 , ( TYPE_77 * ) VAR_484 , VAR_485 , VAR_486 [ VAR_487 ] , VAR_488 , VAR_489 ) <= 0 ) { VAR_490 : if ( VAR_491 ) ( TYPE_78 ) METHOD_99 ( VAR_492 , METHOD_100 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( VAR_493 . VAR_494 - VAR_495 - 1 ) ) ; break ; } } else { if ( METHOD_101 ( VAR_496 , ( TYPE_79 * ) VAR_497 , VAR_498 , VAR_499 [ VAR_500 ] , VAR_501 , VAR_502 ) <= 0 ) goto VAR_503 ; if ( VAR_504 <= 1 && ( VAR_505 == VAR_506 || VAR_507 == VAR_508 || VAR_509 == VAR_510 || VAR_511 == VAR_512 ) ) METHOD_102 ( VAR_513 , VAR_514 . VAR_515 ) ; } if ( ! METHOD_103 ( VAR_516 , VAR_517 ) ) { if ( VAR_518 ) ( TYPE_80 ) METHOD_104 ( VAR_519 , METHOD_105 ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( VAR_520 . VAR_521 - VAR_522 - 1 ) ) ; goto VAR_523 ; } } } while ( VAR_524 -- >= 2 ) ; VAR_525 : if ( VAR_526 . VAR_527 & VAR_528 ) { VAR_529 = METHOD_106 ( VAR_530 ) ; VAR_531 = METHOD_107 ( VAR_532 ) ; if ( VAR_533 == VAR_534 || VAR_535 == VAR_536 ) { METHOD_108 ( VAR_537 , VAR_538 -> VAR_539 , VAR_540 . VAR_541 , VAR_542 . VAR_543 , VAR_544 , VAR_545 , VAR_546 , & VAR_547 , & VAR_548 ) ; } if ( VAR_549 == VAR_550 ) for ( VAR_551 = 0 ; VAR_552 < ( TYPE_81 ) VAR_553 . VAR_554 ; VAR_555 ++ ) { METHOD_109 ( VAR_556 , VAR_557 , ( TYPE_82 * ) VAR_558 ) ; METHOD_110 ( ( TYPE_83 * ) VAR_559 , VAR_560 , VAR_561 , VAR_562 , VAR_563 ) ; } if ( VAR_564 == VAR_565 ) for ( VAR_566 = 0 ; VAR_567 < ( TYPE_84 ) VAR_568 . VAR_569 ; VAR_570 ++ ) { METHOD_111 ( VAR_571 , VAR_572 , ( TYPE_85 * ) VAR_573 ) ; METHOD_112 ( ( TYPE_86 * ) VAR_574 , VAR_575 , VAR_576 , VAR_577 , VAR_578 ) ; } } if ( ( VAR_579 . VAR_580 == 8 ) && ( ( VAR_581 . VAR_582 & VAR_583 ) == 0 ) ) VAR_584 -> VAR_585 = VAR_586 ; if ( VAR_587 -> VAR_588 == 1 ) VAR_589 -> VAR_590 = VAR_591 ; if ( VAR_592 == VAR_593 ) VAR_594 = VAR_595 ; VAR_596 = METHOD_113 ( VAR_597 , 90.0 , VAR_598 ) ; if ( VAR_599 != ( TYPE_87 * ) VAR_600 ) { VAR_601 -> VAR_602 . VAR_603 = 0 ; VAR_604 -> VAR_605 . VAR_606 = 0 ; VAR_607 = VAR_608 -> VAR_609 ; VAR_610 -> VAR_611 = VAR_612 -> VAR_613 ; VAR_614 -> VAR_615 = VAR_616 -> VAR_617 ; VAR_618 -> VAR_619 = VAR_620 ; METHOD_114 ( & VAR_621 , VAR_622 ) ; METHOD_115 ( & VAR_623 ) ; } VAR_624 : if ( VAR_625 != VAR_626 ) if ( VAR_627 != VAR_628 ) { METHOD_116 ( & VAR_629 ) ; if ( VAR_630 ) { if ( VAR_631 -> VAR_632 ) { METHOD_117 ( VAR_633 -> VAR_634 ) ; VAR_635 -> VAR_636 = VAR_637 ; ( TYPE_88 ) METHOD_118 ( VAR_638 -> VAR_639 ) ; } } } METHOD_119 ( VAR_640 , VAR_641 ) ; if ( VAR_642 -> VAR_643 == ( TYPE_89 * ) VAR_644 ) break ; VAR_645 = METHOD_120 ( VAR_646 ) ; VAR_647 -> VAR_648 = VAR_649 -> VAR_650 = 0 ; VAR_651 -> VAR_652 = 0 ; METHOD_121 ( VAR_653 ) ; VAR_654 = VAR_655 ; if ( -- VAR_656 > 0 ) { VAR_657 = VAR_658 ; if ( VAR_659 == VAR_660 ) VAR_661 = VAR_662 ; goto VAR_663 ; } if ( VAR_664 != VAR_665 ) if ( VAR_666 != VAR_667 ) { METHOD_122 ( & VAR_668 ) ; if ( VAR_669 ) { if ( VAR_670 -> VAR_671 ) { METHOD_123 ( VAR_672 -> VAR_673 ) ; VAR_674 -> VAR_675 = VAR_676 ; ( TYPE_90 ) METHOD_124 ( VAR_677 -> VAR_678 ) ; } } } } METHOD_125 ( VAR_679 ) ; if ( VAR_680 != ( TYPE_91 * ) VAR_681 ) VAR_682 = METHOD_126 ( VAR_683 ) ; VAR_684 : if ( VAR_685 ) VAR_686 = METHOD_127 ( VAR_687 ) ; METHOD_128 ( VAR_688 ) ; { TYPE_92 * VAR_689 ; TYPE_93 VAR_690 = 0 ; VAR_691 = VAR_692 ; VAR_693 = VAR_694 ; while ( VAR_695 != ( TYPE_94 * ) VAR_696 ) { TYPE_95 * VAR_697 = VAR_698 ; if ( ( VAR_699 -> VAR_700 == 0 ) || ( VAR_701 -> VAR_702 == 0 ) ) { VAR_703 = VAR_704 -> VAR_705 ; METHOD_129 ( & VAR_706 ) ; } else { VAR_707 = VAR_708 ; VAR_709 = VAR_710 -> VAR_711 ; } } for ( VAR_712 = VAR_713 ; VAR_714 != ( TYPE_96 * ) VAR_715 ; VAR_716 = VAR_717 -> VAR_718 ) VAR_719 -> VAR_720 = VAR_721 ++ ; } if ( VAR_722 != VAR_723 ) { if ( VAR_724 -> VAR_725 ) { METHOD_130 ( VAR_726 -> VAR_727 ) ; VAR_728 -> VAR_729 = VAR_730 ; ( TYPE_97 ) METHOD_131 ( VAR_731 -> VAR_732 ) ; } METHOD_132 ( VAR_733 ) ; VAR_734 = VAR_735 ; } if ( VAR_736 ) ( TYPE_98 ) METHOD_133 ( VAR_737 , METHOD_134 ( ) , ""return"" ) ; if ( VAR_738 == VAR_739 ) METHOD_135 ( VAR_740 , ""ImproperImageHeader"" ) ; return ( VAR_741 ) ; }","<S2SV_ModStart> 6 ) ) { VAR_372 : VAR_734 = METHOD_132 ( VAR_734 ) ; <S2SV_ModEnd> METHOD_135 ( VAR_740 <S2SV_ModStart> ""ImproperImageHeader"" ) ; }","CWE-772 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; quantum_info = ( QuantumInfo * ) NULL ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) <S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( MATLAB_HDR . ObjectSize + filepos > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ;  if d ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; }   if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; }"
365,CWE-134 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_StartBug> TYPE_2 * VAR_1 ; <S2SV_EndBug> TYPE_3 VAR_2 = 0 ; VAR_3 = VAR_4 ; while ( * VAR_5 != '\\0' ) if ( * VAR_6 ++ == '%' ) { if ( * VAR_7 == '\\0' ) return 1 ; if ( * VAR_8 == '%' ) VAR_9 ++ ; else if ( * VAR_10 == 's' || * VAR_11 == 'S' ) { VAR_12 = 1 ; VAR_13 ++ ; } else { if ( * VAR_14 == '<S2SV_blank>' ) VAR_15 ++ ; while ( * VAR_16 >= '0' && * VAR_17 <= '9' ) VAR_18 ++ ; if ( * VAR_19 ++ != 'l' ) return 1 ; if ( * VAR_20 == 'u' ) VAR_21 ++ ; else return 1 ; VAR_22 ++ ; } } return ( VAR_23 != 3 ) ; },"<S2SV_ModStart> VAR_4 ) { return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , VAR_4 <S2SV_ModEnd> ) ; }",CWE-134 int bad_format_imginfo ( char * fmt ) { <S2SV_StartBug> char * ptr ; <S2SV_EndBug> int n = 0 ; ptr = fmt ; while ( * ptr != '\\0' ) if ( * ptr ++ == '%' ) { if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 'S' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '<S2SV_blank>' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; },"<S2SV_ModStart> fmt ) { return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> ) ; }"
366,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { if ( VAR_1 -> VAR_2 != VAR_3 ) { return METHOD_1 ( VAR_4 -> VAR_5 ) ; } else { TYPE_1 * VAR_6 = VAR_7 -> VAR_8 ; if ( VAR_9 == VAR_10 ) { <S2SV_StartBug> VAR_11 = METHOD_2 ( VAR_12 -> VAR_13 , VAR_14 ) ; <S2SV_EndBug> if ( VAR_15 == VAR_16 ) { METHOD_3 ( VAR_17 ) ; return 1 ; } else { VAR_18 -> VAR_19 = VAR_20 ; } } return METHOD_4 ( VAR_21 ) == 0 ; } }",<S2SV_ModStart> { VAR_21 = METHOD_5 <S2SV_ModEnd> ( VAR_18 -> <S2SV_ModStart> VAR_18 -> VAR_13 <S2SV_ModEnd> ) ; if,"CWE-125 static int decoding_feof ( struct tok_state * tok ) { if ( tok -> decoding_state != STATE_NORMAL ) { return feof ( tok -> fp ) ; } else { PyObject * buf = tok -> decoding_buffer ; if ( buf == NULL ) { <S2SV_StartBug> buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> if ( buf == NULL ) { error_ret ( tok ) ; return 1 ; } else { tok -> decoding_buffer = buf ; } } return PyObject_Length ( buf ) == 0 ; } }",<S2SV_ModStart> { buf = _PyObject_CallNoArg <S2SV_ModEnd> ( tok -> <S2SV_ModStart> tok -> decoding_readline <S2SV_ModEnd> ) ; if
367,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { struct STRUCT_OR_UNION_1 * VAR_2 = METHOD_1 ( VAR_3 ) ; if ( ( VAR_4 & VAR_5 ) == VAR_6 && ( VAR_7 & VAR_8 ) == VAR_9 ) { TYPE_2 VAR_10 = ( VAR_11 & VAR_12 ) >> 11 ; TYPE_3 VAR_13 = ( VAR_14 & VAR_15 ) >> 16 ; METHOD_2 ( VAR_16 , <S2SV_StartBug> 1 , 0 , VAR_17 , 0 ) ; <S2SV_EndBug> switch ( VAR_18 ) { case 0 : VAR_19 -> VAR_20 [ VAR_21 ] = METHOD_3 ( ) ; return 0 ; case 1 : VAR_22 -> VAR_23 [ VAR_24 ] = METHOD_4 ( VAR_25 . VAR_26 . VAR_27 , VAR_28 . VAR_29 . VAR_30 ) ; return 0 ; case 2 : VAR_31 -> VAR_32 [ VAR_33 ] = METHOD_5 ( ) ; return 0 ; case 3 : switch ( VAR_34 . VAR_35 ) { case VAR_36 : case VAR_37 : VAR_38 -> VAR_39 [ VAR_40 ] = 1 ; break ; default : VAR_41 -> VAR_42 [ VAR_43 ] = 2 ; } return 0 ; case 29 : VAR_44 -> VAR_45 [ VAR_46 ] = VAR_47 -> VAR_48 ; return 0 ; default : return - 1 ; } } return - 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> VAR_45 , 0","CWE-400 static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0"
368,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , const struct STRUCT_OR_UNION_2 * VAR_2 ) { TYPE_1 VAR_3 = - VAR_4 ; unsigned TYPE_2 * VAR_5 = VAR_6 ; TYPE_3 VAR_7 ; TYPE_4 VAR_8 ; <S2SV_StartBug> struct STRUCT_OR_UNION_3 * VAR_9 = VAR_10 ; <S2SV_EndBug> struct STRUCT_OR_UNION_4 * VAR_11 ; VAR_12 = VAR_13 ; VAR_14 = METHOD_1 ( VAR_15 , VAR_16 ) ; if ( VAR_17 == VAR_18 ) { VAR_19 = - VAR_20 ; goto VAR_21 ; } VAR_22 = METHOD_2 ( VAR_23 , VAR_24 , VAR_25 , VAR_26 ) ; if ( VAR_27 < 0 ) goto VAR_28 ; VAR_29 = VAR_30 ; VAR_31 = ( VAR_32 + 3 ) & ~ 3 ; VAR_33 = METHOD_3 ( sizeof ( * VAR_34 ) + VAR_35 , VAR_36 ) ; if ( VAR_37 == VAR_38 ) { VAR_39 = - VAR_40 ; goto VAR_41 ; } <S2SV_StartBug> METHOD_4 ( VAR_42 -> VAR_43 , VAR_44 , VAR_45 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_46 -> VAR_47 = VAR_48 ; <S2SV_EndBug> <S2SV_StartBug> VAR_49 -> VAR_50 = sizeof ( struct STRUCT_OR_UNION_5 ) ; <S2SV_EndBug> METHOD_5 ( VAR_51 ) ; VAR_52 = VAR_53 ; VAR_54 = METHOD_6 ( VAR_55 ) ; VAR_56 = METHOD_7 ( & VAR_57 -> VAR_58 , VAR_59 ) ; <S2SV_StartBug> METHOD_8 ( VAR_60 ) ; <S2SV_EndBug> return 0 ; VAR_61 : METHOD_9 ( VAR_62 ) ; METHOD_10 ( VAR_63 ) ; return VAR_64 ; }","<S2SV_ModStart> VAR_48 ; struct STRUCT_OR_UNION_6 <S2SV_ModEnd> * VAR_63 = <S2SV_ModStart> ( VAR_63 -> VAR_63 . <S2SV_ModStart> ; VAR_63 -> VAR_63 . <S2SV_ModStart> ; VAR_63 -> VAR_63 . <S2SV_ModStart> VAR_63 ) ; if ( VAR_63 ) METHOD_11 ( & VAR_63 -> VAR_65 , VAR_66 <S2SV_ModEnd> ) ; return","CWE-362 int cipso_v4_req_setattr ( struct request_sock * req , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - EPERM ; unsigned char * buf = NULL ; u32 buf_len ; u32 opt_len ; <S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> struct inet_request_sock * req_inet ; buf_len = CIPSO_V4_OPT_LEN_MAX ; buf = kmalloc ( buf_len , GFP_ATOMIC ) ; if ( buf == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto req_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ; if ( opt == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> kfree ( buf ) ; buf = NULL ; req_inet = inet_rsk ( req ) ; opt = xchg ( & req_inet -> opt , opt ) ; <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug> return 0 ; req_setattr_failure : kfree ( buf ) ; kfree ( opt ) ; return ret_val ; }","<S2SV_ModStart> opt_len ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> opt ) ; if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return"
369,"CWE-78 TYPE_0 TYPE_1 * METHOD_0 ( const TYPE_2 * VAR_0 , TYPE_3 * VAR_1 , TYPE_4 * VAR_2 ) { <S2SV_StartBug> TYPE_5 * VAR_3 = METHOD_1 ( ""R2_CURL"" ) ; <S2SV_EndBug> if ( VAR_4 && * VAR_5 ) { TYPE_6 * VAR_6 = METHOD_2 ( VAR_7 ) ; TYPE_7 * VAR_8 = METHOD_3 ( ""curl<S2SV_blank>\'%s\'"" , VAR_9 ) ; METHOD_4 ( VAR_10 ) ; if ( VAR_11 ) { if ( VAR_12 ) { * VAR_13 = 200 ; } if ( VAR_14 ) { * VAR_15 = METHOD_5 ( VAR_16 ) ; } <S2SV_StartBug> } <S2SV_EndBug> METHOD_6 ( VAR_17 ) ; return VAR_18 ; } METHOD_7 ( VAR_19 ) ; VAR_20 * VAR_21 ; TYPE_8 VAR_22 = METHOD_8 ( VAR_23 , ""https://"" ) ; TYPE_9 * VAR_24 , * VAR_25 , * VAR_26 , * VAR_27 = ""80"" ; TYPE_10 * VAR_28 = METHOD_9 ( VAR_29 ) ; if ( ! VAR_30 ) { return VAR_31 ; } if ( VAR_32 ) { * VAR_33 = 0 ; } if ( VAR_34 ) { * VAR_35 = 0 ; } VAR_36 = METHOD_10 ( VAR_37 , ""://"" ) ; if ( ! VAR_38 ) { METHOD_11 ( VAR_39 ) ; METHOD_12 ( ""r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI"" ) ; return VAR_40 ; } VAR_41 += 3 ; VAR_42 = METHOD_13 ( VAR_43 , ':' ) ; if ( ! VAR_44 ) { VAR_45 = VAR_46 ? ""443"" : ""80"" ; VAR_47 = VAR_48 ; } else { * VAR_49 ++ = 0 ; VAR_50 = VAR_51 ; } VAR_52 = METHOD_14 ( VAR_53 , '/' ) ; if ( ! VAR_54 ) { VAR_55 = """" ; } else { * VAR_56 ++ = 0 ; } VAR_57 = METHOD_15 ( VAR_58 ) ; if ( ! VAR_59 ) { METHOD_16 ( ""r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; METHOD_17 ( VAR_60 ) ; return VAR_61 ; } if ( METHOD_18 ( VAR_62 , VAR_63 , VAR_64 , 0 ) ) { r_socket_printf ( VAR_65 , ""GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s:%s\\r\\n"" ""\\r\\n"" , VAR_66 , VAR_67 , VAR_68 ) ; VAR_69 = METHOD_19 ( VAR_70 , VAR_71 , VAR_72 ) ; } else { METHOD_20 ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , VAR_73 , VAR_74 ) ; VAR_75 = VAR_76 ; } METHOD_21 ( VAR_77 ) ; METHOD_22 ( VAR_78 ) ; return VAR_79 ; }","<S2SV_ModStart> VAR_72 ) { return METHOD_23 ( VAR_29 , VAR_71 , VAR_72 , VAR_80 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>","CWE-78 R_API char * r_socket_http_get ( const char * url , int * code , int * rlen ) { <S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> if ( curl_env && * curl_env ) { char * encoded_url = r_str_escape ( url ) ; char * res = r_sys_cmd_strf ( ""curl<S2SV_blank>\'%s\'"" , encoded_url ) ; free ( encoded_url ) ; if ( res ) { if ( code ) { * code = 200 ; } if ( rlen ) { * rlen = strlen ( res ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( curl_env ) ; return res ; } free ( curl_env ) ; RSocket * s ; int ssl = r_str_startswith ( url , ""https://"" ) ; char * response , * host , * path , * port = ""80"" ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } if ( code ) { * code = 0 ; } if ( rlen ) { * rlen = 0 ; } host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; eprintf ( ""r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; port = strchr ( host , ':' ) ; if ( ! port ) { port = ssl ? ""443"" : ""80"" ; path = host ; } else { * port ++ = 0 ; path = port ; } path = strchr ( path , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { eprintf ( ""r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( r_socket_connect_tcp ( s , host , port , 0 ) ) { r_socket_printf ( s , ""GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s:%s\\r\\n"" ""\\r\\n"" , path , host , port ) ; response = r_socket_http_answer ( s , code , rlen ) ; } else { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; response = NULL ; } free ( uri ) ; r_socket_free ( s ) ; return response ; }","<S2SV_ModStart> rlen ) { return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
370,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = METHOD_1 ( VAR_2 ) ; struct STRUCT_OR_UNION_2 * VAR_3 = METHOD_2 ( VAR_4 ) ; struct STRUCT_OR_UNION_3 * VAR_5 = METHOD_3 ( VAR_6 ) ; unsigned TYPE_1 VAR_7 ; unsigned TYPE_2 VAR_8 ; unsigned TYPE_3 VAR_9 ; if ( VAR_10 ) { VAR_11 = METHOD_4 ( VAR_12 , VAR_13 , VAR_14 -> VAR_15 ) ; VAR_16 = METHOD_5 ( VAR_17 , VAR_18 , VAR_19 -> VAR_20 ) ; VAR_21 = ( VAR_22 - VAR_23 ) - METHOD_6 ( & VAR_24 -> VAR_25 , VAR_26 , VAR_27 ) ; <S2SV_StartBug> METHOD_7 ( & VAR_28 -> VAR_29 , VAR_30 ) ; <S2SV_EndBug> if ( VAR_31 ) { METHOD_8 ( VAR_32 , - VAR_33 ) ; METHOD_9 ( VAR_34 , VAR_35 ) ; } } }",<S2SV_ModStart> VAR_27 ) ; METHOD_10 ( VAR_19 <S2SV_ModEnd> ) ; if,"CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }",<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
371,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_EndBug> TYPE_1 VAR_1 [ 32 ] ; TYPE_2 VAR_2 = 0 ; TYPE_3 VAR_3 ; VAR_4 . VAR_5 = sizeof ( VAR_6 ) ; if ( METHOD_1 ( VAR_7 , 1 , 32 , VAR_8 -> VAR_9 ) == 32 ) { TYPE_4 VAR_10 ; if ( METHOD_2 ( VAR_11 ) < 256 * 1024 * 1024 ) { for ( VAR_12 = 0 ; VAR_13 < METHOD_3 ( ) ; ++ VAR_14 ) { const TYPE_5 * const VAR_15 = METHOD_4 ( VAR_16 ) ; <S2SV_StartBug> if ( ! METHOD_5 ( VAR_17 -> METHOD_6 ( ) , <S2SV_EndBug> VAR_18 + 4 , 32 - 4 , & VAR_19 ) ) { VAR_20 = 1 ; VAR_21 -> VAR_22 = VAR_23 -> VAR_24 ; VAR_25 -> VAR_26 = VAR_27 . VAR_28 ; VAR_29 -> VAR_30 = VAR_31 . VAR_32 ; VAR_33 -> VAR_34 . VAR_35 = 30 ; VAR_36 -> VAR_37 . VAR_38 = 1 ; break ; } } } } METHOD_7 ( VAR_39 -> VAR_40 ) ; return VAR_41 ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ( VAR_23 -> METHOD_8 <S2SV_ModEnd> ( ) ,","CWE-119 <S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> uint8_t buf [ 32 ] ; int is_raw = 0 ; vpx_codec_stream_info_t si ; si . sz = sizeof ( si ) ; if ( fread ( buf , 1 , 32 , input -> file ) == 32 ) { int i ; if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> buf + 4 , 32 - 4 , & si ) ) { is_raw = 1 ; input -> fourcc = decoder -> fourcc ; input -> width = si . w ; input -> height = si . h ; input -> framerate . numerator = 30 ; input -> framerate . denominator = 1 ; break ; } } } } rewind ( input -> file ) ; return is_raw ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ,"
372,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , signed TYPE_1 * VAR_1 , unsigned TYPE_2 VAR_2 ) { VAR_3 -> VAR_4 = VAR_5 ; <S2SV_StartBug> METHOD_1 ( VAR_6 -> VAR_7 , VAR_8 , sizeof ( VAR_9 -> VAR_10 ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> = VAR_5 ; METHOD_2 <S2SV_ModEnd> ( VAR_9 ->,"CWE-119 void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( seg ->
373,"CWE-190 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { switch ( VAR_3 -> VAR_4 ) { case VAR_5 : return 0 ; case VAR_6 : case VAR_7 : <S2SV_StartBug> return ( ( VAR_8 < VAR_9 -> VAR_10 ) || <S2SV_EndBug> <S2SV_StartBug> ( ( VAR_11 + VAR_12 ) > ( VAR_13 -> VAR_14 + VAR_15 -> VAR_16 ) ) ) ? <S2SV_EndBug> - VAR_17 : 0 ; default : return - VAR_18 ; } }",<S2SV_ModStart> case VAR_7 : if <S2SV_ModEnd> ( VAR_14 < <S2SV_ModStart> VAR_15 -> VAR_14 || VAR_16 > VAR_15 -> VAR_16 || VAR_14 > <S2SV_ModEnd> VAR_15 -> VAR_14 <S2SV_ModStart> VAR_15 -> VAR_16 - VAR_16 ) return - VAR_18 ; return <S2SV_ModEnd> 0 ; default,"CWE-190 int mem_check_range ( struct rxe_mem * mem , u64 iova , size_t length ) { switch ( mem -> type ) { case RXE_MEM_TYPE_DMA : return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : <S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> - EFAULT : 0 ; default : return - EFAULT ; } }",<S2SV_ModStart> case RXE_MEM_TYPE_FMR : if <S2SV_ModEnd> ( iova < <S2SV_ModStart> mem -> iova || length > mem -> length || iova > <S2SV_ModEnd> mem -> iova <S2SV_ModStart> mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default
374,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * * VAR_3 ) { TYPE_5 * VAR_4 = VAR_5 -> VAR_6 ; TYPE_6 VAR_7 ; if ( VAR_8 -> VAR_9 == 1 ) VAR_10 -> VAR_11 = 0 ; else VAR_12 -> VAR_13 = 1 ; <S2SV_StartBug> VAR_14 -> VAR_15 = - 1 ; <S2SV_EndBug> VAR_16 -> VAR_17 = METHOD_1 ( VAR_18 ) ; if ( ! VAR_19 -> VAR_20 ) return METHOD_2 ( VAR_21 ) ; if ( VAR_22 ) METHOD_3 ( & VAR_23 -> VAR_24 , * VAR_25 , 0 ) ; if ( VAR_26 -> VAR_27 ) { TYPE_7 VAR_28 = METHOD_4 ( VAR_29 -> VAR_30 ) ; if ( VAR_31 < 2 || METHOD_5 ( ""\\r\\n"" , VAR_32 -> VAR_33 + VAR_34 - 2 ) ) { METHOD_6 ( VAR_35 , VAR_36 , ""No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n"" ) ; VAR_37 = METHOD_7 ( & VAR_38 -> VAR_39 , VAR_40 + 3 ) ; if ( VAR_41 < 0 ) return VAR_42 ; VAR_43 -> VAR_44 [ VAR_45 ] = '\\r' ; VAR_46 -> VAR_47 [ VAR_48 + 1 ] = '\\n' ; VAR_49 -> VAR_50 [ VAR_51 + 2 ] = '\\0' ; } } if ( VAR_52 -> VAR_53 ) { return METHOD_8 ( VAR_54 , VAR_55 , VAR_56 , VAR_57 ) ; } VAR_58 = METHOD_9 ( VAR_59 , VAR_60 ) ; if ( VAR_61 < 0 ) METHOD_10 ( & VAR_62 -> VAR_63 ) ; return VAR_64 ; }",<S2SV_ModStart> -> VAR_15 = VAR_65 <S2SV_ModEnd> ; VAR_62 ->,"CWE-119 static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( ""\\r\\n"" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , ""No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n"" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }",<S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
375,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { <S2SV_EndBug> TYPE_2 VAR_2 , VAR_3 , VAR_4 ; METHOD_1 ( VAR_5 -> VAR_6 , & VAR_7 , & VAR_8 ) ; VAR_9 = VAR_10 -> VAR_11 - VAR_12 ; while ( VAR_13 -- ) <S2SV_StartBug> METHOD_2 ( VAR_14 , 1 ) ; <S2SV_EndBug> if ( VAR_15 -> VAR_16 < VAR_17 ) <S2SV_StartBug> METHOD_3 ( VAR_18 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_4 ( VAR_19 , VAR_20 -> VAR_21 != 0 ) ; <S2SV_EndBug> if ( VAR_22 -> VAR_23 != 0 ) <S2SV_StartBug> METHOD_5 ( VAR_24 , VAR_25 -> VAR_26 != 1 ) ; <S2SV_EndBug> }","<S2SV_ModStart> TYPE_0 METHOD_0 ( const TYPE_1 * const <S2SV_ModEnd> VAR_25 , struct <S2SV_ModStart> VAR_25 , struct vpx_write_bit_buffer <S2SV_ModEnd> * VAR_24 ) <S2SV_ModStart> VAR_13 -- ) METHOD_6 <S2SV_ModEnd> ( VAR_24 , <S2SV_ModStart> < VAR_17 ) METHOD_6 <S2SV_ModEnd> ( VAR_24 , <S2SV_ModStart> 0 ) ; METHOD_6 <S2SV_ModEnd> ( VAR_24 , <S2SV_ModStart> != 0 ) METHOD_6 <S2SV_ModEnd> ( VAR_24 ,","CWE-119 <S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> if ( cm -> log2_tile_cols < max_log2_tile_cols ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> if ( cm -> log2_tile_rows != 0 ) <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> }","<S2SV_ModStart> void write_tile_info ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> ones -- ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> < max_log2_tile_cols ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> != 0 ) vpx_wb_write_bit <S2SV_ModEnd> ( wb ,"
376,"CWE-295 TYPE_0 METHOD_0 ( ) { unsigned VAR_0 = 0 ; VAR_1 * VAR_2 ; METHOD_1 ( VAR_3 [ VAR_4 ] ) ; <S2SV_StartBug> METHOD_2 ( & VAR_5 , & VAR_6 , sizeof ( VAR_7 ) ) ; <S2SV_EndBug> for ( VAR_8 = VAR_9 . VAR_10 ; VAR_11 ; VAR_12 = VAR_13 -> VAR_14 ) VAR_15 -> VAR_16 = VAR_17 ++ ; METHOD_3 ( & VAR_18 , & VAR_19 , sizeof ( VAR_20 ) ) ; <S2SV_StartBug> VAR_21 = VAR_22 ; <S2SV_EndBug> METHOD_4 ( VAR_23 [ VAR_24 ] ) ; }","<S2SV_ModStart> , & VAR_6 , sizeof ( VAR_7 ) ) ; METHOD_5 ( & VAR_6 , 0 <S2SV_ModStart> ) ) ; METHOD_5 ( & VAR_19 , 0 , sizeof ( VAR_20 ) ) ;","CWE-295 void options_apply ( ) { unsigned num = 0 ; SERVICE_OPTIONS * section ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_StartBug> memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_EndBug> for ( section = new_service_options . next ; section ; section = section -> next ) section -> section_number = num ++ ; memcpy ( & service_options , & new_service_options , sizeof ( SERVICE_OPTIONS ) ) ; <S2SV_StartBug> number_of_sections = num ; <S2SV_EndBug> CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }","<S2SV_ModStart> , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_global_options , 0 <S2SV_ModStart> ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ;"
377,"CWE-415 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * * VAR_2 ) { VAR_3 * VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 * VAR_6 = VAR_7 ; TYPE_6 VAR_8 [ VAR_9 ] , VAR_10 [ VAR_11 ] , * VAR_12 = VAR_13 ; unsigned TYPE_7 VAR_14 ; TYPE_8 VAR_15 , VAR_16 ; METHOD_1 ( VAR_17 != VAR_18 && VAR_19 != VAR_20 ) ; VAR_21 = VAR_22 -> VAR_23 ; METHOD_2 ( VAR_24 , VAR_25 -> VAR_26 , VAR_27 -> VAR_28 ) ; VAR_29 = VAR_30 -> VAR_31 ; METHOD_3 ( VAR_32 , & VAR_33 , VAR_34 , 0xA4 , 0 , 0x04 ) ; switch ( VAR_35 -> VAR_36 ) { case VAR_37 : if ( VAR_38 != 2 ) return VAR_39 ; case VAR_40 : VAR_41 . VAR_42 = 9 ; break ; case VAR_43 : VAR_44 . VAR_45 = 4 ; break ; case VAR_46 : VAR_47 . VAR_48 = 8 ; if ( VAR_49 >= 2 && METHOD_4 ( VAR_50 , ""\\x3F\\x00"" , 2 ) == 0 ) VAR_51 += 2 , VAR_52 -= 2 ; if ( VAR_53 == 0 ) VAR_54 . VAR_55 = 0 ; break ; case VAR_56 : VAR_57 . VAR_58 = 3 ; VAR_59 = 0 ; break ; default : METHOD_5 ( VAR_60 , VAR_61 , VAR_62 ) ; } if ( VAR_63 == 0 ) VAR_64 . VAR_65 = VAR_66 ; VAR_67 . VAR_68 = VAR_69 ; VAR_70 . VAR_71 = VAR_72 ; VAR_73 . VAR_74 = VAR_75 ; if ( VAR_76 != VAR_77 ) { VAR_78 . VAR_79 = VAR_80 ; VAR_81 . VAR_82 = sizeof ( VAR_83 ) ; VAR_84 . VAR_85 = 256 ; } else { VAR_86 . VAR_87 = 0 ; VAR_88 . VAR_89 = 0 ; VAR_90 . VAR_91 = 0x0C ; VAR_92 . VAR_93 = ( VAR_94 == 0 ) ? VAR_95 : VAR_96 ; } VAR_97 = METHOD_6 ( VAR_98 , & VAR_99 ) ; METHOD_7 ( VAR_100 , VAR_101 , VAR_102 , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; VAR_103 = METHOD_8 ( VAR_104 , VAR_105 . VAR_106 , VAR_107 . VAR_108 ) ; if ( VAR_109 || VAR_110 == VAR_111 ) METHOD_9 ( VAR_112 , VAR_113 , VAR_114 ) ; if ( VAR_115 . VAR_116 < 1 || VAR_117 . VAR_118 [ 0 ] != 0x62 ) { METHOD_10 ( VAR_119 , VAR_120 , ""received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n"" , VAR_121 . VAR_122 [ 0 ] ) ; METHOD_11 ( VAR_123 , VAR_124 , VAR_125 ) ; } VAR_126 = METHOD_12 ( ) ; if ( VAR_127 == VAR_128 ) METHOD_13 ( VAR_129 , VAR_130 , VAR_131 ) ; * VAR_132 = VAR_133 ; VAR_134 -> VAR_135 = * VAR_136 ; for ( VAR_137 = 2 ; VAR_138 + 1 < VAR_139 . VAR_140 && VAR_141 + 1 + VAR_142 . VAR_143 [ VAR_144 + 1 ] < VAR_145 . VAR_146 ; VAR_147 += 2 + VAR_148 . VAR_149 [ VAR_150 + 1 ] ) { <S2SV_StartBug> TYPE_9 VAR_151 , VAR_152 = VAR_153 . VAR_154 [ VAR_155 + 1 ] ; <S2SV_EndBug> unsigned TYPE_10 VAR_156 = VAR_157 . VAR_158 [ VAR_159 ] , * VAR_160 = VAR_161 . VAR_162 + VAR_163 + 2 ; switch ( VAR_164 ) { case 0x80 : case 0x81 : VAR_165 -> VAR_166 = 0 ; for ( VAR_167 = 0 ; VAR_168 < VAR_169 ; ++ VAR_170 ) VAR_171 -> VAR_172 = ( VAR_173 -> VAR_174 << 8 ) | VAR_175 [ VAR_176 ] ; break ; case 0x82 : VAR_177 -> VAR_178 = ( VAR_179 [ 0 ] & 0x40 ) ? 1 : 0 ; VAR_180 -> VAR_181 = VAR_182 [ 0 ] & 7 ; switch ( ( VAR_183 [ 0 ] >> 3 ) & 7 ) { case 0 : VAR_184 -> VAR_185 = VAR_186 ; break ; case 7 : VAR_187 -> VAR_188 = VAR_189 ; break ; default : METHOD_14 ( VAR_190 , VAR_191 , ""invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n"" , VAR_192 [ 0 ] ) ; METHOD_15 ( VAR_193 , VAR_194 , VAR_195 ) ; } break ; case 0x83 : VAR_196 -> VAR_197 = ( VAR_198 [ 0 ] << 8 ) | VAR_199 [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> METHOD_16 ( VAR_200 -> VAR_201 , VAR_202 , VAR_203 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_204 -> VAR_205 = VAR_206 ; <S2SV_EndBug> break ; case 0x86 : METHOD_17 ( VAR_207 , VAR_208 , VAR_209 ) ; break ; default : if ( VAR_210 > 0 ) METHOD_18 ( VAR_211 , VAR_212 , VAR_213 ) ; } } VAR_214 -> VAR_215 = VAR_216 ; METHOD_19 ( VAR_217 , VAR_218 , VAR_219 -> VAR_220 , VAR_221 -> VAR_222 ) ; return 0 ; }","<S2SV_ModStart> ] ) { TYPE_11 <S2SV_ModEnd> VAR_176 , VAR_213 <S2SV_ModStart> case 0x84 : VAR_221 -> VAR_205 = METHOD_20 ( sizeof VAR_221 -> VAR_201 , VAR_213 ) ; <S2SV_ModStart> , VAR_212 , <S2SV_ModEnd> VAR_221 -> VAR_205 <S2SV_ModStart> VAR_221 -> VAR_205 ) <S2SV_ModEnd> ; break ;","CWE-415 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , ""\\x3F\\x00"" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , ""received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n"" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , ""invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n"" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }","<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;"
378,"CWE-416 static TYPE_0 * METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { struct STRUCT_OR_UNION_3 * VAR_1 = VAR_2 ; struct STRUCT_OR_UNION_4 VAR_3 = { . VAR_4 = """" , } ; struct STRUCT_OR_UNION_5 * STRUCT_OR_UNION_6 ; struct STRUCT_OR_UNION_7 * STRUCT_OR_UNION_8 ; unsigned TYPE_1 VAR_5 ; METHOD_1 ( ) ; VAR_6 = METHOD_2 ( & VAR_7 -> VAR_8 ) ; if ( ! VAR_9 ) goto VAR_10 ; STRUCT_OR_UNION_9 = ( struct STRUCT_OR_UNION_10 * ) VAR_11 ; if ( ! METHOD_3 ( & STRUCT_OR_UNION_11 -> VAR_12 ) ) goto VAR_13 ; METHOD_4 ( ) ; VAR_14 -> VAR_15 -> METHOD_5 ( VAR_16 ) ; VAR_17 : STRUCT_OR_UNION_12 -> VAR_18 = METHOD_6 ( VAR_19 ) ; STRUCT_OR_UNION_13 -> STRUCT_OR_UNION_14 = STRUCT_OR_UNION_15 ; return VAR_20 ; VAR_21 : METHOD_7 ( ) ; STRUCT_OR_UNION_16 = METHOD_8 ( VAR_22 -> VAR_23 ) ; if ( ! STRUCT_OR_UNION_17 ) { VAR_24 -> VAR_25 -> METHOD_9 ( VAR_26 ) ; return METHOD_10 ( - VAR_27 ) ; } STRUCT_OR_UNION_18 -> VAR_28 = VAR_29 -> VAR_30 ; STRUCT_OR_UNION_19 -> VAR_31 = STRUCT_OR_UNION_20 -> VAR_32 = STRUCT_OR_UNION_21 -> VAR_33 = METHOD_11 ( STRUCT_OR_UNION_22 ) ; STRUCT_OR_UNION_23 -> VAR_34 |= VAR_35 ; STRUCT_OR_UNION_24 -> VAR_36 = VAR_37 | VAR_38 ; STRUCT_OR_UNION_25 -> VAR_39 = & VAR_40 ; STRUCT_OR_UNION_26 -> VAR_41 = VAR_42 ; STRUCT_OR_UNION_27 = METHOD_12 ( VAR_43 -> VAR_44 , & VAR_45 ) ; if ( ! STRUCT_OR_UNION_28 ) { METHOD_13 ( STRUCT_OR_UNION_29 ) ; return METHOD_14 ( - VAR_46 ) ; } METHOD_15 ( STRUCT_OR_UNION_30 , STRUCT_OR_UNION_31 ) ; <S2SV_StartBug> STRUCT_OR_UNION_32 -> VAR_47 = ( TYPE_2 * ) VAR_48 -> VAR_49 ; <S2SV_EndBug> VAR_50 = METHOD_16 ( & VAR_51 -> VAR_52 , 0 , ( unsigned TYPE_3 ) STRUCT_OR_UNION_33 ) ; if ( VAR_53 ) { METHOD_17 ( STRUCT_OR_UNION_34 ) ; METHOD_18 ( STRUCT_OR_UNION_35 ) ; METHOD_19 ( ) ; return METHOD_20 ( - VAR_54 ) ; } goto VAR_55 ; }",<S2SV_ModStart> ; STRUCT_OR_UNION_35 -> VAR_56 |= VAR_57 ; STRUCT_OR_UNION_35 ->,"CWE-416 static void * __ns_get_path ( struct path * path , struct ns_common * ns ) { struct vfsmount * mnt = nsfs_mnt ; struct qstr qname = { . name = """" , } ; struct dentry * dentry ; struct inode * inode ; unsigned long d ; rcu_read_lock ( ) ; d = atomic_long_read ( & ns -> stashed ) ; if ( ! d ) goto slow ; dentry = ( struct dentry * ) d ; if ( ! lockref_get_not_dead ( & dentry -> d_lockref ) ) goto slow ; rcu_read_unlock ( ) ; ns -> ops -> put ( ns ) ; got_it : path -> mnt = mntget ( mnt ) ; path -> dentry = dentry ; return NULL ; slow : rcu_read_unlock ( ) ; inode = new_inode_pseudo ( mnt -> mnt_sb ) ; if ( ! inode ) { ns -> ops -> put ( ns ) ; return ERR_PTR ( - ENOMEM ) ; } inode -> i_ino = ns -> inum ; inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; inode -> i_flags |= S_IMMUTABLE ; inode -> i_mode = S_IFREG | S_IRUGO ; inode -> i_fop = & ns_file_operations ; inode -> i_private = ns ; dentry = d_alloc_pseudo ( mnt -> mnt_sb , & qname ) ; if ( ! dentry ) { iput ( inode ) ; return ERR_PTR ( - ENOMEM ) ; } d_instantiate ( dentry , inode ) ; <S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ; if ( d ) { d_delete ( dentry ) ; dput ( dentry ) ; cpu_relax ( ) ; return ERR_PTR ( - EAGAIN ) ; } goto got_it ; }",<S2SV_ModStart> ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
379,"CWE-772 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 = VAR_3 ; <S2SV_EndBug> TYPE_4 VAR_4 = 0 , VAR_5 , VAR_6 , VAR_7 ; TYPE_5 VAR_8 ; if ( VAR_9 == VAR_10 ) return VAR_11 ; VAR_12 = METHOD_1 ( VAR_13 ) ; while ( ( VAR_14 > 0 ) && METHOD_2 ( VAR_15 [ VAR_16 - 1 ] ) ) VAR_17 -- ; VAR_18 = VAR_19 + 1 ; if ( VAR_20 ) <S2SV_StartBug> VAR_21 = ( TYPE_6 ) METHOD_3 ( VAR_22 , VAR_23 * sizeof ( VAR_24 ) ) ; <S2SV_EndBug> if ( VAR_25 == VAR_26 ) { METHOD_4 ( VAR_27 , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; METHOD_5 ( - 2 ) ; } METHOD_6 ( VAR_28 , 0 , VAR_29 * sizeof ( VAR_30 ) ) ; for ( VAR_31 = 0 ; VAR_32 < VAR_33 ; VAR_34 ++ ) { switch ( VAR_35 [ VAR_36 ] ) { case '<' : VAR_37 = VAR_38 ? 13 : 4 ; VAR_39 += VAR_40 - 1 ; <S2SV_StartBug> VAR_41 = ( TYPE_7 ) METHOD_7 ( VAR_42 , VAR_43 * sizeof ( VAR_44 ) ) ; <S2SV_EndBug> if ( VAR_45 == VAR_46 ) { METHOD_8 ( VAR_47 , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; METHOD_9 ( - 3 ) ; } if ( VAR_48 ) METHOD_10 ( & VAR_49 [ VAR_50 ] , ""<replaceable>"" , VAR_51 ) ; else METHOD_11 ( & VAR_52 [ VAR_53 ] , ""&lt;"" , VAR_54 ) ; VAR_55 += VAR_56 ; break ; case '>' : VAR_57 = VAR_58 ? 14 : 4 ; VAR_59 += VAR_60 - 1 ; <S2SV_StartBug> VAR_61 = ( TYPE_8 ) METHOD_12 ( VAR_62 , VAR_63 * sizeof ( VAR_64 ) ) ; <S2SV_EndBug> if ( VAR_65 == VAR_66 ) { METHOD_13 ( VAR_67 , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; METHOD_14 ( - 4 ) ; } if ( VAR_68 ) METHOD_15 ( & VAR_69 [ VAR_70 ] , ""</replaceable>"" , VAR_71 ) ; else METHOD_16 ( & VAR_72 [ VAR_73 ] , ""&lt;"" , VAR_74 ) ; VAR_75 += VAR_76 ; break ; case '\\'' : VAR_77 += 5 ; <S2SV_StartBug> VAR_78 = ( TYPE_9 ) METHOD_17 ( VAR_79 , VAR_80 * sizeof ( VAR_81 ) ) ; <S2SV_EndBug> if ( VAR_82 == VAR_83 ) { METHOD_18 ( VAR_84 , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; METHOD_19 ( - 5 ) ; } VAR_85 [ VAR_86 ++ ] = '&' ; VAR_87 [ VAR_88 ++ ] = 'a' ; VAR_89 [ VAR_90 ++ ] = 'p' ; VAR_91 [ VAR_92 ++ ] = 'o' ; VAR_93 [ VAR_94 ++ ] = 's' ; VAR_95 [ VAR_96 ++ ] = ';' ; break ; case \'""\' : VAR_97 += 5 ; <S2SV_StartBug> VAR_98 = ( TYPE_10 ) METHOD_20 ( VAR_99 , VAR_100 * sizeof ( VAR_101 ) ) ; <S2SV_EndBug> if ( VAR_102 == VAR_103 ) { METHOD_21 ( VAR_104 , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; METHOD_22 ( - 6 ) ; } VAR_105 [ VAR_106 ++ ] = '&' ; VAR_107 [ VAR_108 ++ ] = 'q' ; VAR_109 [ VAR_110 ++ ] = 'u' ; VAR_111 [ VAR_112 ++ ] = 'o' ; VAR_113 [ VAR_114 ++ ] = 't' ; VAR_115 [ VAR_116 ++ ] = ';' ; break ; case '&' : VAR_117 += 4 ; <S2SV_StartBug> VAR_118 = ( TYPE_11 ) METHOD_23 ( VAR_119 , VAR_120 * sizeof ( VAR_121 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_122 == VAR_123 ) <S2SV_EndBug> { METHOD_24 ( VAR_124 , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; METHOD_25 ( - 7 ) ; } VAR_125 [ VAR_126 ++ ] = '&' ; VAR_127 [ VAR_128 ++ ] = 'a' ; VAR_129 [ VAR_130 ++ ] = 'm' ; VAR_131 [ VAR_132 ++ ] = 'p' ; VAR_133 [ VAR_134 ++ ] = ';' ; break ; default : VAR_135 [ VAR_136 ++ ] = VAR_137 [ VAR_138 ] ; break ; } VAR_139 [ VAR_140 - 1 ] = '\\0' ; } return VAR_141 ; }",<S2SV_ModStart> { TYPE_11 VAR_141 = VAR_122 ; TYPE_11 VAR_142 <S2SV_ModStart> ( VAR_33 ) { VAR_142 <S2SV_ModEnd> = ( TYPE_11 <S2SV_ModStart> ) ) ; if ( ! VAR_142 ) METHOD_26 ( VAR_141 ) ; VAR_141 = VAR_142 ; } <S2SV_ModStart> - 1 ; VAR_142 <S2SV_ModEnd> = ( TYPE_11 <S2SV_ModStart> VAR_121 ) ) ; if ( ! VAR_142 ) METHOD_26 ( VAR_141 ) ; VAR_141 = VAR_142 <S2SV_ModStart> - 1 ; VAR_142 <S2SV_ModEnd> = ( TYPE_11 <S2SV_ModStart> VAR_121 ) ) ; if ( ! VAR_142 ) METHOD_26 ( VAR_141 ) ; VAR_141 = VAR_142 <S2SV_ModStart> += 5 ; VAR_142 <S2SV_ModEnd> = ( TYPE_11 <S2SV_ModStart> VAR_121 ) ) ; if ( ! VAR_142 ) METHOD_26 ( VAR_141 ) ; VAR_141 = VAR_142 <S2SV_ModStart> += 5 ; VAR_142 <S2SV_ModEnd> = ( TYPE_11 <S2SV_ModStart> VAR_121 ) ) ; if ( ! VAR_142 ) METHOD_26 ( VAR_141 ) ; VAR_141 = VAR_142 <S2SV_ModStart> += 4 ; VAR_142 <S2SV_ModEnd> = ( TYPE_11 <S2SV_ModStart> ; if ( ! VAR_142 ) METHOD_26 ( VAR_141 ) ; VAR_141 = VAR_142 ; if (,"CWE-772 LPSTR tr_esc_str ( LPCSTR arg , bool format ) { <S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> size_t cs = 0 , x , ds , len ; size_t s ; if ( NULL == arg ) return NULL ; s = strlen ( arg ) ; while ( ( s > 0 ) && isspace ( arg [ s - 1 ] ) ) s -- ; ds = s + 1 ; if ( s ) <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 2 ) ; } memset ( tmp , 0 , ds * sizeof ( CHAR ) ) ; for ( x = 0 ; x < s ; x ++ ) { switch ( arg [ x ] ) { case '<' : len = format ? 13 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 3 ) ; } if ( format ) strncpy ( & tmp [ cs ] , ""<replaceable>"" , len ) ; else strncpy ( & tmp [ cs ] , ""&lt;"" , len ) ; cs += len ; break ; case '>' : len = format ? 14 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 4 ) ; } if ( format ) strncpy ( & tmp [ cs ] , ""</replaceable>"" , len ) ; else strncpy ( & tmp [ cs ] , ""&lt;"" , len ) ; cs += len ; break ; case '\\'' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 5 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 's' ; tmp [ cs ++ ] = ';' ; break ; case \'""\' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 6 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'q' ; tmp [ cs ++ ] = 'u' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 't' ; tmp [ cs ++ ] = ';' ; break ; case '&' : ds += 4 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 7 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'm' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = ';' ; break ; default : tmp [ cs ++ ] = arg [ x ] ; break ; } tmp [ ds - 1 ] = '\\0' ; } return tmp ; }",<S2SV_ModStart> { LPSTR tmp = NULL ; LPSTR tmp2 <S2SV_ModStart> ( s ) { tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 4 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if (
380,"CWE-476 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 = VAR_5 ; TYPE_6 * VAR_6 = VAR_7 ; TYPE_7 VAR_8 , VAR_9 = 0 ; VAR_10 * VAR_11 ; <S2SV_StartBug> TYPE_8 VAR_12 = VAR_13 -> VAR_14 . VAR_15 ; <S2SV_EndBug> if ( ! ( VAR_16 = METHOD_1 ( METHOD_2 ( ) ) ) ) { METHOD_3 ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>context.\\n"" ) ; return VAR_17 ; } VAR_18 = METHOD_4 ( ) ; if ( ! VAR_19 ) <S2SV_StartBug> { <S2SV_EndBug> if ( VAR_20 -> VAR_21 . VAR_22 ) { if ( ! METHOD_5 ( VAR_23 , VAR_24 -> VAR_25 . VAR_26 , VAR_27 ) ) { METHOD_6 ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>from<S2SV_blank>%s.\\n"" , VAR_28 -> VAR_29 . VAR_30 ) ; goto VAR_31 ; } } else { METHOD_7 ( ""Using<S2SV_blank>default<S2SV_blank>paths<S2SV_blank>for<S2SV_blank>certificate<S2SV_blank>verification.\\n"" ) ; METHOD_8 ( VAR_32 ) ; } if ( VAR_33 -> VAR_34 . VAR_35 ) { if ( ! METHOD_9 ( VAR_36 -> VAR_37 . VAR_38 , VAR_39 ) ) { METHOD_10 ( ""CRLs<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto VAR_40 ; } if ( VAR_41 == VAR_42 ) VAR_43 = VAR_44 ; } if ( VAR_45 -> VAR_46 . VAR_47 && VAR_48 -> VAR_49 . VAR_50 ) { if ( METHOD_11 ( VAR_51 , VAR_52 -> VAR_53 . VAR_54 ) != 1 ) { METHOD_12 ( ""Client<S2SV_blank>certificate<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto VAR_55 ; } if ( METHOD_13 ( VAR_56 , VAR_57 -> VAR_58 . VAR_59 , VAR_60 ) != 1 ) { METHOD_14 ( ""Client<S2SV_blank>private<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto VAR_61 ; } if ( METHOD_15 ( VAR_62 ) == 0 ) { METHOD_16 ( ""Client<S2SV_blank>certificate<S2SV_blank>and<S2SV_blank>private<S2SV_blank>key<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.\\n"" ) ; goto VAR_63 ; } } METHOD_17 ( VAR_64 , VAR_65 , VAR_66 ) ; if ( VAR_67 == VAR_68 ) METHOD_18 ( VAR_69 , VAR_70 ) ; else if ( VAR_71 == VAR_72 ) METHOD_19 ( VAR_73 , VAR_74 | VAR_75 ) ; if ( ! METHOD_20 ( VAR_76 , VAR_77 -> VAR_78 , METHOD_21 ( VAR_79 -> VAR_80 ) ) ) { METHOD_22 ( ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>server<S2SV_blank>name<S2SV_blank>for<S2SV_blank>verification.\\n"" ) ; goto VAR_81 ; } METHOD_23 ( VAR_82 , VAR_83 ) ; } if ( ! ( VAR_84 = METHOD_24 ( VAR_85 ) ) ) { METHOD_25 ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>session.\\n"" ) ; goto VAR_86 ; } METHOD_26 ( VAR_87 , ""ALL"" ) ; METHOD_27 ( VAR_88 , VAR_89 ) ; METHOD_28 ( VAR_90 , VAR_91 ) ; do { VAR_92 = METHOD_29 ( VAR_93 ) ; if ( VAR_94 != 1 ) { if ( METHOD_30 ( VAR_95 , VAR_96 , 1 ) != 1 ) { VAR_97 = 1 ; METHOD_31 ( VAR_98 ) ; goto VAR_99 ; } } } while ( VAR_100 != 1 && VAR_101 != 1 ) ; METHOD_32 ( VAR_102 ) ; return VAR_103 ; VAR_104 : METHOD_33 ( VAR_105 ) ; VAR_106 : METHOD_34 ( VAR_107 ) ; METHOD_35 ( VAR_108 ) ; return VAR_109 ; }",<S2SV_ModStart> ; TYPE_8 VAR_71 <S2SV_ModEnd> ; if ( <S2SV_ModStart> VAR_19 ) { VAR_71 = VAR_57 -> VAR_58 . VAR_15 ;,"CWE-476 static SSL * open_ssl_connection ( rfbClient * client , int sockfd , rfbBool anonTLS , rfbCredential * cred ) { SSL_CTX * ssl_ctx = NULL ; SSL * ssl = NULL ; int n , finished = 0 ; X509_VERIFY_PARAM * param ; <S2SV_StartBug> uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ; <S2SV_EndBug> if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) { rfbClientLog ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>context.\\n"" ) ; return NULL ; } param = X509_VERIFY_PARAM_new ( ) ; if ( ! anonTLS ) <S2SV_StartBug> { <S2SV_EndBug> if ( cred -> x509Credential . x509CACertFile ) { if ( ! SSL_CTX_load_verify_locations ( ssl_ctx , cred -> x509Credential . x509CACertFile , NULL ) ) { rfbClientLog ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>from<S2SV_blank>%s.\\n"" , cred -> x509Credential . x509CACertFile ) ; goto error_free_ctx ; } } else { rfbClientLog ( ""Using<S2SV_blank>default<S2SV_blank>paths<S2SV_blank>for<S2SV_blank>certificate<S2SV_blank>verification.\\n"" ) ; SSL_CTX_set_default_verify_paths ( ssl_ctx ) ; } if ( cred -> x509Credential . x509CACrlFile ) { if ( ! load_crls_from_file ( cred -> x509Credential . x509CACrlFile , ssl_ctx ) ) { rfbClientLog ( ""CRLs<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto error_free_ctx ; } if ( verify_crls == rfbX509CrlVerifyNone ) verify_crls = rfbX509CrlVerifyAll ; } if ( cred -> x509Credential . x509ClientCertFile && cred -> x509Credential . x509ClientKeyFile ) { if ( SSL_CTX_use_certificate_chain_file ( ssl_ctx , cred -> x509Credential . x509ClientCertFile ) != 1 ) { rfbClientLog ( ""Client<S2SV_blank>certificate<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto error_free_ctx ; } if ( SSL_CTX_use_PrivateKey_file ( ssl_ctx , cred -> x509Credential . x509ClientKeyFile , SSL_FILETYPE_PEM ) != 1 ) { rfbClientLog ( ""Client<S2SV_blank>private<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n"" ) ; goto error_free_ctx ; } if ( SSL_CTX_check_private_key ( ssl_ctx ) == 0 ) { rfbClientLog ( ""Client<S2SV_blank>certificate<S2SV_blank>and<S2SV_blank>private<S2SV_blank>key<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.\\n"" ) ; goto error_free_ctx ; } } SSL_CTX_set_verify ( ssl_ctx , SSL_VERIFY_PEER , NULL ) ; if ( verify_crls == rfbX509CrlVerifyClient ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK ) ; else if ( verify_crls == rfbX509CrlVerifyAll ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL ) ; if ( ! X509_VERIFY_PARAM_set1_host ( param , client -> serverHost , strlen ( client -> serverHost ) ) ) { rfbClientLog ( ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>server<S2SV_blank>name<S2SV_blank>for<S2SV_blank>verification.\\n"" ) ; goto error_free_ctx ; } SSL_CTX_set1_param ( ssl_ctx , param ) ; } if ( ! ( ssl = SSL_new ( ssl_ctx ) ) ) { rfbClientLog ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>session.\\n"" ) ; goto error_free_ctx ; } SSL_set_cipher_list ( ssl , ""ALL"" ) ; SSL_set_fd ( ssl , sockfd ) ; SSL_CTX_set_app_data ( ssl_ctx , client ) ; do { n = SSL_connect ( ssl ) ; if ( n != 1 ) { if ( wait_for_data ( ssl , n , 1 ) != 1 ) { finished = 1 ; SSL_shutdown ( ssl ) ; goto error_free_ssl ; } } } while ( n != 1 && finished != 1 ) ; X509_VERIFY_PARAM_free ( param ) ; return ssl ; error_free_ssl : SSL_free ( ssl ) ; error_free_ctx : X509_VERIFY_PARAM_free ( param ) ; SSL_CTX_free ( ssl_ctx ) ; return NULL ; }",<S2SV_ModStart> ; uint8_t verify_crls <S2SV_ModEnd> ; if ( <S2SV_ModStart> anonTLS ) { verify_crls = cred -> x509Credential . x509CrlVerifyMode ;
381,"CWE-59 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 [ ] ) { TYPE_3 VAR_2 ; struct STRUCT_OR_UNION_0 * VAR_3 ; VAR_4 = METHOD_1 ( VAR_5 , VAR_6 ) ; if ( ! VAR_7 ) { METHOD_2 ( VAR_8 , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>unnamed<S2SV_blank>lock\\n"" , VAR_9 ) ; METHOD_3 ( 1 ) ; } VAR_10 = METHOD_4 ( VAR_11 , 0 ) ; if ( VAR_12 ) { METHOD_5 ( VAR_13 , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>take<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , VAR_14 , VAR_15 ) ; METHOD_6 ( 1 ) ; } VAR_16 = METHOD_7 ( VAR_17 ) ; if ( VAR_18 ) { METHOD_8 ( VAR_19 , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , VAR_20 , VAR_21 ) ; METHOD_9 ( 1 ) ; } METHOD_10 ( VAR_22 ) ; VAR_23 = METHOD_11 ( ""/var/lib/lxc"" , VAR_24 ) ; if ( ! VAR_25 ) { METHOD_12 ( VAR_26 , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>lock\\n"" , VAR_27 ) ; METHOD_13 ( 1 ) ; } struct STRUCT_OR_UNION_1 VAR_28 ; <S2SV_StartBug> TYPE_4 * VAR_29 = VAR_30 ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> VAR_31 = STRUCT_OR_UNION_2 ( VAR_32 , & VAR_33 ) ; if ( VAR_34 != 0 ) { METHOD_14 ( VAR_35 , ""%d:<S2SV_blank>filename<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>created\\n"" , VAR_36 , VAR_37 ) ; METHOD_15 ( 1 ) ; } METHOD_16 ( VAR_38 ) ; METHOD_17 ( ) ; METHOD_18 ( VAR_39 , ""all<S2SV_blank>tests<S2SV_blank>passed\\n"" ) ; METHOD_19 ( VAR_40 ) ; }","<S2SV_ModStart> VAR_37 = VAR_30 ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> ; VAR_40 =","CWE-59 int main ( int argc , char * argv [ ] ) { int ret ; struct lxc_lock * lock ; lock = lxc_newlock ( NULL , NULL ) ; if ( ! lock ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>unnamed<S2SV_blank>lock\\n"" , __LINE__ ) ; exit ( 1 ) ; } ret = lxclock ( lock , 0 ) ; if ( ret ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>take<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , __LINE__ , ret ) ; exit ( 1 ) ; } ret = lxcunlock ( lock ) ; if ( ret ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , __LINE__ , ret ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; lock = lxc_newlock ( ""/var/lib/lxc"" , mycontainername ) ; if ( ! lock ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>lock\\n"" , __LINE__ ) ; exit ( 1 ) ; } struct stat sb ; <S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ret = stat ( pathname , & sb ) ; if ( ret != 0 ) { fprintf ( stderr , ""%d:<S2SV_blank>filename<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>created\\n"" , __LINE__ , pathname ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; test_two_locks ( ) ; fprintf ( stderr , ""all<S2SV_blank>tests<S2SV_blank>passed\\n"" ) ; exit ( ret ) ; }","<S2SV_ModStart> pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> ; ret ="
382,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , struct STRUCT_OR_UNION_1 VAR_3 [ ] , TYPE_3 VAR_4 ) { const struct STRUCT_OR_UNION_2 * VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 ; TYPE_4 VAR_8 = 0 ; TYPE_5 VAR_9 = 0 ; METHOD_1 ( ) ; VAR_10 = METHOD_2 ( VAR_11 -> VAR_12 ) ; while ( ( TYPE_6 ) VAR_13 > VAR_14 ) { TYPE_7 VAR_15 ; if ( METHOD_3 ( VAR_16 >= VAR_17 ) ) { VAR_18 = - VAR_19 ; break ; } VAR_20 = METHOD_4 ( VAR_21 , VAR_22 , VAR_23 ) ; if ( METHOD_5 ( ! VAR_24 ) ) { VAR_25 = - VAR_26 ; break ; } VAR_27 = VAR_28 + VAR_29 ; VAR_30 = VAR_31 -> VAR_32 - VAR_33 + VAR_34 -> VAR_35 ; <S2SV_StartBug> VAR_36 -> VAR_37 = METHOD_6 ( ( TYPE_8 ) VAR_38 , VAR_39 ) ; <S2SV_EndBug> VAR_40 -> VAR_41 = ( TYPE_9 TYPE_10 * ) ( unsigned TYPE_11 ) ( VAR_42 -> VAR_43 + VAR_44 - VAR_45 -> VAR_46 ) ; VAR_47 += VAR_48 ; VAR_49 += VAR_50 ; ++ VAR_51 ; } METHOD_7 ( ) ; return VAR_52 ; }",<S2SV_ModStart> TYPE_8 ) VAR_38 - VAR_47,"CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }",<S2SV_ModStart> u64 ) len - s
383,"CWE-401 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , TYPE_1 VAR_3 ) { struct STRUCT_OR_UNION_3 * VAR_4 ; TYPE_2 VAR_5 ; TYPE_3 VAR_6 = 0 ; TYPE_4 VAR_7 ; TYPE_5 VAR_8 ; TYPE_6 VAR_9 ; TYPE_7 VAR_10 ; VAR_11 = METHOD_1 ( VAR_12 , VAR_13 ) ; if ( ! VAR_14 ) return - VAR_15 ; if ( VAR_16 ) VAR_17 = METHOD_2 ( VAR_18 -> VAR_19 , VAR_20 , VAR_21 , VAR_22 ) ; else VAR_23 = METHOD_3 ( VAR_24 -> VAR_25 , VAR_26 , VAR_27 , VAR_28 ) ; <S2SV_StartBug> if ( VAR_29 < 0 ) <S2SV_EndBug> <S2SV_StartBug> return VAR_30 ; <S2SV_EndBug> VAR_31 = VAR_32 -> VAR_33 ; VAR_34 = VAR_35 -> VAR_36 ; METHOD_4 ( VAR_37 , VAR_38 , VAR_39 -> VAR_40 ) ; METHOD_5 ( & VAR_41 -> VAR_42 -> VAR_43 ) ; for ( VAR_44 = 0 ; VAR_45 < VAR_46 -> VAR_47 ; VAR_48 ++ ) { VAR_49 = METHOD_6 ( VAR_50 , VAR_51 ) ; VAR_52 -> VAR_53 = VAR_54 ; VAR_55 -> VAR_56 . VAR_57 . VAR_58 = VAR_59 -> VAR_60 + VAR_61 ; VAR_62 -> VAR_63 = VAR_64 ; VAR_65 -= VAR_66 ; VAR_67 -> VAR_68 = VAR_69 ; if ( VAR_70 ) METHOD_7 ( VAR_71 -> VAR_72 , VAR_73 -> VAR_74 + VAR_75 , VAR_76 ) ; VAR_77 = METHOD_8 ( VAR_78 -> VAR_79 , VAR_80 -> VAR_81 . VAR_82 . VAR_83 , VAR_84 , VAR_85 -> VAR_86 . VAR_87 . VAR_88 , VAR_89 , VAR_90 -> VAR_91 . VAR_92 . VAR_93 ) ; if ( VAR_94 < 0 ) break ; if ( ! VAR_95 ) METHOD_9 ( VAR_96 -> VAR_97 + VAR_98 , VAR_99 -> VAR_100 , VAR_101 ) ; VAR_102 += VAR_103 ; } METHOD_10 ( & VAR_104 -> VAR_105 -> VAR_106 ) ; METHOD_11 ( VAR_107 ) ; return VAR_108 ; }",<S2SV_ModStart> < 0 ) { METHOD_11 ( VAR_107 ) ; <S2SV_ModStart> return VAR_108 ; },"CWE-401 static int sof_set_get_large_ctrl_data ( struct snd_sof_dev * sdev , struct sof_ipc_ctrl_data * cdata , struct sof_ipc_ctrl_data_params * sparams , bool send ) { struct sof_ipc_ctrl_data * partdata ; size_t send_bytes ; size_t offset = 0 ; size_t msg_bytes ; size_t pl_size ; int err ; int i ; partdata = kzalloc ( SOF_IPC_MSG_MAX_SIZE , GFP_KERNEL ) ; if ( ! partdata ) return - ENOMEM ; if ( send ) err = sof_get_ctrl_copy_params ( cdata -> type , cdata , partdata , sparams ) ; else err = sof_get_ctrl_copy_params ( cdata -> type , partdata , cdata , sparams ) ; <S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> msg_bytes = sparams -> msg_bytes ; pl_size = sparams -> pl_size ; memcpy ( partdata , cdata , sparams -> hdr_bytes ) ; mutex_lock ( & sdev -> ipc -> tx_mutex ) ; for ( i = 0 ; i < sparams -> num_msg ; i ++ ) { send_bytes = min ( msg_bytes , pl_size ) ; partdata -> num_elems = send_bytes ; partdata -> rhdr . hdr . size = sparams -> hdr_bytes + send_bytes ; partdata -> msg_index = i ; msg_bytes -= send_bytes ; partdata -> elems_remaining = msg_bytes ; if ( send ) memcpy ( sparams -> dst , sparams -> src + offset , send_bytes ) ; err = sof_ipc_tx_message_unlocked ( sdev -> ipc , partdata -> rhdr . hdr . cmd , partdata , partdata -> rhdr . hdr . size , partdata , partdata -> rhdr . hdr . size ) ; if ( err < 0 ) break ; if ( ! send ) memcpy ( sparams -> dst + offset , sparams -> src , send_bytes ) ; offset += pl_size ; } mutex_unlock ( & sdev -> ipc -> tx_mutex ) ; kfree ( partdata ) ; return err ; }",<S2SV_ModStart> < 0 ) { kfree ( partdata ) ; <S2SV_ModStart> return err ; }
384,"CWE-399 static VAR_0 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 VAR_3 = METHOD_1 ( VAR_4 -> VAR_5 -> VAR_6 ) ; <S2SV_StartBug> if ( METHOD_2 ( VAR_7 < VAR_8 ) ) <S2SV_EndBug> return 0 ; return 1 ; }",<S2SV_ModStart> ( METHOD_2 ( VAR_4 -> VAR_9 ) ) return 0 ; if ( METHOD_2 (,"CWE-399 static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }",<S2SV_ModStart> ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely (
385,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , TYPE_1 METHOD_1 , struct STRUCT_OR_UNION_3 * VAR_1 , const TYPE_2 * VAR_2 , TYPE_3 * VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = & STRUCT_OR_UNION_5 -> STRUCT_OR_UNION_6 ; struct STRUCT_OR_UNION_7 VAR_5 ; struct STRUCT_OR_UNION_8 VAR_6 ; enum VAR_7 VAR_8 = VAR_9 -> VAR_10 . VAR_11 . VAR_12 == 0 ? VAR_13 : VAR_14 ; TYPE_4 VAR_15 = VAR_16 -> VAR_17 ; if ( ! VAR_18 -> VAR_19 ) return ; if ( ! VAR_20 ) METHOD_2 ( ""bad<S2SV_blank>tree<S2SV_blank>object"" ) ; if ( VAR_21 -> VAR_22 & ( VAR_23 | VAR_24 ) ) return ; if ( METHOD_3 ( STRUCT_OR_UNION_9 , VAR_25 -> VAR_26 ) < 0 ) { if ( VAR_27 -> VAR_28 ) return ; METHOD_4 ( ""bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s"" , METHOD_5 ( & VAR_29 -> VAR_30 ) ) ; } VAR_31 -> VAR_32 |= VAR_33 ; <S2SV_StartBug> METHOD_6 ( VAR_34 , VAR_35 , VAR_36 , VAR_37 ) ; <S2SV_EndBug> METHOD_7 ( VAR_38 , VAR_39 ) ; if ( VAR_40 -> VAR_41 ) METHOD_8 ( VAR_42 , '/' ) ; METHOD_9 ( & VAR_43 , STRUCT_OR_UNION_10 -> VAR_44 , STRUCT_OR_UNION_11 -> VAR_45 ) ; while ( METHOD_10 ( & VAR_46 , & VAR_47 ) ) { if ( VAR_48 != VAR_49 ) { VAR_50 = METHOD_11 ( & VAR_51 , VAR_52 , 0 , & VAR_53 -> VAR_54 . VAR_55 ) ; if ( VAR_56 == VAR_57 ) break ; if ( VAR_58 == VAR_59 ) continue ; } if ( METHOD_12 ( VAR_60 . VAR_61 ) ) METHOD_13 ( VAR_62 , METHOD_14 ( VAR_63 . VAR_64 ) , METHOD_15 , VAR_65 , VAR_66 . VAR_67 , VAR_68 ) ; else if ( METHOD_16 ( VAR_69 . VAR_70 ) ) METHOD_17 ( VAR_71 , VAR_72 . VAR_73 , METHOD_18 , VAR_74 , VAR_75 . VAR_76 , VAR_77 ) ; else METHOD_19 ( VAR_78 , METHOD_20 ( VAR_79 . VAR_80 ) , METHOD_21 , VAR_81 , VAR_82 . VAR_83 , VAR_84 ) ; } METHOD_22 ( VAR_85 , VAR_86 ) ; METHOD_23 ( STRUCT_OR_UNION_12 ) ; }","<S2SV_ModStart> |= VAR_33 ; METHOD_7 ( VAR_85 , VAR_39 ) ; <S2SV_ModStart> VAR_34 , VAR_85 -> VAR_87 , VAR_84 <S2SV_ModEnd> ) ; if","CWE-119 static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct strbuf * base , const char * name , void * cb_data ) { struct object * obj = & tree -> object ; struct tree_desc desc ; struct name_entry entry ; enum interesting match = revs -> diffopt . pathspec . nr == 0 ? all_entries_interesting : entry_not_interesting ; int baselen = base -> len ; if ( ! revs -> tree_objects ) return ; if ( ! obj ) die ( ""bad<S2SV_blank>tree<S2SV_blank>object"" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) { if ( revs -> ignore_missing_links ) return ; die ( ""bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s"" , oid_to_hex ( & obj -> oid ) ) ; } obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> strbuf_addstr ( base , name ) ; if ( base -> len ) strbuf_addch ( base , '/' ) ; init_tree_desc ( & desc , tree -> buffer , tree -> size ) ; while ( tree_entry ( & desc , & entry ) ) { if ( match != all_entries_interesting ) { match = tree_entry_interesting ( & entry , base , 0 , & revs -> diffopt . pathspec ) ; if ( match == all_entries_not_interesting ) break ; if ( match == entry_not_interesting ) continue ; } if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , base , entry . path , cb_data ) ; else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , base , entry . path , cb_data ) ; else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , base , entry . path , cb_data ) ; } strbuf_setlen ( base , baselen ) ; free_tree_buffer ( tree ) ; }","<S2SV_ModStart> |= SEEN ; strbuf_addstr ( base , name ) ; <S2SV_ModStart> obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if"
386,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; TYPE_7 VAR_6 , VAR_7 , VAR_8 ; TYPE_8 VAR_9 ; unsigned TYPE_9 VAR_10 [ 32 ] ; if ( ( VAR_11 == VAR_12 ) || ( VAR_13 == VAR_14 ) ) { METHOD_1 ( ""reverseSamplesBytes"" , ""Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer"" ) ; return ( 1 ) ; } VAR_15 = ( ( VAR_16 * VAR_17 ) + 7 ) / 8 ; <S2SV_StartBug> switch ( VAR_18 / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( VAR_19 = 0 ; VAR_20 < ( VAR_21 / 2 ) ; VAR_22 ++ ) { VAR_23 = VAR_24 * VAR_25 ; METHOD_2 ( VAR_26 , VAR_27 + VAR_28 , VAR_29 ) ; METHOD_3 ( VAR_30 + VAR_31 , VAR_32 - VAR_33 - VAR_34 , VAR_35 ) ; METHOD_4 ( VAR_36 - VAR_37 - VAR_38 , VAR_39 , VAR_40 ) ; } break ; case 1 : for ( VAR_41 = 0 ; VAR_42 < ( VAR_43 / 2 ) ; VAR_44 ++ ) { for ( VAR_45 = 0 ; VAR_46 < VAR_47 ; VAR_48 ++ ) { VAR_49 = * VAR_50 ; * VAR_51 ++ = * ( VAR_52 - VAR_53 + VAR_54 ) ; * ( VAR_55 - VAR_56 + VAR_57 ) = VAR_58 ; } VAR_59 -= VAR_60 ; } break ; default : METHOD_5 ( ""reverseSamplesBytes"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , VAR_61 ) ; return ( 1 ) ; } return ( 0 ) ; }","<S2SV_ModStart> / 8 ; if ( VAR_40 > sizeof ( VAR_39 ) ) { METHOD_5 ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; }","CWE-787 static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( ""reverseSamplesBytes"" , ""Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer"" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( ""reverseSamplesBytes"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }","<S2SV_ModStart> / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; }"
387,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_3 < VAR_4 ) return ; VAR_5 -= VAR_6 ; METHOD_1 ( VAR_7 -> VAR_8 ) ; while ( ( VAR_9 -> VAR_10 == VAR_11 && ( const TYPE_3 * ) VAR_12 < VAR_13 -> VAR_14 ) || METHOD_2 ( * VAR_15 , ( VAR_16 -> VAR_17 + 2 ) ) ) { unsigned TYPE_4 VAR_18 = VAR_19 -> VAR_20 + 2 ; if ( VAR_21 -> VAR_22 == VAR_23 ) { VAR_24 = 1 ; METHOD_3 ( ( VAR_25 , ""<S2SV_blank>opt:pad0"" ) ) ; } else { METHOD_4 ( ( VAR_26 , ""<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>"" , METHOD_5 ( VAR_27 , ""subopt:%u"" , VAR_28 -> VAR_29 ) , VAR_30 ) ) ; if ( VAR_31 -> VAR_32 > 2 ) { unsigned TYPE_5 VAR_33 = VAR_34 -> VAR_35 ; if ( VAR_36 > VAR_37 ) VAR_38 = VAR_39 ; METHOD_6 ( VAR_40 , ""<S2SV_blank>"" , ( ( const TYPE_6 * ) VAR_41 ) + VAR_42 , VAR_43 ) ; } } VAR_44 = ( const struct STRUCT_OR_UNION_1 * ) ( ( ( const TYPE_7 * ) VAR_45 ) + VAR_46 ) ; VAR_47 -= VAR_48 ; <S2SV_StartBug> } <S2SV_EndBug> return ; VAR_49 : <S2SV_StartBug> METHOD_7 ( ( VAR_50 , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }","<S2SV_ModStart> -= VAR_48 ; METHOD_1 ( VAR_45 -> VAR_35 ) ; <S2SV_ModStart> ( VAR_50 , ""%s"" , VAR_51 <S2SV_ModEnd> ) ) ;","CWE-125 static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , ""<S2SV_blank>opt:pad0"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>"" , tok2str ( rpl_subopt_values , ""subopt:%u"" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , ""<S2SV_blank>"" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }","<S2SV_ModStart> -= optlen ; ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;"
388,"CWE-399 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = VAR_4 ; TYPE_4 VAR_5 = VAR_6 -> VAR_7 ; TYPE_5 VAR_8 , VAR_9 , VAR_10 , VAR_11 ; TYPE_6 VAR_12 = VAR_13 ; TYPE_7 VAR_14 = VAR_15 ; struct STRUCT_OR_UNION_1 STRUCT_OR_UNION_2 ; VAR_16 -> VAR_17 . VAR_18 = VAR_19 ; VAR_20 -> VAR_21 = VAR_22 ; VAR_23 -> VAR_24 = VAR_25 -> VAR_26 ; VAR_27 -> VAR_28 . VAR_29 = VAR_30 -> VAR_31 . VAR_32 ; VAR_33 -> VAR_34 . VAR_35 = VAR_36 -> VAR_37 . VAR_38 + VAR_39 ; VAR_40 -> VAR_41 = 1 ; if ( VAR_42 > 0 ) METHOD_1 ( VAR_43 -> VAR_44 . VAR_45 , VAR_46 , VAR_47 ) ; else { VAR_48 = METHOD_2 ( VAR_49 , 1 ) ; if ( VAR_50 != VAR_51 ) return VAR_52 ; } switch ( VAR_53 ) { case VAR_54 : case VAR_55 : case VAR_56 : VAR_57 = VAR_58 = 2 ; break ; case VAR_59 : VAR_60 = VAR_61 = 4 ; break ; TYPE_8 TYPE_9 case VAR_62 : VAR_63 = 4 ; VAR_64 = 8 ; break ; default : return VAR_65 ; } VAR_66 -> VAR_67 = VAR_68 ; VAR_69 -> VAR_70 = VAR_71 ; for ( ; ; ) { switch ( VAR_72 -> VAR_73 = METHOD_3 ( VAR_74 , VAR_75 ) ) { case 0x66 : VAR_76 = VAR_77 ; VAR_78 -> VAR_79 = VAR_80 ^ 6 ; break ; case 0x67 : if ( VAR_81 == VAR_82 ) VAR_83 -> VAR_84 = VAR_85 ^ 12 ; else VAR_86 -> VAR_87 = VAR_88 ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : VAR_89 = VAR_90 ; VAR_91 -> VAR_92 = ( VAR_93 -> VAR_94 >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : VAR_95 = VAR_96 ; VAR_97 -> VAR_98 = VAR_99 -> VAR_100 & 7 ; break ; case 0x40 ... 0x4f : if ( VAR_101 != VAR_102 ) goto VAR_103 ; VAR_104 -> VAR_105 = VAR_106 -> VAR_107 ; continue ; case 0xf0 : VAR_108 -> VAR_109 = 1 ; break ; case 0xf2 : case 0xf3 : VAR_110 -> VAR_111 = VAR_112 -> VAR_113 ; break ; default : goto VAR_114 ; } VAR_115 -> VAR_116 = 0 ; } VAR_117 : if ( VAR_118 -> VAR_119 & 8 ) VAR_120 -> VAR_121 = 8 ; STRUCT_OR_UNION_3 = VAR_122 [ VAR_123 -> VAR_124 ] ; if ( VAR_125 -> VAR_126 == 0x0f ) { VAR_127 -> VAR_128 = 2 ; VAR_129 -> VAR_130 = METHOD_4 ( VAR_131 , VAR_132 ) ; STRUCT_OR_UNION_4 = VAR_133 [ VAR_134 -> VAR_135 ] ; if ( VAR_136 -> VAR_137 == 0x38 ) { VAR_138 -> VAR_139 = 3 ; VAR_140 -> VAR_141 = METHOD_5 ( VAR_142 , VAR_143 ) ; STRUCT_OR_UNION_5 = VAR_144 [ VAR_145 -> VAR_146 ] ; } } VAR_147 -> VAR_148 = STRUCT_OR_UNION_6 . VAR_149 ; if ( VAR_150 -> VAR_151 & VAR_152 ) VAR_153 -> VAR_154 = METHOD_6 ( VAR_155 , VAR_156 ) ; if ( VAR_157 -> VAR_158 == 1 && ( VAR_159 -> VAR_160 == 0xc5 || VAR_161 -> VAR_162 == 0xc4 ) && ( VAR_163 == VAR_164 || ( VAR_165 >= VAR_166 && ( VAR_167 -> VAR_168 & 0x80 ) ) ) ) { VAR_169 -> VAR_170 = VAR_171 ; } while ( VAR_172 -> VAR_173 & VAR_174 ) { switch ( VAR_175 -> VAR_176 & VAR_177 ) { case VAR_178 : VAR_179 = ( VAR_180 -> VAR_181 >> 3 ) & 7 ; STRUCT_OR_UNION_7 = STRUCT_OR_UNION_8 . VAR_182 . VAR_183 [ VAR_184 ] ; break ; case VAR_185 : VAR_186 = ( VAR_187 -> VAR_188 >> 3 ) & 7 ; if ( ( VAR_189 -> VAR_190 >> 6 ) == 3 ) STRUCT_OR_UNION_9 = STRUCT_OR_UNION_10 . VAR_191 . VAR_192 -> VAR_193 [ VAR_194 ] ; else STRUCT_OR_UNION_11 = STRUCT_OR_UNION_12 . VAR_195 . VAR_196 -> VAR_197 [ VAR_198 ] ; break ; case VAR_199 : VAR_200 = VAR_201 -> VAR_202 & 7 ; STRUCT_OR_UNION_13 = STRUCT_OR_UNION_14 . VAR_203 . VAR_204 [ VAR_205 ] ; break ; case VAR_206 : if ( VAR_207 -> VAR_208 && VAR_209 ) return VAR_210 ; VAR_211 = VAR_212 ? 0x66 : VAR_213 -> VAR_214 ; switch ( VAR_215 ) { case 0x00 : STRUCT_OR_UNION_15 = STRUCT_OR_UNION_16 . VAR_216 . VAR_217 -> VAR_218 ; break ; case 0x66 : STRUCT_OR_UNION_17 = STRUCT_OR_UNION_18 . VAR_219 . VAR_220 -> VAR_221 ; break ; case 0xf2 : STRUCT_OR_UNION_19 = STRUCT_OR_UNION_20 . VAR_222 . VAR_223 -> VAR_224 ; break ; case 0xf3 : STRUCT_OR_UNION_21 = STRUCT_OR_UNION_22 . VAR_225 . VAR_226 -> VAR_227 ; break ; } break ; case VAR_228 : if ( VAR_229 -> VAR_230 > 0xbf ) STRUCT_OR_UNION_23 = STRUCT_OR_UNION_24 . VAR_231 . VAR_232 -> VAR_233 [ VAR_234 -> VAR_235 - 0xc0 ] ; else STRUCT_OR_UNION_25 = STRUCT_OR_UNION_26 . VAR_236 . VAR_237 -> VAR_238 [ ( VAR_239 -> VAR_240 >> 3 ) & 7 ] ; break ; default : return VAR_241 ; } VAR_242 -> VAR_243 &= ~ ( TYPE_10 ) VAR_244 ; VAR_245 -> VAR_246 |= STRUCT_OR_UNION_27 . VAR_247 ; } if ( VAR_248 -> VAR_249 == 0 ) return VAR_250 ; VAR_251 -> VAR_252 = STRUCT_OR_UNION_28 . VAR_253 . VAR_254 ; if ( METHOD_7 ( VAR_255 -> VAR_256 ) && METHOD_8 ( ! ( VAR_257 -> VAR_258 & VAR_259 ) ) ) return VAR_260 ; if ( METHOD_9 ( VAR_261 -> VAR_262 & ( VAR_263 | VAR_264 | VAR_265 | VAR_266 | VAR_267 | VAR_268 | VAR_269 ) ) ) { VAR_270 -> VAR_271 = STRUCT_OR_UNION_29 . VAR_272 ; VAR_273 -> VAR_274 = STRUCT_OR_UNION_30 . VAR_275 ; if ( VAR_276 -> VAR_277 & VAR_278 ) return VAR_279 ; if ( VAR_280 == VAR_281 && ( VAR_282 -> VAR_283 & VAR_284 ) ) VAR_285 -> VAR_286 = 8 ; if ( VAR_287 -> VAR_288 & VAR_289 ) { if ( VAR_290 == VAR_291 ) VAR_292 -> VAR_293 = 8 ; else VAR_294 -> VAR_295 = 4 ; } if ( VAR_296 -> VAR_297 & VAR_298 ) VAR_299 -> VAR_300 = 16 ; else if ( VAR_301 -> VAR_302 & VAR_303 ) VAR_304 -> VAR_305 = 8 ; } if ( VAR_306 -> VAR_307 & VAR_308 ) { VAR_309 = METHOD_10 ( VAR_310 , & VAR_311 -> VAR_312 ) ; if ( ! VAR_313 ) { VAR_314 = VAR_315 ; VAR_316 -> VAR_317 = VAR_318 -> VAR_319 ; } } else if ( VAR_320 -> VAR_321 & VAR_322 ) VAR_323 = METHOD_11 ( VAR_324 , & VAR_325 -> VAR_326 ) ; if ( VAR_327 != VAR_328 ) goto VAR_329 ; if ( ! VAR_330 ) VAR_331 -> VAR_332 = VAR_333 ; VAR_334 -> VAR_335 . VAR_336 . VAR_337 . VAR_338 = VAR_339 -> VAR_340 ; VAR_341 = METHOD_12 ( VAR_342 , & VAR_343 -> VAR_344 , ( VAR_345 -> VAR_346 >> VAR_347 ) & VAR_348 ) ; if ( VAR_349 != VAR_350 ) goto VAR_351 ; VAR_352 = METHOD_13 ( VAR_353 , & VAR_354 -> VAR_355 , ( VAR_356 -> VAR_357 >> VAR_358 ) & VAR_359 ) ; if ( VAR_360 != VAR_361 ) goto VAR_362 ; VAR_363 = METHOD_14 ( VAR_364 , & VAR_365 -> VAR_366 , ( VAR_367 -> VAR_368 >> VAR_369 ) & VAR_370 ) ; <S2SV_StartBug> VAR_371 : <S2SV_EndBug> if ( VAR_372 -> VAR_373 ) <S2SV_StartBug> VAR_374 -> VAR_375 -> VAR_376 . VAR_377 . VAR_378 += VAR_379 -> VAR_380 ; <S2SV_EndBug> return ( VAR_381 != VAR_382 ) ? VAR_383 : VAR_384 ; }",<S2SV_ModStart> VAR_370 ) ; <S2SV_ModEnd> if ( VAR_379 <S2SV_ModStart> -> VAR_380 ; VAR_371 :,"CWE-399 int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ;  ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ;   default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( mode >= X86EMUL_MODE_PROT16 && ( ctxt -> modrm & 0x80 ) ) ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <S2SV_StartBug> done : <S2SV_EndBug> if ( ctxt -> rip_relative ) <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }",<S2SV_ModStart> OpMask ) ; <S2SV_ModEnd> if ( ctxt <S2SV_ModStart> -> _eip ; done :
389,"CWE-125 static VAR_0 signed TYPE_0 METHOD_0 ( const TYPE_1 VAR_1 , const unsigned TYPE_2 * VAR_2 ) { union { unsigned TYPE_3 VAR_3 ; signed TYPE_4 VAR_4 ; } VAR_5 ; unsigned TYPE_5 VAR_6 ; if ( VAR_7 == VAR_8 ) { <S2SV_StartBug> VAR_9 = ( unsigned TYPE_6 ) ( ( VAR_10 [ 1 ] << 8 ) | VAR_11 [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_12 . VAR_13 = ( VAR_14 & 0xffff ) ; <S2SV_EndBug> return ( VAR_15 . VAR_16 ) ; } <S2SV_StartBug> VAR_17 = ( unsigned TYPE_7 ) ( ( ( ( unsigned TYPE_8 * ) VAR_18 ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned TYPE_9 * ) VAR_19 ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_20 . VAR_21 = ( VAR_22 & 0xffff ) ; <S2SV_EndBug> return ( VAR_23 . VAR_24 ) ; }",<S2SV_ModStart> unsigned TYPE_7 ) <S2SV_ModEnd> VAR_19 [ 1 <S2SV_ModStart> ] << 8 ; VAR_22 |= ( unsigned TYPE_7 ) <S2SV_ModEnd> VAR_19 [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; VAR_23 . <S2SV_ModStart> . VAR_21 = <S2SV_ModEnd> VAR_22 & 0xffff <S2SV_ModStart> VAR_22 & 0xffff <S2SV_ModEnd> ; return ( <S2SV_ModStart> unsigned TYPE_7 ) VAR_19 <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; VAR_22 |= ( unsigned TYPE_7 ) VAR_19 <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; VAR_23 . <S2SV_ModStart> . VAR_21 = <S2SV_ModEnd> VAR_22 & 0xffff <S2SV_ModStart> VAR_22 & 0xffff <S2SV_ModEnd> ; return (,"CWE-125 static inline signed short ReadPropertySignedShort ( const EndianType endian , const unsigned char * buffer ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }",<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return ( <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) buffer <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
390,CWE-415 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; VAR_2 = METHOD_1 ( VAR_3 ) ; METHOD_2 ( & VAR_4 -> VAR_5 ) ; <S2SV_StartBug> METHOD_3 ( VAR_6 -> VAR_7 ) ; <S2SV_EndBug> return 0 ; },<S2SV_ModStart> VAR_5 ) ; <S2SV_ModEnd> return 0 ;,CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; },<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
391,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , TYPE_2 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 ; TYPE_3 * VAR_4 = VAR_5 ; TYPE_4 VAR_6 ; METHOD_1 ( VAR_7 , ""filter<S2SV_blank>session:<S2SV_blank>%p:<S2SV_blank>%s<S2SV_blank>%s"" , VAR_8 , METHOD_2 ( VAR_9 ) , METHOD_3 ( STRUCT_OR_UNION_3 ) ) ; switch ( VAR_10 ) { case VAR_11 : VAR_12 : VAR_13 = METHOD_4 ( VAR_14 -> STRUCT_OR_UNION_4 , & VAR_15 ) ; if ( VAR_16 == VAR_17 ) return ; METHOD_5 ( VAR_18 -> VAR_19 , VAR_20 ) ; goto VAR_21 ; <S2SV_StartBug> case VAR_22 : <S2SV_EndBug> METHOD_6 ( VAR_23 -> STRUCT_OR_UNION_5 ) ; VAR_24 -> STRUCT_OR_UNION_6 = VAR_25 ; break ; } }",<S2SV_ModStart> goto VAR_21 ; <S2SV_ModEnd> } } <S2SV_null>,"CWE-476 static void filter_session_io ( struct io * io , int evt , void * arg ) { struct filter_session * fs = arg ; char * line = NULL ; ssize_t len ; log_trace ( TRACE_IO , ""filter<S2SV_blank>session:<S2SV_blank>%p:<S2SV_blank>%s<S2SV_blank>%s"" , fs , io_strevent ( evt ) , io_strio ( io ) ) ; switch ( evt ) { case IO_DATAIN : nextline : line = io_getline ( fs -> io , & len ) ; if ( line == NULL ) return ; filter_data ( fs -> id , line ) ; goto nextline ; <S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> io_free ( fs -> io ) ; fs -> io = NULL ; break ; } }",<S2SV_ModStart> goto nextline ; <S2SV_ModEnd> } } <S2SV_null>
392,"CWE-369 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = VAR_2 ; TYPE_3 * VAR_3 = VAR_4 ; TYPE_4 VAR_5 = 0 ; if ( ! VAR_6 -> VAR_7 ) { goto VAR_8 ; } else { TYPE_5 VAR_9 , VAR_10 ; VAR_11 -> VAR_12 = 0 ; VAR_13 -> VAR_14 = 0 ; VAR_15 -> VAR_16 = 0 ; for ( VAR_17 = 0 ; VAR_18 < VAR_19 -> VAR_20 ; VAR_21 ++ ) { VAR_22 = & VAR_23 -> VAR_24 [ VAR_25 ] ; for ( VAR_26 = 0 ; VAR_27 < VAR_28 -> VAR_29 ; VAR_30 ++ ) { TYPE_6 VAR_31 , VAR_32 ; VAR_33 = & VAR_34 -> VAR_35 [ VAR_36 ] ; VAR_37 = VAR_38 -> VAR_39 * ( 1u << ( VAR_40 -> VAR_41 + VAR_42 -> VAR_43 - 1 - VAR_44 ) ) ; VAR_45 = VAR_46 -> VAR_47 * ( 1u << ( VAR_48 -> VAR_49 + VAR_50 -> VAR_51 - 1 - VAR_52 ) ) ; VAR_53 -> VAR_54 = ! VAR_55 -> VAR_56 ? VAR_57 : METHOD_1 ( VAR_58 -> VAR_59 , VAR_60 ) ; VAR_61 -> VAR_62 = ! VAR_63 -> VAR_64 ? VAR_65 : METHOD_2 ( VAR_66 -> VAR_67 , VAR_68 ) ; } } } if ( ! VAR_69 -> VAR_70 ) { VAR_71 -> VAR_72 . VAR_73 = VAR_74 -> VAR_75 ; VAR_76 -> VAR_77 . VAR_78 = VAR_79 -> VAR_80 ; VAR_81 -> VAR_82 . VAR_83 = VAR_84 -> VAR_85 ; VAR_86 -> VAR_87 . VAR_88 = VAR_89 -> VAR_90 ; } for ( VAR_91 -> VAR_92 = VAR_93 -> VAR_94 . VAR_95 ; VAR_96 -> VAR_97 < VAR_98 -> VAR_99 . VAR_100 ; VAR_101 -> VAR_102 ++ ) { for ( VAR_103 -> VAR_104 = VAR_105 -> VAR_106 . VAR_107 ; VAR_108 -> VAR_109 < VAR_110 -> VAR_111 . VAR_112 ; VAR_113 -> VAR_114 += ( TYPE_7 ) ( VAR_115 -> VAR_116 - ( TYPE_8 ) ( VAR_117 -> VAR_118 % ( TYPE_9 ) VAR_119 -> VAR_120 ) ) ) { for ( VAR_121 -> VAR_122 = VAR_123 -> VAR_124 . VAR_125 ; VAR_126 -> VAR_127 < VAR_128 -> VAR_129 . VAR_130 ; VAR_131 -> VAR_132 += ( TYPE_10 ) ( VAR_133 -> VAR_134 - ( TYPE_11 ) ( VAR_135 -> VAR_136 % ( TYPE_12 ) VAR_137 -> VAR_138 ) ) ) { for ( VAR_139 -> VAR_140 = VAR_141 -> VAR_142 . VAR_143 ; VAR_144 -> VAR_145 < VAR_146 -> VAR_147 . VAR_148 ; VAR_149 -> VAR_150 ++ ) { TYPE_13 VAR_151 ; TYPE_14 VAR_152 , VAR_153 ; TYPE_15 VAR_154 , VAR_155 ; TYPE_16 VAR_156 , VAR_157 ; TYPE_17 VAR_158 , VAR_159 ; VAR_160 = & VAR_161 -> VAR_162 [ VAR_163 -> VAR_164 ] ; if ( VAR_165 -> VAR_166 >= VAR_167 -> VAR_168 ) { continue ; } VAR_169 = & VAR_170 -> VAR_171 [ VAR_172 -> VAR_173 ] ; VAR_174 = VAR_175 -> VAR_176 - 1 - VAR_177 -> VAR_178 ; VAR_179 = METHOD_3 ( VAR_180 -> VAR_181 , ( TYPE_18 ) ( VAR_182 -> VAR_183 << VAR_184 ) ) ; VAR_185 = METHOD_4 ( VAR_186 -> VAR_187 , ( TYPE_19 ) ( VAR_188 -> VAR_189 << VAR_190 ) ) ; VAR_191 = METHOD_5 ( VAR_192 -> VAR_193 , ( TYPE_20 ) ( VAR_194 -> VAR_195 << VAR_196 ) ) ; VAR_197 = METHOD_6 ( VAR_198 -> VAR_199 , ( TYPE_21 ) ( VAR_200 -> VAR_201 << VAR_202 ) ) ; VAR_203 = VAR_204 -> VAR_205 + VAR_206 ; VAR_207 = VAR_208 -> VAR_209 + VAR_210 ; <S2SV_StartBug> if ( ! ( ( VAR_211 -> VAR_212 % ( TYPE_22 ) ( VAR_213 -> VAR_214 << VAR_215 ) == 0 ) || ( ( VAR_216 -> VAR_217 == VAR_218 -> VAR_219 ) && <S2SV_EndBug> ( ( VAR_220 << VAR_221 ) % ( 1 << VAR_222 ) ) ) ) ) { continue ; } if ( ! ( ( VAR_223 -> VAR_224 % ( TYPE_23 ) ( VAR_225 -> VAR_226 << VAR_227 ) == 0 ) || ( ( VAR_228 -> VAR_229 == VAR_230 -> VAR_231 ) && ( ( VAR_232 << VAR_233 ) % ( 1 << VAR_234 ) ) ) ) ) { continue ; } if ( ( VAR_235 -> VAR_236 == 0 ) || ( VAR_237 -> VAR_238 == 0 ) ) { continue ; } if ( ( VAR_239 == VAR_240 ) || ( VAR_241 == VAR_242 ) ) { continue ; } VAR_243 = METHOD_7 ( METHOD_8 ( VAR_244 -> VAR_245 , ( TYPE_24 ) ( VAR_246 -> VAR_247 << VAR_248 ) ) , ( TYPE_25 ) VAR_249 -> VAR_250 ) - METHOD_9 ( VAR_251 , ( TYPE_26 ) VAR_252 -> VAR_253 ) ; VAR_254 = METHOD_10 ( METHOD_11 ( VAR_255 -> VAR_256 , ( TYPE_27 ) ( VAR_257 -> VAR_258 << VAR_259 ) ) , ( TYPE_28 ) VAR_260 -> VAR_261 ) - METHOD_12 ( VAR_262 , ( TYPE_29 ) VAR_263 -> VAR_264 ) ; VAR_265 -> VAR_266 = ( TYPE_30 ) ( VAR_267 + VAR_268 * ( TYPE_31 ) VAR_269 -> VAR_270 ) ; for ( VAR_271 -> VAR_272 = VAR_273 -> VAR_274 . VAR_275 ; VAR_276 -> VAR_277 < VAR_278 -> VAR_279 . VAR_280 ; VAR_281 -> VAR_282 ++ ) { VAR_283 = VAR_284 -> VAR_285 * VAR_286 -> VAR_287 + VAR_288 -> VAR_289 * VAR_290 -> VAR_291 + VAR_292 -> VAR_293 * VAR_294 -> VAR_295 + VAR_296 -> VAR_297 * VAR_298 -> VAR_299 ; if ( ! VAR_300 -> VAR_301 [ VAR_302 ] ) { VAR_303 -> VAR_304 [ VAR_305 ] = 1 ; return VAR_306 ; } VAR_307 : ; } } } } } return VAR_308 ; }",<S2SV_ModStart> ; if ( VAR_234 >= 31 || ( ( VAR_257 -> VAR_247 << VAR_234 ) >> VAR_234 ) != VAR_257 -> VAR_247 || VAR_222 >= 31 || ( ( VAR_257 -> VAR_258 << VAR_222 ) >> VAR_222 ) != VAR_257 -> VAR_258 ) { continue ; } if (,"CWE-369 static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }",<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
393,"CWE-200 VAR_0 TYPE_0 METHOD_0 ( TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_0 * VAR_2 , TYPE_2 * VAR_3 ) { METHOD_1 ( VAR_4 , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'"" , VAR_5 -> VAR_6 , VAR_7 ) ; TYPE_3 VAR_8 = 400 ; TYPE_4 * VAR_9 = VAR_10 ; METHOD_2 ( VAR_11 -> VAR_12 . VAR_13 ) ; TYPE_5 * VAR_14 = ""0.6"" , * VAR_15 = ""0"" , * VAR_16 = ""0"" , * VAR_17 = ""json"" , * VAR_18 = VAR_19 , * VAR_20 = VAR_21 ; TYPE_6 VAR_22 = 0 , VAR_23 = 0 ; TYPE_7 * VAR_24 = VAR_25 , * VAR_26 = VAR_27 , * VAR_28 = VAR_29 , * VAR_30 = VAR_31 , * VAR_32 = VAR_33 ; TYPE_8 VAR_34 = VAR_35 ; TYPE_9 VAR_36 = VAR_37 ; TYPE_10 VAR_38 = 0x00000000 ; while ( VAR_39 ) { TYPE_11 * VAR_40 = METHOD_3 ( & VAR_41 , ""?&"" ) ; if ( ! VAR_42 || ! * VAR_43 ) continue ; TYPE_12 * VAR_44 = METHOD_4 ( & VAR_45 , ""="" ) ; if ( ! VAR_46 || ! * VAR_47 ) continue ; if ( ! VAR_48 || ! * VAR_49 ) continue ; METHOD_5 ( VAR_50 , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'"" , VAR_51 -> VAR_52 , VAR_53 , VAR_54 ) ; if ( ! METHOD_6 ( VAR_55 , ""chart"" ) ) VAR_56 = VAR_57 ; else if ( ! METHOD_7 ( VAR_58 , ""dimension"" ) || ! METHOD_8 ( VAR_59 , ""dim"" ) || ! METHOD_9 ( VAR_60 , ""dimensions"" ) || ! METHOD_10 ( VAR_61 , ""dims"" ) ) { if ( ! VAR_62 ) VAR_63 = METHOD_11 ( 100 ) ; METHOD_12 ( VAR_64 , ""|"" ) ; METHOD_13 ( VAR_65 , VAR_66 ) ; } else if ( ! METHOD_14 ( VAR_67 , ""after"" ) ) VAR_68 = VAR_69 ; else if ( ! METHOD_15 ( VAR_70 , ""before"" ) ) VAR_71 = VAR_72 ; else if ( ! METHOD_16 ( VAR_73 , ""points"" ) ) VAR_74 = VAR_75 ; else if ( ! METHOD_17 ( VAR_76 , ""gtime"" ) ) VAR_77 = VAR_78 ; else if ( ! METHOD_18 ( VAR_79 , ""group"" ) ) { VAR_80 = METHOD_19 ( VAR_81 , VAR_82 ) ; } else if ( ! METHOD_20 ( VAR_83 , ""format"" ) ) { VAR_84 = METHOD_21 ( VAR_85 ) ; } else if ( ! METHOD_22 ( VAR_86 , ""options"" ) ) { VAR_87 |= METHOD_23 ( VAR_88 ) ; } else if ( ! METHOD_24 ( VAR_89 , ""callback"" ) ) { VAR_90 = VAR_91 ; } else if ( ! METHOD_25 ( VAR_92 , ""filename"" ) ) { VAR_93 = VAR_94 ; } else if ( ! METHOD_26 ( VAR_95 , ""tqx"" ) ) { TYPE_13 * VAR_96 , * VAR_97 ; while ( VAR_98 ) { VAR_99 = METHOD_27 ( & VAR_100 , "";"" ) ; if ( ! VAR_101 || ! * VAR_102 ) continue ; VAR_103 = METHOD_28 ( & VAR_104 , "":"" ) ; if ( ! VAR_105 || ! * VAR_106 ) continue ; if ( ! VAR_107 || ! * VAR_108 ) continue ; if ( ! METHOD_29 ( VAR_109 , ""version"" ) ) VAR_110 = VAR_111 ; else if ( ! METHOD_30 ( VAR_112 , ""reqId"" ) ) VAR_113 = VAR_114 ; else if ( ! METHOD_31 ( VAR_115 , ""sig"" ) ) { VAR_116 = VAR_117 ; VAR_118 = METHOD_32 ( VAR_119 , VAR_120 , 0 ) ; } else if ( ! METHOD_33 ( VAR_121 , ""out"" ) ) { VAR_122 = VAR_123 ; VAR_124 = METHOD_34 ( VAR_125 ) ; } else if ( ! METHOD_35 ( VAR_126 , ""responseHandler"" ) ) VAR_127 = VAR_128 ; else if ( ! METHOD_36 ( VAR_129 , ""outFileName"" ) ) VAR_130 = VAR_131 ; } } } <S2SV_StartBug> if ( ! VAR_132 || ! * VAR_133 ) { <S2SV_EndBug> METHOD_37 ( VAR_134 -> VAR_135 . VAR_136 , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ; goto VAR_137 ; } TYPE_14 * VAR_138 = METHOD_38 ( VAR_139 , VAR_140 ) ; if ( ! VAR_141 ) VAR_142 = METHOD_39 ( VAR_143 , VAR_144 ) ; if ( ! VAR_145 ) { METHOD_40 ( VAR_146 -> VAR_147 . VAR_148 , ""Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>"" ) ; METHOD_41 ( VAR_149 -> VAR_150 . VAR_151 , VAR_152 ) ; VAR_153 = 404 ; goto VAR_154 ; } VAR_155 -> VAR_156 = METHOD_42 ( ) ; TYPE_15 TYPE_16 VAR_157 = ( VAR_158 && * VAR_159 ) ? METHOD_43 ( VAR_160 ) : 0 ; TYPE_17 TYPE_18 VAR_161 = ( VAR_162 && * VAR_163 ) ? METHOD_44 ( VAR_164 ) : 0 ; TYPE_19 VAR_165 = ( VAR_166 && * VAR_167 ) ? METHOD_45 ( VAR_168 ) : 0 ; TYPE_20 VAR_169 = ( VAR_170 && * VAR_171 ) ? METHOD_46 ( VAR_172 ) : 0 ; METHOD_47 ( VAR_173 , ""%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'"" , VAR_174 -> VAR_175 , VAR_176 , ( VAR_177 ) ? METHOD_48 ( VAR_178 ) : """" , VAR_179 , VAR_180 , VAR_181 , VAR_182 , VAR_183 , VAR_184 ) ; if ( VAR_185 && * VAR_186 ) { METHOD_49 ( VAR_187 -> VAR_188 . VAR_189 , ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , VAR_190 ) ; METHOD_50 ( VAR_191 , ""%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'"" , VAR_192 -> VAR_193 , VAR_194 ) ; } if ( VAR_195 == VAR_196 ) { if ( VAR_197 == VAR_198 ) VAR_199 = ""google.visualization.Query.setResponse"" ; METHOD_51 ( VAR_200 , ""%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'"" , VAR_201 -> VAR_202 , VAR_203 , VAR_204 , VAR_205 , VAR_206 , VAR_207 , VAR_208 ) ; METHOD_52 ( VAR_209 -> VAR_210 . VAR_211 , ""%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:"" , VAR_212 , VAR_213 , VAR_214 , VAR_215 -> VAR_216 . VAR_217 ) ; } else if ( VAR_218 == VAR_219 ) { if ( VAR_220 == VAR_221 ) VAR_222 = ""callback"" ; METHOD_53 ( VAR_223 -> VAR_224 . VAR_225 , VAR_226 ) ; METHOD_54 ( VAR_227 -> VAR_228 . VAR_229 , ""("" ) ; } VAR_230 = METHOD_55 ( VAR_231 , VAR_232 -> VAR_233 . VAR_234 , VAR_235 , VAR_236 , VAR_237 , VAR_238 , VAR_239 , VAR_240 , VAR_241 , VAR_242 , & VAR_243 ) ; if ( VAR_244 == VAR_245 ) { if ( VAR_246 < VAR_247 ) METHOD_56 ( VAR_248 -> VAR_249 . VAR_250 , ""});"" ) ; else { METHOD_57 ( VAR_251 -> VAR_252 . VAR_253 ) ; METHOD_58 ( VAR_254 -> VAR_255 . VAR_256 , ""%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});"" , VAR_257 , VAR_258 , VAR_259 ) ; } } else if ( VAR_260 == VAR_261 ) METHOD_59 ( VAR_262 -> VAR_263 . VAR_264 , "");"" ) ; VAR_265 : METHOD_60 ( VAR_266 ) ; return VAR_267 ; }",<S2SV_ModStart> } } } METHOD_61 ( VAR_206 ) ; METHOD_61 ( VAR_205 ) ; METHOD_61 ( VAR_259 ) ; METHOD_61 ( VAR_258 ) ; METHOD_61 ( VAR_257 ) ; METHOD_61 ( VAR_208 ) ;,"CWE-200 inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'"" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = ""0.6"" , * google_reqId = ""0"" , * google_sig = ""0"" , * google_out = ""json"" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , ""?&"" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , ""="" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'"" , w -> id , name , value ) ; if ( ! strcmp ( name , ""chart"" ) ) chart = value ; else if ( ! strcmp ( name , ""dimension"" ) || ! strcmp ( name , ""dim"" ) || ! strcmp ( name , ""dimensions"" ) || ! strcmp ( name , ""dims"" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , ""|"" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , ""after"" ) ) after_str = value ; else if ( ! strcmp ( name , ""before"" ) ) before_str = value ; else if ( ! strcmp ( name , ""points"" ) ) points_str = value ; else if ( ! strcmp ( name , ""gtime"" ) ) group_time_str = value ; else if ( ! strcmp ( name , ""group"" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , ""format"" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , ""options"" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , ""callback"" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , ""filename"" ) ) { outFileName = value ; } else if ( ! strcmp ( name , ""tqx"" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , "";"" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , "":"" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , ""version"" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , ""reqId"" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , ""sig"" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , ""out"" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , ""responseHandler"" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , ""outFileName"" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , ""Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>"" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'"" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : """" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , outFileName ) ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'"" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""google.visualization.Query.setResponse"" ; debug ( D_WEB_CLIENT_ACCESS , ""%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'"" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:"" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""callback"" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , ""("" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , ""});"" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});"" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , "");"" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }",<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
394,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * * VAR_0 , unsigned VAR_1 , TYPE_1 VAR_2 , enum VAR_3 VAR_4 ) { struct STRUCT_OR_UNION_1 * VAR_5 = METHOD_1 ( VAR_6 , VAR_7 , VAR_8 ) ; TYPE_2 TYPE_3 struct STRUCT_OR_UNION_2 * VAR_9 = METHOD_2 ( VAR_10 , VAR_11 , VAR_12 ) ; unsigned TYPE_4 VAR_13 ; unsigned VAR_14 ; if ( VAR_15 == VAR_16 ) { VAR_17 = 0 ; while ( VAR_18 < VAR_19 ) { TYPE_5 TYPE_6 struct STRUCT_OR_UNION_3 * VAR_20 = VAR_21 [ VAR_22 ] ; unsigned VAR_23 = 0 , VAR_24 ; if ( ! VAR_25 [ VAR_26 ] ) { ++ VAR_27 ; continue ; } TYPE_7 TYPE_8 <S2SV_StartBug> if ( ! ( VAR_28 & VAR_29 ) ) { <S2SV_EndBug> for ( VAR_30 = 0 ; VAR_31 < VAR_32 ; ++ VAR_33 ) if ( VAR_34 ++ != VAR_35 [ VAR_36 + VAR_37 ] ) break ; if ( VAR_38 == VAR_39 ) VAR_40 = VAR_41 ; } if ( METHOD_3 ( VAR_42 [ VAR_43 ] ) != 1 ) METHOD_4 ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; METHOD_5 ( VAR_44 [ VAR_45 ] , VAR_46 ) ; VAR_47 = 1 << VAR_48 ; while ( VAR_49 ) { VAR_50 [ VAR_51 ++ ] = VAR_52 ; -- VAR_53 ; } } return ; } VAR_54 = 0 ; TYPE_9 TYPE_10 if ( VAR_55 ) { unsigned VAR_56 , VAR_57 ; METHOD_6 ( & VAR_58 -> VAR_59 , VAR_60 ) ; <S2SV_StartBug> while ( VAR_61 < VAR_62 ) { <S2SV_EndBug> struct STRUCT_OR_UNION_4 * VAR_63 = VAR_64 [ VAR_65 ] ; unsigned VAR_66 ; if ( ! VAR_67 ) break ; for ( VAR_68 = 0 ; VAR_69 < VAR_70 ; ++ VAR_71 ) if ( VAR_72 ++ != VAR_73 [ VAR_74 + VAR_75 ] ) break ; if ( VAR_76 != VAR_77 ) break ; METHOD_7 ( & VAR_78 [ VAR_79 ] -> VAR_80 , & VAR_81 -> VAR_82 ) ; for ( VAR_83 = 0 ; VAR_84 < VAR_85 ; ++ VAR_86 ) VAR_87 [ VAR_88 ++ ] = VAR_89 ; VAR_90 -> VAR_91 ++ ; } VAR_92 = VAR_93 -> VAR_94 . VAR_95 ; VAR_96 /= VAR_97 ; if ( VAR_98 -> VAR_99 > VAR_100 ) VAR_101 = VAR_102 -> VAR_103 - VAR_104 ; else VAR_105 = 0 ; METHOD_8 ( & VAR_106 -> VAR_107 , VAR_108 ) ; if ( VAR_109 ) METHOD_9 ( VAR_110 , VAR_111 , VAR_112 ) ; } METHOD_10 ( & VAR_113 -> VAR_114 , VAR_115 ) ; while ( VAR_116 < VAR_117 ) { if ( VAR_118 [ VAR_119 ] ) { if ( METHOD_11 ( VAR_120 [ VAR_121 ] ) != 1 ) METHOD_12 ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; METHOD_13 ( & VAR_122 [ VAR_123 ] -> VAR_124 , & VAR_125 -> VAR_126 ) ; VAR_127 [ VAR_128 ] = VAR_129 ; VAR_130 -> VAR_131 ++ ; } ++ VAR_132 ; } VAR_133 = 0 ; if ( VAR_134 -> VAR_135 > VAR_136 -> VAR_137 . VAR_138 ) { VAR_139 = VAR_140 -> VAR_141 - VAR_142 -> VAR_143 . VAR_144 ; if ( VAR_145 < VAR_146 ) VAR_147 = VAR_148 ; } METHOD_14 ( & VAR_149 -> VAR_150 , VAR_151 ) ; if ( VAR_152 ) METHOD_15 ( VAR_153 , VAR_154 , VAR_155 ) ; }",<S2SV_ModStart> & VAR_29 ) && ( VAR_154 - VAR_132 ) >= VAR_97 <S2SV_ModStart> ; while ( ( VAR_154 - VAR_132 ) >= VAR_97 <S2SV_ModEnd> ) { struct,"CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ;  ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ;   unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) {  ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ;   unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; }  ifdef CONFIG_TRANSPARENT_HUGEPAGE <S2SV_StartBug> if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { <S2SV_EndBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; }   if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ;  ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; <S2SV_StartBug> while ( i < npages ) { <S2SV_EndBug> struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; }   spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }",<S2SV_ModStart> & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModStart> ; while ( ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModEnd> ) { struct
395,"CWE-000 asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }","CWE-000 asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }"
396,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 ) { METHOD_1 ( ""ENABLE<S2SV_blank>BT"" ) ; if ( VAR_0 ) { METHOD_2 ( ""Bluetooth<S2SV_blank>is<S2SV_blank>already<S2SV_blank>enabled"" ) ; return ; } <S2SV_StartBug> VAR_1 = VAR_2 -> METHOD_3 ( ) ; <S2SV_EndBug> METHOD_4 ( VAR_3 ) ; }",<S2SV_ModStart> -> METHOD_3 ( VAR_4,"CWE-20 void bdt_enable ( void ) { bdt_log ( ""ENABLE<S2SV_blank>BT"" ) ; if ( bt_enabled ) { bdt_log ( ""Bluetooth<S2SV_blank>is<S2SV_blank>already<S2SV_blank>enabled"" ) ; return ; } <S2SV_StartBug> status = sBtInterface -> enable ( ) ; <S2SV_EndBug> check_return_status ( status ) ; }",<S2SV_ModStart> -> enable ( false
397,"CWE-125 static TYPE_0 <S2SV_StartBug> METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( VAR_4 > VAR_5 ) return 0 ; return ( METHOD_1 ( VAR_6 , VAR_7 , VAR_8 ) == 0 ? 1 : 0 ) ; }","<S2SV_ModStart> TYPE_0 METHOD_0 ( TYPE_5 * VAR_9 , <S2SV_ModStart> VAR_5 ) { if ( ! METHOD_2 ( * VAR_7 , VAR_8 ) ) { return 0 ; }","CWE-125 static int <S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }","<S2SV_ModStart> int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }"
398,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , const struct STRUCT_OR_UNION_1 * VAR_4 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = METHOD_1 ( VAR_5 -> VAR_6 ) ; struct STRUCT_OR_UNION_4 * VAR_7 = VAR_8 ; struct STRUCT_OR_UNION_5 * VAR_9 = METHOD_2 ( VAR_10 ) ; struct STRUCT_OR_UNION_6 * VAR_11 ; struct STRUCT_OR_UNION_7 * VAR_12 ; const struct STRUCT_OR_UNION_8 * VAR_13 = VAR_14 ; struct STRUCT_OR_UNION_9 * VAR_15 ; struct STRUCT_OR_UNION_10 VAR_16 ; struct STRUCT_OR_UNION_11 VAR_17 ; struct STRUCT_OR_UNION_12 VAR_18 ; struct STRUCT_OR_UNION_13 VAR_19 = { 0 } ; struct STRUCT_OR_UNION_14 VAR_20 ; TYPE_4 VAR_21 = 0 ; TYPE_5 VAR_22 = 0 ; TYPE_6 VAR_23 ; TYPE_7 VAR_24 = 0 ; TYPE_8 VAR_25 = METHOD_3 ( STRUCT_OR_UNION_15 , VAR_26 -> VAR_27 ) ; if ( ( TYPE_9 * ) VAR_28 < VAR_29 -> VAR_30 || ( METHOD_4 ( VAR_31 ) + sizeof ( * VAR_32 ) ) > METHOD_5 ( VAR_33 ) ) return ; VAR_34 = METHOD_6 ( & VAR_35 -> VAR_36 ) ; if ( METHOD_7 ( STRUCT_OR_UNION_16 , & VAR_37 -> VAR_38 , VAR_39 -> VAR_40 , 0 ) || METHOD_8 ( STRUCT_OR_UNION_17 , VAR_41 -> VAR_42 , & VAR_43 -> VAR_44 ) ) VAR_45 = & VAR_46 -> VAR_47 ; if ( VAR_48 & VAR_49 || VAR_50 -> VAR_51 != VAR_52 ) { if ( VAR_53 != VAR_54 && ! ( VAR_55 == VAR_56 && VAR_57 == VAR_58 && ( METHOD_9 ( VAR_59 , VAR_60 ) ) ) ) return ; VAR_61 = VAR_62 ; } VAR_63 = METHOD_10 ( & VAR_64 -> VAR_65 ) ; if ( METHOD_11 ( VAR_66 ) ) VAR_67 = VAR_68 -> VAR_69 -> VAR_70 ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> VAR_71 = METHOD_12 ( METHOD_13 ( VAR_72 ) -> VAR_73 ) ; <S2SV_EndBug> if ( ( VAR_74 == VAR_75 ) || ( VAR_76 & VAR_77 ) ) { METHOD_14 ( ""icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & VAR_78 -> VAR_79 , & VAR_80 -> VAR_81 ) ; return ; } if ( METHOD_15 ( VAR_82 ) ) { METHOD_16 ( ""icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & VAR_83 -> VAR_84 , & VAR_85 -> VAR_86 ) ; return ; } METHOD_17 ( VAR_87 ) ; METHOD_18 ( & VAR_88 , 0 , sizeof ( VAR_89 ) ) ; VAR_90 . VAR_91 = VAR_92 ; VAR_93 . VAR_94 = VAR_95 -> VAR_96 ; if ( VAR_97 ) VAR_98 = VAR_99 ; if ( VAR_100 ) VAR_101 . VAR_102 = * VAR_103 ; VAR_104 . VAR_105 = VAR_106 ; VAR_107 . VAR_108 = VAR_109 ; VAR_110 . VAR_111 = VAR_112 ; VAR_113 . VAR_114 = VAR_115 ; METHOD_19 ( VAR_116 , METHOD_20 ( & VAR_117 ) ) ; VAR_118 = METHOD_21 ( STRUCT_OR_UNION_18 ) ; if ( ! VAR_119 ) return ; VAR_120 -> VAR_121 = VAR_122 ; VAR_123 = METHOD_22 ( VAR_124 ) ; if ( ! METHOD_23 ( VAR_125 , VAR_126 , & VAR_127 ) ) goto VAR_128 ; VAR_129 . VAR_130 = VAR_131 ; VAR_132 . VAR_133 = VAR_134 ; VAR_135 . VAR_136 = 0 ; VAR_137 . VAR_138 = METHOD_24 ( VAR_139 ) ; if ( ! VAR_140 . VAR_141 && METHOD_25 ( & VAR_142 . VAR_143 ) ) VAR_144 . VAR_145 = VAR_146 -> VAR_147 ; else if ( ! VAR_148 . VAR_149 ) VAR_150 . VAR_151 = VAR_152 -> VAR_153 ; VAR_154 . VAR_155 = VAR_156 -> VAR_157 ; VAR_158 . VAR_159 = METHOD_26 ( VAR_160 . VAR_161 , VAR_162 . VAR_163 ) ; VAR_164 = METHOD_27 ( STRUCT_OR_UNION_19 , VAR_165 , VAR_166 , & VAR_167 ) ; if ( METHOD_28 ( VAR_168 ) ) goto VAR_169 ; VAR_170 . VAR_171 = METHOD_29 ( VAR_172 , & VAR_173 , VAR_174 ) ; VAR_175 . VAR_176 = VAR_177 -> VAR_178 ; VAR_179 . VAR_180 = VAR_181 ; VAR_182 . VAR_183 = VAR_184 ; VAR_185 . VAR_186 = METHOD_30 ( VAR_187 ) ; VAR_188 . VAR_189 = VAR_190 ; VAR_191 = VAR_192 -> VAR_193 - VAR_194 . VAR_195 ; VAR_196 = min_t ( unsigned TYPE_10 , VAR_197 , VAR_198 - sizeof ( struct STRUCT_OR_UNION_20 ) - sizeof ( struct STRUCT_OR_UNION_21 ) ) ; if ( VAR_199 < 0 ) { METHOD_31 ( ""icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & VAR_200 -> VAR_201 , & VAR_202 -> VAR_203 ) ; goto VAR_204 ; } METHOD_32 ( ) ; VAR_205 = METHOD_33 ( VAR_206 -> VAR_207 ) ; VAR_208 = METHOD_34 ( VAR_209 , VAR_210 , & VAR_211 , VAR_212 + sizeof ( struct STRUCT_OR_UNION_22 ) , sizeof ( struct STRUCT_OR_UNION_23 ) , & VAR_213 , & VAR_214 , ( struct STRUCT_OR_UNION_24 * ) VAR_215 , VAR_216 , & VAR_217 ) ; if ( VAR_218 ) { METHOD_35 ( STRUCT_OR_UNION_25 , VAR_219 , VAR_220 ) ; METHOD_36 ( VAR_221 ) ; } else { VAR_222 = METHOD_37 ( VAR_223 , & VAR_224 , & VAR_225 , VAR_226 + sizeof ( struct STRUCT_OR_UNION_26 ) ) ; } METHOD_38 ( ) ; VAR_227 : METHOD_39 ( VAR_228 ) ; VAR_229 : METHOD_40 ( VAR_230 ) ; }",<S2SV_ModStart> VAR_70 ; else { VAR_228 = METHOD_13 ( VAR_206 ) ; <S2SV_ModStart> = METHOD_12 ( VAR_228 ? VAR_228 -> VAR_207 : VAR_206 -> VAR_207 ) ; } <S2SV_ModEnd> if ( (,"CWE-20 static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( ""icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }",<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
399,"CWE-125 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) <S2SV_EndBug> { if ( VAR_2 -> VAR_3 > 0 ) { <S2SV_StartBug> if ( ( VAR_4 -> VAR_5 + VAR_6 -> VAR_7 ) > METHOD_1 ( VAR_8 ) ) <S2SV_EndBug> return - 1 ; VAR_9 -> VAR_10 = ( TYPE_3 ) METHOD_2 ( VAR_11 -> VAR_12 ) ; if ( ! VAR_13 -> VAR_14 ) return - 1 ; METHOD_3 ( VAR_15 , VAR_16 -> VAR_17 ) ; METHOD_4 ( VAR_18 , VAR_19 -> VAR_20 , VAR_21 -> VAR_22 ) ; } return 1 ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 0 ) { const TYPE_4 VAR_23 = ( TYPE_4 ) <S2SV_ModEnd> VAR_21 -> VAR_17 <S2SV_ModStart> -> VAR_17 + ( TYPE_4 ) <S2SV_ModStart> VAR_21 -> VAR_22 ; if ( VAR_23 <S2SV_ModEnd> > METHOD_1 (,"CWE-125 <S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 0 ) { const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> fields -> BufferOffset <S2SV_ModStart> -> BufferOffset + ( UINT64 ) <S2SV_ModStart> fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length (
400,"CWE-59 static TYPE_0 METHOD_0 ( TYPE_1 ) { TYPE_2 * VAR_0 = METHOD_1 ( VAR_1 -> VAR_2 ) ; struct STRUCT_OR_UNION_0 VAR_3 ; VAR_4 * VAR_5 ; TYPE_3 VAR_6 ; if ( ! VAR_7 -> VAR_8 ) { METHOD_2 ( VAR_9 , ""No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing"" , VAR_10 -> VAR_11 ) ; METHOD_3 ( VAR_12 -> VAR_13 , VAR_14 -> VAR_15 -> VAR_16 ) ; return ; } if ( VAR_17 == VAR_18 ) return ; VAR_19 = STRUCT_OR_UNION_1 ( VAR_20 -> VAR_21 , & VAR_22 ) ; if ( ! VAR_23 ) { if ( VAR_24 == VAR_25 ) { return ; } if ( ( VAR_26 . VAR_27 & VAR_28 ) != VAR_29 ) { METHOD_4 ( VAR_30 , ""Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , VAR_31 -> VAR_32 ) ; return ; } if ( VAR_33 ) return ; } if ( ! METHOD_5 ( VAR_34 , & VAR_35 ) ) { <S2SV_StartBug> if ( ( VAR_36 = METHOD_6 ( VAR_37 -> VAR_38 , ""w"" ) ) ) { <S2SV_EndBug> METHOD_7 ( VAR_39 , ""%d\\n"" , VAR_40 ) ; METHOD_8 ( VAR_41 ) ; } else METHOD_9 ( VAR_42 , ""Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s"" , VAR_43 -> VAR_44 ) ; } }",<S2SV_ModStart> ( VAR_41 = METHOD_10 <S2SV_ModEnd> ( VAR_43 ->,"CWE-59 static void vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , ""No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing"" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , ""Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { <S2SV_EndBug> fprintf ( tf , ""%d\\n"" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , ""Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s"" , tfile -> fname ) ; } }",<S2SV_ModStart> ( tf = fopen_safe <S2SV_ModEnd> ( tfile ->
401,"CWE-119 TYPE_0 <S2SV_StartBug> METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * * VAR_1 , TYPE_3 * VAR_2 ) <S2SV_EndBug> { struct STRUCT_OR_UNION_0 * VAR_3 ; <S2SV_StartBug> VAR_4 = ( struct STRUCT_OR_UNION_1 * ) * VAR_5 ; <S2SV_EndBug> <S2SV_StartBug> * VAR_6 = METHOD_1 ( VAR_7 -> VAR_8 ) ; <S2SV_EndBug> * VAR_9 = VAR_10 -> VAR_11 ; * VAR_12 = VAR_13 -> VAR_14 - 2 ; <S2SV_StartBug> return ( VAR_15 -> VAR_16 ) ; <S2SV_EndBug> }","<S2SV_ModStart> TYPE_1 * VAR_6 , unsigned TYPE_4 * VAR_17 <S2SV_ModStart> TYPE_3 * VAR_12 , const TYPE_2 * VAR_18 , TYPE_3 VAR_19 <S2SV_ModStart> * VAR_15 ; if ( VAR_19 < sizeof ( struct STRUCT_OR_UNION_1 ) ) { return - 1 ; } <S2SV_ModStart> STRUCT_OR_UNION_1 * ) VAR_18 <S2SV_ModEnd> ; * VAR_6 <S2SV_ModStart> -> VAR_8 ) ; * VAR_17 = VAR_15 -> VAR_16 <S2SV_ModStart> - 2 ; if ( ( VAR_15 -> VAR_14 + 4 ) > VAR_19 ) { return - 1 ; }","CWE-119 int <S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> { struct vendor_attribute * attr ; <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> * data = attr -> attrib_data ; * len = attr -> attrib_len - 2 ; <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> }","<S2SV_ModStart> u_int32_t * vendor , unsigned char * type <S2SV_ModStart> size_t * len , const void * raw , size_t raw_len <S2SV_ModStart> * attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> vendor_attribute * ) raw <S2SV_ModEnd> ; * vendor <S2SV_ModStart> -> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> - 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }"
402,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 TYPE_1 * VAR_0 ) { struct STRUCT_OR_UNION_3 * VAR_1 ; struct STRUCT_OR_UNION_4 VAR_2 ; TYPE_2 VAR_3 [ 32 ] ; TYPE_3 VAR_4 = 0 ; VAR_5 = STRUCT_OR_UNION_5 -> VAR_6 ; <S2SV_StartBug> METHOD_1 ( & VAR_7 -> VAR_8 ) ; <S2SV_EndBug> if ( VAR_9 -> VAR_10 ) { METHOD_2 ( VAR_11 -> VAR_12 ) ; VAR_13 -> VAR_14 = VAR_15 ; } if ( METHOD_3 ( & VAR_16 , VAR_17 , sizeof ( VAR_18 ) ) ) { VAR_19 = - VAR_20 ; goto VAR_21 ; } METHOD_4 ( VAR_22 , ""application<S2SV_blank>%i"" , VAR_23 -> VAR_24 ) ; if ( VAR_25 . VAR_26 . VAR_27 != VAR_28 ) VAR_29 . VAR_30 . VAR_31 = VAR_32 ; VAR_33 = METHOD_5 ( & VAR_34 -> VAR_35 , VAR_36 , & VAR_37 . VAR_38 , VAR_39 -> VAR_40 ) ; if ( VAR_41 < 0 ) goto VAR_42 ; METHOD_6 ( VAR_43 -> VAR_44 ) ; VAR_45 -> VAR_46 = VAR_47 ; METHOD_7 ( VAR_48 -> VAR_49 ) ; VAR_50 -> VAR_51 = VAR_52 ; if ( VAR_53 -> VAR_54 ) { VAR_55 -> VAR_56 = METHOD_8 ( VAR_57 -> VAR_58 * sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_59 ) ; if ( VAR_60 -> VAR_61 == VAR_62 ) VAR_63 = - VAR_64 ; } else { VAR_65 -> VAR_66 = METHOD_9 ( VAR_67 -> VAR_68 * sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_69 ) ; if ( VAR_70 -> VAR_71 == VAR_72 ) VAR_73 = - VAR_74 ; } if ( VAR_75 < 0 ) { METHOD_10 ( VAR_76 -> VAR_77 ) ; VAR_78 -> VAR_79 = VAR_80 ; } else { VAR_81 -> VAR_82 -> VAR_83 |= VAR_84 ; VAR_85 -> VAR_86 -> VAR_87 = VAR_88 -> VAR_89 ? VAR_90 : VAR_91 ; VAR_92 -> VAR_93 -> VAR_94 = VAR_95 ; VAR_96 -> VAR_97 -> VAR_98 = ( TYPE_4 * ) VAR_99 ; } VAR_100 : <S2SV_StartBug> METHOD_11 ( & VAR_101 -> VAR_102 ) ; <S2SV_EndBug> return VAR_103 ; }",<S2SV_ModStart> -> VAR_6 ; <S2SV_ModEnd> if ( VAR_101 <S2SV_ModStart> } VAR_100 : <S2SV_ModEnd> return VAR_103 ;,"CWE-362 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }",<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;
403,"CWE-20 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 [ VAR_3 ] , VAR_4 [ VAR_5 ] , VAR_6 [ VAR_7 ] , VAR_8 [ VAR_9 ] ; TYPE_4 * VAR_10 ; TYPE_5 * VAR_11 ; TYPE_6 * VAR_12 , VAR_13 , * VAR_14 , * VAR_15 , VAR_16 , * VAR_17 ; TYPE_7 VAR_18 , VAR_19 , VAR_20 , VAR_21 , VAR_22 ; TYPE_8 VAR_23 ; TYPE_9 * VAR_24 ; register TYPE_10 VAR_25 , VAR_26 ; register TYPE_11 * VAR_27 ; register unsigned TYPE_12 * VAR_28 ; TYPE_13 VAR_29 , VAR_30 , VAR_31 , VAR_32 , VAR_33 , VAR_34 , VAR_35 , VAR_36 , VAR_37 , VAR_38 , VAR_39 , VAR_40 , VAR_41 , VAR_42 , VAR_43 , VAR_44 ; TYPE_14 VAR_45 , VAR_46 , VAR_47 , VAR_48 , VAR_49 , VAR_50 ; unsigned TYPE_15 * VAR_51 ; unsigned TYPE_16 VAR_52 , VAR_53 ; METHOD_1 ( VAR_54 != ( const TYPE_17 * ) VAR_55 ) ; METHOD_2 ( VAR_56 -> VAR_57 == VAR_58 ) ; if ( VAR_59 -> VAR_60 != VAR_61 ) ( TYPE_18 ) METHOD_3 ( VAR_62 , METHOD_4 ( ) , ""%s"" , VAR_63 -> VAR_64 ) ; METHOD_5 ( VAR_65 != ( TYPE_19 * ) VAR_66 ) ; METHOD_6 ( VAR_67 -> VAR_68 == VAR_69 ) ; VAR_70 = METHOD_7 ( VAR_71 , VAR_72 ) ; VAR_73 = METHOD_8 ( VAR_74 , VAR_75 , VAR_76 , VAR_77 ) ; if ( VAR_78 == VAR_79 ) { VAR_80 = METHOD_9 ( VAR_81 ) ; return ( ( TYPE_20 * ) VAR_82 ) ; } VAR_83 -> VAR_84 = 8UL ; VAR_85 -> VAR_86 = VAR_87 ; VAR_88 = ( TYPE_21 * ) METHOD_10 ( sizeof ( * VAR_89 ) ) ; if ( VAR_90 == ( TYPE_22 * ) VAR_91 ) METHOD_11 ( VAR_92 , ""MemoryAllocationFailed"" ) ; ( TYPE_23 ) METHOD_12 ( VAR_93 , 0 , sizeof ( * VAR_94 ) ) ; VAR_95 = METHOD_13 ( VAR_96 , 128 , ( unsigned TYPE_24 * ) VAR_97 ) ; if ( VAR_98 != 128 ) METHOD_14 ( VAR_99 , ""ImproperImageHeader"" ) ; VAR_100 = METHOD_15 ( VAR_101 , 4 , ( unsigned TYPE_25 * ) VAR_102 ) ; if ( ( VAR_103 != 4 ) || ( METHOD_16 ( VAR_104 , ""DICM"" , 4 ) != 0 ) ) { VAR_105 = METHOD_17 ( VAR_106 , 0L , VAR_107 ) ; if ( VAR_108 < 0 ) METHOD_18 ( VAR_109 , ""ImproperImageHeader"" ) ; } ( TYPE_26 ) METHOD_19 ( VAR_110 , ""MONOCHROME1<S2SV_blank>"" , VAR_111 ) ; VAR_112 = 8 ; VAR_113 = 1 ; VAR_114 = VAR_115 ; VAR_116 = ( unsigned TYPE_27 * ) VAR_117 ; VAR_118 = 8 ; VAR_119 = 0 ; VAR_120 [ 2 ] = '\\0' ; VAR_121 = VAR_122 ; VAR_123 = 0 ; VAR_124 = ( TYPE_28 * ) VAR_125 ; VAR_126 = ( TYPE_29 * ) VAR_127 ; VAR_128 = ( TYPE_30 * ) VAR_129 ; VAR_130 = ( TYPE_31 * ) VAR_131 ; VAR_132 = 0 ; VAR_133 = 255UL ; VAR_134 = 0xffff ; VAR_135 = 1 ; VAR_136 = 0 ; VAR_137 = 1 ; VAR_138 = 1 ; VAR_139 = ( TYPE_32 * ) VAR_140 ; VAR_141 = VAR_142 ; VAR_143 = ( ~ 0UL ) ; VAR_144 = 0 ; VAR_145 = VAR_146 ; VAR_147 = VAR_148 ; VAR_149 = 0 ; VAR_150 = 0 ; VAR_151 = 0 ; for ( VAR_152 = 0 ; ( VAR_153 != 0x7FE0 ) || ( VAR_154 != 0x0010 ) || ( VAR_155 != VAR_156 ) ; ) { VAR_157 -> VAR_158 = ( TYPE_33 ) METHOD_20 ( VAR_159 ) ; VAR_160 = METHOD_21 ( VAR_161 ) ; VAR_162 = METHOD_22 ( VAR_163 ) ; if ( ( VAR_164 != 0x0002 ) && ( VAR_165 -> VAR_166 == VAR_167 ) ) { VAR_168 = ( unsigned TYPE_34 ) ( ( VAR_169 << 8 ) | ( ( VAR_170 >> 8 ) & 0xFF ) ) ; VAR_171 = ( unsigned TYPE_35 ) ( ( VAR_172 << 8 ) | ( ( VAR_173 >> 8 ) & 0xFF ) ) ; } VAR_174 = 0 ; for ( VAR_175 = 0 ; VAR_176 [ VAR_177 ] . VAR_178 < 0xffff ; VAR_179 ++ ) if ( ( VAR_180 == VAR_181 [ VAR_182 ] . VAR_183 ) && ( VAR_184 == VAR_185 [ VAR_186 ] . VAR_187 ) ) break ; ( TYPE_36 ) METHOD_23 ( VAR_188 , VAR_189 [ VAR_190 ] . VAR_191 , VAR_192 ) ; VAR_193 = METHOD_24 ( VAR_194 , 2 , ( unsigned TYPE_37 * ) VAR_195 ) ; if ( VAR_196 != 2 ) METHOD_25 ( VAR_197 , ""ImproperImageHeader"" ) ; if ( ( VAR_198 == VAR_199 ) && ( VAR_200 != 0x0002 ) ) VAR_201 = ( METHOD_26 ( ( unsigned TYPE_38 ) * VAR_202 ) != VAR_203 ) && ( METHOD_27 ( ( unsigned TYPE_39 ) * ( VAR_204 + 1 ) ) != VAR_205 ) ? VAR_206 : VAR_207 ; VAR_208 = ( ( VAR_209 == 0x0002 ) && ( VAR_210 == VAR_211 ) ) || ( VAR_212 != VAR_213 ) ? VAR_214 : VAR_215 ; if ( ( VAR_216 != VAR_217 ) && ( METHOD_28 ( VAR_218 , ""xs"" , 2 ) == 0 ) ) ( TYPE_40 ) METHOD_29 ( VAR_219 , VAR_220 , VAR_221 ) ; if ( ( VAR_222 == VAR_223 ) || ( METHOD_30 ( VAR_224 , ""!!"" , 2 ) == 0 ) ) { VAR_225 = METHOD_31 ( VAR_226 , ( TYPE_41 ) - 2 , VAR_227 ) ; if ( VAR_228 < 0 ) METHOD_32 ( VAR_229 , ""ImproperImageHeader"" ) ; VAR_230 = 4 ; } else { VAR_231 = 2 ; if ( ( METHOD_33 ( VAR_232 , ""OB"" , 2 ) == 0 ) || ( METHOD_34 ( VAR_233 , ""UN"" , 2 ) == 0 ) || ( METHOD_35 ( VAR_234 , ""OW"" , 2 ) == 0 ) || ( METHOD_36 ( VAR_235 , ""SQ"" , 2 ) == 0 ) ) { ( TYPE_42 ) METHOD_37 ( VAR_236 ) ; VAR_237 = 4 ; } } VAR_238 = 0 ; if ( VAR_239 == 4 ) { if ( VAR_240 == 0x0002 ) VAR_241 = METHOD_38 ( VAR_242 ) ; else VAR_243 = METHOD_39 ( VAR_244 ) ; } else if ( VAR_245 == 2 ) { if ( VAR_246 == 0x0002 ) VAR_247 = METHOD_40 ( VAR_248 ) ; else VAR_249 = METHOD_41 ( VAR_250 ) ; } VAR_251 = 0 ; VAR_252 = 1 ; if ( VAR_253 != 0 ) { if ( ( METHOD_42 ( VAR_254 , ""SS"" , 2 ) == 0 ) || ( METHOD_43 ( VAR_255 , ""US"" , 2 ) == 0 ) ) VAR_256 = 2 ; else if ( ( METHOD_44 ( VAR_257 , ""UL"" , 2 ) == 0 ) || ( METHOD_45 ( VAR_258 , ""SL"" , 2 ) == 0 ) || ( METHOD_46 ( VAR_259 , ""FL"" , 2 ) == 0 ) ) VAR_260 = 4 ; else if ( METHOD_47 ( VAR_261 , ""FD"" , 2 ) != 0 ) VAR_262 = 1 ; else VAR_263 = 8 ; if ( VAR_264 != ~ 0 ) VAR_265 = ( TYPE_43 ) VAR_266 / VAR_267 ; else { VAR_268 = 0 ; VAR_269 = 0 ; } } if ( VAR_270 -> VAR_271 != VAR_272 ) { if ( VAR_273 == VAR_274 ) VAR_275 [ 0 ] = '\\0' ; for ( VAR_276 = 0 ; VAR_277 [ VAR_278 ] . VAR_279 != ( TYPE_44 * ) VAR_280 ; VAR_281 ++ ) if ( ( VAR_282 == VAR_283 [ VAR_284 ] . VAR_285 ) && ( VAR_286 == VAR_287 [ VAR_288 ] . VAR_289 ) ) break ; ( TYPE_45 ) METHOD_48 ( VAR_290 , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned TYPE_46 ) VAR_291 -> VAR_292 , ( TYPE_47 ) VAR_293 , VAR_294 , VAR_295 , ( unsigned TYPE_48 ) VAR_296 , ( unsigned TYPE_49 ) VAR_297 ) ; if ( VAR_298 [ VAR_299 ] . VAR_300 != ( TYPE_50 * ) VAR_301 ) ( TYPE_51 ) METHOD_49 ( VAR_302 , ""<S2SV_blank>%s"" , VAR_303 [ VAR_304 ] . VAR_305 ) ; ( TYPE_52 ) METHOD_50 ( VAR_306 , "":<S2SV_blank>"" ) ; } if ( ( VAR_307 == VAR_308 ) && ( VAR_309 == 0x7FE0 ) && ( VAR_310 == 0x0010 ) ) { if ( VAR_311 -> VAR_312 != VAR_313 ) ( TYPE_53 ) METHOD_51 ( VAR_314 , ""\\n"" ) ; break ; } VAR_315 = ( unsigned TYPE_54 * ) VAR_316 ; if ( ( VAR_317 == 1 ) && ( VAR_318 == 1 ) ) VAR_319 = METHOD_52 ( VAR_320 ) ; else if ( ( VAR_321 == 1 ) && ( VAR_322 == 2 ) ) { if ( VAR_323 == 0x0002 ) VAR_324 = METHOD_53 ( VAR_325 ) ; else VAR_326 = METHOD_54 ( VAR_327 ) ; } else if ( ( VAR_328 == 1 ) && ( VAR_329 == 4 ) ) { if ( VAR_330 == 0x0002 ) VAR_331 = METHOD_55 ( VAR_332 ) ; else VAR_333 = METHOD_56 ( VAR_334 ) ; } else if ( ( VAR_335 != 0 ) && ( VAR_336 != 0 ) ) { if ( ~ VAR_337 >= 1 ) VAR_338 = ( unsigned TYPE_55 * ) METHOD_57 ( VAR_339 + 1 , VAR_340 * sizeof ( * VAR_341 ) ) ; if ( VAR_342 == ( unsigned TYPE_56 * ) VAR_343 ) METHOD_58 ( VAR_344 , ""MemoryAllocationFailed"" ) ; VAR_345 = METHOD_59 ( VAR_346 , ( TYPE_57 ) VAR_347 * VAR_348 , VAR_349 ) ; if ( VAR_350 != ( TYPE_58 ) ( VAR_351 * VAR_352 ) ) { if ( VAR_353 -> VAR_354 != VAR_355 ) ( TYPE_59 ) METHOD_60 ( VAR_356 , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( TYPE_60 ) VAR_357 , ( TYPE_61 ) VAR_358 , ( TYPE_62 ) VAR_359 , ( TYPE_63 ) VAR_360 ) ; METHOD_61 ( VAR_361 , ""InsufficientImageDataInFile"" ) ; } VAR_362 [ VAR_363 * VAR_364 ] = '\\0' ; } else if ( ( unsigned TYPE_64 ) VAR_365 == 0xFFFFFFFFU ) { VAR_366 = VAR_367 ; continue ; } if ( ( unsigned TYPE_65 ) ( ( VAR_368 << 16 ) | VAR_369 ) == 0xFFFEE0DD ) { if ( VAR_370 != ( unsigned TYPE_66 * ) VAR_371 ) VAR_372 = ( unsigned TYPE_67 * ) METHOD_62 ( VAR_373 ) ; VAR_374 = VAR_375 ; continue ; } if ( VAR_376 != VAR_377 ) { if ( VAR_378 != ( unsigned TYPE_68 * ) VAR_379 ) VAR_380 = ( unsigned TYPE_69 * ) METHOD_63 ( VAR_381 ) ; continue ; } switch ( VAR_382 ) { case 0x0002 : { switch ( VAR_383 ) { case 0x0010 : { TYPE_70 VAR_384 [ VAR_385 ] ; if ( ( VAR_386 == 0 ) && ( VAR_387 == VAR_388 ) ) { VAR_389 = VAR_390 ; ( TYPE_71 ) METHOD_64 ( VAR_391 , ( TYPE_72 ) 0 , VAR_392 ) ; VAR_393 = 0 ; VAR_394 = 0 ; if ( VAR_395 -> VAR_396 != VAR_397 ) ( TYPE_73 ) METHOD_65 ( VAR_398 , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * VAR_399 = '\\0' ; if ( VAR_400 != ( unsigned TYPE_74 * ) VAR_401 ) ( TYPE_75 ) METHOD_66 ( VAR_402 , ( TYPE_76 * ) VAR_403 , VAR_404 ) ; if ( VAR_405 -> VAR_406 != VAR_407 ) ( TYPE_77 ) METHOD_67 ( VAR_408 , ""transfer_syntax=%s\\n"" , ( const TYPE_78 * ) VAR_409 ) ; if ( METHOD_68 ( VAR_410 , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { TYPE_79 VAR_411 , VAR_412 , VAR_413 ; VAR_414 = 1 ; VAR_415 = 0 ; if ( METHOD_69 ( VAR_416 ) > 17 ) { VAR_417 = METHOD_70 ( VAR_418 + 17 , "".%d.%d"" , & VAR_419 , & VAR_420 ) ; if ( VAR_421 < 1 ) METHOD_71 ( VAR_422 , ""ImproperImageHeader"" ) ; } switch ( VAR_423 ) { case 1 : { VAR_424 -> VAR_425 = VAR_426 ; break ; } case 2 : { VAR_427 -> VAR_428 = VAR_429 ; break ; } case 4 : { if ( ( VAR_430 >= 80 ) && ( VAR_431 <= 81 ) ) VAR_432 -> VAR_433 = VAR_434 ; else if ( ( VAR_435 >= 90 ) && ( VAR_436 <= 93 ) ) VAR_437 -> VAR_438 = VAR_439 ; else VAR_440 -> VAR_441 = VAR_442 ; break ; } case 5 : { VAR_443 -> VAR_444 = VAR_445 ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( VAR_446 ) { case 0x0002 : { VAR_447 = ( TYPE_80 ) VAR_448 ; break ; } case 0x0004 : { <S2SV_StartBug> for ( VAR_449 = 0 ; VAR_450 < ( TYPE_81 ) METHOD_72 ( VAR_451 , VAR_452 - 1 ) ; VAR_453 ++ ) <S2SV_EndBug> VAR_454 [ VAR_455 ] = ( TYPE_82 ) VAR_456 [ VAR_457 ] ; VAR_458 [ VAR_459 ] = '\\0' ; VAR_460 = METHOD_73 ( VAR_461 , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? VAR_462 : VAR_463 ; break ; } case 0x0006 : { if ( VAR_464 == 1 ) VAR_465 -> VAR_466 = VAR_467 ; break ; } case 0x0008 : <S2SV_StartBug> { <S2SV_EndBug> VAR_468 = METHOD_74 ( ( TYPE_83 * ) VAR_469 ) ; break ; } case 0x0010 : { VAR_470 = ( TYPE_84 ) VAR_471 ; break ; } case 0x0011 : { VAR_472 = ( TYPE_85 ) VAR_473 ; break ; } case 0x0100 : { VAR_474 = ( TYPE_86 ) VAR_475 ; VAR_476 = 1 ; if ( VAR_477 > 8 ) VAR_478 = 2 ; VAR_479 = VAR_480 ; if ( VAR_481 > 32 ) METHOD_75 ( VAR_482 , ""ImproperImageHeader"" ) ; VAR_483 = ( 1UL << VAR_484 ) - 1 ; break ; } case 0x0101 : { VAR_485 = ( TYPE_87 ) VAR_486 ; VAR_487 = 1 ; if ( VAR_488 > 8 ) VAR_489 = 2 ; VAR_490 = VAR_491 ; if ( VAR_492 > 32 ) METHOD_76 ( VAR_493 , ""ImproperImageHeader"" ) ; VAR_494 = ( 1UL << VAR_495 ) - 1 ; VAR_496 = ( TYPE_88 ) METHOD_77 ( VAR_497 ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { VAR_498 = ( TYPE_89 ) VAR_499 ; break ; } case 0x1050 : { if ( VAR_500 != ( unsigned TYPE_90 * ) VAR_501 ) VAR_502 = ( TYPE_91 ) METHOD_78 ( ( TYPE_92 * ) VAR_503 ) ; break ; } case 0x1051 : { if ( VAR_504 != ( unsigned TYPE_93 * ) VAR_505 ) VAR_506 = METHOD_79 ( ( TYPE_94 * ) VAR_507 ) ; break ; } case 0x1052 : { if ( VAR_508 != ( unsigned TYPE_95 * ) VAR_509 ) VAR_510 = ( TYPE_96 ) METHOD_80 ( ( TYPE_97 * ) VAR_511 ) ; break ; } case 0x1053 : { if ( VAR_512 != ( unsigned TYPE_98 * ) VAR_513 ) VAR_514 = ( TYPE_99 ) METHOD_81 ( ( TYPE_100 * ) VAR_515 ) ; break ; } case 0x1200 : case 0x3006 : { if ( VAR_516 == ( unsigned TYPE_101 * ) VAR_517 ) break ; VAR_518 = ( TYPE_102 ) ( VAR_519 / VAR_520 ) ; VAR_521 = ( TYPE_103 ) VAR_522 ; VAR_523 = ( TYPE_104 * ) METHOD_82 ( ( TYPE_105 ) VAR_524 , sizeof ( * VAR_525 ) ) ; if ( VAR_526 == ( TYPE_106 * ) VAR_527 ) METHOD_83 ( VAR_528 , ""MemoryAllocationFailed"" ) ; for ( VAR_529 = 0 ; VAR_530 < ( TYPE_107 ) VAR_531 ; VAR_532 ++ ) if ( VAR_533 == 1 ) VAR_534 [ VAR_535 ] = ( TYPE_108 ) VAR_536 [ VAR_537 ] ; else VAR_538 [ VAR_539 ] = ( TYPE_109 ) ( ( TYPE_110 * ) VAR_540 ) [ VAR_541 ] ; break ; } case 0x1201 : { unsigned TYPE_111 VAR_542 ; if ( VAR_543 == ( unsigned TYPE_112 * ) VAR_544 ) break ; VAR_545 = ( TYPE_113 ) ( VAR_546 / 2 ) ; VAR_547 = ( TYPE_114 ) VAR_548 ; VAR_549 = ( TYPE_115 * ) METHOD_84 ( ( TYPE_116 ) VAR_550 , sizeof ( * VAR_551 ) ) ; if ( VAR_552 == ( TYPE_117 * ) VAR_553 ) METHOD_85 ( VAR_554 , ""MemoryAllocationFailed"" ) ; VAR_555 = VAR_556 ; for ( VAR_557 = 0 ; VAR_558 < ( TYPE_118 ) VAR_559 ; VAR_560 ++ ) { if ( VAR_561 -> VAR_562 == VAR_563 ) VAR_564 = ( unsigned TYPE_119 ) ( ( * VAR_565 << 8 ) | * ( VAR_566 + 1 ) ) ; else VAR_567 = ( unsigned TYPE_120 ) ( * VAR_568 | ( * ( VAR_569 + 1 ) << 8 ) ) ; VAR_570 [ VAR_571 ] = ( TYPE_121 ) VAR_572 ; VAR_573 += 2 ; } break ; } case 0x1202 : { unsigned TYPE_122 VAR_574 ; if ( VAR_575 == ( unsigned TYPE_123 * ) VAR_576 ) break ; VAR_577 = ( TYPE_124 ) ( VAR_578 / 2 ) ; VAR_579 = ( TYPE_125 ) VAR_580 ; VAR_581 = ( TYPE_126 * ) METHOD_86 ( ( TYPE_127 ) VAR_582 , sizeof ( * VAR_583 ) ) ; if ( VAR_584 == ( TYPE_128 * ) VAR_585 ) METHOD_87 ( VAR_586 , ""MemoryAllocationFailed"" ) ; VAR_587 = VAR_588 ; for ( VAR_589 = 0 ; VAR_590 < ( TYPE_129 ) VAR_591 ; VAR_592 ++ ) { if ( VAR_593 -> VAR_594 == VAR_595 ) VAR_596 = ( unsigned TYPE_130 ) ( ( * VAR_597 << 8 ) | * ( VAR_598 + 1 ) ) ; else VAR_599 = ( unsigned TYPE_131 ) ( * VAR_600 | ( * ( VAR_601 + 1 ) << 8 ) ) ; VAR_602 [ VAR_603 ] = ( TYPE_132 ) VAR_604 ; VAR_605 += 2 ; } break ; } case 0x1203 : { unsigned TYPE_133 VAR_606 ; if ( VAR_607 == ( unsigned TYPE_134 * ) VAR_608 ) break ; VAR_609 = ( TYPE_135 ) ( VAR_610 / 2 ) ; VAR_611 = ( TYPE_136 ) VAR_612 ; VAR_613 = ( TYPE_137 * ) METHOD_88 ( ( TYPE_138 ) VAR_614 , sizeof ( * VAR_615 ) ) ; if ( VAR_616 == ( TYPE_139 * ) VAR_617 ) METHOD_89 ( VAR_618 , ""MemoryAllocationFailed"" ) ; VAR_619 = VAR_620 ; for ( VAR_621 = 0 ; VAR_622 < ( TYPE_140 ) VAR_623 ; VAR_624 ++ ) { if ( VAR_625 -> VAR_626 == VAR_627 ) VAR_628 = ( unsigned TYPE_141 ) ( ( * VAR_629 << 8 ) | * ( VAR_630 + 1 ) ) ; else VAR_631 = ( unsigned TYPE_142 ) ( * VAR_632 | ( * ( VAR_633 + 1 ) << 8 ) ) ; VAR_634 [ VAR_635 ] = ( TYPE_143 ) VAR_636 ; VAR_637 += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( VAR_638 ) { case 0x0020 : { if ( ( VAR_639 != ( unsigned TYPE_144 * ) VAR_640 ) && ( METHOD_90 ( ( TYPE_145 * ) VAR_641 , ""INVERSE"" , 7 ) == 0 ) ) VAR_642 = VAR_643 ; break ; } default : break ; } break ; } default : break ; } if ( VAR_644 != ( unsigned TYPE_146 * ) VAR_645 ) { TYPE_147 * VAR_646 ; for ( VAR_647 = 0 ; VAR_648 [ VAR_649 ] . VAR_650 != ( TYPE_148 * ) VAR_651 ; VAR_652 ++ ) if ( ( VAR_653 == VAR_654 [ VAR_655 ] . VAR_656 ) && ( VAR_657 == VAR_658 [ VAR_659 ] . VAR_660 ) ) break ; if ( VAR_661 [ VAR_662 ] . VAR_663 != ( TYPE_149 * ) VAR_664 ) { VAR_665 = METHOD_91 ( ""dcm:"" ) ; ( TYPE_150 ) METHOD_92 ( & VAR_666 , VAR_667 [ VAR_668 ] . VAR_669 ) ; for ( VAR_670 = 0 ; VAR_671 < ( TYPE_151 ) METHOD_93 ( VAR_672 , 4 ) ; VAR_673 ++ ) if ( METHOD_94 ( ( TYPE_152 ) VAR_674 [ VAR_675 ] ) == VAR_676 ) break ; if ( ( VAR_677 == ( TYPE_153 ) VAR_678 ) || ( VAR_679 > 4 ) ) { ( TYPE_154 ) METHOD_95 ( & VAR_680 , ""<S2SV_blank>"" , """" ) ; ( TYPE_155 ) METHOD_96 ( VAR_681 , VAR_682 , ( TYPE_156 * ) VAR_683 , VAR_684 ) ; } VAR_685 = METHOD_97 ( VAR_686 ) ; } } if ( VAR_687 -> VAR_688 != VAR_689 ) { if ( VAR_690 == ( unsigned TYPE_157 * ) VAR_691 ) ( TYPE_158 ) METHOD_98 ( VAR_692 , ""%d\\n"" , VAR_693 ) ; else { for ( VAR_694 = 0 ; VAR_695 < ( TYPE_159 ) METHOD_99 ( VAR_696 , 4 ) ; VAR_697 ++ ) if ( METHOD_100 ( ( TYPE_160 ) VAR_698 [ VAR_699 ] ) == VAR_700 ) break ; if ( ( VAR_701 != ( TYPE_161 ) VAR_702 ) && ( VAR_703 <= 4 ) ) { TYPE_162 VAR_704 ; VAR_705 = 0 ; for ( VAR_706 = ( TYPE_163 ) VAR_707 - 1 ; VAR_708 >= 0 ; VAR_709 -- ) VAR_710 = ( 256 * VAR_711 + VAR_712 [ VAR_713 ] ) ; ( TYPE_164 ) METHOD_101 ( VAR_714 , ""%d"" , VAR_715 ) ; } else for ( VAR_716 = 0 ; VAR_717 < ( TYPE_165 ) VAR_718 ; VAR_719 ++ ) if ( METHOD_102 ( ( TYPE_166 ) VAR_720 [ VAR_721 ] ) != VAR_722 ) ( TYPE_167 ) METHOD_103 ( VAR_723 , ""%c"" , VAR_724 [ VAR_725 ] ) ; else ( TYPE_168 ) METHOD_104 ( VAR_726 , ""%c"" , '.' ) ; ( TYPE_169 ) METHOD_105 ( VAR_727 , ""\\n"" ) ; } } if ( VAR_728 != ( unsigned TYPE_170 * ) VAR_729 ) VAR_730 = ( unsigned TYPE_171 * ) METHOD_106 ( VAR_731 ) ; if ( METHOD_107 ( VAR_732 ) != VAR_733 ) { METHOD_108 ( VAR_734 , VAR_735 , ""UnexpectedEndOfFile"" , VAR_736 -> VAR_737 ) ; break ; } } if ( ( VAR_738 == 0 ) || ( VAR_739 == 0 ) ) METHOD_109 ( VAR_740 , ""ImproperImageHeader"" ) ; VAR_741 -> VAR_742 = ( TYPE_172 ) VAR_743 ; VAR_744 -> VAR_745 = ( TYPE_173 ) VAR_746 ; if ( VAR_747 == 0xffff ) VAR_748 = ( TYPE_174 ) ( VAR_749 == 16 ? 1 : 0 ) ; if ( ( VAR_750 -> VAR_751 == VAR_752 ) || ( VAR_753 -> VAR_754 == VAR_755 ) ) { TYPE_175 * VAR_756 ; TYPE_176 * VAR_757 ; TYPE_177 VAR_758 ; TYPE_178 VAR_759 ; unsigned TYPE_179 VAR_760 ; for ( VAR_761 = 0 ; VAR_762 < ( TYPE_180 ) VAR_763 -> VAR_764 ; VAR_765 ++ ) ( TYPE_181 ) METHOD_110 ( VAR_766 ) ; VAR_767 = ( METHOD_111 ( VAR_768 ) << 16 ) | METHOD_112 ( VAR_769 ) ; ( TYPE_182 ) VAR_770 ; VAR_771 = ( TYPE_183 ) METHOD_113 ( VAR_772 ) ; VAR_773 -> VAR_774 = VAR_775 >> 2 ; if ( VAR_776 -> VAR_777 != 0 ) { TYPE_184 VAR_778 ; VAR_779 -> VAR_780 = ( TYPE_185 * ) METHOD_114 ( VAR_781 -> VAR_782 , sizeof ( * VAR_783 -> VAR_784 ) ) ; if ( VAR_785 -> VAR_786 == ( TYPE_186 * ) VAR_787 ) METHOD_115 ( VAR_788 , ""MemoryAllocationFailed"" ) ; for ( VAR_789 = 0 ; VAR_790 < ( TYPE_187 ) VAR_791 -> VAR_792 ; VAR_793 ++ ) VAR_794 -> VAR_795 [ VAR_796 ] = ( TYPE_188 ) METHOD_116 ( VAR_797 ) ; VAR_798 = METHOD_117 ( VAR_799 ) ; for ( VAR_800 = 0 ; VAR_801 < ( TYPE_189 ) VAR_802 -> VAR_803 ; VAR_804 ++ ) VAR_805 -> VAR_806 [ VAR_807 ] += VAR_808 ; } VAR_809 = METHOD_118 ( VAR_810 ) ; METHOD_119 ( VAR_811 , ( TYPE_190 * ) VAR_812 , 0 ) ; VAR_813 = METHOD_120 ( ) ; for ( VAR_814 = 0 ; VAR_815 < ( TYPE_191 ) VAR_816 ; VAR_817 ++ ) { TYPE_192 VAR_818 [ VAR_819 ] ; const TYPE_193 * VAR_820 ; TYPE_194 * VAR_821 ; TYPE_195 * VAR_822 ; TYPE_196 VAR_823 ; unsigned TYPE_197 VAR_824 ; VAR_825 = ( METHOD_121 ( VAR_826 ) << 16 ) | METHOD_122 ( VAR_827 ) ; VAR_828 = ( TYPE_198 ) METHOD_123 ( VAR_829 ) ; if ( VAR_830 == 0xFFFEE0DD ) break ; if ( VAR_831 != 0xFFFEE000 ) METHOD_124 ( VAR_832 , ""ImproperImageHeader"" ) ; VAR_833 = ( TYPE_199 * ) VAR_834 ; VAR_835 = METHOD_125 ( VAR_836 ) ; if ( VAR_837 != - 1 ) VAR_838 = METHOD_126 ( VAR_839 , ""wb"" ) ; if ( VAR_840 == ( TYPE_200 * ) VAR_841 ) { ( TYPE_201 ) METHOD_127 ( VAR_842 ) ; METHOD_128 ( VAR_843 , VAR_844 , ""UnableToCreateTemporaryFile"" , VAR_845 ) ; break ; } for ( ; VAR_846 != 0 ; VAR_847 -- ) { VAR_848 = METHOD_129 ( VAR_849 ) ; if ( VAR_850 == VAR_851 ) { METHOD_130 ( VAR_852 , VAR_853 , ""UnexpectedEndOfFile"" , VAR_854 -> VAR_855 ) ; break ; } ( TYPE_202 ) METHOD_131 ( VAR_856 , VAR_857 ) ; } ( TYPE_203 ) METHOD_132 ( VAR_858 ) ; ( TYPE_204 ) METHOD_133 ( VAR_859 -> VAR_860 , VAR_861 , ""jpeg:%s"" , VAR_862 ) ; if ( VAR_863 -> VAR_864 == VAR_865 ) ( TYPE_205 ) METHOD_134 ( VAR_866 -> VAR_867 , VAR_868 , ""j2k:%s"" , VAR_869 ) ; VAR_870 = METHOD_135 ( VAR_871 , VAR_872 ) ; if ( VAR_873 != ( TYPE_206 * ) VAR_874 ) { METHOD_136 ( VAR_875 ) ; VAR_876 = METHOD_137 ( VAR_877 ) ; while ( VAR_878 != ( const TYPE_207 * ) VAR_879 ) { ( TYPE_208 ) METHOD_138 ( VAR_880 , VAR_881 , METHOD_139 ( VAR_882 , VAR_883 , VAR_884 ) , VAR_885 ) ; VAR_886 = METHOD_140 ( VAR_887 ) ; } METHOD_141 ( & VAR_888 , VAR_889 ) ; } ( TYPE_209 ) METHOD_142 ( VAR_890 ) ; } VAR_891 = METHOD_143 ( VAR_892 ) ; VAR_893 = METHOD_144 ( VAR_894 ) ; return ( METHOD_145 ( VAR_895 ) ) ; } if ( VAR_896 != ( 1UL * VAR_897 ) ) { TYPE_210 VAR_898 ; TYPE_211 VAR_899 ; VAR_900 = ( TYPE_212 ) ( METHOD_146 ( VAR_901 ) + 1 ) ; VAR_902 = ( TYPE_213 * ) METHOD_147 ( VAR_903 , sizeof ( * VAR_904 ) ) ; if ( VAR_905 == ( TYPE_214 * ) VAR_906 ) METHOD_148 ( VAR_907 , ""MemoryAllocationFailed"" ) ; VAR_908 = METHOD_149 ( VAR_909 ) ; <S2SV_StartBug> for ( VAR_910 = 0 ; VAR_911 < ( TYPE_215 ) ( METHOD_150 ( VAR_912 ) + 1 ) ; VAR_913 ++ ) <S2SV_EndBug> VAR_914 [ VAR_915 ] = METHOD_151 ( ( TYPE_216 ) VAR_916 , VAR_917 ) ; } if ( VAR_918 -> VAR_919 == VAR_920 ) { TYPE_217 VAR_921 ; unsigned TYPE_218 VAR_922 ; for ( VAR_923 = 0 ; VAR_924 < ( TYPE_219 ) VAR_925 -> VAR_926 ; VAR_927 ++ ) ( TYPE_220 ) METHOD_152 ( VAR_928 ) ; VAR_929 = ( METHOD_153 ( VAR_930 ) << 16 ) | METHOD_154 ( VAR_931 ) ; ( TYPE_221 ) VAR_932 ; VAR_933 = ( TYPE_222 ) METHOD_155 ( VAR_934 ) ; VAR_935 -> VAR_936 = VAR_937 >> 2 ; if ( VAR_938 -> VAR_939 != 0 ) { TYPE_223 VAR_940 ; VAR_941 -> VAR_942 = ( TYPE_224 * ) METHOD_156 ( VAR_943 -> VAR_944 , sizeof ( * VAR_945 -> VAR_946 ) ) ; if ( VAR_947 -> VAR_948 == ( TYPE_225 * ) VAR_949 ) METHOD_157 ( VAR_950 , ""MemoryAllocationFailed"" ) ; for ( VAR_951 = 0 ; VAR_952 < ( TYPE_226 ) VAR_953 -> VAR_954 ; VAR_955 ++ ) VAR_956 -> VAR_957 [ VAR_958 ] = ( TYPE_227 ) METHOD_158 ( VAR_959 ) ; VAR_960 = METHOD_159 ( VAR_961 ) ; for ( VAR_962 = 0 ; VAR_963 < ( TYPE_228 ) VAR_964 -> VAR_965 ; VAR_966 ++ ) VAR_967 -> VAR_968 [ VAR_969 ] += VAR_970 ; } } for ( VAR_971 = 0 ; VAR_972 < ( TYPE_229 ) VAR_973 ; VAR_974 ++ ) { if ( VAR_975 -> VAR_976 != VAR_977 ) break ; VAR_978 -> VAR_979 = ( TYPE_230 ) VAR_980 ; VAR_981 -> VAR_982 = ( TYPE_231 ) VAR_983 ; VAR_984 -> VAR_985 = VAR_986 ; VAR_987 = METHOD_160 ( VAR_988 , VAR_989 -> VAR_990 , VAR_991 -> VAR_992 , VAR_993 ) ; if ( VAR_994 == VAR_995 ) break ; VAR_996 -> VAR_997 = VAR_998 ; if ( ( VAR_999 -> VAR_1000 == ( TYPE_232 * ) VAR_1001 ) && ( VAR_1002 == 1 ) ) { TYPE_233 VAR_1003 ; VAR_1004 = 1 ; if ( VAR_1005 == 0 ) VAR_1006 = VAR_1007 << VAR_1008 ; if ( METHOD_161 ( VAR_1009 , VAR_1010 << VAR_1011 , VAR_1012 ) == VAR_1013 ) METHOD_162 ( VAR_1014 , ""MemoryAllocationFailed"" ) ; if ( VAR_1015 != ( TYPE_234 * ) VAR_1016 ) for ( VAR_1017 = 0 ; VAR_1018 < ( TYPE_235 ) VAR_1019 ; VAR_1020 ++ ) { VAR_1021 = VAR_1022 [ VAR_1023 ] ; if ( ( VAR_1024 != ( TYPE_236 * ) VAR_1025 ) && ( VAR_1026 <= ( TYPE_237 ) VAR_1027 ) ) VAR_1028 = ( TYPE_238 ) VAR_1029 [ VAR_1030 ] ; VAR_1031 -> VAR_1032 [ VAR_1033 ] . VAR_1034 = ( TYPE_239 ) VAR_1035 ; } if ( VAR_1036 != ( TYPE_240 * ) VAR_1037 ) for ( VAR_1038 = 0 ; VAR_1039 < ( TYPE_241 ) VAR_1040 ; VAR_1041 ++ ) { VAR_1042 = VAR_1043 [ VAR_1044 ] ; if ( ( VAR_1045 != ( TYPE_242 * ) VAR_1046 ) && ( VAR_1047 <= ( TYPE_243 ) VAR_1048 ) ) VAR_1049 = ( TYPE_244 ) VAR_1050 [ VAR_1051 ] ; VAR_1052 -> VAR_1053 [ VAR_1054 ] . VAR_1055 = ( TYPE_245 ) VAR_1056 ; } if ( VAR_1057 != ( TYPE_246 * ) VAR_1058 ) for ( VAR_1059 = 0 ; VAR_1060 < ( TYPE_247 ) VAR_1061 ; VAR_1062 ++ ) { VAR_1063 = VAR_1064 [ VAR_1065 ] ; if ( ( VAR_1066 != ( TYPE_248 * ) VAR_1067 ) && ( VAR_1068 <= ( TYPE_249 ) VAR_1069 ) ) VAR_1070 = ( TYPE_250 ) VAR_1071 [ VAR_1072 ] ; VAR_1073 -> VAR_1074 [ VAR_1075 ] . VAR_1076 = ( TYPE_251 ) VAR_1077 ; } if ( VAR_1078 != ( TYPE_252 * ) VAR_1079 ) for ( VAR_1080 = 0 ; VAR_1081 < ( TYPE_253 ) VAR_1082 ; VAR_1083 ++ ) { VAR_1084 = VAR_1085 [ VAR_1086 ] ; if ( ( VAR_1087 != ( TYPE_254 * ) VAR_1088 ) && ( VAR_1089 <= ( TYPE_255 ) VAR_1090 ) ) VAR_1091 = ( TYPE_256 ) VAR_1092 [ VAR_1093 ] ; VAR_1094 -> VAR_1095 [ VAR_1096 ] . VAR_1097 = ( TYPE_257 ) VAR_1098 ; VAR_1099 -> VAR_1100 [ VAR_1101 ] . VAR_1102 = ( TYPE_258 ) VAR_1103 ; VAR_1104 -> VAR_1105 [ VAR_1106 ] . VAR_1107 = ( TYPE_259 ) VAR_1108 ; } } if ( VAR_1109 -> VAR_1110 == VAR_1111 ) { unsigned TYPE_260 VAR_1112 ; for ( VAR_1113 = 0 ; VAR_1114 < ( TYPE_261 ) VAR_1115 -> VAR_1116 ; VAR_1117 ++ ) ( TYPE_262 ) METHOD_163 ( VAR_1118 ) ; VAR_1119 = ( METHOD_164 ( VAR_1120 ) << 16 ) | METHOD_165 ( VAR_1121 ) ; VAR_1122 -> VAR_1123 = ( TYPE_263 ) METHOD_166 ( VAR_1124 ) ; if ( ( VAR_1125 != 0xFFFEE000 ) || ( VAR_1126 -> VAR_1127 <= 64 ) || ( METHOD_167 ( VAR_1128 ) != VAR_1129 ) ) METHOD_168 ( VAR_1130 , ""ImproperImageHeader"" ) ; VAR_1131 -> VAR_1132 = 0 ; VAR_1133 -> VAR_1134 = METHOD_169 ( VAR_1135 ) ; if ( VAR_1136 -> VAR_1137 > 1 ) { VAR_1138 = 1 ; VAR_1139 = 8 ; } for ( VAR_1140 = 0 ; VAR_1141 < 15 ; VAR_1142 ++ ) VAR_1143 -> VAR_1144 [ VAR_1145 ] = ( TYPE_264 ) METHOD_170 ( VAR_1146 ) ; VAR_1147 -> VAR_1148 -= 64 ; } if ( ( VAR_1149 > 1 ) && ( VAR_1150 -> VAR_1151 == VAR_1152 ) ) { for ( VAR_1153 = 0 ; VAR_1154 < ( TYPE_265 ) VAR_1155 ; VAR_1156 ++ ) { for ( VAR_1157 = 0 ; VAR_1158 < ( TYPE_266 ) VAR_1159 -> VAR_1160 ; VAR_1161 ++ ) { VAR_1162 = METHOD_171 ( VAR_1163 , 0 , VAR_1164 , VAR_1165 -> VAR_1166 , 1 , VAR_1167 ) ; if ( VAR_1168 == ( TYPE_267 * ) VAR_1169 ) break ; for ( VAR_1170 = 0 ; VAR_1171 < ( TYPE_268 ) VAR_1172 -> VAR_1173 ; VAR_1174 ++ ) { switch ( ( TYPE_269 ) VAR_1175 ) { case 0 : { METHOD_172 ( VAR_1176 , METHOD_173 ( ( unsigned TYPE_270 ) METHOD_174 ( VAR_1177 , VAR_1178 ) ) , VAR_1179 ) ; break ; } case 1 : { METHOD_175 ( VAR_1180 , METHOD_176 ( ( unsigned TYPE_271 ) METHOD_177 ( VAR_1181 , VAR_1182 ) ) , VAR_1183 ) ; break ; } case 2 : { METHOD_178 ( VAR_1184 , METHOD_179 ( ( unsigned TYPE_272 ) METHOD_180 ( VAR_1185 , VAR_1186 ) ) , VAR_1187 ) ; break ; } case 3 : { METHOD_181 ( VAR_1188 , METHOD_182 ( ( unsigned TYPE_273 ) METHOD_183 ( VAR_1189 , VAR_1190 ) ) , VAR_1191 ) ; break ; } default : break ; } VAR_1192 += METHOD_184 ( VAR_1193 ) ; } if ( METHOD_185 ( VAR_1194 , VAR_1195 ) == VAR_1196 ) break ; if ( VAR_1197 -> VAR_1198 == ( TYPE_274 * ) VAR_1199 ) { VAR_1200 = METHOD_186 ( VAR_1201 , VAR_1202 , ( TYPE_275 ) VAR_1203 , VAR_1204 -> VAR_1205 ) ; if ( VAR_1206 == VAR_1207 ) break ; } } } } else { const TYPE_276 * VAR_1208 ; TYPE_277 VAR_1209 ; TYPE_278 VAR_1210 ; VAR_1211 = 0 ; VAR_1212 = 0 ; if ( ( VAR_1213 != 0 ) && ( VAR_1214 == 0 ) ) VAR_1215 = ( TYPE_279 ) VAR_1216 ; VAR_1217 = METHOD_187 ( VAR_1218 , ""dcm:display-range"" ) ; if ( VAR_1219 != ( const TYPE_280 * ) VAR_1220 ) { if ( METHOD_188 ( VAR_1221 , ""reset"" ) == 0 ) VAR_1222 = 0 ; } ( TYPE_281 ) METHOD_189 ( & VAR_1223 , 0 , sizeof ( VAR_1224 ) ) ; for ( VAR_1225 = 0 ; VAR_1226 < ( TYPE_282 ) VAR_1227 -> VAR_1228 ; VAR_1229 ++ ) { VAR_1230 = METHOD_190 ( VAR_1231 , 0 , VAR_1232 , VAR_1233 -> VAR_1234 , 1 , VAR_1235 ) ; if ( VAR_1236 == ( TYPE_283 * ) VAR_1237 ) break ; for ( VAR_1238 = 0 ; VAR_1239 < ( TYPE_284 ) VAR_1240 -> VAR_1241 ; VAR_1242 ++ ) { if ( VAR_1243 == 1 ) { TYPE_285 VAR_1244 ; if ( VAR_1245 == 1 ) VAR_1246 = VAR_1247 != VAR_1248 ? ( ( TYPE_286 ) VAR_1249 - METHOD_191 ( VAR_1250 , VAR_1251 ) ) : METHOD_192 ( VAR_1252 , VAR_1253 ) ; else if ( ( VAR_1254 != 12 ) || ( VAR_1255 != 12 ) ) { if ( VAR_1256 ) VAR_1257 = METHOD_193 ( VAR_1258 , VAR_1259 ) ; else VAR_1260 = METHOD_194 ( VAR_1261 , VAR_1262 ) ; if ( VAR_1263 != VAR_1264 ) VAR_1265 = ( TYPE_287 ) VAR_1266 - VAR_1267 ; } else { if ( ( VAR_1268 & 0x01 ) != 0 ) VAR_1269 = ( METHOD_195 ( VAR_1270 , VAR_1271 ) << 8 ) | VAR_1272 ; else { VAR_1273 = METHOD_196 ( VAR_1274 , VAR_1275 ) ; VAR_1276 = ( TYPE_288 ) ( VAR_1277 & 0x0f ) ; VAR_1278 >>= 4 ; } VAR_1279 ++ ; } VAR_1280 = ( VAR_1281 * VAR_1282 ) + VAR_1283 ; if ( VAR_1284 == 0 ) { if ( VAR_1285 == 1 ) VAR_1286 -= 32767 ; } else { TYPE_289 VAR_1287 , VAR_1288 ; VAR_1289 = ( TYPE_290 ) METHOD_197 ( ( TYPE_291 ) VAR_1290 - ( VAR_1291 - 1.0 ) / 2.0 - 0.5 ) ; VAR_1292 = ( TYPE_292 ) METHOD_198 ( ( TYPE_293 ) VAR_1293 + ( VAR_1294 - 1.0 ) / 2.0 + 0.5 ) ; if ( ( TYPE_294 ) VAR_1295 <= VAR_1296 ) VAR_1297 = 0 ; else if ( ( TYPE_295 ) VAR_1298 > VAR_1299 ) VAR_1300 = ( TYPE_296 ) VAR_1301 ; else VAR_1302 = ( TYPE_297 ) ( VAR_1303 * ( ( ( VAR_1304 - VAR_1305 - 0.5 ) / ( VAR_1306 - 1 ) ) + 0.5 ) ) ; } VAR_1307 &= VAR_1308 ; VAR_1309 = ( TYPE_298 ) METHOD_199 ( VAR_1310 , ( TYPE_299 ) VAR_1311 , VAR_1312 ) ; METHOD_200 ( VAR_1313 , ( TYPE_300 ) VAR_1314 , VAR_1315 ) ; VAR_1316 . VAR_1317 = ( unsigned TYPE_301 ) VAR_1318 -> VAR_1319 [ VAR_1320 ] . VAR_1321 ; VAR_1322 . VAR_1323 = ( unsigned TYPE_302 ) VAR_1324 -> VAR_1325 [ VAR_1326 ] . VAR_1327 ; VAR_1328 . VAR_1329 = ( unsigned TYPE_303 ) VAR_1330 -> VAR_1331 [ VAR_1332 ] . VAR_1333 ; } else { if ( VAR_1334 == 1 ) { VAR_1335 . VAR_1336 = ( unsigned TYPE_304 ) METHOD_201 ( VAR_1337 , VAR_1338 ) ; VAR_1339 . VAR_1340 = ( unsigned TYPE_305 ) METHOD_202 ( VAR_1341 , VAR_1342 ) ; VAR_1343 . VAR_1344 = ( unsigned TYPE_306 ) METHOD_203 ( VAR_1345 , VAR_1346 ) ; } else { VAR_1347 . VAR_1348 = METHOD_204 ( VAR_1349 , VAR_1350 ) ; VAR_1351 . VAR_1352 = METHOD_205 ( VAR_1353 , VAR_1354 ) ; VAR_1355 . VAR_1356 = METHOD_206 ( VAR_1357 , VAR_1358 ) ; } VAR_1359 . VAR_1360 &= VAR_1361 ; VAR_1362 . VAR_1363 &= VAR_1364 ; VAR_1365 . VAR_1366 &= VAR_1367 ; if ( VAR_1368 != ( TYPE_307 * ) VAR_1369 ) { <S2SV_StartBug> VAR_1370 . VAR_1371 = VAR_1372 [ VAR_1373 . VAR_1374 ] ; <S2SV_EndBug> <S2SV_StartBug> VAR_1375 . VAR_1376 = VAR_1377 [ VAR_1378 . VAR_1379 ] ; <S2SV_EndBug> <S2SV_StartBug> VAR_1380 . VAR_1381 = VAR_1382 [ VAR_1383 . VAR_1384 ] ; <S2SV_EndBug> } } METHOD_207 ( VAR_1385 , ( TYPE_308 ) VAR_1386 . VAR_1387 , VAR_1388 ) ; METHOD_208 ( VAR_1389 , ( TYPE_309 ) VAR_1390 . VAR_1391 , VAR_1392 ) ; METHOD_209 ( VAR_1393 , ( TYPE_310 ) VAR_1394 . VAR_1395 , VAR_1396 ) ; VAR_1397 += METHOD_210 ( VAR_1398 ) ; } if ( METHOD_211 ( VAR_1399 , VAR_1400 ) == VAR_1401 ) break ; if ( VAR_1402 -> VAR_1403 == ( TYPE_311 * ) VAR_1404 ) { VAR_1405 = METHOD_212 ( VAR_1406 , VAR_1407 , ( TYPE_312 ) VAR_1408 , VAR_1409 -> VAR_1410 ) ; if ( VAR_1411 == VAR_1412 ) break ; } } if ( VAR_1413 -> VAR_1414 > 1 ) for ( VAR_1415 = 0 ; VAR_1416 < ( TYPE_313 ) VAR_1417 -> VAR_1418 ; VAR_1419 ++ ) { VAR_1420 = METHOD_213 ( VAR_1421 , 0 , VAR_1422 , VAR_1423 -> VAR_1424 , 1 , VAR_1425 ) ; if ( VAR_1426 == ( TYPE_314 * ) VAR_1427 ) break ; for ( VAR_1428 = 0 ; VAR_1429 < ( TYPE_315 ) VAR_1430 -> VAR_1431 ; VAR_1432 ++ ) { if ( VAR_1433 == 1 ) { TYPE_316 VAR_1434 ; if ( VAR_1435 == 1 ) VAR_1436 = VAR_1437 != VAR_1438 ? ( ( TYPE_317 ) VAR_1439 - METHOD_214 ( VAR_1440 , VAR_1441 ) ) : METHOD_215 ( VAR_1442 , VAR_1443 ) ; else if ( ( VAR_1444 != 12 ) || ( VAR_1445 != 12 ) ) { VAR_1446 = ( TYPE_318 ) ( VAR_1447 != VAR_1448 ? ( VAR_1449 - METHOD_216 ( VAR_1450 , VAR_1451 ) ) : METHOD_217 ( VAR_1452 , VAR_1453 ) ) ; if ( VAR_1454 == 1 ) VAR_1455 = ( ( signed TYPE_319 ) VAR_1456 ) ; } else { if ( ( VAR_1457 & 0x01 ) != 0 ) VAR_1458 = ( METHOD_218 ( VAR_1459 , VAR_1460 ) << 8 ) | VAR_1461 ; else { VAR_1462 = METHOD_219 ( VAR_1463 , VAR_1464 ) ; VAR_1465 = ( TYPE_320 ) ( VAR_1466 & 0x0f ) ; VAR_1467 >>= 4 ; } VAR_1468 ++ ; } VAR_1469 = ( VAR_1470 * VAR_1471 ) + VAR_1472 ; if ( VAR_1473 == 0 ) { if ( VAR_1474 == 1 ) VAR_1475 -= 32767 ; } else { TYPE_321 VAR_1476 , VAR_1477 ; VAR_1478 = ( TYPE_322 ) METHOD_220 ( ( TYPE_323 ) VAR_1479 - ( VAR_1480 - 1.0 ) / 2.0 - 0.5 ) ; VAR_1481 = ( TYPE_324 ) METHOD_221 ( ( TYPE_325 ) VAR_1482 + ( VAR_1483 - 1.0 ) / 2.0 + 0.5 ) ; if ( ( TYPE_326 ) VAR_1484 <= VAR_1485 ) VAR_1486 = 0 ; else if ( ( TYPE_327 ) VAR_1487 > VAR_1488 ) VAR_1489 = ( TYPE_328 ) VAR_1490 ; else VAR_1491 = ( TYPE_329 ) ( VAR_1492 * ( ( ( VAR_1493 - VAR_1494 - 0.5 ) / ( VAR_1495 - 1 ) ) + 0.5 ) ) ; } VAR_1496 &= VAR_1497 ; VAR_1498 = ( TYPE_330 ) METHOD_222 ( VAR_1499 , ( TYPE_331 ) VAR_1500 , VAR_1501 ) ; METHOD_223 ( VAR_1502 , ( TYPE_332 ) ( ( ( TYPE_333 ) METHOD_224 ( VAR_1503 , VAR_1504 ) ) | ( ( ( TYPE_334 ) VAR_1505 ) << 8 ) ) , VAR_1506 ) ; VAR_1507 . VAR_1508 = ( unsigned TYPE_335 ) VAR_1509 -> VAR_1510 [ VAR_1511 ] . VAR_1512 ; VAR_1513 . VAR_1514 = ( unsigned TYPE_336 ) VAR_1515 -> VAR_1516 [ VAR_1517 ] . VAR_1518 ; VAR_1519 . VAR_1520 = ( unsigned TYPE_337 ) VAR_1521 -> VAR_1522 [ VAR_1523 ] . VAR_1524 ; } else { if ( VAR_1525 == 1 ) { VAR_1526 . VAR_1527 = ( unsigned TYPE_338 ) METHOD_225 ( VAR_1528 , VAR_1529 ) ; VAR_1530 . VAR_1531 = ( unsigned TYPE_339 ) METHOD_226 ( VAR_1532 , VAR_1533 ) ; VAR_1534 . VAR_1535 = ( unsigned TYPE_340 ) METHOD_227 ( VAR_1536 , VAR_1537 ) ; } else { VAR_1538 . VAR_1539 = METHOD_228 ( VAR_1540 , VAR_1541 ) ; VAR_1542 . VAR_1543 = METHOD_229 ( VAR_1544 , VAR_1545 ) ; VAR_1546 . VAR_1547 = METHOD_230 ( VAR_1548 , VAR_1549 ) ; } VAR_1550 . VAR_1551 &= VAR_1552 ; VAR_1553 . VAR_1554 &= VAR_1555 ; VAR_1556 . VAR_1557 &= VAR_1558 ; if ( VAR_1559 != ( TYPE_341 * ) VAR_1560 ) { VAR_1561 . VAR_1562 = VAR_1563 [ VAR_1564 . VAR_1565 ] ; VAR_1566 . VAR_1567 = VAR_1568 [ VAR_1569 . VAR_1570 ] ; VAR_1571 . VAR_1572 = VAR_1573 [ VAR_1574 . VAR_1575 ] ; } } METHOD_231 ( VAR_1576 , ( TYPE_342 ) ( ( ( TYPE_343 ) METHOD_232 ( VAR_1577 , VAR_1578 ) ) | ( ( ( TYPE_344 ) VAR_1579 . VAR_1580 ) << 8 ) ) , VAR_1581 ) ; METHOD_233 ( VAR_1582 , ( TYPE_345 ) ( ( ( TYPE_346 ) METHOD_234 ( VAR_1583 , VAR_1584 ) ) | ( ( ( TYPE_347 ) VAR_1585 . VAR_1586 ) << 8 ) ) , VAR_1587 ) ; METHOD_235 ( VAR_1588 , ( TYPE_348 ) ( ( ( TYPE_349 ) METHOD_236 ( VAR_1589 , VAR_1590 ) ) | ( ( ( TYPE_350 ) VAR_1591 . VAR_1592 ) << 8 ) ) , VAR_1593 ) ; VAR_1594 += METHOD_237 ( VAR_1595 ) ; } if ( METHOD_238 ( VAR_1596 , VAR_1597 ) == VAR_1598 ) break ; if ( VAR_1599 -> VAR_1600 == ( TYPE_351 * ) VAR_1601 ) { VAR_1602 = METHOD_239 ( VAR_1603 , VAR_1604 , ( TYPE_352 ) VAR_1605 , VAR_1606 -> VAR_1607 ) ; if ( VAR_1608 == VAR_1609 ) break ; } } } if ( METHOD_240 ( VAR_1610 , VAR_1611 ) != VAR_1612 ) ( TYPE_353 ) METHOD_241 ( VAR_1613 , VAR_1614 , VAR_1615 ) ; if ( METHOD_242 ( VAR_1616 ) != VAR_1617 ) { METHOD_243 ( VAR_1618 , VAR_1619 , ""UnexpectedEndOfFile"" , VAR_1620 -> VAR_1621 ) ; break ; } if ( VAR_1622 -> VAR_1623 != 0 ) if ( VAR_1624 -> VAR_1625 >= ( VAR_1626 -> VAR_1627 + VAR_1628 -> VAR_1629 - 1 ) ) break ; if ( VAR_1630 < ( TYPE_354 ) ( VAR_1631 - 1 ) ) { METHOD_244 ( VAR_1632 , VAR_1633 , VAR_1634 ) ; if ( METHOD_245 ( VAR_1635 ) == ( TYPE_355 * ) VAR_1636 ) { VAR_1637 = METHOD_246 ( VAR_1638 ) ; return ( ( TYPE_356 * ) VAR_1639 ) ; } VAR_1640 = METHOD_247 ( VAR_1641 ) ; VAR_1642 = METHOD_248 ( VAR_1643 , VAR_1644 , METHOD_249 ( VAR_1645 ) , METHOD_250 ( VAR_1646 ) ) ; if ( VAR_1647 == VAR_1648 ) break ; } } if ( VAR_1649 -> VAR_1650 != ( TYPE_357 * ) VAR_1651 ) VAR_1652 -> VAR_1653 = ( TYPE_358 * ) METHOD_251 ( VAR_1654 -> VAR_1655 ) ; VAR_1656 = ( TYPE_359 * ) METHOD_252 ( VAR_1657 ) ; if ( VAR_1658 != ( TYPE_360 * ) VAR_1659 ) VAR_1660 = ( TYPE_361 * ) METHOD_253 ( VAR_1661 ) ; if ( VAR_1662 != ( TYPE_362 * ) VAR_1663 ) VAR_1664 = ( TYPE_363 * ) METHOD_254 ( VAR_1665 ) ; if ( VAR_1666 != ( TYPE_364 * ) VAR_1667 ) VAR_1668 = ( TYPE_365 * ) METHOD_255 ( VAR_1669 ) ; if ( VAR_1670 != ( TYPE_366 * ) VAR_1671 ) VAR_1672 = ( TYPE_367 * ) METHOD_256 ( VAR_1673 ) ; if ( VAR_1674 != ( TYPE_368 * ) VAR_1675 ) VAR_1676 = ( TYPE_369 * ) METHOD_257 ( VAR_1677 ) ; ( TYPE_370 ) METHOD_258 ( VAR_1678 ) ; return ( METHOD_259 ( VAR_1679 ) ) ; }",<S2SV_ModStart> 0x0004 : { if ( VAR_731 == ( unsigned TYPE_280 * ) VAR_1675 ) break ; <S2SV_ModStart> 0x0008 : { if ( VAR_731 == ( unsigned TYPE_280 * ) VAR_1675 ) break ; <S2SV_ModStart> 0 ; VAR_1468 <= <S2SV_ModEnd> ( TYPE_358 ) <S2SV_ModStart> ( TYPE_358 ) <S2SV_ModEnd> METHOD_150 ( VAR_1139 <S2SV_ModStart> METHOD_150 ( VAR_1139 <S2SV_ModEnd> ) ; VAR_1468 <S2SV_ModStart> VAR_1675 ) { if ( VAR_1591 . VAR_1580 <= METHOD_150 ( VAR_1139 ) ) <S2SV_ModStart> VAR_1580 ] ; if ( VAR_1591 . VAR_1586 <= METHOD_150 ( VAR_1139 ) ) <S2SV_ModStart> VAR_1586 ] ; if ( VAR_1591 . VAR_1592 <= METHOD_150 ( VAR_1139 ) ),"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , rescale_intercept , rescale_slope , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; rescale_intercept = 0 ; rescale_slope = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : <S2SV_StartBug> { <S2SV_EndBug> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( depth ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; PixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { if ( signed_data ) pixel_value = ReadDCMSignedShort ( stream_info , image ) ; else pixel_value = ReadDCMShort ( stream_info , image ) ; if ( polarity != MagickFalse ) pixel_value = ( int ) max_value - pixel_value ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMSignedShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) index , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> } } SetPixelRed ( image , ( Quantum ) pixel . red , q ) ; SetPixelGreen ( image , ( Quantum ) pixel . green , q ) ; SetPixelBlue ( image , ( Quantum ) pixel . blue , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) ( ( ( size_t ) GetPixelIndex ( image , q ) ) | ( ( ( size_t ) index ) << 8 ) ) , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( image , ( Quantum ) ( ( ( size_t ) GetPixelRed ( image , q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( ( size_t ) GetPixelGreen ( image , q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( ( size_t ) GetPixelBlue ( image , q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",<S2SV_ModStart> 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0 ; i <= <S2SV_ModEnd> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> GetQuantumRange ( depth <S2SV_ModStart> GetQuantumRange ( depth <S2SV_ModEnd> ) ; i <S2SV_ModStart> NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
404,"CWE-119 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , const TYPE_5 * VAR_4 , TYPE_6 VAR_5 ) { <S2SV_StartBug> TYPE_7 VAR_6 = METHOD_1 ( VAR_7 ) ; <S2SV_EndBug> TYPE_8 VAR_8 = METHOD_2 ( VAR_9 , VAR_10 ) ; METHOD_3 ( VAR_11 == VAR_12 ) ; <S2SV_StartBug> if ( VAR_13 > VAR_14 * VAR_15 -> VAR_16 ) { <S2SV_EndBug> DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_StartBug> VAR_17 , VAR_18 * VAR_19 -> VAR_20 ) ) ; <S2SV_EndBug> return - 1 ; } ( TYPE_9 ) METHOD_4 ( ( ( TYPE_10 * ) VAR_21 ) + VAR_22 , ( ( const TYPE_11 * ) VAR_23 -> VAR_24 ) + VAR_25 , VAR_26 ) ; return VAR_27 ; }","<S2SV_ModStart> TYPE_8 VAR_18 = METHOD_5 <S2SV_ModEnd> ( VAR_9 ) <S2SV_ModStart> ( VAR_25 > METHOD_1 ( VAR_9 ) <S2SV_ModEnd> * VAR_23 -> <S2SV_ModStart> , VAR_25 , METHOD_1 ( VAR_9 ) <S2SV_ModEnd> * VAR_23 ->","CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }","<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) <S2SV_ModStart> ( pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> <S2SV_ModStart> , pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst ->"
405,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * * VAR_5 ) { TYPE_7 VAR_6 ; TYPE_8 VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 ; TYPE_9 * VAR_12 ; TYPE_10 * VAR_13 ; TYPE_11 * VAR_14 ; ( * VAR_15 ) = 0 ; ( * VAR_16 ) = ( * VAR_17 ) = 0 ; if ( VAR_18 ) ( * VAR_19 ) = VAR_20 ; if ( ! VAR_21 || ! VAR_22 ) return VAR_23 ; if ( ! VAR_24 -> VAR_25 || ! VAR_26 -> VAR_27 || ! VAR_28 -> VAR_29 ) return VAR_30 ; if ( VAR_31 -> VAR_32 && VAR_33 -> VAR_34 -> VAR_35 == VAR_36 -> VAR_37 -> VAR_38 ) { VAR_39 = & VAR_40 -> VAR_41 -> VAR_42 [ VAR_43 - 1 ] ; if ( ! VAR_44 ) return VAR_45 ; ( * VAR_46 ) = VAR_47 -> VAR_48 ; ( * VAR_49 ) = VAR_50 ; if ( VAR_51 ) * VAR_52 = VAR_53 ; if ( VAR_54 -> VAR_55 -> VAR_56 == VAR_57 ) { VAR_58 = ( TYPE_12 * ) VAR_59 -> VAR_60 ; if ( ! VAR_61 -> VAR_62 ) return VAR_63 ; <S2SV_StartBug> ( * VAR_64 ) = ( TYPE_13 ) VAR_65 -> VAR_66 [ VAR_67 - 1 ] ; <S2SV_EndBug> } else { VAR_68 = ( TYPE_14 * ) VAR_69 -> VAR_70 ; <S2SV_StartBug> if ( ! VAR_71 -> VAR_72 ) return VAR_73 ; <S2SV_EndBug> ( * VAR_74 ) = VAR_75 -> VAR_76 [ VAR_77 - 1 ] ; } return VAR_78 ; } if ( VAR_79 -> VAR_80 -> VAR_81 && ( VAR_82 -> VAR_83 -> VAR_84 <= VAR_85 ) ) { VAR_86 = VAR_87 -> VAR_88 -> VAR_89 ; VAR_90 = & VAR_91 -> VAR_92 -> VAR_93 [ VAR_94 -> VAR_95 -> VAR_96 ] ; METHOD_1 ( VAR_97 , VAR_98 , VAR_99 -> VAR_100 -> VAR_101 , VAR_102 ) ; VAR_103 = VAR_104 -> VAR_105 -> VAR_106 ; } else { VAR_107 = 0 ; VAR_108 -> VAR_109 -> VAR_110 = 0 ; VAR_111 -> VAR_112 -> VAR_113 = 1 ; VAR_114 -> VAR_115 -> VAR_116 = 1 ; VAR_117 -> VAR_118 -> VAR_119 = 1 ; VAR_120 = & VAR_121 -> VAR_122 -> VAR_123 [ 0 ] ; METHOD_2 ( VAR_124 , 0 , VAR_125 -> VAR_126 -> VAR_127 , VAR_128 ) ; VAR_129 = VAR_130 -> VAR_131 -> VAR_132 ; } for ( ; VAR_133 < VAR_134 -> VAR_135 -> VAR_136 ; VAR_137 ++ ) { METHOD_3 ( VAR_138 -> VAR_139 -> VAR_140 <= VAR_141 ) ; if ( VAR_142 > VAR_143 -> VAR_144 -> VAR_145 ) { return VAR_146 ; } TYPE_15 VAR_147 = VAR_148 -> VAR_149 -> VAR_150 - VAR_151 ; TYPE_16 VAR_152 = VAR_153 - VAR_154 -> VAR_155 -> VAR_156 ; if ( VAR_157 -> VAR_158 ) VAR_159 /= VAR_160 -> VAR_161 ; if ( ( VAR_162 <= VAR_163 ) && ( VAR_164 -> VAR_165 -> VAR_166 + ( VAR_167 + 1 ) * VAR_168 -> VAR_169 > VAR_170 ) ) { VAR_171 -> VAR_172 -> VAR_173 += VAR_174 * VAR_175 -> VAR_176 ; VAR_177 -> VAR_178 -> VAR_179 += VAR_180 ; goto VAR_181 ; } VAR_182 += 1 ; VAR_183 -> VAR_184 -> VAR_185 += VAR_186 * VAR_187 -> VAR_188 ; VAR_189 -> VAR_190 -> VAR_191 += VAR_192 ; if ( VAR_193 + 1 != VAR_194 -> VAR_195 -> VAR_196 ) { VAR_197 = & VAR_198 -> VAR_199 -> VAR_200 [ VAR_201 + 1 ] ; METHOD_4 ( VAR_202 , VAR_203 + 1 , VAR_204 -> VAR_205 -> VAR_206 , VAR_207 ) ; VAR_208 -> VAR_209 -> VAR_210 = VAR_211 + 1 ; VAR_212 -> VAR_213 -> VAR_214 = 1 ; VAR_215 = 1 ; } } return VAR_216 ; VAR_217 : ( * VAR_218 ) = VAR_219 -> VAR_220 ; ( * VAR_221 ) = VAR_222 = VAR_223 -> VAR_224 + VAR_225 -> VAR_226 -> VAR_227 - 1 ; if ( VAR_228 ) * VAR_229 = VAR_230 ; if ( ! * VAR_231 ) return VAR_232 ; VAR_233 = 0 ; if ( VAR_234 -> VAR_235 && VAR_236 -> VAR_237 -> VAR_238 ) { TYPE_17 VAR_239 = VAR_240 - VAR_241 -> VAR_242 -> VAR_243 ; VAR_244 += VAR_245 * VAR_246 -> VAR_247 -> VAR_248 ; } else if ( ( VAR_249 -> VAR_250 == VAR_251 ) && ( VAR_252 -> VAR_253 == VAR_254 ) ) { VAR_255 = VAR_256 -> VAR_257 ; } else if ( ( VAR_258 -> VAR_259 == VAR_260 ) && ( VAR_261 -> VAR_262 + 1 == VAR_263 ) ) { VAR_264 = METHOD_5 ( VAR_265 -> VAR_266 , VAR_267 -> VAR_268 , & VAR_269 ) ; if ( VAR_270 ) return VAR_271 ; VAR_272 -> VAR_273 += VAR_274 ; VAR_275 -> VAR_276 = VAR_277 ; VAR_278 = VAR_279 -> VAR_280 ; } else { for ( VAR_281 = VAR_282 -> VAR_283 -> VAR_284 ; VAR_285 < VAR_286 ; VAR_287 ++ ) { VAR_288 = METHOD_6 ( VAR_289 -> VAR_290 , VAR_291 , & VAR_292 ) ; if ( VAR_293 ) return VAR_294 ; VAR_295 += VAR_296 ; } VAR_297 -> VAR_298 = VAR_299 ; VAR_300 -> VAR_301 = VAR_302 ; VAR_303 -> VAR_304 = VAR_305 ; } if ( VAR_306 -> VAR_307 -> VAR_308 == VAR_309 ) { VAR_310 = ( TYPE_18 * ) VAR_311 -> VAR_312 ; if ( VAR_313 -> VAR_314 < ( * VAR_315 ) ) return VAR_316 ; ( * VAR_317 ) = ( TYPE_19 ) VAR_318 -> VAR_319 [ ( * VAR_320 ) - 1 ] + ( TYPE_20 ) VAR_321 ; } else { VAR_322 = ( TYPE_21 * ) VAR_323 -> VAR_324 ; if ( VAR_325 -> VAR_326 < ( * VAR_327 ) ) return VAR_328 ; ( * VAR_329 ) = VAR_330 -> VAR_331 [ ( * VAR_332 ) - 1 ] + ( TYPE_22 ) VAR_333 ; } return VAR_334 ; }",<S2SV_ModStart> return VAR_328 ; if ( VAR_318 -> VAR_326 < VAR_302 ) return VAR_328 ; <S2SV_ModStart> VAR_330 -> VAR_331 ) return VAR_328 ; if ( VAR_330 -> VAR_326 < VAR_302,"CWE-119 GF_Err stbl_GetSampleInfos ( GF_SampleTableBox * stbl , u32 sampleNumber , u64 * offset , u32 * chunkNumber , u32 * descIndex , GF_StscEntry * * out_ent ) { GF_Err e ; u32 i , k , offsetInChunk , size , chunk_num ; GF_ChunkOffsetBox * stco ; GF_ChunkLargeOffsetBox * co64 ; GF_StscEntry * ent ; ( * offset ) = 0 ; ( * chunkNumber ) = ( * descIndex ) = 0 ; if ( out_ent ) ( * out_ent ) = NULL ; if ( ! stbl || ! sampleNumber ) return GF_BAD_PARAM ; if ( ! stbl -> ChunkOffset || ! stbl -> SampleToChunk || ! stbl -> SampleSize ) return GF_ISOM_INVALID_FILE ; if ( stbl -> SampleSize && stbl -> SampleToChunk -> nb_entries == stbl -> SampleSize -> sampleCount ) { ent = & stbl -> SampleToChunk -> entries [ sampleNumber - 1 ] ; if ( ! ent ) return GF_BAD_PARAM ; ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = sampleNumber ; if ( out_ent ) * out_ent = ent ; if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( ! stco -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> ( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ; <S2SV_EndBug> } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; <S2SV_StartBug> if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> ( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ; } return GF_OK ; } if ( stbl -> SampleToChunk -> firstSampleInCurrentChunk && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ) { i = stbl -> SampleToChunk -> currentIndex ; ent = & stbl -> SampleToChunk -> entries [ stbl -> SampleToChunk -> currentIndex ] ; GetGhostNum ( ent , i , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } else { i = 0 ; stbl -> SampleToChunk -> currentIndex = 0 ; stbl -> SampleToChunk -> currentChunk = 1 ; stbl -> SampleToChunk -> ghostNumber = 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk = 1 ; ent = & stbl -> SampleToChunk -> entries [ 0 ] ; GetGhostNum ( ent , 0 , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } for ( ; i < stbl -> SampleToChunk -> nb_entries ; i ++ ) { assert ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ; if ( k > stbl -> SampleToChunk -> ghostNumber ) { return GF_ISOM_INVALID_FILE ; } u32 max_chunks_in_entry = stbl -> SampleToChunk -> ghostNumber - k ; u32 nb_chunks_for_sample = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; if ( ent -> samplesPerChunk ) nb_chunks_for_sample /= ent -> samplesPerChunk ; if ( ( nb_chunks_for_sample <= max_chunks_in_entry ) && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk + ( nb_chunks_for_sample + 1 ) * ent -> samplesPerChunk > sampleNumber ) ) { stbl -> SampleToChunk -> firstSampleInCurrentChunk += nb_chunks_for_sample * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += nb_chunks_for_sample ; goto sample_found ; } max_chunks_in_entry += 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk += max_chunks_in_entry * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += max_chunks_in_entry ; if ( i + 1 != stbl -> SampleToChunk -> nb_entries ) { ent = & stbl -> SampleToChunk -> entries [ i + 1 ] ; GetGhostNum ( ent , i + 1 , stbl -> SampleToChunk -> nb_entries , stbl ) ; stbl -> SampleToChunk -> currentIndex = i + 1 ; stbl -> SampleToChunk -> currentChunk = 1 ; k = 1 ; } } return GF_ISOM_INVALID_FILE ; sample_found : ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = chunk_num = ent -> firstChunk + stbl -> SampleToChunk -> currentChunk - 1 ; if ( out_ent ) * out_ent = ent ; if ( ! * chunkNumber ) return GF_ISOM_INVALID_FILE ; offsetInChunk = 0 ; if ( stbl -> SampleSize && stbl -> SampleSize -> sampleSize ) { u32 diff = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; offsetInChunk += diff * stbl -> SampleSize -> sampleSize ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num == sampleNumber ) ) { offsetInChunk = stbl -> r_last_offset_in_chunk ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num + 1 == sampleNumber ) ) { e = stbl_GetSampleSize ( stbl -> SampleSize , stbl -> r_last_sample_num , & size ) ; if ( e ) return e ; stbl -> r_last_offset_in_chunk += size ; stbl -> r_last_sample_num = sampleNumber ; offsetInChunk = stbl -> r_last_offset_in_chunk ; } else { for ( i = stbl -> SampleToChunk -> firstSampleInCurrentChunk ; i < sampleNumber ; i ++ ) { e = stbl_GetSampleSize ( stbl -> SampleSize , i , & size ) ; if ( e ) return e ; offsetInChunk += size ; } stbl -> r_last_chunk_num = chunk_num ; stbl -> r_last_sample_num = sampleNumber ; stbl -> r_last_offset_in_chunk = offsetInChunk ; } if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( stco -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = ( u64 ) stco -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; if ( co64 -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = co64 -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } return GF_OK ; }",<S2SV_ModStart> return GF_ISOM_INVALID_FILE ; if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> co64 -> offsets ) return GF_ISOM_INVALID_FILE ; if ( co64 -> nb_entries < sampleNumber
406,"CWE-000 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , TYPE_0 VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 ; struct STRUCT_OR_UNION_4 * VAR_4 , * VAR_5 = METHOD_1 ( VAR_6 ) ; struct STRUCT_OR_UNION_5 * VAR_7 ; struct STRUCT_OR_UNION_6 * VAR_8 ; VAR_9 = METHOD_2 ( METHOD_3 ( VAR_10 ) , VAR_11 , VAR_12 , VAR_13 -> VAR_14 , VAR_15 ) ; if ( ! VAR_16 ) goto VAR_17 ; METHOD_4 ( VAR_18 , VAR_19 ) ; METHOD_5 ( VAR_20 , VAR_21 , VAR_22 ) ; METHOD_6 ( VAR_23 , VAR_24 ) ; VAR_25 = ( struct STRUCT_OR_UNION_7 * ) VAR_26 ; METHOD_7 ( VAR_27 ) -> VAR_28 = & VAR_29 -> VAR_30 ; METHOD_8 ( VAR_31 ) -> VAR_32 = METHOD_9 ( VAR_33 ) -> VAR_34 ; VAR_35 = METHOD_10 ( VAR_36 ) ; <S2SV_StartBug> METHOD_11 ( VAR_37 , VAR_38 , sizeof ( struct STRUCT_OR_UNION_8 ) ) ; <S2SV_EndBug> METHOD_12 ( ) ; VAR_39 = METHOD_13 ( VAR_40 -> VAR_41 ) ; if ( VAR_42 ) VAR_43 = METHOD_14 ( VAR_44 , VAR_45 ) ; METHOD_15 ( VAR_46 -> VAR_47 , VAR_48 ) ; METHOD_16 ( ) ; METHOD_17 ( & VAR_49 -> VAR_50 . VAR_51 , VAR_52 ) ; VAR_53 -> VAR_54 = VAR_55 -> VAR_56 ; METHOD_18 ( VAR_57 ) ; if ( VAR_58 -> VAR_59 -> METHOD_19 ( VAR_60 ) ) { METHOD_20 ( VAR_61 ) ; VAR_62 = VAR_63 ; } VAR_64 : return VAR_65 ; }",<S2SV_ModStart> STRUCT_OR_UNION_8 ) ) ; VAR_46 -> VAR_66 = VAR_63 ; VAR_46 -> VAR_67 = VAR_63 ; VAR_46 -> VAR_68 = VAR_63,"CWE-000 static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }",<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
407,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { METHOD_1 ( & VAR_1 -> VAR_2 ) ; <S2SV_StartBug> METHOD_2 ( VAR_3 -> VAR_4 . VAR_5 . VAR_6 , VAR_7 , sizeof ( VAR_8 ) ) ; <S2SV_EndBug> { TYPE_2 VAR_9 [ 2 ] = { 1 , 1 } ; METHOD_3 ( VAR_10 -> VAR_11 . VAR_12 , ( const TYPE_3 * ) VAR_13 -> VAR_14 . VAR_15 . VAR_16 , VAR_17 ) ; } <S2SV_StartBug> METHOD_4 ( & VAR_18 -> VAR_19 , & VAR_20 -> VAR_21 . VAR_22 , sizeof ( VAR_23 -> VAR_24 . VAR_25 ) ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_5 ( & VAR_26 -> VAR_27 , & VAR_28 -> VAR_29 . VAR_30 , sizeof ( VAR_31 -> VAR_32 . VAR_33 ) ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_6 ( & VAR_34 -> VAR_35 , & VAR_36 -> VAR_37 . VAR_38 , sizeof ( VAR_39 -> VAR_40 . VAR_41 ) ) ; <S2SV_EndBug> VAR_42 -> VAR_43 . VAR_44 = VAR_45 -> VAR_46 . VAR_47 * 3 / 8 ; if ( VAR_48 -> VAR_49 ) VAR_50 -> VAR_51 = VAR_52 -> VAR_53 ; else VAR_54 -> VAR_55 = VAR_56 ; VAR_57 -> VAR_58 . VAR_59 = 1 ; VAR_60 -> VAR_61 . VAR_62 = 1 ; }",<S2SV_ModStart> VAR_61 ) ; METHOD_7 <S2SV_ModEnd> ( VAR_60 -> <S2SV_ModStart> ) ; } METHOD_7 <S2SV_ModEnd> ( & VAR_60 <S2SV_ModStart> ) ) ; METHOD_7 <S2SV_ModEnd> ( & VAR_60 <S2SV_ModStart> ) ) ; METHOD_7 <S2SV_ModEnd> ( & VAR_60,"CWE-119 void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }",<S2SV_ModStart> common ) ; memcpy <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi
408,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 ; TYPE_3 VAR_2 , VAR_3 , VAR_4 = 0 ; METHOD_1 ( VAR_5 , VAR_6 ) ; METHOD_2 ( & VAR_7 , 0 , sizeof ( VAR_8 ) ) ; VAR_9 . VAR_10 = METHOD_3 ( VAR_11 ) ; METHOD_4 ( VAR_12 , ""Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\n"" , VAR_13 . VAR_14 , VAR_15 . VAR_16 ) ; if ( VAR_17 . VAR_18 > METHOD_5 ( VAR_19 -> VAR_20 ) ) { VAR_21 . VAR_22 = METHOD_6 ( 1 , VAR_23 . VAR_24 ) ; VAR_25 . VAR_26 = VAR_27 ; } else { VAR_28 . VAR_29 = VAR_30 -> VAR_31 ; VAR_32 . VAR_33 = VAR_34 ; } ; METHOD_7 ( VAR_35 . VAR_36 , VAR_37 . VAR_38 , 1 , VAR_39 ) ; VAR_40 -> VAR_41 = VAR_42 -> VAR_43 = VAR_44 . VAR_45 ; VAR_46 . VAR_47 = METHOD_8 ( & VAR_48 , 0 ) ; VAR_49 . VAR_50 = METHOD_9 ( & VAR_51 , 4 ) ; VAR_52 . VAR_53 = METHOD_10 ( & VAR_54 , 8 ) ; VAR_55 . VAR_56 = METHOD_11 ( & VAR_57 , 12 ) ; if ( VAR_58 . VAR_59 == 0x51607 && VAR_60 . VAR_61 == 0x20000 ) { METHOD_12 ( VAR_62 , ""Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\n"" ) ; VAR_63 . VAR_64 = METHOD_13 ( & VAR_65 , 0x52 + 0 ) + 0x52 ; VAR_66 . VAR_67 = METHOD_14 ( & VAR_68 , 0x52 + 4 ) + 0x52 ; VAR_69 . VAR_70 = METHOD_15 ( & VAR_71 , 0x52 + 8 ) ; VAR_72 . VAR_73 = METHOD_16 ( & VAR_74 , 0x52 + 12 ) ; } ; METHOD_17 ( VAR_75 , ""<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n"" ""<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n"" , VAR_76 . VAR_77 , VAR_78 . VAR_79 , VAR_80 . VAR_81 , VAR_82 . VAR_83 ) ; if ( VAR_84 . VAR_85 > VAR_86 . VAR_87 ) { METHOD_18 ( VAR_88 , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\n"" , VAR_89 . VAR_90 , VAR_91 . VAR_92 ) ; VAR_93 = VAR_94 ; goto VAR_95 ; } ; if ( VAR_96 . VAR_97 > VAR_98 . VAR_99 ) { METHOD_19 ( VAR_100 , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\n"" ) ; VAR_101 = VAR_102 ; goto VAR_103 ; } ; if ( VAR_104 . VAR_105 > VAR_106 . VAR_107 ) { METHOD_20 ( VAR_108 , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; VAR_109 = VAR_110 ; goto VAR_111 ; } ; if ( VAR_112 . VAR_113 > VAR_114 . VAR_115 ) { METHOD_21 ( VAR_116 , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; VAR_117 = VAR_118 ; goto VAR_119 ; } ; if ( VAR_120 . VAR_121 + VAR_122 . VAR_123 != VAR_124 . VAR_125 || VAR_126 . VAR_127 + VAR_128 . VAR_129 != VAR_130 . VAR_131 ) { METHOD_22 ( VAR_132 , ""Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\n"" ) ; VAR_133 = VAR_134 ; goto VAR_135 ; } ; if ( VAR_136 . VAR_137 + 28 >= VAR_138 . VAR_139 ) { METHOD_23 ( VAR_140 , ""Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\n"" , VAR_141 . VAR_142 , VAR_143 . VAR_144 ) ; VAR_145 = VAR_146 ; goto VAR_147 ; } ; VAR_148 . VAR_149 = VAR_150 . VAR_151 + METHOD_24 ( & VAR_152 , VAR_153 . VAR_154 + 26 ) ; if ( VAR_155 . VAR_156 > VAR_157 . VAR_158 ) { METHOD_25 ( VAR_159 , ""Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , VAR_160 . VAR_161 ) ; VAR_162 = VAR_163 ; goto VAR_164 ; } ; VAR_165 . VAR_166 = VAR_167 . VAR_168 + 30 ; <S2SV_StartBug> VAR_169 . VAR_170 = METHOD_26 ( & VAR_171 , VAR_172 . VAR_173 + 28 ) + 1 ; <S2SV_EndBug> if ( VAR_174 . VAR_175 < 1 ) { METHOD_27 ( VAR_176 , ""Bad<S2SV_blank>type<S2SV_blank>count.\\n"" ) ; VAR_177 = VAR_178 ; goto VAR_179 ; } ; VAR_180 . VAR_181 = VAR_182 . VAR_183 + VAR_184 . VAR_185 * 8 ; if ( VAR_186 . VAR_187 < 0 || VAR_188 . VAR_189 > VAR_190 . VAR_191 ) { METHOD_28 ( VAR_192 , ""Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , VAR_193 . VAR_194 ) ; VAR_195 = VAR_196 ; goto VAR_197 ; } ; VAR_198 . VAR_199 = - 1 ; for ( VAR_200 = 0 ; VAR_201 < VAR_202 . VAR_203 ; VAR_204 ++ ) <S2SV_StartBug> { VAR_205 = METHOD_29 ( & VAR_206 , VAR_207 . VAR_208 + VAR_209 * 8 ) ; <S2SV_EndBug> if ( VAR_210 == VAR_211 ) { VAR_212 . VAR_213 = VAR_214 ; VAR_215 . VAR_216 = METHOD_30 ( & VAR_217 , VAR_218 . VAR_219 + VAR_220 * 8 + 4 ) + 1 ; VAR_221 = METHOD_31 ( VAR_222 , & VAR_223 ) ; goto VAR_224 ; } ; } ; METHOD_32 ( VAR_225 , ""No<S2SV_blank>\'STR<S2SV_blank>\'<S2SV_blank>resource.\\n"" ) ; VAR_226 = VAR_227 ; VAR_228 : METHOD_33 ( VAR_229 , VAR_230 ) ; if ( VAR_231 . VAR_232 ) METHOD_34 ( VAR_233 . VAR_234 ) ; return VAR_235 ; }","<S2SV_ModStart> + 30 ; if ( VAR_233 . VAR_173 + 28 > VAR_233 . VAR_191 ) { METHOD_32 ( VAR_229 , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto VAR_228 ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> VAR_233 . VAR_219 <S2SV_ModStart> VAR_220 * 8 > VAR_233 . VAR_191 ) { METHOD_32 ( VAR_229 , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto VAR_228 ; } ; VAR_210 = METHOD_29 ( & VAR_233 , VAR_233 . VAR_219 + VAR_220 * 8","CWE-119 static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , ""Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\n"" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , ""Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\n"" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n"" ""<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n"" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\n"" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\n"" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , ""Bad<S2SV_blank>type<S2SV_blank>count.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , ""No<S2SV_blank>\'STR<S2SV_blank>\'<S2SV_blank>resource.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }","<S2SV_ModStart> + 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> rsrc . type_offset <S2SV_ModStart> k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8"
409,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { <S2SV_StartBug> TYPE_1 VAR_1 = 0 ; <S2SV_EndBug> TYPE_2 VAR_2 , VAR_3 ; METHOD_1 ( & STRUCT_OR_UNION_3 -> VAR_4 . VAR_5 -> VAR_6 . VAR_7 ) ; VAR_8 = STRUCT_OR_UNION_4 -> VAR_9 . VAR_10 -> VAR_11 . VAR_12 & VAR_13 ; VAR_14 = VAR_15 -> VAR_16 & VAR_17 ; if ( ! VAR_18 && VAR_19 ) VAR_20 = 1 ; METHOD_2 ( & STRUCT_OR_UNION_5 -> VAR_21 . VAR_22 -> VAR_23 . VAR_24 , & VAR_25 -> VAR_26 , sizeof ( STRUCT_OR_UNION_6 -> VAR_27 . VAR_28 -> VAR_29 . VAR_30 ) ) ; STRUCT_OR_UNION_7 -> VAR_31 . VAR_32 -> VAR_33 . VAR_34 = VAR_35 -> VAR_36 ; <S2SV_StartBug> METHOD_3 ( STRUCT_OR_UNION_8 , 0 , STRUCT_OR_UNION_9 -> VAR_37 . VAR_38 -> VAR_39 . VAR_40 [ 0 ] . VAR_41 , VAR_42 ) ; <S2SV_EndBug> METHOD_4 ( & STRUCT_OR_UNION_10 -> VAR_43 . VAR_44 -> VAR_45 . VAR_46 ) ; return 0 ; }","<S2SV_ModStart> VAR_42 = 0 ; TYPE_1 VAR_47 <S2SV_ModStart> -> VAR_36 ; for ( VAR_47 = 0 ; VAR_47 < 3 ; VAR_47 ++ ) <S2SV_ModStart> ( STRUCT_OR_UNION_10 , VAR_47 <S2SV_ModEnd> , STRUCT_OR_UNION_10 -> <S2SV_ModStart> . VAR_40 [ VAR_47 <S2SV_ModEnd> ] . VAR_41","CWE-000 static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { <S2SV_StartBug> int start = 0 ; <S2SV_EndBug> u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }","<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count"
410,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 ) { TYPE_2 * VAR_0 = METHOD_1 ( VAR_1 , VAR_2 ) + METHOD_2 ( VAR_3 ) ; TYPE_3 VAR_4 ; if ( METHOD_3 ( VAR_5 , ""%i"" , & VAR_6 ) != 1 ) { METHOD_4 ( VAR_7 , VAR_8 ) ; * ( METHOD_5 ( VAR_9 ) - 1 ) = '<S2SV_blank>' ; METHOD_6 ( ) ; <S2SV_StartBug> METHOD_7 ( VAR_10 , VAR_11 ) ; <S2SV_EndBug> METHOD_8 ( VAR_12 , VAR_13 ) ; VAR_14 = METHOD_9 ( VAR_15 ) ; } }","<S2SV_ModStart> ( ) ; METHOD_10 ( VAR_16 , METHOD_2 ( VAR_15 ) + METHOD_2 ( VAR_13 ) + 1 , VAR_17 ) ; <S2SV_ModStart> VAR_13 , VAR_15 ) ; METHOD_10 ( VAR_18 , METHOD_2 ( VAR_13 ) + 1 , VAR_17","CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE"
411,"CWE-264 TYPE_0 TYPE_1 METHOD_0 ( TYPE_2 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_3 VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_2 * VAR_6 ; unsigned TYPE_4 VAR_7 = 0 ; struct STRUCT_OR_UNION_3 * VAR_8 = VAR_9 ; struct STRUCT_OR_UNION_4 * VAR_10 = VAR_11 ; struct STRUCT_OR_UNION_5 * VAR_12 = VAR_13 ; TYPE_5 VAR_14 ; METHOD_1 ( VAR_15 ) ; if ( VAR_16 -> VAR_17 & VAR_18 ) return METHOD_2 ( VAR_19 ) ; if ( METHOD_3 ( VAR_20 ) ) return METHOD_4 ( VAR_21 ) ; if ( ( VAR_22 & VAR_23 ) && ( VAR_24 -> VAR_25 > ( TYPE_6 ) - 1 ) && ! METHOD_5 ( & VAR_26 -> VAR_27 -> VAR_28 ) ) return METHOD_6 ( VAR_29 ) ; if ( METHOD_7 ( VAR_30 ) && ( VAR_31 & VAR_32 ) ) { VAR_33 = METHOD_8 ( VAR_34 , VAR_35 -> VAR_36 . VAR_37 , VAR_38 -> VAR_39 . VAR_40 , VAR_41 -> VAR_42 , VAR_43 , & VAR_44 , VAR_45 , & VAR_46 ) ; if ( VAR_47 ) return VAR_48 ; } VAR_49 = METHOD_9 ( VAR_50 , VAR_51 ) ; VAR_52 = METHOD_10 ( VAR_53 , & METHOD_11 ( VAR_54 ) -> VAR_55 , 0 , 0 ) ; if ( VAR_56 ) goto VAR_57 ; VAR_58 = VAR_59 ; METHOD_12 ( VAR_60 , VAR_61 ) ; if ( ! METHOD_13 ( METHOD_14 ( VAR_62 ) ) ) { VAR_63 = METHOD_15 ( VAR_64 ) ; goto VAR_65 ; } if ( VAR_66 & VAR_67 ) { if ( METHOD_16 ( ) != & VAR_68 ) { VAR_69 = METHOD_17 ( VAR_70 ) ; goto VAR_71 ; } if ( METHOD_18 ( VAR_72 ) && METHOD_19 ( VAR_73 ) && METHOD_20 ( VAR_74 ) != VAR_75 -> VAR_76 ) { METHOD_21 ( VAR_77 ) ; VAR_78 = METHOD_22 ( VAR_79 , VAR_80 , VAR_81 , VAR_82 , VAR_83 , METHOD_23 ( VAR_84 ) ? VAR_85 : 0 ) ; if ( VAR_86 ) goto VAR_87 ; } } if ( VAR_88 & VAR_89 ) { if ( VAR_90 -> VAR_91 . VAR_92 && ( ( VAR_93 -> VAR_94 . VAR_95 << VAR_96 -> VAR_97 . VAR_98 ) != VAR_99 -> VAR_100 ) ) { VAR_101 = METHOD_24 ( VAR_102 ) ; goto VAR_103 ; } if ( VAR_104 -> VAR_105 != 0 ) { TYPE_7 VAR_106 ; TYPE_8 VAR_107 ; VAR_108 = METHOD_25 ( VAR_109 , VAR_110 -> VAR_111 ) ; if ( VAR_112 > VAR_113 ) { VAR_114 = METHOD_26 ( VAR_115 ) ; goto VAR_116 ; } if ( METHOD_27 ( VAR_117 ) || ( ( VAR_118 & VAR_119 ) && ( VAR_120 -> VAR_121 & VAR_122 ) ) ) { VAR_123 = VAR_124 -> VAR_125 . VAR_126 << VAR_127 -> VAR_128 . VAR_129 ; } else { VAR_130 = VAR_131 -> VAR_132 . VAR_133 ; if ( VAR_134 > VAR_135 -> VAR_136 . VAR_137 / 2 ) { VAR_138 = METHOD_28 ( VAR_139 ) ; goto VAR_140 ; } } if ( VAR_141 -> VAR_142 % VAR_143 ) { VAR_144 = METHOD_29 ( VAR_145 ) ; goto VAR_146 ; } } } if ( VAR_147 & VAR_148 ) { if ( ( VAR_149 -> VAR_150 . VAR_151 || VAR_152 -> VAR_153 ) && ( METHOD_30 ( VAR_154 ) ) != ( VAR_155 -> VAR_156 & VAR_157 ) ) { VAR_158 = METHOD_31 ( VAR_159 ) ; goto VAR_160 ; } if ( ( VAR_161 -> VAR_162 & VAR_163 ) ) { if ( ( VAR_164 -> VAR_165 . VAR_166 == 0 ) || ( VAR_167 -> VAR_168 . VAR_169 == 0 ) || ( VAR_170 -> VAR_171 . VAR_172 % VAR_173 -> VAR_174 . VAR_175 ) ) { VAR_176 = METHOD_32 ( VAR_177 ) ; goto VAR_178 ; } } if ( ( VAR_179 -> VAR_180 . VAR_181 & ( VAR_182 | VAR_183 ) || ( VAR_184 -> VAR_185 & ( VAR_186 | VAR_187 ) ) ) && ! METHOD_33 ( VAR_188 ) ) { VAR_189 = METHOD_34 ( VAR_190 ) ; goto VAR_191 ; } } METHOD_35 ( VAR_192 , VAR_193 , 0 ) ; if ( VAR_194 & VAR_195 ) { if ( ( VAR_196 -> VAR_197 . VAR_198 & ( VAR_199 | VAR_200 ) ) && <S2SV_StartBug> ! METHOD_36 ( METHOD_37 ( VAR_201 ) , VAR_202 ) ) <S2SV_EndBug> VAR_203 -> VAR_204 . VAR_205 &= ~ ( VAR_206 | VAR_207 ) ; if ( METHOD_38 ( VAR_208 ) != VAR_209 -> VAR_210 ) { if ( METHOD_39 ( VAR_211 ) && METHOD_40 ( VAR_212 ) ) { VAR_213 = METHOD_41 ( VAR_214 , VAR_215 , & VAR_216 -> VAR_217 , VAR_218 ) ; } METHOD_42 ( VAR_219 , VAR_220 -> VAR_221 ) ; if ( VAR_222 -> VAR_223 . VAR_224 == 1 ) METHOD_43 ( VAR_225 , VAR_226 ) ; } } if ( VAR_227 & VAR_228 ) VAR_229 -> VAR_230 . VAR_231 = VAR_232 -> VAR_233 >> VAR_234 -> VAR_235 . VAR_236 ; if ( VAR_237 & VAR_238 ) { METHOD_44 ( VAR_239 , VAR_240 -> VAR_241 ) ; METHOD_45 ( VAR_242 ) ; } METHOD_46 ( VAR_243 , VAR_244 , VAR_245 ) ; METHOD_47 ( VAR_246 , VAR_247 , VAR_248 ) ; METHOD_48 ( VAR_249 ) ; if ( VAR_250 -> VAR_251 & VAR_252 ) METHOD_49 ( VAR_253 ) ; VAR_254 = METHOD_50 ( VAR_255 , 0 ) ; METHOD_51 ( VAR_256 , VAR_257 ) ; METHOD_52 ( VAR_258 ) ; METHOD_53 ( VAR_259 ) ; METHOD_54 ( VAR_260 ) ; return VAR_261 ; VAR_262 : METHOD_55 ( VAR_263 ) ; METHOD_56 ( VAR_264 ) ; METHOD_57 ( VAR_265 , 0 ) ; if ( VAR_266 ) METHOD_58 ( VAR_267 , VAR_268 ) ; return VAR_269 ; }",<S2SV_ModStart> ) && ! METHOD_59 <S2SV_ModEnd> ( METHOD_37 (,"CWE-264 STATIC int xfs_ioctl_setattr ( xfs_inode_t * ip , struct fsxattr * fa , int mask ) { struct xfs_mount * mp = ip -> i_mount ; struct xfs_trans * tp ; unsigned int lock_flags = 0 ; struct xfs_dquot * udqp = NULL ; struct xfs_dquot * pdqp = NULL ; struct xfs_dquot * olddquot = NULL ; int code ; trace_xfs_ioctl_setattr ( ip ) ; if ( mp -> m_flags & XFS_MOUNT_RDONLY ) return XFS_ERROR ( EROFS ) ; if ( XFS_FORCED_SHUTDOWN ( mp ) ) return XFS_ERROR ( EIO ) ; if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) { code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ; if ( code ) return code ; } tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ; code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ; if ( code ) goto error_return ; lock_flags = XFS_ILOCK_EXCL ; xfs_ilock ( ip , lock_flags ) ; if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } if ( mask & FSX_PROJID ) { if ( current_user_ns ( ) != & init_user_ns ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) && xfs_get_projid ( ip ) != fa -> fsx_projid ) { ASSERT ( tp ) ; code = xfs_qm_vop_chown_reserve ( tp , ip , udqp , NULL , pdqp , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( code ) goto error_return ; } } if ( mask & FSX_EXTSIZE ) { if ( ip -> i_d . di_nextents && ( ( ip -> i_d . di_extsize << mp -> m_sb . sb_blocklog ) != fa -> fsx_extsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( fa -> fsx_extsize != 0 ) { xfs_extlen_t size ; xfs_fsblock_t extsize_fsb ; extsize_fsb = XFS_B_TO_FSB ( mp , fa -> fsx_extsize ) ; if ( extsize_fsb > MAXEXTLEN ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_REALTIME_INODE ( ip ) || ( ( mask & FSX_XFLAGS ) && ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) ) { size = mp -> m_sb . sb_rextsize << mp -> m_sb . sb_blocklog ; } else { size = mp -> m_sb . sb_blocksize ; if ( extsize_fsb > mp -> m_sb . sb_agblocks / 2 ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( fa -> fsx_extsize % size ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } } if ( mask & FSX_XFLAGS ) { if ( ( ip -> i_d . di_nextents || ip -> i_delayed_blks ) && ( XFS_IS_REALTIME_INODE ( ip ) ) != ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { if ( ( mp -> m_sb . sb_rblocks == 0 ) || ( mp -> m_sb . sb_rextsize == 0 ) || ( ip -> i_d . di_extsize % mp -> m_sb . sb_rextsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( ( ip -> i_d . di_flags & ( XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND ) || ( fa -> fsx_xflags & ( XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND ) ) ) && ! capable ( CAP_LINUX_IMMUTABLE ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } } xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & FSX_PROJID ) { if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( xfs_get_projid ( ip ) != fa -> fsx_projid ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) ) { olddquot = xfs_qm_vop_chown ( tp , ip , & ip -> i_pdquot , pdqp ) ; } xfs_set_projid ( ip , fa -> fsx_projid ) ; if ( ip -> i_d . di_version == 1 ) xfs_bump_ino_vers2 ( tp , ip ) ; } } if ( mask & FSX_EXTSIZE ) ip -> i_d . di_extsize = fa -> fsx_extsize >> mp -> m_sb . sb_blocklog ; if ( mask & FSX_XFLAGS ) { xfs_set_diflags ( ip , fa -> fsx_xflags ) ; xfs_diflags_to_linux ( ip ) ; } xfs_trans_ichgtime ( tp , ip , XFS_ICHGTIME_CHG ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; code = xfs_trans_commit ( tp , 0 ) ; xfs_iunlock ( ip , lock_flags ) ; xfs_qm_dqrele ( olddquot ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; return code ; error_return : xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; xfs_trans_cancel ( tp , 0 ) ; if ( lock_flags ) xfs_iunlock ( ip , lock_flags ) ; return code ; }",<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I (
412,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; METHOD_2 ( VAR_8 ) ; if ( VAR_9 -> VAR_10 == VAR_11 && METHOD_3 ( VAR_12 , & METHOD_4 ( VAR_13 ) -> VAR_14 ) ) { METHOD_5 ( VAR_15 -> VAR_16 -> VAR_17 , 0 ) ; VAR_18 -> VAR_19 = VAR_20 ; <S2SV_StartBug> METHOD_6 ( VAR_21 ) ; <S2SV_EndBug> return 0 ; } METHOD_7 ( VAR_22 ) ; return METHOD_8 ( VAR_23 , STRUCT_OR_UNION_7 , VAR_24 , VAR_25 , VAR_26 ) ; }",<S2SV_ModStart> = VAR_20 ; VAR_24 -> VAR_27 = 0 ;,"CWE-200 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }",<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;
413,"CWE-399 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , unsigned TYPE_1 VAR_0 , unsigned TYPE_2 VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; TYPE_3 VAR_3 ; VAR_4 = METHOD_1 ( STRUCT_OR_UNION_3 ) ; if ( ! VAR_5 ) return - VAR_6 ; METHOD_2 ( VAR_7 ) ; switch ( VAR_8 ) { case VAR_9 : { unsigned TYPE_4 VAR_10 , VAR_11 ; VAR_12 = METHOD_3 ( VAR_13 ) ; VAR_14 = VAR_15 >> VAR_16 ; VAR_17 = - VAR_18 ; if ( ! VAR_19 ) goto VAR_20 ; if ( ! METHOD_4 ( VAR_21 ) && VAR_22 > VAR_23 ) { VAR_24 = - VAR_25 ; goto VAR_26 ; <S2SV_StartBug> } <S2SV_EndBug> VAR_27 = METHOD_5 ( VAR_28 , VAR_29 ) ; break ; } case VAR_30 : VAR_31 = VAR_32 -> VAR_33 * VAR_34 ; break ; default : VAR_35 = - VAR_36 ; break ; } VAR_37 : METHOD_6 ( VAR_38 ) ; return VAR_39 ; }",<S2SV_ModStart> VAR_37 ; } else if ( ( METHOD_7 ( VAR_38 -> VAR_40 ) || METHOD_8 ( VAR_38 -> VAR_40 ) ) && ! METHOD_4 ( VAR_21 ) && ! METHOD_4 ( VAR_41 ) ) { VAR_39 = - VAR_25 ; goto VAR_37 ; },"CWE-399 long pipe_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct pipe_inode_info * pipe ; long ret ; pipe = get_pipe_info ( file ) ; if ( ! pipe ) return - EBADF ; __pipe_lock ( pipe ) ; switch ( cmd ) { case F_SETPIPE_SZ : { unsigned int size , nr_pages ; size = round_pipe_size ( arg ) ; nr_pages = size >> PAGE_SHIFT ; ret = - EINVAL ; if ( ! nr_pages ) goto out ; if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size ) { ret = - EPERM ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> ret = pipe_set_size ( pipe , nr_pages ) ; break ; } case F_GETPIPE_SZ : ret = pipe -> buffers * PAGE_SIZE ; break ; default : ret = - EINVAL ; break ; } out : __pipe_unlock ( pipe ) ; return ret ; }",<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
414,"CWE-835 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * * VAR_1 , unsigned TYPE_1 VAR_2 , unsigned TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = VAR_4 -> VAR_5 ; <S2SV_StartBug> TYPE_3 TYPE_4 <S2SV_EndBug> if ( ! STRUCT_OR_UNION_4 ) { <S2SV_StartBug> * VAR_6 = VAR_7 ; <S2SV_EndBug> METHOD_1 ( VAR_8 , VAR_9 , VAR_10 ) ; return 0 ; } if ( METHOD_2 ( STRUCT_OR_UNION_5 -> VAR_11 ) ) { <S2SV_StartBug> * VAR_12 = VAR_13 ; <S2SV_EndBug> METHOD_3 ( VAR_14 , VAR_15 , VAR_16 , STRUCT_OR_UNION_6 -> VAR_17 ) ; return 0 ; } else if ( ! STRUCT_OR_UNION_7 ) return - VAR_18 ; if ( METHOD_4 ( METHOD_5 ( STRUCT_OR_UNION_8 ) ) ) { return 0 ; } <S2SV_StartBug> * VAR_19 = VAR_20 ; <S2SV_EndBug> VAR_21 = ( ( VAR_22 - VAR_23 -> VAR_24 ) >> VAR_25 ) + VAR_26 -> VAR_27 ; if ( VAR_28 > VAR_29 -> VAR_30 ) VAR_31 = VAR_32 -> VAR_33 ; VAR_34 = ( ( VAR_35 - VAR_36 -> VAR_37 ) >> VAR_38 ) + VAR_39 -> VAR_40 ; METHOD_6 ( STRUCT_OR_UNION_9 -> VAR_41 , STRUCT_OR_UNION_10 , VAR_42 , VAR_43 - VAR_44 ) ; return 0 ; }",<S2SV_ModStart> -> VAR_5 ; * VAR_19 = VAR_39 ; <S2SV_ModStart> STRUCT_OR_UNION_10 ) { <S2SV_ModEnd> METHOD_1 ( VAR_39 <S2SV_ModStart> ) ) { <S2SV_ModEnd> METHOD_3 ( VAR_39 <S2SV_ModStart> 0 ; } <S2SV_ModEnd> VAR_44 = (,"CWE-835 static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ; <S2SV_StartBug>  ifdef CONFIG_SWAP <S2SV_EndBug> if ( ! file ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; }  else if ( ! file ) return - EBADF ;   if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; } <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }",<S2SV_ModStart> -> vm_file ; * prev = vma ; <S2SV_ModStart> file ) { <S2SV_ModEnd> force_swapin_readahead ( vma <S2SV_ModStart> ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma <S2SV_ModStart> 0 ; } <S2SV_ModEnd> start = (
415,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { const struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 -> VAR_4 ; TYPE_1 VAR_5 , VAR_6 , VAR_7 ; struct STRUCT_OR_UNION_3 VAR_8 ; TYPE_2 TYPE_3 ; <S2SV_StartBug> TYPE_4 = ( VAR_9 -> VAR_10 & ~ VAR_11 ) == VAR_12 ; <S2SV_EndBug> VAR_13 = VAR_14 -> VAR_15 ; if ( VAR_16 ) { VAR_17 -> VAR_18 = METHOD_1 ( VAR_19 ) ; } else if ( ! VAR_20 -> VAR_21 ) { if ( ! TYPE_5 ) return ; } VAR_22 -> METHOD_2 ( VAR_23 -> VAR_24 , & VAR_25 ) ; VAR_26 = METHOD_3 ( VAR_27 ) ; if ( VAR_28 && ( VAR_29 -> VAR_30 & VAR_31 || TYPE_6 ) ) VAR_32 -> VAR_33 += VAR_34 -> METHOD_4 ( VAR_35 , VAR_36 ) ; VAR_37 = VAR_38 -> METHOD_5 ( VAR_39 , VAR_40 ) ; if ( VAR_41 <= 0 ) { if ( ! TYPE_7 ) VAR_42 -> VAR_43 . VAR_44 = 1 ; } else { VAR_45 -> VAR_46 = METHOD_6 ( VAR_47 ) ; } }",<S2SV_ModStart> ; TYPE_7 = <S2SV_ModEnd> VAR_39 -> VAR_10 <S2SV_ModStart> VAR_39 -> VAR_10 <S2SV_ModEnd> == VAR_12 ;,"CWE-125 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }",<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
416,"CWE-476 TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; <S2SV_StartBug> if ( ! ( VAR_4 = METHOD_1 ( sizeof ( TYPE_5 ) ) ) ) { <S2SV_EndBug> return 0 ; } VAR_5 -> VAR_6 = 0 ; VAR_7 -> VAR_8 = VAR_9 ; VAR_10 -> VAR_11 = VAR_12 ; VAR_13 -> VAR_14 = 0 ; VAR_15 -> VAR_16 = VAR_17 ; VAR_18 -> VAR_19 = 0 ; VAR_20 -> VAR_21 = VAR_22 * VAR_23 ; if ( VAR_24 -> VAR_25 > 0 ) { if ( ! ( VAR_26 -> VAR_27 = METHOD_2 ( VAR_28 -> VAR_29 , sizeof ( TYPE_6 * ) ) ) ) { METHOD_3 ( VAR_30 ) ; return 0 ; } } if ( VAR_31 -> VAR_32 > 0 ) { if ( ! ( VAR_33 -> VAR_34 = METHOD_4 ( VAR_35 -> VAR_36 , sizeof ( TYPE_7 ) ) ) ) { METHOD_5 ( VAR_37 ) ; return 0 ; } } for ( VAR_38 = 0 ; VAR_39 < VAR_40 ; ++ VAR_41 ) { VAR_42 -> VAR_43 [ VAR_44 ] = & VAR_45 -> VAR_46 [ VAR_47 * VAR_48 -> VAR_49 ] ; } for ( VAR_50 = 0 ; VAR_51 < VAR_52 -> VAR_53 ; ++ VAR_54 ) { VAR_55 -> VAR_56 [ VAR_57 ] = 0 ; } VAR_58 -> VAR_59 = 0 ; VAR_60 -> VAR_61 = 0 ; VAR_62 -> VAR_63 = VAR_64 -> VAR_65 ; VAR_66 -> VAR_67 = VAR_68 -> VAR_69 ; return VAR_70 ; }",<S2SV_ModStart> ; if ( VAR_40 < 0 || VAR_23 < 0 ) { return 0 ; } if (,"CWE-476 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> return 0 ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }",<S2SV_ModStart> ; if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
417,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 ) { TYPE_2 VAR_0 [ 16 ] ; <S2SV_StartBug> TYPE_3 VAR_1 = METHOD_1 ( VAR_2 , VAR_3 ) ; <S2SV_EndBug> if ( ! METHOD_2 ( VAR_4 == sizeof ( VAR_5 ) - 1 ) ) { METHOD_3 ( ""Expected:<S2SV_blank>%zu"" , sizeof ( VAR_6 ) - 1 ) ; METHOD_4 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , VAR_7 ) ; } VAR_8 [ VAR_9 ] = '\\0' ; if ( ! METHOD_5 ( METHOD_6 ( VAR_10 , VAR_11 ) == 0 ) ) { METHOD_7 ( ""Expected:<S2SV_blank>%s"" , VAR_12 ) ; METHOD_8 ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , VAR_13 ) ; } }","<S2SV_ModStart> VAR_13 , VAR_3 , sizeof ( VAR_13 )","CWE-119 void test_base64_decode ( void ) { char buffer [ 16 ] ; <S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , sizeof ( clear ) - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , len ) ; } buffer [ len ] = '\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , clear ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , buffer ) ; } }","<S2SV_ModStart> buffer , encoded , sizeof ( buffer )"
418,"CWE-787 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 = STRUCT_OR_UNION_4 -> VAR_4 ; struct STRUCT_OR_UNION_5 VAR_5 ; TYPE_3 VAR_6 , VAR_7 = 0 ; METHOD_1 ( ""sk<S2SV_blank>%p"" , VAR_8 ) ; if ( ! VAR_9 || VAR_10 -> VAR_11 != VAR_12 ) return - VAR_13 ; METHOD_2 ( & VAR_14 , 0 , sizeof ( VAR_15 ) ) ; VAR_16 = min_t ( unsigned TYPE_4 , sizeof ( VAR_17 ) , VAR_18 ) ; METHOD_3 ( & VAR_19 , VAR_20 , VAR_21 ) ; if ( VAR_22 . VAR_23 ) return - VAR_24 ; METHOD_4 ( VAR_25 ) ; if ( VAR_26 -> VAR_27 == VAR_28 && ! VAR_29 . VAR_30 ) { VAR_31 = - VAR_32 ; goto VAR_33 ; } switch ( METHOD_5 ( VAR_34 ) -> VAR_35 ) { case VAR_36 : break ; case VAR_37 : <S2SV_StartBug> if ( VAR_38 ) <S2SV_EndBug> break ; default : VAR_39 = - VAR_40 ; goto VAR_41 ; } switch ( VAR_42 -> VAR_43 ) { case VAR_44 : case VAR_45 : case VAR_46 : goto VAR_47 ; case VAR_48 : goto VAR_49 ; case VAR_50 : case VAR_51 : break ; default : VAR_52 = - VAR_53 ; goto VAR_54 ; } METHOD_6 ( & METHOD_7 ( VAR_55 ) -> VAR_56 , & VAR_57 . VAR_58 ) ; METHOD_8 ( VAR_59 ) -> VAR_60 = VAR_61 . VAR_62 ; VAR_63 = METHOD_9 ( VAR_64 ) ; if ( VAR_65 ) goto VAR_66 ; VAR_67 : VAR_68 = METHOD_10 ( VAR_69 , VAR_70 , METHOD_11 ( VAR_71 , VAR_72 & VAR_73 ) ) ; VAR_74 : METHOD_12 ( VAR_75 ) ; return VAR_76 ; }",<S2SV_ModStart> case VAR_37 : case VAR_77 :,"CWE-787 static int l2cap_sock_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_l2 la ; int len , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & la , 0 , sizeof ( la ) ) ; len = min_t ( unsigned int , sizeof ( la ) , alen ) ; memcpy ( & la , addr , len ) ; if ( la . l2_cid ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && ! la . l2_psm ) { err = - EINVAL ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case L2CAP_MODE_BASIC : break ; case L2CAP_MODE_ERTM : <S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> break ; default : err = - ENOTSUPP ; goto done ; } switch ( sk -> sk_state ) { case BT_CONNECT : case BT_CONNECT2 : case BT_CONFIG : goto wait ; case BT_CONNECTED : goto done ; case BT_OPEN : case BT_BOUND : break ; default : err = - EBADFD ; goto done ; } bacpy ( & bt_sk ( sk ) -> dst , & la . l2_bdaddr ) ; l2cap_pi ( sk ) -> psm = la . l2_psm ; err = l2cap_do_connect ( sk ) ; if ( err ) goto done ; wait : err = bt_sock_wait_state ( sk , BT_CONNECTED , sock_sndtimeo ( sk , flags & O_NONBLOCK ) ) ; done : release_sock ( sk ) ; return err ; }",<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
419,"CWE-476 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { if ( VAR_4 ) { TYPE_5 VAR_5 ; TYPE_6 VAR_6 = VAR_7 ? VAR_8 -> VAR_9 : 0 ; for ( VAR_10 = 0 ; VAR_11 < VAR_12 -> VAR_13 ; VAR_14 ++ ) { TYPE_7 * VAR_15 = METHOD_1 ( VAR_16 -> VAR_17 , VAR_18 -> VAR_19 [ VAR_20 ] . VAR_21 , 0 ) ; <S2SV_StartBug> if ( VAR_22 && VAR_23 && VAR_24 -> VAR_25 == VAR_26 ) { <S2SV_EndBug> VAR_27 -> VAR_28 = VAR_29 ; <S2SV_StartBug> VAR_30 -> VAR_31 &= ~ ( VAR_32 | VAR_33 | VAR_34 ) ; <S2SV_EndBug> } VAR_35 = METHOD_2 ( VAR_36 , VAR_37 , VAR_38 ) ; if ( VAR_39 ) VAR_40 -> VAR_41 [ VAR_42 + VAR_43 ] . VAR_44 = VAR_45 -> VAR_46 [ VAR_47 ] . VAR_48 ; } } return VAR_49 ; }","<S2SV_ModStart> 0 ) ; METHOD_4 ( VAR_38 == 0 || ! METHOD_3 ( VAR_38 , VAR_50 ) ) ; <S2SV_ModStart> | VAR_34 ) ; VAR_38 -> VAR_51 . VAR_52 = 0","CWE-476 static ExprList * exprListAppendList ( Parse * pParse , ExprList * pList , ExprList * pAppend , int bIntToNull ) { if ( pAppend ) { int i ; int nInit = pList ? pList -> nExpr : 0 ; for ( i = 0 ; i < pAppend -> nExpr ; i ++ ) { Expr * pDup = sqlite3ExprDup ( pParse -> db , pAppend -> a [ i ] . pExpr , 0 ) ; <S2SV_StartBug> if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) { <S2SV_EndBug> pDup -> op = TK_NULL ; <S2SV_StartBug> pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ; <S2SV_EndBug> } pList = sqlite3ExprListAppend ( pParse , pList , pDup ) ; if ( pList ) pList -> a [ nInit + i ] . sortFlags = pAppend -> a [ i ] . sortFlags ; } } return pList ; }","<S2SV_ModStart> 0 ) ; assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ; <S2SV_ModStart> | EP_IsFalse ) ; pDup -> u . zToken = 0"
420,"CWE-310 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { VAR_4 * VAR_5 ; unsigned TYPE_5 VAR_6 [ VAR_7 ] , * VAR_8 = VAR_9 ; unsigned TYPE_6 VAR_10 [ VAR_11 ] , * VAR_12 = VAR_13 ; TYPE_7 VAR_14 , VAR_15 ; if ( METHOD_1 ( VAR_16 , VAR_17 , ""02"" , & VAR_18 , & VAR_19 ) > 0 ) { TYPE_8 VAR_20 = METHOD_2 ( METHOD_3 ( VAR_21 ) ) ; rb_warn ( ""arguments<S2SV_blank>for<S2SV_blank>%"" PRIsVALUE ""encrypt<S2SV_blank>and<S2SV_blank>%"" PRIsVALUE ""decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>"" ""use<S2SV_blank>%"" PRIsVALUE ""pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV"" , VAR_22 , VAR_23 , VAR_24 ) ; METHOD_4 ( VAR_25 ) ; METHOD_5 ( VAR_26 , VAR_27 ) ; if ( METHOD_6 ( VAR_28 ) ) METHOD_7 ( VAR_29 , ""OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!"" , sizeof ( VAR_30 ) ) ; else { METHOD_8 ( VAR_31 ) ; if ( VAR_32 > METHOD_9 ( VAR_33 ) ) { METHOD_10 ( VAR_34 , 0 , VAR_35 ) ; METHOD_11 ( VAR_36 , METHOD_12 ( VAR_37 ) , METHOD_13 ( VAR_38 ) ) ; } else METHOD_14 ( VAR_39 , METHOD_15 ( VAR_40 ) , sizeof ( VAR_41 ) ) ; } METHOD_16 ( METHOD_17 ( VAR_42 ) , METHOD_18 ( ) , VAR_43 , ( unsigned TYPE_9 * ) METHOD_19 ( VAR_44 ) , METHOD_20 ( VAR_45 ) , 1 , VAR_46 , VAR_47 ) ; VAR_48 = VAR_49 ; VAR_50 = VAR_51 ; } else { METHOD_21 ( VAR_52 , VAR_53 ) ; } if ( METHOD_22 ( VAR_54 , VAR_55 , VAR_56 , VAR_57 , VAR_58 , VAR_59 ) != 1 ) { METHOD_23 ( VAR_60 , VAR_61 ) ; } <S2SV_StartBug> return VAR_62 ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; } if ( VAR_57 ) METHOD_24 ( VAR_62 , VAR_63 , VAR_64 ) ;","CWE-310 static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) { EVP_CIPHER_CTX * ctx ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; VALUE pass , init_v ; if ( rb_scan_args ( argc , argv , ""02"" , & pass , & init_v ) > 0 ) { VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; rb_warn ( ""arguments<S2SV_blank>for<S2SV_blank>%"" PRIsVALUE ""encrypt<S2SV_blank>and<S2SV_blank>%"" PRIsVALUE ""decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>"" ""use<S2SV_blank>%"" PRIsVALUE ""pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV"" , cname , cname , cname ) ; StringValue ( pass ) ; GetCipher ( self , ctx ) ; if ( NIL_P ( init_v ) ) memcpy ( iv , ""OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!"" , sizeof ( iv ) ) ; else { StringValue ( init_v ) ; if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; } else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; } EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; p_key = key ; p_iv = iv ; } else { GetCipher ( self , ctx ) ; } if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { ossl_raise ( eCipherError , NULL ) ; } <S2SV_StartBug> return self ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;"
421,"CWE-476 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , unsigned TYPE_2 VAR_1 , const TYPE_3 * VAR_2 , unsigned TYPE_4 VAR_3 , const TYPE_5 * VAR_4 , const TYPE_6 * VAR_5 , unsigned TYPE_7 VAR_6 ) { TYPE_8 VAR_7 , VAR_8 ; TYPE_9 VAR_9 [ 32 ] ; TYPE_10 VAR_10 [ 32 ] ; unsigned TYPE_11 VAR_11 ; struct STRUCT_OR_UNION_0 VAR_12 ; unsigned TYPE_12 VAR_13 ; VAR_14 = METHOD_1 ( VAR_15 ) ; if ( METHOD_2 ( VAR_16 , & VAR_17 ) <= 0 ) { METHOD_3 ( VAR_18 , ""inet_aton(%s)<S2SV_blank>FAILED"" , VAR_19 ) ; return - 1 ; } if ( ! METHOD_4 ( VAR_20 , VAR_21 , VAR_22 , VAR_23 , VAR_24 ) ) { METHOD_5 ( VAR_25 , ""redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>"" ""%hu->%s:%hu<S2SV_blank>%s"" , VAR_26 , VAR_27 , VAR_28 , VAR_29 ) ; return - 3 ; } <S2SV_StartBug> VAR_30 [ 0 ] = '\\0' ; <S2SV_EndBug> VAR_31 = METHOD_6 ( VAR_32 , VAR_33 , VAR_34 , VAR_35 , sizeof ( VAR_36 ) , & VAR_37 , 0 , 0 , VAR_38 , sizeof ( VAR_39 ) , & VAR_40 , 0 , 0 ) ; if ( VAR_41 == 0 ) { if ( METHOD_7 ( VAR_42 , VAR_43 ) == 0 && ( ( VAR_44 == VAR_45 && VAR_46 [ 0 ] == '\\0' ) || ( VAR_47 && ( METHOD_8 ( VAR_48 , ""*"" ) == 0 ) && VAR_49 [ 0 ] == '\\0' ) || ( VAR_50 && ( METHOD_9 ( VAR_51 , VAR_52 ) == 0 ) ) ) ) { METHOD_10 ( VAR_53 , ""updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu"" , VAR_54 , VAR_55 , VAR_56 , VAR_57 , VAR_58 ) ; VAR_59 = ( VAR_60 > 0 ) ? METHOD_11 ( ) + VAR_61 : 0 ; if ( VAR_62 != VAR_63 ) { VAR_64 = METHOD_12 ( VAR_65 , VAR_66 , VAR_67 , VAR_68 , VAR_69 , VAR_70 ) ; } else { VAR_71 = METHOD_13 ( VAR_72 , VAR_73 , VAR_74 , VAR_75 , VAR_76 ) ; } TYPE_13 TYPE_14 if ( VAR_77 == 0 ) { METHOD_14 ( VAR_78 , VAR_79 ) ; METHOD_15 ( VAR_80 , VAR_81 , VAR_82 , VAR_83 , VAR_84 , VAR_85 ) ; } return VAR_86 ; } else { METHOD_16 ( VAR_87 , ""port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu"" , VAR_88 , VAR_89 , VAR_90 , VAR_91 , VAR_92 ) ; return - 2 ; } TYPE_15 TYPE_16 } else if ( METHOD_17 ( VAR_93 , VAR_94 , VAR_95 , VAR_96 , VAR_97 ) > 0 ) { METHOD_18 ( VAR_98 , ""port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , VAR_99 , VAR_100 ) ; return - 4 ; } else { VAR_101 = ( VAR_102 > 0 ) ? METHOD_19 ( ) + VAR_103 : 0 ; METHOD_20 ( VAR_104 , ""redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s"" , VAR_105 , VAR_106 , VAR_107 , VAR_108 , VAR_109 ) ; return METHOD_21 ( VAR_110 , VAR_111 , VAR_112 , VAR_113 , VAR_114 , VAR_115 , VAR_116 ) ; } }","<S2SV_ModStart> 3 ; } if ( VAR_115 == VAR_45 ) VAR_115 = """" ;","CWE-476 int upnp_redirect ( const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , const char * protocol , const char * desc , unsigned int leaseduration ) { int proto , r ; char iaddr_old [ 32 ] ; char rhost_old [ 32 ] ; unsigned short iport_old ; struct in_addr address ; unsigned int timestamp ; proto = proto_atoi ( protocol ) ; if ( inet_aton ( iaddr , & address ) <= 0 ) { syslog ( LOG_ERR , ""inet_aton(%s)<S2SV_blank>FAILED"" , iaddr ) ; return - 1 ; } if ( ! check_upnp_rule_against_permissions ( upnppermlist , num_upnpperm , eport , address , iport ) ) { syslog ( LOG_INFO , ""redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>"" ""%hu->%s:%hu<S2SV_blank>%s"" , eport , iaddr , iport , protocol ) ; return - 3 ; } <S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ; if ( r == 0 ) { if ( strcmp ( iaddr , iaddr_old ) == 0 && ( ( rhost == NULL && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , ""*"" ) == 0 ) && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , rhost_old ) == 0 ) ) ) ) { syslog ( LOG_INFO , ""updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu"" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; if ( iport != iport_old ) { r = update_portmapping ( ext_if_name , eport , proto , iport , desc , timestamp ) ; } else { r = update_portmapping_desc_timestamp ( ext_if_name , eport , proto , desc , timestamp ) ; }  ifdef ENABLE_LEASEFILE if ( r == 0 ) { lease_file_remove ( eport , proto ) ; lease_file_add ( eport , iaddr , iport , proto , desc , timestamp ) ; }   return r ; } else { syslog ( LOG_INFO , ""port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu"" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; return - 2 ; }  ifdef CHECK_PORTINUSE } else if ( port_in_use ( ext_if_name , eport , proto , iaddr , iport ) > 0 ) { syslog ( LOG_INFO , ""port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , eport , protocol ) ; return - 4 ;   } else { timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; syslog ( LOG_INFO , ""redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s"" , eport , iaddr , iport , protocol , desc ) ; return upnp_redirect_internal ( rhost , eport , iaddr , iport , proto , desc , timestamp ) ; } }","<S2SV_ModStart> 3 ; } if ( desc == NULL ) desc = """" ;"
422,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , register const TYPE_2 * VAR_1 ) { const struct STRUCT_OR_UNION_0 * VAR_2 ; const struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 ; const TYPE_3 * VAR_3 , * VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 , VAR_7 , VAR_8 , VAR_9 ; TYPE_6 VAR_10 , VAR_11 ; VAR_12 = ( const struct STRUCT_OR_UNION_3 * ) VAR_13 ; METHOD_1 ( * VAR_14 ) ; if ( METHOD_2 ( & VAR_15 -> VAR_16 ) != VAR_17 ) { METHOD_3 ( ( VAR_18 , ""%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , ( VAR_19 -> VAR_20 < 1 ) ? """" : ""\\n\\t"" , METHOD_4 ( & VAR_21 -> VAR_22 ) ) ) ; return 0 ; } VAR_23 = METHOD_5 ( & VAR_24 -> VAR_25 ) ; if ( VAR_26 < sizeof ( const struct STRUCT_OR_UNION_4 ) - 4 ) { METHOD_6 ( ( VAR_27 , ""%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( VAR_28 -> VAR_29 < 1 ) ? """" : ""\\n\\t"" , VAR_30 , ( TYPE_7 ) ( sizeof ( const struct STRUCT_OR_UNION_5 ) - 4 ) ) ) ; return 0 ; } METHOD_7 ( ( VAR_31 , ""%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u"" , ( VAR_32 -> VAR_33 < 1 ) ? """" : ""\\n\\t"" , METHOD_8 ( VAR_34 , & VAR_35 -> VAR_36 ) , METHOD_9 ( & VAR_37 -> VAR_38 ) , VAR_39 ) ) ; if ( VAR_40 -> VAR_41 < 1 ) return 0 ; VAR_42 = VAR_43 + sizeof ( const struct STRUCT_OR_UNION_6 ) ; VAR_44 = VAR_45 - ( sizeof ( const struct STRUCT_OR_UNION_7 ) - 4 ) ; while ( VAR_46 > 0 ) { METHOD_10 ( * VAR_47 , sizeof ( struct STRUCT_OR_UNION_8 ) ) ; STRUCT_OR_UNION_9 = ( const struct STRUCT_OR_UNION_10 * ) VAR_48 ; VAR_49 = METHOD_11 ( STRUCT_OR_UNION_11 -> VAR_50 ) ; VAR_51 = METHOD_12 ( METHOD_13 ( STRUCT_OR_UNION_12 -> VAR_52 ) ) ; if ( VAR_53 < sizeof ( struct STRUCT_OR_UNION_13 ) - 4 ) { METHOD_14 ( ( VAR_54 , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , METHOD_15 ( VAR_55 , ""Unknown"" , VAR_56 ) , VAR_57 , VAR_58 , ( TYPE_8 ) ( sizeof ( struct STRUCT_OR_UNION_14 ) - 4 ) ) ) ; return 0 ; } METHOD_16 ( ( VAR_59 , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]"" , METHOD_17 ( VAR_60 , ""Unknown"" , VAR_61 ) , VAR_62 , VAR_63 , METHOD_18 ( & STRUCT_OR_UNION_15 -> VAR_64 ) , METHOD_19 ( METHOD_20 ( & STRUCT_OR_UNION_16 -> VAR_65 ) ) ? ""continue<S2SV_blank>processing"" : ""ignore"" ) ) ; VAR_66 = VAR_67 + sizeof ( struct STRUCT_OR_UNION_17 ) ; VAR_68 = VAR_69 - ( sizeof ( struct STRUCT_OR_UNION_18 ) - 4 ) ; METHOD_21 ( * VAR_70 , VAR_71 ) ; VAR_72 = VAR_73 ; switch ( VAR_74 ) { case VAR_75 : case VAR_76 : case VAR_77 : case VAR_78 : case VAR_79 : case VAR_80 : case VAR_81 : case VAR_82 : while ( VAR_83 >= 4 ) { VAR_84 = METHOD_22 ( VAR_85 , VAR_86 , VAR_87 ) ; if ( VAR_88 == 0 ) break ; VAR_89 -= VAR_90 ; VAR_91 += VAR_92 ; } break ; case VAR_93 : case VAR_94 : case VAR_95 : default : if ( VAR_96 -> VAR_97 <= 1 ) METHOD_23 ( VAR_98 , VAR_99 , ""\\n\\t<S2SV_blank><S2SV_blank>"" , VAR_100 ) ; break ; } if ( VAR_101 -> VAR_102 > 1 || VAR_103 == VAR_104 ) METHOD_24 ( VAR_105 , VAR_106 + sizeof ( struct STRUCT_OR_UNION_19 ) , ""\\n\\t<S2SV_blank><S2SV_blank>"" , VAR_107 ) ; VAR_108 += VAR_109 + 4 ; VAR_110 -= VAR_111 + 4 ; } return VAR_112 + 4 ; VAR_113 : <S2SV_StartBug> METHOD_25 ( ( VAR_114 , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> return 0 ; }","<S2SV_ModStart> ( VAR_114 , ""%s"" , VAR_115 <S2SV_ModEnd> ) ) ;","CWE-125 static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , ""%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , ""%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( ldp_msg_values , ""Unknown"" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]"" , tok2str ( ldp_msg_values , ""Unknown"" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? ""continue<S2SV_blank>processing"" : ""ignore"" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , ""\\n\\t<S2SV_blank><S2SV_blank>"" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> return 0 ; }","<S2SV_ModStart> ( ndo , ""%s"" , tstr <S2SV_ModEnd> ) ) ;"
423,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { register TYPE_2 * VAR_1 = & VAR_2 -> VAR_3 ; TYPE_3 VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; TYPE_7 VAR_8 ; TYPE_8 VAR_9 ; <S2SV_StartBug> TYPE_9 VAR_10 ; <S2SV_EndBug> TYPE_10 VAR_11 ; TYPE_11 VAR_12 ; TYPE_12 * VAR_13 ; TYPE_13 * VAR_14 ; VAR_15 = VAR_16 -> VAR_17 [ 0 ] ; VAR_18 = VAR_19 -> VAR_20 [ 0 ] ; METHOD_1 ( VAR_21 -> VAR_22 == VAR_23 ) ; if ( ( VAR_24 -> VAR_25 == VAR_26 ) && ( ! METHOD_2 ( VAR_27 ) ) ) VAR_28 = VAR_29 -> VAR_30 [ 1 ] ; else VAR_31 = 1 ; VAR_32 = METHOD_3 ( VAR_33 , VAR_34 ) ; if ( VAR_35 > VAR_36 ) { VAR_37 = VAR_38 ; VAR_39 = VAR_40 ; } else if ( VAR_41 > 0 ) { TYPE_14 VAR_42 ; VAR_43 = ( TYPE_15 ) ( VAR_44 / VAR_45 ) ; VAR_46 = VAR_47 * VAR_48 ; VAR_49 = VAR_50 * VAR_51 ; } else return ; if ( VAR_52 >= VAR_53 -> VAR_54 ) return ; <S2SV_StartBug> VAR_55 = METHOD_4 ( VAR_56 , VAR_57 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( VAR_58 == 0 ) || ( VAR_59 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; VAR_60 = ( TYPE_16 ) VAR_61 ; <S2SV_StartBug> VAR_62 = ( TYPE_17 * ) VAR_63 ( VAR_64 , VAR_65 , sizeof ( TYPE_18 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ; <S2SV_StartBug> VAR_66 = ( TYPE_19 * ) VAR_67 ( VAR_68 , VAR_69 , sizeof ( TYPE_20 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( VAR_70 == VAR_71 || VAR_72 == VAR_73 ) { if ( VAR_74 != VAR_75 ) METHOD_5 ( VAR_76 ) ; if ( VAR_77 != VAR_78 ) METHOD_6 ( VAR_79 ) ; return ; } <S2SV_StartBug> for ( VAR_80 = 0 ; VAR_81 < VAR_82 ; VAR_83 ++ ) { <S2SV_EndBug> if ( VAR_84 > VAR_85 ) VAR_86 = VAR_87 ; VAR_88 [ VAR_89 ] = VAR_90 ; <S2SV_StartBug> VAR_91 [ VAR_92 ] = VAR_93 ; <S2SV_EndBug> VAR_94 += VAR_95 ; VAR_96 -= VAR_97 ; } <S2SV_StartBug> VAR_98 -> VAR_99 = VAR_100 -> VAR_101 = VAR_102 ; <S2SV_EndBug> METHOD_7 ( VAR_103 , VAR_104 , VAR_105 ) ; METHOD_8 ( VAR_106 -> VAR_107 ) ; METHOD_9 ( VAR_108 -> VAR_109 ) ; VAR_110 -> VAR_111 = VAR_112 ; VAR_113 -> VAR_114 = VAR_115 ; VAR_116 -> VAR_117 = 1 ; }","<S2SV_ModStart> TYPE_16 VAR_92 ; TYPE_16 VAR_118 <S2SV_ModEnd> ; TYPE_16 VAR_105 <S2SV_ModStart> ) return ; VAR_118 = METHOD_10 ( VAR_116 -> VAR_119 , VAR_105 ) ; if ( VAR_118 <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> VAR_112 = ( <S2SV_ModStart> ( VAR_103 , VAR_118 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( VAR_103 , VAR_118 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; VAR_92 < VAR_118 <S2SV_ModEnd> ; VAR_92 ++ <S2SV_ModStart> VAR_92 ] = VAR_97 ? VAR_94 : 0 <S2SV_ModEnd> ; VAR_94 += <S2SV_ModStart> -> VAR_101 = VAR_118 <S2SV_ModEnd> ; METHOD_7 (","CWE-125 static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; <S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; nstrips32 = ( uint32 ) nstrips64 ; <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ; <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> offset += stripbytes ; bytecount -= stripbytes ; } <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }","<S2SV_ModStart> uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip <S2SV_ModStart> ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> newcounts = ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; strip < nstrips <S2SV_ModEnd> ; strip ++ <S2SV_ModStart> strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += <S2SV_ModStart> -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField ("
424,CWE-000 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> STRUCT_OR_UNION_2 -> VAR_0 = & STRUCT_OR_UNION_3 -> VAR_1 ; STRUCT_OR_UNION_4 -> VAR_2 -> VAR_3 = STRUCT_OR_UNION_5 -> VAR_4 ; <S2SV_StartBug> STRUCT_OR_UNION_6 -> VAR_5 -> VAR_6 = STRUCT_OR_UNION_7 -> VAR_7 ; <S2SV_EndBug> STRUCT_OR_UNION_8 -> VAR_8 = 1 ; STRUCT_OR_UNION_9 -> VAR_9 = 0 ; return 0 ; },"<S2SV_ModStart> TYPE_0 METHOD_0 ( TYPE_1 VAR_10 , struct STRUCT_OR_UNION_10 * STRUCT_OR_UNION_10 , <S2SV_ModStart> STRUCT_OR_UNION_9 ) { TYPE_1 VAR_11 ; VAR_11 = METHOD_1 ( VAR_10 , STRUCT_OR_UNION_10 , & STRUCT_OR_UNION_9 -> VAR_12 , STRUCT_OR_UNION_9 -> VAR_7 ) ; if ( VAR_11 < 0 ) return VAR_11 ; <S2SV_ModStart> -> VAR_6 = VAR_11 <S2SV_ModEnd> ; STRUCT_OR_UNION_9 ->",CWE-000 <S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> kiocb -> ki_iovec = & kiocb -> ki_inline_vec ; kiocb -> ki_iovec -> iov_base = kiocb -> ki_buf ; <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> kiocb -> ki_nr_segs = 1 ; kiocb -> ki_cur_seg = 0 ; return 0 ; },"<S2SV_ModStart> ssize_t aio_setup_single_vector ( int type , struct file * file , <S2SV_ModStart> kiocb ) { int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> -> iov_len = bytes <S2SV_ModEnd> ; kiocb ->"
425,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , unsigned * VAR_2 , unsigned VAR_3 ) { TYPE_3 VAR_4 ; unsigned VAR_5 ; unsigned VAR_6 ; TYPE_4 * VAR_7 ; TYPE_5 VAR_8 [ VAR_9 + 1 ] ; METHOD_1 ( VAR_10 != VAR_11 ) ; METHOD_2 ( VAR_12 != VAR_13 ) ; METHOD_3 ( VAR_14 ) ; METHOD_4 ( VAR_15 >= 0 ) ; METHOD_5 ( VAR_16 != VAR_17 ) ; METHOD_6 ( VAR_18 != VAR_19 ) ; METHOD_7 ( VAR_20 , 0 , VAR_21 + 1 ) ; if ( VAR_22 == 0 ) METHOD_8 ( ) ; <S2SV_StartBug> switch ( VAR_23 = ( * VAR_24 ) ( VAR_25 ) ) <S2SV_EndBug> { case '-' : case '+' : * VAR_26 = VAR_27 == '-' ; if ( ( * VAR_28 ) ( VAR_29 , VAR_30 , VAR_31 ) != ( TYPE_6 ) VAR_32 ) { return ( VAR_33 ) ; } if ( VAR_34 >= VAR_35 ) { if ( VAR_36 > VAR_37 ) goto VAR_38 ; if ( METHOD_9 ( VAR_39 , VAR_40 , VAR_41 ) > 0 ) goto VAR_42 ; } VAR_43 = VAR_44 ; VAR_45 = 0 ; do { if ( ( ( VAR_46 = * VAR_47 ++ ) < '0' ) || ( VAR_48 > '9' ) ) { return ( VAR_49 ) ; } VAR_50 = 10 * VAR_51 + VAR_52 - '0' ; } while ( -- VAR_53 ) ; * VAR_54 = VAR_55 ; return ( VAR_56 ) ; break ; case '0' : return ( VAR_57 ) ; break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : VAR_58 = VAR_59 - '0' ; if ( VAR_60 > 1 ) { if ( ( * VAR_61 ) ( VAR_62 , VAR_63 + 1 , VAR_64 - 1 ) != ( TYPE_7 ) VAR_65 - 1 ) { return ( VAR_66 ) ; } VAR_67 = VAR_68 ; if ( VAR_69 >= VAR_70 ) { if ( VAR_71 > VAR_72 ) break ; * VAR_73 = VAR_74 ; if ( METHOD_10 ( VAR_75 , VAR_76 , VAR_77 ) > 0 ) break ; } while ( -- VAR_78 ) { if ( ( ( VAR_79 = * ++ VAR_80 ) < '0' ) || ( VAR_81 > '9' ) ) { return ( VAR_82 ) ; } VAR_83 = 10 * VAR_84 + VAR_85 - '0' ; } } return ( METHOD_11 ( VAR_86 , VAR_87 , VAR_88 , VAR_89 ) ) ; break ; case - 1 : return ( VAR_90 ) ; break ; case - 2 : return ( VAR_91 ) ; break ; default : return ( VAR_92 ) ; break ; } * VAR_93 = VAR_94 ; VAR_95 : * VAR_96 = VAR_97 ; return ( VAR_98 ) ; }","<S2SV_ModStart> ( ) ; if ( VAR_78 >= VAR_77 ) { if ( VAR_78 > VAR_77 ) goto VAR_95 ; if ( METHOD_10 ( VAR_75 , VAR_76 , VAR_77 ) > 0 ) goto VAR_95 ; }","CWE-119 int disrsi_ ( int stream , int * negate , unsigned * value , unsigned count ) { int c ; unsigned locval ; unsigned ndigs ; char * cp ; char scratch [ DIS_BUFSIZ + 1 ] ; assert ( negate != NULL ) ; assert ( value != NULL ) ; assert ( count ) ; assert ( stream >= 0 ) ; assert ( dis_getc != NULL ) ; assert ( dis_gets != NULL ) ; memset ( scratch , 0 , DIS_BUFSIZ + 1 ) ; if ( dis_umaxd == 0 ) disiui_ ( ) ; <S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> { case '-' : case '+' : * negate = c == '-' ; if ( ( * dis_gets ) ( stream , scratch , count ) != ( int ) count ) { return ( DIS_EOD ) ; } if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } cp = scratch ; locval = 0 ; do { if ( ( ( c = * cp ++ ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } locval = 10 * locval + c - '0' ; } while ( -- count ) ; * value = locval ; return ( DIS_SUCCESS ) ; break ; case '0' : return ( DIS_LEADZRO ) ; break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : ndigs = c - '0' ; if ( count > 1 ) { if ( ( * dis_gets ) ( stream , scratch + 1 , count - 1 ) != ( int ) count - 1 ) { return ( DIS_EOD ) ; } cp = scratch ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) break ; * cp = c ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) break ; } while ( -- count ) { if ( ( ( c = * ++ cp ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } ndigs = 10 * ndigs + c - '0' ; } } return ( disrsi_ ( stream , negate , value , ndigs ) ) ; break ; case - 1 : return ( DIS_EOD ) ; break ; case - 2 : return ( DIS_EOF ) ; break ; default : return ( DIS_NONDIGIT ) ; break ; } * negate = FALSE ; overflow : * value = UINT_MAX ; return ( DIS_OVERFLOW ) ; }","<S2SV_ModStart> ( ) ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; }"
426,"CWE-284 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 ) { METHOD_1 ( VAR_1 != VAR_2 ) ; TYPE_2 VAR_3 = 0 ; <S2SV_StartBug> if ( METHOD_2 ( VAR_4 -> VAR_5 , VAR_6 , & VAR_7 ) == - 1 ) <S2SV_EndBug> return - 1 ; return VAR_8 ; }","<S2SV_ModStart> ; if ( METHOD_3 ( <S2SV_ModStart> , & VAR_8 )","CWE-284 ssize_t socket_bytes_available ( const socket_t * socket ) { assert ( socket != NULL ) ; int size = 0 ; <S2SV_StartBug> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <S2SV_EndBug> return - 1 ; return size ; }","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & size )"
427,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_EndBug> TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , <S2SV_StartBug> TYPE_6 VAR_5 , TYPE_7 VAR_6 , TYPE_8 * VAR_7 ) { <S2SV_EndBug> const TYPE_9 VAR_8 = METHOD_1 ( VAR_9 , VAR_10 , VAR_11 , VAR_12 ) ; <S2SV_StartBug> const TYPE_10 * const VAR_13 = METHOD_2 ( VAR_14 , VAR_15 ) ; <S2SV_EndBug> const TYPE_11 VAR_16 = ( VAR_17 + VAR_18 ) < VAR_19 -> VAR_20 ; const TYPE_12 VAR_21 = ( VAR_22 + VAR_23 ) < VAR_24 -> VAR_25 ; if ( VAR_26 && VAR_27 ) { METHOD_3 ( VAR_28 , VAR_29 , VAR_30 , & VAR_31 [ VAR_32 ] ) ; } else if ( ! VAR_33 && VAR_34 ) { METHOD_4 ( VAR_35 == VAR_36 || VAR_37 == VAR_38 ) ; <S2SV_StartBug> METHOD_5 ( VAR_39 , VAR_40 == VAR_41 , VAR_42 [ 1 ] ) ; <S2SV_EndBug> } else if ( VAR_43 && ! VAR_44 ) { METHOD_6 ( VAR_45 == VAR_46 || VAR_47 == VAR_48 ) ; <S2SV_StartBug> METHOD_7 ( VAR_49 , VAR_50 == VAR_51 , VAR_52 [ 2 ] ) ; <S2SV_EndBug> } else { METHOD_8 ( VAR_53 == VAR_54 ) ; } }","<S2SV_ModStart> TYPE_0 METHOD_0 ( const TYPE_1 * const VAR_24 , const TYPE_2 * const <S2SV_ModEnd> VAR_9 , TYPE_12 <S2SV_ModStart> TYPE_7 VAR_12 , TYPE_13 <S2SV_ModEnd> * VAR_49 ) <S2SV_ModStart> ) ; const TYPE_14 * const VAR_52 = VAR_9 -> VAR_55 [ VAR_15 ] <S2SV_ModEnd> ; const TYPE_12 <S2SV_ModStart> VAR_38 ) ; METHOD_9 <S2SV_ModEnd> ( VAR_49 , <S2SV_ModStart> VAR_48 ) ; METHOD_9 <S2SV_ModEnd> ( VAR_49 ,","CWE-119 <S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int hbs , int mi_row , int mi_col , <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; if ( has_rows && has_cols ) { vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ; } else if ( ! has_rows && has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> } else if ( has_rows && ! has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> } else { assert ( p == PARTITION_SPLIT ) ; } }","<S2SV_ModStart> void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const <S2SV_ModEnd> xd , int <S2SV_ModStart> BLOCK_SIZE bsize , vpx_writer <S2SV_ModEnd> * w ) <S2SV_ModStart> ) ; const vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> ; const int <S2SV_ModStart> PARTITION_HORZ ) ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> PARTITION_VERT ) ; vpx_write <S2SV_ModEnd> ( w ,"
428,CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_StartBug> TYPE_2 VAR_1 ; <S2SV_EndBug> METHOD_1 ( & VAR_2 -> VAR_3 ) ; <S2SV_StartBug> for ( VAR_4 = METHOD_2 ( VAR_5 -> VAR_6 ) - 1 ; VAR_7 >= 0 ; VAR_8 -- ) <S2SV_EndBug> { if ( VAR_9 -> VAR_10 [ VAR_11 ] . METHOD_3 ) VAR_12 -> VAR_13 [ VAR_14 ] . METHOD_4 ( & VAR_15 -> VAR_16 [ VAR_17 ] ) ; } return VAR_18 ; },<S2SV_ModStart> VAR_15 ) { <S2SV_ModEnd> METHOD_1 ( & <S2SV_ModStart> VAR_3 ) ; vpx_free ( VAR_15 ) ; <S2SV_ModEnd> return VAR_18 ;,CWE-119 static vpx_codec_err_t vp8_destroy ( vpx_codec_alg_priv_t * ctx ) { <S2SV_StartBug> int i ; <S2SV_EndBug> vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ; <S2SV_StartBug> for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ; i >= 0 ; i -- ) <S2SV_EndBug> { if ( ctx -> mmaps [ i ] . dtor ) ctx -> mmaps [ i ] . dtor ( & ctx -> mmaps [ i ] ) ; } return VPX_CODEC_OK ; },<S2SV_ModStart> ctx ) { <S2SV_ModEnd> vp8_remove_decoder_instances ( & <S2SV_ModStart> yv12_frame_buffers ) ; vpx_free ( ctx ) ; <S2SV_ModEnd> return VPX_CODEC_OK ;
429,CWE-125 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) <S2SV_EndBug> { if ( VAR_1 ) { if ( VAR_2 -> VAR_3 ) { METHOD_1 ( VAR_4 -> VAR_5 ) ; VAR_6 -> VAR_7 = 0 ; VAR_8 -> VAR_9 = 0 ; VAR_10 -> VAR_11 = VAR_12 ; VAR_13 -> VAR_14 = 0 ; } } },<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } },<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
430,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { TYPE_1 VAR_0 ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = & STRUCT_OR_UNION_4 -> STRUCT_OR_UNION_5 ; struct STRUCT_OR_UNION_6 * VAR_1 = STRUCT_OR_UNION_7 -> VAR_2 . VAR_3 ; struct STRUCT_OR_UNION_8 * VAR_4 = & VAR_5 -> VAR_6 ; struct STRUCT_OR_UNION_9 * VAR_7 ; struct STRUCT_OR_UNION_10 * VAR_8 ; TYPE_2 * VAR_9 , * VAR_10 ; TYPE_3 VAR_11 , VAR_12 , VAR_13 ; TYPE_4 VAR_14 ; TYPE_5 VAR_15 [ 64 ] ; VAR_16 = ( VAR_17 -> VAR_18 - VAR_19 -> VAR_20 ) / sizeof ( VAR_21 -> VAR_22 [ 0 ] ) ; VAR_23 = VAR_24 -> VAR_25 [ VAR_26 ] ; VAR_27 = METHOD_1 ( VAR_28 -> VAR_29 -> VAR_30 . VAR_31 ) ; VAR_32 = VAR_33 + VAR_34 ; VAR_35 = METHOD_2 ( VAR_36 -> VAR_37 [ VAR_38 ] , METHOD_3 ( VAR_39 -> VAR_40 -> VAR_41 . VAR_42 ) , <S2SV_StartBug> VAR_43 , ( TYPE_6 * * ) & VAR_44 ) ; <S2SV_EndBug> if ( VAR_45 == - 1 ) { METHOD_4 ( VAR_46 , ""BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n"" ) ; return 0 ; } VAR_47 = sizeof ( * VAR_48 ) ; if ( VAR_49 - ( TYPE_7 * ) VAR_50 < VAR_51 ) { METHOD_5 ( VAR_52 , ""BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>"" ""descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , VAR_53 - ( TYPE_8 * ) VAR_54 , VAR_55 ) ; return 0 ; } VAR_56 = METHOD_6 ( VAR_57 -> VAR_58 ) ; if ( VAR_59 - ( TYPE_9 * ) VAR_60 < VAR_61 ) { METHOD_7 ( VAR_62 , ""BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>"" ""descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , VAR_63 - ( TYPE_10 * ) VAR_64 , VAR_65 ) ; return 0 ; } VAR_66 = ( TYPE_11 * ) VAR_67 + sizeof ( * VAR_68 ) ; VAR_69 = ( TYPE_12 * ) VAR_70 + METHOD_8 ( VAR_71 -> VAR_72 ) ; VAR_73 = 0 ; VAR_74 = 0 ; while ( VAR_75 < VAR_76 ) { VAR_77 = VAR_78 ; if ( VAR_79 - VAR_80 < sizeof ( * VAR_81 ) ) { METHOD_9 ( VAR_82 , ""BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>"" ""not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n"" , VAR_83 - VAR_84 , sizeof ( * VAR_85 ) ) ; break ; } if ( VAR_86 -> VAR_87 < sizeof ( * VAR_88 ) ) { METHOD_10 ( VAR_89 , ""BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>"" ""descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>"" ""(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , ( TYPE_13 ) VAR_90 -> VAR_91 , sizeof ( * VAR_92 ) ) ; break ; } VAR_93 += VAR_94 -> VAR_95 ; VAR_96 += METHOD_11 ( VAR_97 + VAR_98 , sizeof ( VAR_99 ) - VAR_100 , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , METHOD_12 ( VAR_101 -> VAR_102 ) , VAR_103 -> VAR_104 ) ; STRUCT_OR_UNION_11 -> VAR_105 = VAR_106 ; } METHOD_13 ( VAR_107 , ""supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n"" , VAR_108 ) ; if ( STRUCT_OR_UNION_12 -> VAR_109 == VAR_110 ) { METHOD_14 ( VAR_111 , ""E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n"" ) ; return 0 ; } return 0 ; }","<S2SV_ModStart> ) & VAR_71 , sizeof ( * VAR_71 )","CWE-400 static int hwahc_security_create ( struct hwahc * hwahc ) { int result ; struct wusbhc * wusbhc = & hwahc -> wusbhc ; struct usb_device * usb_dev = hwahc -> wa . usb_dev ; struct device * dev = & usb_dev -> dev ; struct usb_security_descriptor * secd ; struct usb_encryption_descriptor * etd ; void * itr , * top ; size_t itr_size , needed , bytes ; u8 index ; char buf [ 64 ] ; index = ( usb_dev -> actconfig - usb_dev -> config ) / sizeof ( usb_dev -> config [ 0 ] ) ; itr = usb_dev -> rawdescriptors [ index ] ; itr_size = le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ; top = itr + itr_size ; result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> if ( result == - 1 ) { dev_warn ( dev , ""BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n"" ) ; return 0 ; } needed = sizeof ( * secd ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , ""BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>"" ""descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , top - ( void * ) secd , needed ) ; return 0 ; } needed = le16_to_cpu ( secd -> wTotalLength ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , ""BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>"" ""descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , top - ( void * ) secd , needed ) ; return 0 ; } itr = ( void * ) secd + sizeof ( * secd ) ; top = ( void * ) secd + le16_to_cpu ( secd -> wTotalLength ) ; index = 0 ; bytes = 0 ; while ( itr < top ) { etd = itr ; if ( top - itr < sizeof ( * etd ) ) { dev_err ( dev , ""BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>"" ""not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n"" , top - itr , sizeof ( * etd ) ) ; break ; } if ( etd -> bLength < sizeof ( * etd ) ) { dev_err ( dev , ""BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>"" ""descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>"" ""(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n"" , ( size_t ) etd -> bLength , sizeof ( * etd ) ) ; break ; } itr += etd -> bLength ; bytes += snprintf ( buf + bytes , sizeof ( buf ) - bytes , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , wusb_et_name ( etd -> bEncryptionType ) , etd -> bEncryptionValue ) ; wusbhc -> ccm1_etd = etd ; } dev_info ( dev , ""supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n"" , buf ) ; if ( wusbhc -> ccm1_etd == NULL ) { dev_err ( dev , ""E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n"" ) ; return 0 ; } return 0 ; }","<S2SV_ModStart> ) & secd , sizeof ( * secd )"
431,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = VAR_2 -> VAR_3 ; TYPE_3 * VAR_4 = & VAR_5 -> VAR_6 ; TYPE_4 VAR_7 = VAR_8 -> VAR_9 ; const TYPE_5 * VAR_10 = VAR_11 -> VAR_12 ; TYPE_6 VAR_13 ; TYPE_7 VAR_14 ; TYPE_8 VAR_15 , VAR_16 [ 4 ] ; TYPE_9 VAR_17 = VAR_18 -> VAR_19 ; TYPE_10 VAR_20 = VAR_21 -> VAR_22 . VAR_23 ; unsigned TYPE_11 * VAR_24 , * VAR_25 , * VAR_26 ; unsigned TYPE_12 * VAR_27 , * VAR_28 , * VAR_29 ; VAR_30 = VAR_31 -> VAR_32 ; VAR_33 = VAR_34 -> VAR_35 ; VAR_36 = VAR_37 -> VAR_38 ; VAR_39 = VAR_40 -> VAR_41 ; VAR_42 = VAR_43 -> VAR_44 ; VAR_45 = VAR_46 -> VAR_47 ; for ( VAR_48 = 0 ; VAR_49 < VAR_50 -> VAR_51 ; VAR_52 ++ ) { for ( VAR_53 = 0 ; VAR_54 < VAR_55 -> VAR_56 ; VAR_57 ++ ) { if ( VAR_58 == VAR_59 ) VAR_60 = METHOD_1 ( VAR_61 , VAR_62 ) ; else VAR_63 = ( VAR_64 == VAR_65 ? 4 : 0 ) ; if ( VAR_66 ) { if ( VAR_67 < 4 ) { TYPE_13 VAR_68 , VAR_69 ; for ( VAR_70 = 0 ; VAR_71 < 2 ; ++ VAR_72 ) for ( VAR_73 = 0 ; VAR_74 < 2 ; ++ VAR_75 ) { if ( VAR_76 [ VAR_77 * 2 + VAR_78 ] ) { METHOD_2 ( 8 , VAR_79 , VAR_80 , VAR_81 + 8 * ( VAR_82 * VAR_83 -> VAR_84 + VAR_85 ) , VAR_86 + 4 * ( VAR_87 * VAR_88 -> VAR_89 + VAR_90 ) , VAR_91 + 4 * ( VAR_92 * VAR_93 -> VAR_94 + VAR_95 ) , VAR_96 -> VAR_97 , VAR_98 -> VAR_99 , VAR_100 + 8 * ( VAR_101 * VAR_102 -> VAR_103 + VAR_104 ) , VAR_105 + 4 * ( VAR_106 * VAR_107 -> VAR_108 + VAR_109 ) , VAR_110 + 4 * ( VAR_111 * VAR_112 -> VAR_113 + VAR_114 ) , VAR_115 -> VAR_116 , VAR_117 -> VAR_118 ) ; } else { TYPE_14 VAR_119 ; unsigned TYPE_15 * VAR_120 = VAR_121 + 4 * ( VAR_122 * VAR_123 -> VAR_124 + VAR_125 ) ; unsigned TYPE_16 * VAR_126 = VAR_127 + 4 * ( VAR_128 * VAR_129 -> VAR_130 + VAR_131 ) ; unsigned TYPE_17 * VAR_132 = VAR_133 + 4 * ( VAR_134 * VAR_135 -> VAR_136 + VAR_137 ) ; unsigned TYPE_18 * VAR_138 = VAR_139 + 4 * ( VAR_140 * VAR_141 -> VAR_142 + VAR_143 ) ; METHOD_3 ( VAR_144 + 8 * ( VAR_145 * VAR_146 -> VAR_147 + VAR_148 ) , VAR_149 -> VAR_150 , VAR_151 + 8 * ( VAR_152 * VAR_153 -> VAR_154 + VAR_155 ) , VAR_156 -> VAR_157 ) ; for ( VAR_158 = 0 ; VAR_159 < 4 ; ++ VAR_160 , VAR_161 += VAR_162 -> VAR_163 , VAR_164 += VAR_165 -> VAR_166 , VAR_167 += VAR_168 -> VAR_169 , VAR_170 += VAR_171 -> VAR_172 ) { <S2SV_StartBug> METHOD_4 ( VAR_173 , VAR_174 , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_5 ( VAR_175 , VAR_176 , 4 ) ; <S2SV_EndBug> } } } } else { METHOD_6 ( 16 , VAR_177 , VAR_178 , VAR_179 , VAR_180 , VAR_181 , VAR_182 -> VAR_183 , VAR_184 -> VAR_185 , VAR_186 , VAR_187 , VAR_188 , VAR_189 -> VAR_190 , VAR_191 -> VAR_192 ) ; } } else { METHOD_7 ( VAR_193 , VAR_194 -> VAR_195 , VAR_196 , VAR_197 -> VAR_198 ) ; METHOD_8 ( VAR_199 , VAR_200 -> VAR_201 , VAR_202 , VAR_203 -> VAR_204 ) ; METHOD_9 ( VAR_205 , VAR_206 -> VAR_207 , VAR_208 , VAR_209 -> VAR_210 ) ; } VAR_211 += 16 ; VAR_212 += 8 ; VAR_213 += 8 ; VAR_214 += 16 ; VAR_215 += 8 ; VAR_216 += 8 ; VAR_217 ++ ; } VAR_218 += VAR_219 -> VAR_220 * 16 - 16 * VAR_221 -> VAR_222 ; VAR_223 += VAR_224 -> VAR_225 * 8 - 8 * VAR_226 -> VAR_227 ; VAR_228 += VAR_229 -> VAR_230 * 8 - 8 * VAR_231 -> VAR_232 ; VAR_233 += VAR_234 -> VAR_235 * 16 - 16 * VAR_236 -> VAR_237 ; VAR_238 += VAR_239 -> VAR_240 * 8 - 8 * VAR_241 -> VAR_242 ; VAR_243 += VAR_244 -> VAR_245 * 8 - 8 * VAR_246 -> VAR_247 ; VAR_248 ++ ; } }","<S2SV_ModStart> VAR_245 ) { METHOD_10 <S2SV_ModEnd> ( VAR_173 , <S2SV_ModStart> 4 ) ; METHOD_10 <S2SV_ModEnd> ( VAR_175 ,","CWE-119 void vp8_multiframe_quality_enhance ( VP8_COMMON * cm ) { YV12_BUFFER_CONFIG * show = cm -> frame_to_show ; YV12_BUFFER_CONFIG * dest = & cm -> post_proc_buffer ; FRAME_TYPE frame_type = cm -> frame_type ; const MODE_INFO * mode_info_context = cm -> show_frame_mi ; int mb_row ; int mb_col ; int totmap , map [ 4 ] ; int qcurr = cm -> base_qindex ; int qprev = cm -> postproc_state . last_base_qindex ; unsigned char * y_ptr , * u_ptr , * v_ptr ; unsigned char * yd_ptr , * ud_ptr , * vd_ptr ; y_ptr = show -> y_buffer ; u_ptr = show -> u_buffer ; v_ptr = show -> v_buffer ; yd_ptr = dest -> y_buffer ; ud_ptr = dest -> u_buffer ; vd_ptr = dest -> v_buffer ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( frame_type == INTER_FRAME ) totmap = qualify_inter_mb ( mode_info_context , map ) ; else totmap = ( frame_type == KEY_FRAME ? 4 : 0 ) ; if ( totmap ) { if ( totmap < 4 ) { int i , j ; for ( i = 0 ; i < 2 ; ++ i ) for ( j = 0 ; j < 2 ; ++ j ) { if ( map [ i * 2 + j ] ) { multiframe_quality_enhance_block ( 8 , qcurr , qprev , y_ptr + 8 * ( i * show -> y_stride + j ) , u_ptr + 4 * ( i * show -> uv_stride + j ) , v_ptr + 4 * ( i * show -> uv_stride + j ) , show -> y_stride , show -> uv_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , ud_ptr + 4 * ( i * dest -> uv_stride + j ) , vd_ptr + 4 * ( i * dest -> uv_stride + j ) , dest -> y_stride , dest -> uv_stride ) ; } else { int k ; unsigned char * up = u_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * udp = ud_ptr + 4 * ( i * dest -> uv_stride + j ) ; unsigned char * vp = v_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * vdp = vd_ptr + 4 * ( i * dest -> uv_stride + j ) ; vp8_copy_mem8x8 ( y_ptr + 8 * ( i * show -> y_stride + j ) , show -> y_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , dest -> y_stride ) ; for ( k = 0 ; k < 4 ; ++ k , up += show -> uv_stride , udp += dest -> uv_stride , vp += show -> uv_stride , vdp += dest -> uv_stride ) { <S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> } } } } else { multiframe_quality_enhance_block ( 16 , qcurr , qprev , y_ptr , u_ptr , v_ptr , show -> y_stride , show -> uv_stride , yd_ptr , ud_ptr , vd_ptr , dest -> y_stride , dest -> uv_stride ) ; } } else { vp8_copy_mem16x16 ( y_ptr , show -> y_stride , yd_ptr , dest -> y_stride ) ; vp8_copy_mem8x8 ( u_ptr , show -> uv_stride , ud_ptr , dest -> uv_stride ) ; vp8_copy_mem8x8 ( v_ptr , show -> uv_stride , vd_ptr , dest -> uv_stride ) ; } y_ptr += 16 ; u_ptr += 8 ; v_ptr += 8 ; yd_ptr += 16 ; ud_ptr += 8 ; vd_ptr += 8 ; mode_info_context ++ ; } y_ptr += show -> y_stride * 16 - 16 * cm -> mb_cols ; u_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; v_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; yd_ptr += dest -> y_stride * 16 - 16 * cm -> mb_cols ; ud_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; vd_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; mode_info_context ++ ; } }","<S2SV_ModStart> uv_stride ) { memcpy <S2SV_ModEnd> ( udp , <S2SV_ModStart> 4 ) ; memcpy <S2SV_ModEnd> ( vdp ,"
432,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 , enum VAR_5 VAR_6 , TYPE_5 VAR_7 ) { struct STRUCT_OR_UNION_1 * VAR_8 = VAR_9 -> VAR_10 ; struct STRUCT_OR_UNION_2 * VAR_11 = METHOD_1 ( VAR_12 ) ; struct STRUCT_OR_UNION_3 * VAR_13 = VAR_14 + VAR_15 ; TYPE_6 VAR_16 , VAR_17 = 0 ; VAR_18 = METHOD_2 ( VAR_19 ) ; if ( VAR_20 < 0 ) return VAR_21 ; VAR_22 = METHOD_3 ( VAR_23 , VAR_24 , VAR_25 , VAR_26 ) ; if ( VAR_27 ) return VAR_28 ; VAR_29 += VAR_30 -> VAR_31 ; if ( VAR_32 -> VAR_33 == VAR_34 ) { if ( VAR_35 == VAR_36 && VAR_37 >= 0 && METHOD_4 ( VAR_38 , VAR_39 ) ) { METHOD_5 ( VAR_40 , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>map\\n"" , VAR_41 ) ; return - VAR_42 ; } VAR_43 = METHOD_6 ( VAR_44 , VAR_45 , VAR_46 , VAR_47 , VAR_48 ) ; if ( ! VAR_49 && VAR_50 == VAR_51 && VAR_52 >= 0 ) METHOD_7 ( VAR_53 , VAR_54 , VAR_55 ) ; } else if ( VAR_56 -> VAR_57 == VAR_58 ) { enum VAR_59 VAR_60 = VAR_61 ; if ( VAR_62 == VAR_63 && VAR_64 >= 0 && METHOD_8 ( VAR_65 , VAR_66 ) ) { METHOD_9 ( VAR_67 , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>ctx\\n"" , VAR_68 ) ; return - VAR_69 ; } if ( VAR_70 -> VAR_71 ) { METHOD_10 ( VAR_72 , ""dereference<S2SV_blank>of<S2SV_blank>modified<S2SV_blank>ctx<S2SV_blank>ptr<S2SV_blank>R%d<S2SV_blank>off=%d+%d,<S2SV_blank>ctx+const<S2SV_blank>is<S2SV_blank>allowed,<S2SV_blank>ctx+const+const<S2SV_blank>is<S2SV_blank>not\\n"" , VAR_73 , VAR_74 -> VAR_75 , VAR_76 - VAR_77 -> VAR_78 ) ; return - VAR_79 ; } if ( ! METHOD_11 ( VAR_80 -> VAR_81 ) || VAR_82 -> VAR_83 . VAR_84 ) { TYPE_7 VAR_85 [ 48 ] ; METHOD_12 ( VAR_86 , sizeof ( VAR_87 ) , VAR_88 -> VAR_89 ) ; METHOD_13 ( VAR_90 , ""variable<S2SV_blank>ctx<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , VAR_91 , VAR_92 , VAR_93 ) ; return - VAR_94 ; } VAR_95 = METHOD_14 ( VAR_96 , VAR_97 , VAR_98 , VAR_99 , VAR_100 , & VAR_101 ) ; if ( ! VAR_102 && VAR_103 == VAR_104 && VAR_105 >= 0 ) { if ( VAR_106 == VAR_107 ) METHOD_15 ( VAR_108 , VAR_109 , VAR_110 ) ; else METHOD_16 ( VAR_111 , VAR_112 , VAR_113 ) ; VAR_114 [ VAR_115 ] . VAR_116 = 0 ; VAR_117 [ VAR_118 ] . VAR_119 = 0 ; VAR_120 [ VAR_121 ] . VAR_122 = 0 ; VAR_123 [ VAR_124 ] . VAR_125 = VAR_126 ; } } else if ( VAR_127 -> VAR_128 == VAR_129 ) { if ( ! METHOD_17 ( VAR_130 -> VAR_131 ) ) { TYPE_8 VAR_132 [ 48 ] ; METHOD_18 ( VAR_133 , sizeof ( VAR_134 ) , VAR_135 -> VAR_136 ) ; METHOD_19 ( VAR_137 , ""variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , VAR_138 , VAR_139 , VAR_140 ) ; return - VAR_141 ; } VAR_142 += VAR_143 -> VAR_144 . VAR_145 ; if ( VAR_146 >= 0 || VAR_147 < - VAR_148 ) { METHOD_20 ( VAR_149 , ""invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\n"" , VAR_150 , VAR_151 ) ; return - VAR_152 ; } if ( VAR_153 -> VAR_154 -> VAR_155 -> VAR_156 < - VAR_157 ) VAR_158 -> VAR_159 -> VAR_160 -> VAR_161 = - VAR_162 ; if ( VAR_163 == VAR_164 ) VAR_165 = METHOD_21 ( VAR_166 , VAR_167 , VAR_168 , VAR_169 , VAR_170 ) ; else VAR_171 = METHOD_22 ( VAR_172 , VAR_173 , VAR_174 , VAR_175 , VAR_176 ) ; } else if ( METHOD_23 ( VAR_177 ) ) { if ( VAR_178 == VAR_179 && ! METHOD_24 ( VAR_180 , VAR_181 , VAR_182 ) ) { METHOD_25 ( VAR_183 , ""cannot<S2SV_blank>write<S2SV_blank>into<S2SV_blank>packet\\n"" ) ; return - VAR_184 ; } if ( VAR_185 == VAR_186 && VAR_187 >= 0 && METHOD_26 ( VAR_188 , VAR_189 ) ) { METHOD_27 ( VAR_190 , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>packet\\n"" , VAR_191 ) ; return - VAR_192 ; } VAR_193 = METHOD_28 ( VAR_194 , VAR_195 , VAR_196 , VAR_197 , VAR_198 ) ; if ( ! VAR_199 && VAR_200 == VAR_201 && VAR_202 >= 0 ) METHOD_29 ( VAR_203 , VAR_204 , VAR_205 ) ; } else { METHOD_30 ( VAR_206 , ""R%d<S2SV_blank>invalid<S2SV_blank>mem<S2SV_blank>access<S2SV_blank>\'%s\'\\n"" , VAR_207 , VAR_208 [ VAR_209 -> VAR_210 ] ) ; return - VAR_211 ; } if ( ! VAR_212 && VAR_213 < VAR_214 && VAR_215 >= 0 && VAR_216 == VAR_217 && VAR_218 [ VAR_219 ] . VAR_220 == VAR_221 ) { <S2SV_StartBug> VAR_222 [ VAR_223 ] . VAR_224 = <S2SV_EndBug> METHOD_31 ( VAR_225 [ VAR_226 ] . VAR_227 , VAR_228 ) ; METHOD_32 ( & VAR_229 [ VAR_230 ] ) ; } return VAR_231 ; }","<S2SV_ModStart> VAR_221 ) { coerce_reg_to_size ( & <S2SV_ModStart> [ VAR_230 ] , VAR_228 <S2SV_ModEnd> ) ; }","CWE-119 static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , int bpf_size , enum bpf_access_type t , int value_regno ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = cur_regs ( env ) ; struct bpf_reg_state * reg = regs + regno ; int size , err = 0 ; size = bpf_size_to_bytes ( bpf_size ) ; if ( size < 0 ) return size ; err = check_ptr_alignment ( env , reg , off , size ) ; if ( err ) return err ; off += reg -> off ; if ( reg -> type == PTR_TO_MAP_VALUE ) { if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>map\\n"" , value_regno ) ; return - EACCES ; } err = check_map_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else if ( reg -> type == PTR_TO_CTX ) { enum bpf_reg_type reg_type = SCALAR_VALUE ; if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>ctx\\n"" , value_regno ) ; return - EACCES ; } if ( reg -> off ) { verbose ( env , ""dereference<S2SV_blank>of<S2SV_blank>modified<S2SV_blank>ctx<S2SV_blank>ptr<S2SV_blank>R%d<S2SV_blank>off=%d+%d,<S2SV_blank>ctx+const<S2SV_blank>is<S2SV_blank>allowed,<S2SV_blank>ctx+const+const<S2SV_blank>is<S2SV_blank>not\\n"" , regno , reg -> off , off - reg -> off ) ; return - EACCES ; } if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , ""variable<S2SV_blank>ctx<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ; return - EACCES ; } err = check_ctx_access ( env , insn_idx , off , size , t , & reg_type ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) { if ( reg_type == SCALAR_VALUE ) mark_reg_unknown ( env , regs , value_regno ) ; else mark_reg_known_zero ( env , regs , value_regno ) ; regs [ value_regno ] . id = 0 ; regs [ value_regno ] . off = 0 ; regs [ value_regno ] . range = 0 ; regs [ value_regno ] . type = reg_type ; } } else if ( reg -> type == PTR_TO_STACK ) { if ( ! tnum_is_const ( reg -> var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , ""variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ; return - EACCES ; } off += reg -> var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK ) { verbose ( env , ""invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\n"" , off , size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ; else err = check_stack_read ( env , state , off , size , value_regno ) ; } else if ( reg_is_pkt_pointer ( reg ) ) { if ( t == BPF_WRITE && ! may_access_direct_pkt_data ( env , NULL , t ) ) { verbose ( env , ""cannot<S2SV_blank>write<S2SV_blank>into<S2SV_blank>packet\\n"" ) ; return - EACCES ; } if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>packet\\n"" , value_regno ) ; return - EACCES ; } err = check_packet_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else { verbose ( env , ""R%d<S2SV_blank>invalid<S2SV_blank>mem<S2SV_blank>access<S2SV_blank>\'%s\'\\n"" , regno , reg_type_str [ reg -> type ] ) ; return - EACCES ; } if ( ! err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ && regs [ value_regno ] . type == SCALAR_VALUE ) { <S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> tnum_cast ( regs [ value_regno ] . var_off , size ) ; __update_reg_bounds ( & regs [ value_regno ] ) ; } return err ; }","<S2SV_ModStart> SCALAR_VALUE ) { coerce_reg_to_size ( & <S2SV_ModStart> [ value_regno ] , size <S2SV_ModEnd> ) ; }"
433,"CWE-20 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 VAR_4 ; <S2SV_StartBug> TYPE_6 VAR_5 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_7 VAR_6 [ VAR_7 ] ; <S2SV_EndBug> TYPE_8 VAR_8 [ VAR_9 ] ; TYPE_9 VAR_10 ; TYPE_10 VAR_11 [ 13 ] ; VAR_12 = METHOD_1 ( VAR_13 , VAR_14 , VAR_15 , VAR_16 ) ; if ( VAR_17 < 0 ) return VAR_18 ; <S2SV_StartBug> VAR_19 = METHOD_2 ( & VAR_20 -> VAR_21 , VAR_22 , VAR_23 , & VAR_24 , <S2SV_EndBug> VAR_25 , VAR_26 , VAR_27 ) ; if ( VAR_28 == - 1 ) return VAR_29 ; <S2SV_StartBug> if ( ! METHOD_3 ( VAR_30 -> VAR_31 , VAR_32 , VAR_33 , <S2SV_EndBug> <S2SV_StartBug> VAR_34 , & VAR_35 -> VAR_36 , VAR_37 -> VAR_38 , VAR_39 , VAR_40 ) ) <S2SV_EndBug> return VAR_41 ; if ( VAR_42 -> VAR_43 == VAR_44 ) VAR_45 -> VAR_46 = VAR_47 -> VAR_48 . VAR_49 ; else { if ( VAR_50 -> VAR_51 != VAR_52 -> VAR_53 . VAR_54 ) VAR_55 -> VAR_56 = VAR_57 ; } * VAR_58 = VAR_59 ; return VAR_60 ; }","<S2SV_ModStart> TYPE_5 VAR_59 ; <S2SV_ModEnd> TYPE_10 VAR_22 [ <S2SV_ModStart> VAR_22 [ VAR_7 <S2SV_ModEnd> ] ; VAR_59 <S2SV_ModStart> return VAR_41 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( VAR_55 -> <S2SV_ModStart> VAR_55 -> VAR_31 <S2SV_ModEnd> , & VAR_55 <S2SV_ModStart> VAR_55 -> VAR_38 , VAR_22","CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line"
434,"CWE-787 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { unsigned TYPE_1 VAR_3 [ 16 ] ; TYPE_2 VAR_4 ; if ( VAR_5 -> METHOD_1 ( VAR_6 , & VAR_7 [ 0 ] , VAR_8 ) != VAR_9 ) { return VAR_10 ; } if ( ( ( unsigned TYPE_3 ) METHOD_2 ( & VAR_11 [ VAR_12 ] ) != 0x4A41574B ) || ( ( unsigned TYPE_4 ) METHOD_3 ( & VAR_13 [ VAR_14 ] ) != 0xD127F088 ) ) { return VAR_15 ; } VAR_16 -> VAR_17 = METHOD_4 ( & VAR_18 [ VAR_19 ] ) ; VAR_20 -> VAR_21 = METHOD_5 ( & VAR_22 [ VAR_23 ] ) ; VAR_24 -> VAR_25 = METHOD_6 ( & VAR_26 [ VAR_27 ] ) ; VAR_28 -> VAR_29 = 0 ; VAR_30 -> VAR_31 = VAR_32 ; VAR_33 -> VAR_34 = VAR_35 ; VAR_36 -> VAR_37 = 0 ; if ( VAR_38 -> VAR_39 & VAR_40 ) { if ( VAR_41 -> METHOD_7 ( VAR_42 , & VAR_43 [ 0 ] , 4 ) != 4 ) return VAR_44 ; VAR_45 -> VAR_46 = METHOD_8 ( & VAR_47 [ 0 ] ) ; } if ( VAR_48 -> VAR_49 & VAR_50 ) { if ( VAR_51 -> METHOD_9 ( VAR_52 , & VAR_53 [ 0 ] , 2 ) != 2 ) return VAR_54 ; } if ( VAR_55 -> VAR_56 & VAR_57 ) { if ( VAR_58 -> METHOD_10 ( VAR_59 , & VAR_60 [ 0 ] , 2 ) != 2 ) return VAR_61 ; VAR_62 = METHOD_11 ( & VAR_63 [ 0 ] ) ; if ( VAR_64 -> METHOD_12 ( VAR_65 , ( TYPE_5 ) VAR_66 , VAR_67 ) ) return VAR_68 ; } if ( VAR_69 -> VAR_70 & ( VAR_71 | VAR_72 ) ) { <S2SV_StartBug> TYPE_6 VAR_73 = VAR_74 -> METHOD_13 ( VAR_75 ) ; <S2SV_EndBug> TYPE_7 * VAR_76 = ( TYPE_8 * ) VAR_77 -> METHOD_14 ( VAR_78 , ( TYPE_9 ) 13 ) ; <S2SV_StartBug> if ( ! VAR_79 ) return VAR_80 ; <S2SV_EndBug> <S2SV_StartBug> VAR_81 -> VAR_82 = VAR_83 ; <S2SV_EndBug> if ( VAR_84 -> VAR_85 & VAR_86 ) { <S2SV_StartBug> if ( VAR_87 -> METHOD_15 ( VAR_88 , & VAR_89 [ 0 ] , 9 ) != 9 ) return VAR_90 ; <S2SV_EndBug> <S2SV_StartBug> for ( VAR_91 = 0 ; VAR_92 < 9 ; VAR_93 ++ , VAR_94 ++ ) if ( ! ( * VAR_95 = VAR_96 [ VAR_97 ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> VAR_98 += ( VAR_99 < 9 ) ? VAR_100 + 1 : 9 ; <S2SV_EndBug> if ( VAR_101 -> METHOD_16 ( VAR_102 , VAR_103 , VAR_104 ) ) <S2SV_StartBug> return VAR_105 ; <S2SV_EndBug> } if ( VAR_106 -> VAR_107 & VAR_108 ) { * VAR_109 ++ = '.' ; <S2SV_StartBug> if ( VAR_110 -> METHOD_17 ( VAR_111 , & VAR_112 [ 0 ] , 4 ) != 4 ) return VAR_113 ; <S2SV_EndBug> <S2SV_StartBug> for ( VAR_114 = 0 ; VAR_115 < 4 ; VAR_116 ++ , VAR_117 ++ ) if ( ! ( * VAR_118 = VAR_119 [ VAR_120 ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> VAR_121 += ( VAR_122 < 4 ) ? VAR_123 + 1 : 4 ; <S2SV_EndBug> if ( VAR_124 -> METHOD_18 ( VAR_125 , VAR_126 , VAR_127 ) ) <S2SV_StartBug> return VAR_128 ; <S2SV_EndBug> } * VAR_129 = '\\0' ; } if ( VAR_130 -> VAR_131 & VAR_132 ) { if ( VAR_133 -> METHOD_19 ( VAR_134 , & VAR_135 [ 0 ] , 2 ) != 2 ) return VAR_136 ; VAR_137 = METHOD_20 ( & VAR_138 [ 0 ] ) ; VAR_139 -> VAR_140 = ( TYPE_10 * ) VAR_141 -> METHOD_21 ( VAR_142 , ( TYPE_11 ) VAR_143 + 1 ) ; if ( ! VAR_144 -> VAR_145 ) return VAR_146 ; if ( VAR_147 -> METHOD_22 ( VAR_148 , VAR_149 -> VAR_150 , VAR_151 ) != VAR_152 ) return VAR_153 ; VAR_154 -> VAR_155 [ VAR_156 ] = '\\0' ; VAR_157 -> VAR_158 = VAR_159 ; } return VAR_160 ; }","<S2SV_ModStart> ) ) { TYPE_4 VAR_161 <S2SV_ModEnd> ; TYPE_10 * <S2SV_ModStart> if ( ! ( VAR_157 -> VAR_82 = VAR_129 ) ) <S2SV_ModEnd> return VAR_146 ; <S2SV_ModStart> return VAR_146 ; <S2SV_ModEnd> if ( VAR_157 <S2SV_ModStart> { if ( ( VAR_161 = <S2SV_ModStart> , 9 ) ) < 2 <S2SV_ModEnd> ) return VAR_153 <S2SV_ModStart> ; VAR_159 < VAR_161 <S2SV_ModEnd> ; VAR_159 ++ <S2SV_ModStart> ; VAR_159 ++ ) if ( ! ( * VAR_129 ++ <S2SV_ModEnd> = VAR_138 [ <S2SV_ModStart> ) break ; if ( VAR_159 == 9 && VAR_138 [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( VAR_147 -> METHOD_18 ( VAR_148 , ( TYPE_6 ) ( <S2SV_ModEnd> VAR_159 + 1 <S2SV_ModStart> VAR_159 + 1 - VAR_161 ) , VAR_67 <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return VAR_128 ; VAR_129 -- <S2SV_ModStart> ; if ( ( VAR_161 = <S2SV_ModStart> , 4 ) ) < 2 <S2SV_ModEnd> ) return VAR_153 <S2SV_ModStart> ; VAR_159 < VAR_161 <S2SV_ModEnd> ; VAR_159 ++ <S2SV_ModStart> ; VAR_159 ++ ) if ( ! ( * VAR_129 ++ <S2SV_ModEnd> = VAR_138 [ <S2SV_ModStart> ) break ; if ( VAR_159 == 4 && VAR_138 [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( VAR_147 -> METHOD_18 ( VAR_148 , ( TYPE_6 ) ( <S2SV_ModEnd> VAR_159 + 1 <S2SV_ModStart> VAR_159 + 1 - VAR_161 ) , VAR_67 <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return VAR_128 ; VAR_129 --","CWE-787 static int kwajd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mskwajd_header * hdr ) { unsigned char buf [ 16 ] ; int i ; if ( sys -> read ( fh , & buf [ 0 ] , kwajh_SIZEOF ) != kwajh_SIZEOF ) { return MSPACK_ERR_READ ; } if ( ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature1 ] ) != 0x4A41574B ) || ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature2 ] ) != 0xD127F088 ) ) { return MSPACK_ERR_SIGNATURE ; } hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ; hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ; hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ; hdr -> length = 0 ; hdr -> filename = NULL ; hdr -> extra = NULL ; hdr -> extra_length = 0 ; if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) { if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; hdr -> length = EndGetI32 ( & buf [ 0 ] ) ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; } if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { <S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } * fn = '\\0' ; } if ( hdr -> headers & MSKWAJ_HDR_HASEXTRATEXT ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; hdr -> extra = ( char * ) sys -> alloc ( sys , ( size_t ) i + 1 ) ; if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ; if ( sys -> read ( fh , hdr -> extra , i ) != i ) return MSPACK_ERR_READ ; hdr -> extra [ i ] = '\\0' ; hdr -> extra_length = i ; } return MSPACK_ERR_OK ; }","<S2SV_ModStart> ) ) { int len <S2SV_ModEnd> ; char * <S2SV_ModStart> if ( ! ( hdr -> filename = fn ) ) <S2SV_ModEnd> return MSPACK_ERR_NOMEMORY ; <S2SV_ModStart> return MSPACK_ERR_NOMEMORY ; <S2SV_ModEnd> if ( hdr <S2SV_ModStart> { if ( ( len = <S2SV_ModStart> , 9 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModStart> ; if ( ( len = <S2SV_ModStart> , 4 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn --"
435,"CWE-552 TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 * * VAR_2 , <S2SV_StartBug> TYPE_3 * VAR_3 ) <S2SV_EndBug> { TYPE_4 VAR_4 = - 1 ; struct STRUCT_OR_UNION_1 * VAR_5 = VAR_6 ; TYPE_5 VAR_7 = 0 ; TYPE_6 VAR_8 = 0 ; if ( VAR_9 ) * VAR_10 = VAR_11 ; if ( VAR_12 ) * VAR_13 = 0 ; <S2SV_StartBug> if ( VAR_14 < 0 || ( VAR_15 > 0 && ! VAR_16 ) || ! VAR_17 || ! VAR_18 ) <S2SV_EndBug> goto VAR_19 ; if ( VAR_20 == 0 ) { if ( VAR_21 ) { if ( ! ( VAR_22 = METHOD_1 ( 1 , sizeof ( VAR_23 ) ) ) ) goto VAR_24 ; VAR_25 = sizeof ( VAR_26 ) ; } * VAR_27 = VAR_28 ; <S2SV_StartBug> * VAR_29 = VAR_30 ; <S2SV_EndBug> VAR_31 = VAR_32 ; VAR_33 = 0 ; goto VAR_34 ; } for ( TYPE_7 VAR_35 = 0 ; VAR_36 < VAR_37 ; VAR_38 ++ ) VAR_39 += VAR_40 [ VAR_41 ] . VAR_42 ; VAR_43 = ( sizeof ( struct STRUCT_OR_UNION_2 ) * ( TYPE_8 ) VAR_44 ) + VAR_45 ; if ( ! ( VAR_46 = METHOD_2 ( 1 , VAR_47 ) ) ) goto VAR_48 ; { TYPE_9 * VAR_49 = ( TYPE_10 * ) & VAR_50 [ VAR_51 ] ; TYPE_11 VAR_52 = VAR_53 ; TYPE_12 VAR_54 ; for ( VAR_55 = 0 ; VAR_56 < VAR_57 ; VAR_58 ++ ) { const TYPE_13 VAR_59 = VAR_60 [ VAR_61 ] . VAR_62 ; const TYPE_14 * VAR_63 = VAR_64 [ VAR_65 ] . VAR_66 ; if ( VAR_67 ) { VAR_68 [ VAR_69 ] . VAR_70 = VAR_71 ; VAR_72 [ VAR_73 ] . VAR_74 = ( TYPE_15 * ) ( VAR_75 - ( TYPE_16 * ) VAR_76 ) ; if ( ! VAR_77 ) goto VAR_78 ; if ( METHOD_3 ( VAR_79 , VAR_80 , VAR_81 , VAR_82 ) != VAR_83 ) goto VAR_84 ; VAR_85 += VAR_86 ; VAR_87 -= VAR_88 ; } } if ( VAR_89 != 0 ) goto VAR_90 ; } * VAR_91 = VAR_92 ; * VAR_93 = VAR_94 ; <S2SV_StartBug> VAR_95 = VAR_96 ; <S2SV_EndBug> VAR_97 = 0 ; VAR_98 : if ( VAR_99 ) METHOD_4 ( VAR_100 ) ; return VAR_101 ; }","<S2SV_ModStart> TYPE_13 * VAR_93 , TYPE_13 * VAR_102 <S2SV_ModStart> ; if ( VAR_102 ) * VAR_102 = 0 ; if ( <S2SV_ModStart> || ! VAR_93 || ! VAR_102 <S2SV_ModStart> VAR_93 = VAR_94 ; * VAR_102 = VAR_53 <S2SV_ModStart> = VAR_94 ; * VAR_102 = VAR_53 ;","CWE-552 int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out , <S2SV_StartBug> size_t * buf_size_out ) <S2SV_EndBug> { int ret = - 1 ; struct oe_iovec * buf = NULL ; size_t buf_size = 0 ; size_t data_size = 0 ; if ( buf_out ) * buf_out = NULL ; if ( buf_size_out ) * buf_size_out = 0 ; <S2SV_StartBug> if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out ) <S2SV_EndBug> goto done ; if ( iovcnt == 0 ) { if ( iov ) { if ( ! ( buf = oe_calloc ( 1 , sizeof ( uint64_t ) ) ) ) goto done ; buf_size = sizeof ( uint64_t ) ; } * buf_out = buf ; <S2SV_StartBug> * buf_size_out = buf_size ; <S2SV_EndBug> buf = NULL ; ret = 0 ; goto done ; } for ( int i = 0 ; i < iovcnt ; i ++ ) data_size += iov [ i ] . iov_len ; buf_size = ( sizeof ( struct oe_iovec ) * ( size_t ) iovcnt ) + data_size ; if ( ! ( buf = oe_calloc ( 1 , buf_size ) ) ) goto done ; { uint8_t * p = ( uint8_t * ) & buf [ iovcnt ] ; size_t n = data_size ; int i ; for ( i = 0 ; i < iovcnt ; i ++ ) { const size_t iov_len = iov [ i ] . iov_len ; const void * iov_base = iov [ i ] . iov_base ; if ( iov_len ) { buf [ i ] . iov_len = iov_len ; buf [ i ] . iov_base = ( void * ) ( p - ( uint8_t * ) buf ) ; if ( ! iov_base ) goto done ; if ( oe_memcpy_s ( p , n , iov_base , iov_len ) != OE_OK ) goto done ; p += iov_len ; n -= iov_len ; } } if ( n != 0 ) goto done ; } * buf_out = buf ; * buf_size_out = buf_size ; <S2SV_StartBug> buf = NULL ; <S2SV_EndBug> ret = 0 ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> size_t * buf_size_out , size_t * data_size_out <S2SV_ModStart> ; if ( data_size_out ) * data_size_out = 0 ; if ( <S2SV_ModStart> || ! buf_size_out || ! data_size_out <S2SV_ModStart> buf_size_out = buf_size ; * data_size_out = data_size <S2SV_ModStart> = buf_size ; * data_size_out = data_size ;"
436,"CWE-20 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 * VAR_3 = & VAR_4 -> VAR_5 . VAR_6 ; unsigned TYPE_5 VAR_7 ; TYPE_6 VAR_8 ; VAR_9 = 0 ; if ( METHOD_1 ( VAR_10 , & VAR_11 -> VAR_12 ) || METHOD_2 ( VAR_13 , & VAR_14 -> VAR_15 ) || METHOD_3 ( VAR_16 , & VAR_17 -> VAR_18 ) || METHOD_4 ( VAR_19 , & VAR_20 -> VAR_21 ) || METHOD_5 ( VAR_22 , & VAR_23 -> VAR_24 ) || METHOD_6 ( VAR_25 , & VAR_26 -> VAR_27 ) || METHOD_7 ( VAR_28 , & VAR_29 -> VAR_30 ) || METHOD_8 ( VAR_31 , & VAR_32 -> VAR_33 ) || METHOD_9 ( VAR_34 , & VAR_35 -> VAR_36 ) || METHOD_10 ( VAR_37 , & VAR_38 -> VAR_39 ) ) { return - 1 ; } if ( ! VAR_40 -> VAR_41 || ! VAR_42 -> VAR_43 || ! VAR_44 -> VAR_45 || ! VAR_46 -> VAR_47 || ! VAR_48 -> VAR_49 || VAR_50 -> VAR_51 > 16384 ) { return - 1 ; } <S2SV_StartBug> if ( ! ( VAR_52 -> VAR_53 = METHOD_11 ( VAR_54 -> VAR_55 , sizeof ( VAR_56 ) ) ) ) { <S2SV_EndBug> return - 1 ; } for ( VAR_57 = 0 ; VAR_58 < VAR_59 -> VAR_60 ; ++ VAR_61 ) { if ( METHOD_12 ( VAR_62 , & VAR_63 ) || METHOD_13 ( VAR_64 , & VAR_65 -> VAR_66 [ VAR_67 ] . VAR_68 ) || METHOD_14 ( VAR_69 , & VAR_70 -> VAR_71 [ VAR_72 ] . VAR_73 ) ) { METHOD_15 ( VAR_74 -> VAR_75 ) ; return - 1 ; } if ( VAR_76 -> VAR_77 [ VAR_78 ] . VAR_79 == 0 || VAR_80 -> VAR_81 [ VAR_82 ] . VAR_83 > 255 ) { METHOD_16 ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , VAR_84 -> VAR_85 [ VAR_86 ] . VAR_87 ) ; METHOD_17 ( VAR_88 -> VAR_89 ) ; return - 1 ; } if ( VAR_90 -> VAR_91 [ VAR_92 ] . VAR_93 == 0 || VAR_94 -> VAR_95 [ VAR_96 ] . VAR_97 > 255 ) { METHOD_18 ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , VAR_98 -> VAR_99 [ VAR_100 ] . VAR_101 ) ; METHOD_19 ( VAR_102 -> VAR_103 ) ; return - 1 ; } VAR_104 -> VAR_105 [ VAR_106 ] . VAR_107 = ( VAR_108 >> 7 ) & 1 ; VAR_109 -> VAR_110 [ VAR_111 ] . VAR_112 = ( VAR_113 & 0x7f ) + 1 ; } if ( METHOD_20 ( VAR_114 ) ) { METHOD_21 ( VAR_115 -> VAR_116 ) ; return - 1 ; } return 0 ; }","<S2SV_ModStart> } if ( VAR_115 -> VAR_33 >= VAR_115 -> VAR_41 || VAR_115 -> VAR_36 >= VAR_115 -> VAR_43 ) { METHOD_18 ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if (","CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } <S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }","<S2SV_ModStart> } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ("
437,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 ) { TYPE_7 VAR_6 ; TYPE_8 METHOD_1 ; TYPE_9 VAR_7 = - 1 ; TYPE_10 VAR_8 = - 1 ; TYPE_11 VAR_9 = 0 ; if ( METHOD_2 ( VAR_10 -> VAR_11 ) ) VAR_12 |= VAR_13 ; if ( METHOD_3 ( VAR_14 -> VAR_15 ) ) VAR_16 |= VAR_17 ; if ( METHOD_4 ( VAR_18 -> VAR_19 ) ) VAR_20 |= VAR_21 ; if ( METHOD_5 ( VAR_22 -> VAR_23 ) ) METHOD_6 = VAR_24 ; else METHOD_7 = VAR_25 ; if ( METHOD_8 ( VAR_26 -> VAR_27 ) ) { VAR_28 = METHOD_9 ( VAR_29 -> VAR_30 , VAR_31 + VAR_32 , VAR_33 - VAR_34 , <S2SV_StartBug> VAR_35 > 0 ? VAR_36 | VAR_37 : VAR_38 , <S2SV_EndBug> VAR_39 , VAR_40 ) ; } if ( METHOD_10 ( VAR_41 -> VAR_42 ) && VAR_43 == - 1 ) { VAR_44 |= VAR_45 ; VAR_46 = METHOD_11 ( VAR_47 -> VAR_48 , VAR_49 + VAR_50 , VAR_51 - VAR_52 , <S2SV_StartBug> VAR_53 > 0 ? VAR_54 | VAR_55 : VAR_56 , <S2SV_EndBug> VAR_57 , VAR_58 ) ; } switch ( VAR_59 ) { case - 1 : return VAR_60 ; case - 2 : return VAR_61 ; case - 3 : return VAR_62 ; case - 4 : return VAR_63 ; case - 5 : return VAR_64 ; } if ( VAR_65 == 0 && VAR_66 -> VAR_67 == VAR_68 ) return VAR_69 ; VAR_70 . VAR_71 = VAR_72 -> VAR_73 ; VAR_74 . VAR_75 = VAR_76 ; VAR_77 . VAR_78 = VAR_79 ; VAR_80 . VAR_81 = VAR_82 ; VAR_83 . VAR_84 = VAR_85 ; VAR_86 . VAR_87 = VAR_88 ; VAR_89 . VAR_90 = METHOD_12 ( VAR_91 -> VAR_92 ) ; if ( VAR_93 -> VAR_94 != VAR_95 ) { VAR_96 = METHOD_13 ( VAR_97 -> VAR_98 , <S2SV_StartBug> VAR_99 + VAR_100 , <S2SV_EndBug> VAR_101 , VAR_102 | VAR_103 | VAR_104 , METHOD_14 , ( TYPE_12 * ) & VAR_105 ) ; switch ( VAR_106 ) { case - 2 : return VAR_107 ; case - 3 : return VAR_108 ; case - 4 : return VAR_109 ; case - 5 : return VAR_110 ; } } else { METHOD_15 ( METHOD_16 ( VAR_111 + VAR_112 , 0 , VAR_113 , & VAR_114 ) ) ; } return VAR_115 ; }","<S2SV_ModStart> VAR_112 , VAR_112 , <S2SV_ModEnd> VAR_113 , VAR_95 <S2SV_ModStart> VAR_112 , VAR_112 , <S2SV_ModEnd> VAR_113 , VAR_95 <S2SV_ModStart> , VAR_111 + VAR_112 , VAR_82 -","CWE-125 int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string ; callback_args . context = context ; callback_args . data = data ; callback_args . data_size = data_size ; callback_args . data_base = data_base ; callback_args . forward_matches = forward_matches ; callback_args . full_word = STRING_IS_FULL_WORD ( ac_match -> string ) ; if ( ac_match -> backward_code != NULL ) { backward_matches = exec ( ac_match -> backward_code , <S2SV_StartBug> data + offset , <S2SV_EndBug> offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ; switch ( backward_matches ) { case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } } else { FAIL_ON_ERROR ( _yr_scan_match_callback ( data + offset , 0 , flags , & callback_args ) ) ; } return ERROR_SUCCESS ; }","<S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> , data + offset , data_size -"
438,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = 1 ; TYPE_2 VAR_2 = 1 << VAR_3 -> VAR_4 -> VAR_5 ; const TYPE_3 VAR_6 = offsetof ( struct STRUCT_OR_UNION_1 , VAR_7 ) ; METHOD_1 ( VAR_8 -> VAR_9 ) ; VAR_10 -> VAR_11 = VAR_12 ; if ( ( unsigned ) VAR_13 -> VAR_14 > VAR_15 - VAR_16 || ( unsigned ) VAR_17 -> VAR_18 > VAR_19 || ( unsigned ) ( VAR_20 -> VAR_21 + VAR_22 -> VAR_23 ) > VAR_24 ) { METHOD_2 ( KERN_NOTICE ""rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>"" ""extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n"" , VAR_25 -> VAR_26 , VAR_27 -> VAR_28 , VAR_29 -> VAR_30 ) ; VAR_31 = - VAR_32 ; goto VAR_33 ; } if ( VAR_34 -> VAR_35 ) { struct STRUCT_OR_UNION_2 * VAR_36 ; VAR_37 -> VAR_38 = METHOD_3 ( VAR_39 -> VAR_40 , VAR_41 ) ; if ( ! VAR_42 -> VAR_43 ) { VAR_44 = - VAR_45 ; goto VAR_46 ; } VAR_47 = - VAR_48 ; <S2SV_StartBug> VAR_49 = METHOD_4 ( VAR_50 -> VAR_51 -> VAR_52 , VAR_53 -> VAR_54 ) ; <S2SV_EndBug> if ( VAR_55 ) { METHOD_5 ( VAR_56 -> VAR_57 , VAR_58 -> VAR_59 + VAR_60 -> VAR_61 , VAR_62 -> VAR_63 ) ; METHOD_6 ( VAR_64 ) ; VAR_65 -> VAR_66 = VAR_67 -> VAR_68 ; VAR_69 -> VAR_70 = VAR_71 -> VAR_72 ; VAR_73 -> VAR_74 = 0 ; VAR_75 -> VAR_76 = 0 ; VAR_77 -> VAR_78 = 0 ; return 0 ; } METHOD_7 ( ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n"" ) ; } VAR_79 : METHOD_8 ( VAR_80 -> VAR_81 ) ; VAR_82 -> VAR_83 = VAR_84 ; return VAR_85 ; }",<S2SV_ModStart> - VAR_48 ; if ( ++ VAR_82 -> VAR_86 >= VAR_87 ) goto VAR_79 ;,"CWE-399 static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE ""rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>"" ""extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n"" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; <S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n"" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }",<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
439,"CWE-285 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 ) { TYPE_2 VAR_3 ; TYPE_3 * VAR_4 = VAR_5 ; TYPE_4 VAR_6 = 0 ; TYPE_5 VAR_7 ; switch ( VAR_8 ) { case VAR_9 : VAR_10 = VAR_11 ; if ( VAR_12 ) { <S2SV_StartBug> VAR_13 = METHOD_1 ( VAR_14 , & STRUCT_OR_UNION_4 -> VAR_15 ) ; <S2SV_EndBug> if ( VAR_16 < 0 ) return VAR_17 ; <S2SV_StartBug> METHOD_2 ( STRUCT_OR_UNION_5 , STRUCT_OR_UNION_6 -> VAR_18 ) ; <S2SV_EndBug> if ( VAR_19 == 0 ) VAR_20 = VAR_21 ; } break ; case VAR_22 : VAR_23 = VAR_24 ; if ( ! METHOD_3 ( STRUCT_OR_UNION_7 -> VAR_25 ) ) return VAR_26 ? - VAR_27 : 0 ; break ; default : return - VAR_28 ; } if ( VAR_29 ) { VAR_30 = METHOD_4 ( VAR_31 , & VAR_32 ) ; if ( METHOD_5 ( VAR_33 ) ) { METHOD_6 ( STRUCT_OR_UNION_8 , VAR_34 ) ; return ( TYPE_6 ) METHOD_7 ( VAR_35 ) ; } } VAR_36 = METHOD_8 ( STRUCT_OR_UNION_9 , VAR_37 , """" , VAR_38 , VAR_39 , VAR_40 , 0 ) ; METHOD_9 ( VAR_41 ) ; if ( ! VAR_42 ) METHOD_10 ( STRUCT_OR_UNION_10 , VAR_43 , VAR_44 ) ; METHOD_11 ( STRUCT_OR_UNION_11 , VAR_45 ) ; return VAR_46 ; }","<S2SV_ModStart> { VAR_46 = METHOD_12 ( STRUCT_OR_UNION_11 <S2SV_ModEnd> , & STRUCT_OR_UNION_11 <S2SV_ModStart> STRUCT_OR_UNION_11 -> VAR_25 , & VAR_44 ) ; if ( VAR_46 <S2SV_ModEnd> ) return VAR_46 <S2SV_ModStart> -> VAR_25 ) <S2SV_ModEnd> ; } break","CWE-285 static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , """" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> ; } break"
440,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_2 VAR_2 ; <S2SV_EndBug> struct STRUCT_OR_UNION_3 VAR_3 ; struct STRUCT_OR_UNION_4 * VAR_4 = VAR_5 -> VAR_6 ; METHOD_1 ( & VAR_7 -> VAR_8 ) ; METHOD_2 ( & VAR_9 , & VAR_10 -> VAR_11 , sizeof ( struct STRUCT_OR_UNION_5 ) ) ; METHOD_3 ( & VAR_12 -> VAR_13 ) ; VAR_14 . VAR_15 = VAR_16 . VAR_17 ; VAR_18 . VAR_19 = VAR_20 . VAR_21 ; VAR_22 . VAR_23 = VAR_24 . VAR_25 ; VAR_26 . VAR_27 = VAR_28 . VAR_29 ; VAR_30 . VAR_31 = VAR_32 . VAR_33 ; VAR_34 . VAR_35 = VAR_36 . VAR_37 ; VAR_38 . VAR_39 = VAR_40 . VAR_41 ; VAR_42 . VAR_43 = VAR_44 . VAR_45 ; VAR_46 . VAR_47 = VAR_48 . VAR_49 ; VAR_50 . VAR_51 = VAR_52 . VAR_53 ; VAR_54 . VAR_55 = VAR_56 . VAR_57 ; return METHOD_4 ( VAR_58 , & VAR_59 , sizeof ( VAR_60 ) ) ? - VAR_61 : 0 ; }",<S2SV_ModStart> struct STRUCT_OR_UNION_2 VAR_60 = { },"CWE-200 static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq ( & port -> lock ) ; memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ; icount . dcd = cnow . dcd ; icount . rx = cnow . rx ; icount . tx = cnow . tx ; icount . frame = cnow . frame ; icount . overrun = cnow . overrun ; icount . parity = cnow . parity ; icount . brk = cnow . brk ; icount . buf_overrun = cnow . buf_overrun ; return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; }",<S2SV_ModStart> struct serial_icounter_struct icount = { }
441,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 = VAR_8 -> VAR_9 [ VAR_10 -> VAR_11 ] -> VAR_12 ; struct STRUCT_OR_UNION_5 * VAR_13 , * VAR_14 ; TYPE_2 VAR_15 = METHOD_1 ( VAR_16 -> VAR_17 ) ; TYPE_3 VAR_18 ; if ( VAR_19 > VAR_20 ) { METHOD_2 ( VAR_21 , ""invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n"" , VAR_22 ) ; return - VAR_23 ; } if ( METHOD_3 ( VAR_24 -> VAR_25 ) == VAR_26 ) { if ( VAR_27 -> VAR_28 != 0 ) { METHOD_4 ( VAR_29 , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_30 ; } VAR_31 = METHOD_5 ( VAR_32 , VAR_33 -> VAR_34 , VAR_35 ) ; if ( VAR_36 ) return VAR_37 ; if ( METHOD_6 ( VAR_38 , VAR_39 -> VAR_40 ) ) { METHOD_7 ( VAR_41 , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , VAR_42 -> VAR_43 ) ; return - VAR_44 ; } } else { if ( VAR_45 -> VAR_46 != VAR_47 ) { METHOD_8 ( VAR_48 , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_49 ; } } VAR_50 = METHOD_9 ( VAR_51 , VAR_52 -> VAR_53 , VAR_54 ) ; if ( VAR_55 ) return VAR_56 ; VAR_57 = & VAR_58 [ VAR_59 -> VAR_60 ] ; if ( METHOD_10 ( VAR_61 -> VAR_62 ) == VAR_63 ) { TYPE_4 VAR_64 = METHOD_11 ( VAR_65 , VAR_66 -> VAR_67 , VAR_68 ) ; if ( VAR_69 == 1 ) { * VAR_70 += VAR_71 -> VAR_72 ; return 0 ; } else if ( VAR_73 == 0 ) { return 0 ; } } <S2SV_StartBug> VAR_74 = METHOD_12 ( VAR_75 , * VAR_76 + VAR_77 -> VAR_78 + 1 , * VAR_79 ) ; <S2SV_EndBug> if ( ! VAR_80 ) return - VAR_81 ; VAR_82 = VAR_83 -> VAR_84 [ VAR_85 -> VAR_86 ] -> VAR_87 ; if ( METHOD_13 ( VAR_88 -> VAR_89 ) == VAR_90 ) { if ( VAR_91 -> VAR_92 == VAR_93 && VAR_94 [ VAR_95 -> VAR_96 ] . VAR_97 == VAR_98 ) { if ( METHOD_14 ( VAR_99 [ VAR_100 -> VAR_101 ] . VAR_102 ) ) METHOD_15 ( & VAR_103 [ VAR_104 -> VAR_105 ] , VAR_106 , VAR_107 [ VAR_108 -> VAR_109 ] . VAR_110 . VAR_111 , VAR_112 ) ; else if ( METHOD_16 ( VAR_113 -> VAR_114 ) ) METHOD_17 ( & VAR_115 [ VAR_116 -> VAR_117 ] , & VAR_118 [ VAR_119 -> VAR_120 ] , VAR_121 -> VAR_122 . VAR_123 , VAR_124 ) ; else if ( VAR_125 == VAR_126 || VAR_127 == VAR_128 ) METHOD_18 ( & VAR_129 [ VAR_130 -> VAR_131 ] , & VAR_132 [ VAR_133 -> VAR_134 ] , & VAR_135 [ VAR_136 -> VAR_137 ] , & VAR_138 [ VAR_139 -> VAR_140 ] , VAR_141 ) ; } } else if ( VAR_142 -> VAR_143 == VAR_144 ) { METHOD_19 ( & VAR_145 [ VAR_146 -> VAR_147 ] , VAR_148 , VAR_149 -> VAR_150 , VAR_151 ) ; } if ( METHOD_20 ( VAR_152 -> VAR_153 ) == VAR_154 && VAR_155 -> VAR_156 == 0 && ( VAR_157 == VAR_158 || VAR_159 == VAR_160 ) && METHOD_21 ( VAR_161 -> VAR_162 ) ) { METHOD_22 ( VAR_163 , VAR_164 -> VAR_165 , VAR_166 == VAR_167 ) ; METHOD_23 ( VAR_168 , VAR_169 -> VAR_170 , VAR_171 == VAR_172 ) ; } else if ( ! METHOD_24 ( VAR_173 , VAR_174 , & VAR_175 [ VAR_176 -> VAR_177 ] , VAR_178 , VAR_179 ) && METHOD_25 ( VAR_180 , VAR_181 -> VAR_182 ) ) { METHOD_26 ( VAR_183 , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , VAR_184 -> VAR_185 ) ; return - VAR_186 ; } if ( VAR_187 -> VAR_188 . VAR_189 ) METHOD_27 ( VAR_190 , VAR_191 -> VAR_192 [ VAR_193 -> VAR_194 ] ) ; return 0 ; }","<S2SV_ModStart> , * VAR_79 , VAR_195","CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , ""invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }","<S2SV_ModStart> , * insn_idx , false"
442,"CWE-78 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { if ( VAR_2 + 1 == VAR_3 ) { METHOD_1 ( METHOD_2 ( VAR_4 ) ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> TYPE_3 TYPE_4 if ( VAR_5 ) return ; if ( VAR_6 [ VAR_7 ] != VAR_8 ) ++ VAR_9 ; METHOD_3 ( VAR_10 , VAR_11 , VAR_12 ) ; if ( ( VAR_13 [ VAR_14 ] = METHOD_4 ( ( TYPE_5 * ) VAR_15 , VAR_16 ) ) == VAR_17 ) { METHOD_5 ( METHOD_6 ( VAR_18 ) , VAR_19 ) ; if ( VAR_20 ) -- VAR_21 ; return ; } if ( METHOD_7 ( ) == VAR_22 ) return ; if ( VAR_23 ) { TYPE_6 VAR_24 ; TYPE_7 VAR_25 ; TYPE_8 VAR_26 = VAR_27 ; TYPE_9 VAR_28 = VAR_29 ; TYPE_10 VAR_30 = VAR_31 ; TYPE_11 VAR_32 = VAR_33 ; TYPE_12 VAR_34 = VAR_35 ; VAR_36 = VAR_37 ; VAR_38 = VAR_39 ; VAR_40 = 0 ; VAR_41 = VAR_42 ; METHOD_8 ( & VAR_43 ) ; VAR_44 = VAR_45 ; VAR_46 = VAR_47 ; do { METHOD_9 ( ) ; METHOD_10 ( & VAR_48 , VAR_49 ) ; METHOD_11 ( ) ; } while ( VAR_50 [ VAR_51 ] != VAR_52 ) ; VAR_53 = VAR_54 ; VAR_55 = VAR_56 ; VAR_57 = VAR_58 ; VAR_59 = VAR_60 ; VAR_61 = VAR_62 ; } }",<S2SV_ModStart> return ; } if ( METHOD_12 ( ) ) return ;,"CWE-78 void openscript ( char_u * name , int directly ) { if ( curscript + 1 == NSCRIPT ) { emsg ( _ ( e_nesting ) ) ; return ; <S2SV_StartBug> } <S2SV_EndBug>  ifdef FEAT_EVAL if ( ignore_script ) return ;   if ( scriptin [ curscript ] != NULL ) ++ curscript ; expand_env ( name , NameBuff , MAXPATHL ) ; if ( ( scriptin [ curscript ] = mch_fopen ( ( char * ) NameBuff , READBIN ) ) == NULL ) { semsg ( _ ( e_notopen ) , name ) ; if ( curscript ) -- curscript ; return ; } if ( save_typebuf ( ) == FAIL ) return ; if ( directly ) { oparg_T oa ; int oldcurscript ; int save_State = State ; int save_restart_edit = restart_edit ; int save_insertmode = p_im ; int save_finish_op = finish_op ; int save_msg_scroll = msg_scroll ; State = NORMAL ; msg_scroll = FALSE ; restart_edit = 0 ; p_im = FALSE ; clear_oparg ( & oa ) ; finish_op = FALSE ; oldcurscript = curscript ; do { update_topline_cursor ( ) ; normal_cmd ( & oa , FALSE ) ; vpeekc ( ) ; } while ( scriptin [ oldcurscript ] != NULL ) ; State = save_State ; msg_scroll = save_msg_scroll ; restart_edit = save_restart_edit ; p_im = save_insertmode ; finish_op = save_finish_op ; } }",<S2SV_ModStart> return ; } if ( check_secure ( ) ) return ;
443,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 = METHOD_1 ( VAR_5 ) ; struct STRUCT_OR_UNION_3 * VAR_6 = VAR_7 -> VAR_8 ; TYPE_3 VAR_9 = 0 , VAR_10 = 0 , VAR_11 , VAR_12 = 0 , VAR_13 ; switch ( VAR_14 [ 0 ] ) { case VAR_15 : if ( VAR_16 < 4 || ( ( VAR_17 - 4 ) % 9 ) != 0 ) return 0 ; VAR_18 = ( VAR_19 - 4 ) / 9 ; <S2SV_StartBug> VAR_20 -> VAR_21 = 0 ; <S2SV_EndBug> for ( VAR_22 = 0 ; VAR_23 < VAR_24 ; VAR_25 ++ ) METHOD_2 ( VAR_26 , VAR_27 , VAR_28 + VAR_29 * 9 + 4 ) ; VAR_30 = VAR_31 [ 1 ] ; break ; case VAR_32 : if ( VAR_33 < 6 || ( ( VAR_34 - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> VAR_35 = ( VAR_36 - 6 ) / 8 ; <S2SV_EndBug> VAR_37 -> VAR_38 = 0 ; for ( VAR_39 = 0 ; VAR_40 < VAR_41 ; VAR_42 ++ ) METHOD_3 ( VAR_43 , VAR_44 , VAR_45 + VAR_46 * 8 + 6 ) ; VAR_47 = ( TYPE_4 ) ( ( ( VAR_48 [ 3 ] & 0x0c ) << 28 ) | ( VAR_49 [ 1 ] << 22 ) ) >> 22 ; VAR_50 = ( TYPE_5 ) ( ( ( VAR_51 [ 3 ] & 0x30 ) << 26 ) | ( VAR_52 [ 2 ] << 22 ) ) >> 22 ; VAR_53 = VAR_54 [ 3 ] ; break ; case VAR_55 : METHOD_4 ( VAR_56 , VAR_57 , VAR_58 + 2 , VAR_59 [ 1 ] ) ; METHOD_5 ( VAR_60 , VAR_61 , VAR_62 + 2 + VAR_63 [ 1 ] , VAR_64 - 2 - VAR_65 [ 1 ] ) ; break ; default : return 0 ; } if ( VAR_66 -> VAR_67 . VAR_68 == VAR_69 ) { METHOD_6 ( VAR_70 , VAR_71 & 3 ) ; METHOD_7 ( VAR_72 , VAR_73 , VAR_74 ) ; METHOD_8 ( VAR_75 , VAR_76 , VAR_77 ) ; } else { METHOD_9 ( VAR_78 , VAR_79 , VAR_80 & 1 ) ; METHOD_10 ( VAR_81 , VAR_82 ) ; } METHOD_11 ( VAR_83 ) ; return 1 ; }","<S2SV_ModStart> / 9 ; if ( VAR_41 > 15 ) { METHOD_12 ( VAR_60 , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , VAR_64 ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( VAR_41 > 15 ) { METHOD_12 ( VAR_60 , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , VAR_64 ) ; return 0 ; }","CWE-119 static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case TRACKPAD_REPORT_ID : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; <S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case MOUSE_REPORT_ID : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case DOUBLE_REPORT_ID : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == USB_DEVICE_ID_APPLE_MAGICMOUSE ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , REL_X , x ) ; input_report_rel ( input , REL_Y , y ) ; } else { input_report_key ( input , BTN_MOUSE , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }","<S2SV_ModStart> / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; }"
444,"CWE-264 TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) <S2SV_StartBug> { <S2SV_EndBug> if ( METHOD_1 ( METHOD_2 ( ) , STRUCT_OR_UNION_2 -> VAR_0 ) ) return VAR_1 ; <S2SV_StartBug> if ( METHOD_3 ( STRUCT_OR_UNION_3 , VAR_2 ) ) <S2SV_EndBug> return VAR_3 ; return VAR_4 ; }","<S2SV_ModStart> STRUCT_OR_UNION_3 ) { struct STRUCT_OR_UNION_4 * VAR_5 ; <S2SV_ModStart> return VAR_3 ; VAR_5 = METHOD_4 ( ) ; if ( METHOD_5 ( VAR_5 , VAR_2 ) && METHOD_6 ( VAR_5 , STRUCT_OR_UNION_3 -> VAR_0 <S2SV_ModEnd> ) ) return","CWE-264 bool inode_owner_or_capable ( const struct inode * inode ) <S2SV_StartBug> { <S2SV_EndBug> if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ; <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> return true ; return false ; }","<S2SV_ModStart> inode ) { struct user_namespace * ns ; <S2SV_ModStart> return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> ) ) return"
445,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 ) { const TYPE_2 * VAR_3 ; const TYPE_3 * VAR_4 , * VAR_5 ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 ; struct STRUCT_OR_UNION_4 STRUCT_OR_UNION_5 ; struct STRUCT_OR_UNION_6 VAR_6 ; TYPE_4 VAR_7 ; unsigned VAR_8 , VAR_9 ; TYPE_5 * VAR_10 ; TYPE_6 * VAR_11 ; TYPE_7 VAR_12 [ 8 ] ; TYPE_8 VAR_13 [ 8 ] ; TYPE_9 VAR_14 ; struct STRUCT_OR_UNION_7 * VAR_15 , * VAR_16 ; unsigned TYPE_10 VAR_17 ; TYPE_11 VAR_18 = ( VAR_19 ) , VAR_20 ; STRUCT_OR_UNION_8 = ( struct STRUCT_OR_UNION_9 * ) ( VAR_21 -> VAR_22 -> VAR_23 ) ; VAR_24 = STRUCT_OR_UNION_10 -> VAR_25 ; if ( VAR_26 == VAR_27 ) { if ( ! STRUCT_OR_UNION_11 -> VAR_28 ) { STRUCT_OR_UNION_12 -> VAR_29 = METHOD_1 ( & ( VAR_30 -> VAR_31 ) ) ; STRUCT_OR_UNION_13 -> VAR_32 = 1 ; } VAR_33 = STRUCT_OR_UNION_14 -> VAR_34 ; } if ( ( VAR_35 = METHOD_2 ( VAR_36 , 7 , VAR_37 ) ) == VAR_38 ) return ( VAR_39 ) ; VAR_40 = VAR_41 ; METHOD_3 ( & STRUCT_OR_UNION_15 , VAR_42 , sizeof ( STRUCT_OR_UNION_16 ) ) ; STRUCT_OR_UNION_17 -> VAR_43 = METHOD_4 ( STRUCT_OR_UNION_18 . VAR_44 ) ; VAR_45 = METHOD_5 ( STRUCT_OR_UNION_19 . VAR_46 ) ; if ( VAR_47 < ( TYPE_12 ) sizeof ( VAR_48 ) + 7 ) { METHOD_6 ( & VAR_49 -> VAR_50 , VAR_51 , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( VAR_52 ) ; } VAR_53 = METHOD_7 ( 0 , ( const unsigned TYPE_13 * ) VAR_54 + 2 , 7 - 2 ) ; METHOD_8 ( VAR_55 , 7 ) ; if ( ! ( STRUCT_OR_UNION_20 -> VAR_56 & VAR_57 ) ) { STRUCT_OR_UNION_21 -> VAR_58 = 0 ; STRUCT_OR_UNION_22 -> VAR_59 = 0 ; STRUCT_OR_UNION_23 -> VAR_60 = 0 ; STRUCT_OR_UNION_24 -> VAR_61 = 0 ; STRUCT_OR_UNION_25 -> VAR_62 = 0 ; STRUCT_OR_UNION_26 -> VAR_63 = 0 ; STRUCT_OR_UNION_27 -> VAR_64 = 0 ; STRUCT_OR_UNION_28 -> VAR_65 = 0 ; METHOD_9 ( & STRUCT_OR_UNION_29 -> VAR_66 , 0 , sizeof ( STRUCT_OR_UNION_30 -> VAR_67 ) ) ; STRUCT_OR_UNION_31 -> VAR_68 = 0 ; STRUCT_OR_UNION_32 -> VAR_69 = 0 ; STRUCT_OR_UNION_33 -> VAR_70 = 0 ; STRUCT_OR_UNION_34 -> VAR_71 = 0 ; STRUCT_OR_UNION_35 -> VAR_72 = 0 ; STRUCT_OR_UNION_36 -> VAR_73 = 0 ; STRUCT_OR_UNION_37 -> VAR_74 = 0 ; STRUCT_OR_UNION_38 -> VAR_75 = 0 ; } else { METHOD_10 ( & VAR_76 -> VAR_77 , VAR_78 , ""RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable."" ) ; return ( VAR_79 ) ; } if ( ( VAR_80 = METHOD_11 ( VAR_81 , ( TYPE_14 ) VAR_82 - 7 , VAR_83 ) ) == VAR_84 ) return ( VAR_85 ) ; VAR_86 = METHOD_12 ( VAR_87 , VAR_88 , ( unsigned ) ( VAR_89 - 7 ) ) ; if ( ( VAR_90 & 0xffff ) != METHOD_13 ( STRUCT_OR_UNION_39 . VAR_91 ) ) { METHOD_14 ( & VAR_92 -> VAR_93 , VAR_94 , ""Header<S2SV_blank>CRC<S2SV_blank>error"" ) ; return ( VAR_95 ) ; } VAR_96 = VAR_97 ; VAR_98 = VAR_99 + VAR_100 - 7 ; METHOD_15 ( & VAR_101 , VAR_102 , sizeof ( VAR_103 ) ) ; VAR_104 += sizeof ( VAR_105 ) ; STRUCT_OR_UNION_40 -> VAR_106 = VAR_107 . VAR_108 ; VAR_109 = METHOD_16 ( VAR_110 . VAR_111 ) ; STRUCT_OR_UNION_41 -> VAR_112 = METHOD_17 ( VAR_113 ) ; STRUCT_OR_UNION_42 -> VAR_114 = METHOD_18 ( VAR_115 . VAR_116 ) ; if ( STRUCT_OR_UNION_43 -> VAR_117 & VAR_118 ) { METHOD_19 ( VAR_119 , 1 ) ; STRUCT_OR_UNION_44 -> VAR_120 = 1 ; METHOD_20 ( & VAR_121 -> VAR_122 , VAR_123 , ""RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable."" ) ; } if ( STRUCT_OR_UNION_45 -> VAR_124 & VAR_125 ) { METHOD_21 ( VAR_126 , VAR_127 . VAR_128 , 4 ) ; METHOD_22 ( VAR_129 + 4 , VAR_130 , 4 ) ; VAR_131 += 4 ; METHOD_23 ( VAR_132 , VAR_133 . VAR_134 , 4 ) ; METHOD_24 ( VAR_135 + 4 , VAR_136 , 4 ) ; VAR_137 += 4 ; STRUCT_OR_UNION_46 -> VAR_138 = METHOD_25 ( & VAR_139 ) ; STRUCT_OR_UNION_47 -> VAR_140 = METHOD_26 ( & VAR_141 ) ; } else { STRUCT_OR_UNION_48 -> VAR_142 = METHOD_27 ( VAR_143 . VAR_144 ) ; STRUCT_OR_UNION_49 -> VAR_145 = METHOD_28 ( VAR_146 . VAR_147 ) ; } if ( STRUCT_OR_UNION_50 -> VAR_148 < 0 || STRUCT_OR_UNION_51 -> VAR_149 < 0 ) { METHOD_29 ( & VAR_150 -> VAR_151 , VAR_152 , ""Invalid<S2SV_blank>sizes<S2SV_blank>specified."" ) ; return ( VAR_153 ) ; } STRUCT_OR_UNION_52 -> VAR_154 = STRUCT_OR_UNION_53 -> VAR_155 ; if ( VAR_156 == VAR_157 ) { TYPE_15 VAR_158 = VAR_159 - ( const TYPE_16 * ) VAR_160 ; VAR_161 += STRUCT_OR_UNION_54 -> VAR_162 ; if ( ( VAR_163 = METHOD_30 ( VAR_164 , ( TYPE_17 ) VAR_165 - 7 , VAR_166 ) ) == VAR_167 ) return ( VAR_168 ) ; VAR_169 = VAR_170 ; VAR_171 = VAR_172 + VAR_173 - 7 ; VAR_174 += VAR_175 ; } VAR_176 = METHOD_31 ( VAR_177 . VAR_178 ) ; if ( VAR_179 + VAR_180 > VAR_181 ) { METHOD_32 ( & VAR_182 -> VAR_183 , VAR_184 , ""Invalid<S2SV_blank>filename<S2SV_blank>size"" ) ; return ( VAR_185 ) ; } if ( STRUCT_OR_UNION_55 -> VAR_186 < VAR_187 * 2 + 2 ) { TYPE_18 * VAR_188 ; TYPE_19 VAR_189 = VAR_190 * 2 + 2 ; VAR_191 = METHOD_33 ( STRUCT_OR_UNION_56 -> VAR_192 , VAR_193 ) ; if ( VAR_194 == VAR_195 ) { METHOD_34 ( & VAR_196 -> VAR_197 , VAR_198 , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( VAR_199 ) ; } STRUCT_OR_UNION_57 -> VAR_200 = VAR_201 ; STRUCT_OR_UNION_58 -> VAR_202 = VAR_203 ; } VAR_204 = STRUCT_OR_UNION_59 -> VAR_205 ; METHOD_35 ( VAR_206 , VAR_207 , VAR_208 ) ; VAR_209 [ VAR_210 ] = '\\0' ; if ( STRUCT_OR_UNION_60 -> VAR_211 & VAR_212 ) { if ( VAR_213 != METHOD_36 ( VAR_214 ) ) { unsigned TYPE_20 VAR_215 , VAR_216 , VAR_217 ; unsigned VAR_218 , VAR_219 ; VAR_220 = VAR_221 ; VAR_222 = VAR_223 * 2 ; VAR_224 = 0 ; VAR_225 = ( unsigned ) METHOD_37 ( VAR_226 ) + 1 ; VAR_227 = * ( VAR_228 + VAR_229 ++ ) ; VAR_230 = 0 ; VAR_231 = 0 ; while ( VAR_232 < VAR_233 && VAR_234 < VAR_235 ) { if ( ! VAR_236 ) { VAR_237 = * ( VAR_238 + VAR_239 ++ ) ; VAR_240 = 8 ; } VAR_241 -= 2 ; switch ( ( VAR_242 >> VAR_243 ) & 3 ) { case 0 : VAR_244 [ VAR_245 ++ ] = '\\0' ; VAR_246 [ VAR_247 ++ ] = * ( VAR_248 + VAR_249 ++ ) ; break ; case 1 : VAR_250 [ VAR_251 ++ ] = VAR_252 ; VAR_253 [ VAR_254 ++ ] = * ( VAR_255 + VAR_256 ++ ) ; break ; case 2 : VAR_257 [ VAR_258 ++ ] = * ( VAR_259 + VAR_260 + 1 ) ; VAR_261 [ VAR_262 ++ ] = * ( VAR_263 + VAR_264 ) ; VAR_265 += 2 ; break ; case 3 : { TYPE_21 VAR_266 , VAR_267 ; TYPE_22 VAR_268 = * ( VAR_269 + VAR_270 ++ ) ; if ( VAR_271 & 0x80 ) { VAR_272 = * ( VAR_273 + VAR_274 ++ ) ; VAR_275 = ( TYPE_23 ) VAR_276 ; } else VAR_277 = VAR_278 = 0 ; VAR_279 = ( VAR_280 & 0x7f ) + 2 ; while ( VAR_281 && VAR_282 < VAR_283 ) { unsigned VAR_284 = VAR_285 >> 1 ; VAR_286 [ VAR_287 ++ ] = VAR_288 ; VAR_289 [ VAR_290 ++ ] = VAR_291 [ VAR_292 ] + VAR_293 ; VAR_294 -- ; } } break ; } } if ( VAR_295 > VAR_296 ) { METHOD_38 ( & VAR_297 -> VAR_298 , VAR_299 , ""Invalid<S2SV_blank>filename"" ) ; return ( VAR_300 ) ; } VAR_301 [ VAR_302 ++ ] = '\\0' ; <S2SV_StartBug> VAR_303 [ VAR_304 ++ ] = '\\0' ; <S2SV_EndBug> if ( STRUCT_OR_UNION_61 -> VAR_305 == VAR_306 ) { STRUCT_OR_UNION_62 -> VAR_307 = METHOD_39 ( & VAR_308 -> VAR_309 , ""UTF-16BE"" , 1 ) ; if ( STRUCT_OR_UNION_63 -> VAR_310 == VAR_311 ) return ( VAR_312 ) ; } VAR_313 = STRUCT_OR_UNION_64 -> VAR_314 ; VAR_315 = VAR_316 ; while ( METHOD_40 ( VAR_317 , ""\\x00\\x00"" , 2 ) ) { if ( ! METHOD_41 ( VAR_318 , ""\\x00\\\\"" , 2 ) ) * ( VAR_319 + 1 ) = '/' ; VAR_320 += 2 ; } VAR_321 += VAR_322 ; } else { if ( STRUCT_OR_UNION_65 -> VAR_323 == VAR_324 ) { STRUCT_OR_UNION_66 -> VAR_325 = METHOD_42 ( & VAR_326 -> VAR_327 , ""UTF-8"" , 1 ) ; if ( STRUCT_OR_UNION_67 -> VAR_328 == VAR_329 ) return ( VAR_330 ) ; } VAR_331 = STRUCT_OR_UNION_68 -> VAR_332 ; while ( ( VAR_333 = METHOD_43 ( VAR_334 , '\\\\' ) ) != VAR_335 ) * VAR_336 = '/' ; VAR_337 += VAR_338 ; } } else { VAR_339 = VAR_340 ; while ( ( VAR_341 = METHOD_44 ( VAR_342 , '\\\\' ) ) != VAR_343 ) * VAR_344 = '/' ; VAR_345 += VAR_346 ; } if ( STRUCT_OR_UNION_69 -> VAR_347 && VAR_348 == STRUCT_OR_UNION_70 -> VAR_349 && ! METHOD_45 ( STRUCT_OR_UNION_71 -> VAR_350 , STRUCT_OR_UNION_72 -> VAR_351 , VAR_352 + 1 ) ) { METHOD_46 ( VAR_353 , VAR_354 - 7 ) ; STRUCT_OR_UNION_73 -> VAR_355 ++ ; if ( STRUCT_OR_UNION_74 -> VAR_356 >= STRUCT_OR_UNION_75 -> VAR_357 ) { STRUCT_OR_UNION_76 -> VAR_358 ++ ; if ( ( STRUCT_OR_UNION_77 -> VAR_359 = METHOD_47 ( STRUCT_OR_UNION_78 -> VAR_360 , sizeof ( * STRUCT_OR_UNION_79 -> VAR_361 ) * STRUCT_OR_UNION_80 -> VAR_362 ) ) == VAR_363 ) { METHOD_48 ( & VAR_364 -> VAR_365 , VAR_366 , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( VAR_367 ) ; } STRUCT_OR_UNION_81 -> VAR_368 [ STRUCT_OR_UNION_82 -> VAR_369 ] . VAR_370 = VAR_371 ; STRUCT_OR_UNION_83 -> VAR_372 [ STRUCT_OR_UNION_84 -> VAR_373 ] . VAR_374 = - 1 ; STRUCT_OR_UNION_85 -> VAR_375 [ STRUCT_OR_UNION_86 -> VAR_376 ] . VAR_377 = - 1 ; } if ( STRUCT_OR_UNION_87 -> VAR_378 [ STRUCT_OR_UNION_88 -> VAR_379 ] . VAR_380 < 0 ) { STRUCT_OR_UNION_89 -> VAR_381 [ STRUCT_OR_UNION_90 -> VAR_382 ] . VAR_383 = VAR_384 -> VAR_385 -> VAR_386 ; STRUCT_OR_UNION_91 -> VAR_387 [ STRUCT_OR_UNION_92 -> VAR_388 ] . VAR_389 = STRUCT_OR_UNION_93 -> VAR_390 [ STRUCT_OR_UNION_94 -> VAR_391 ] . VAR_392 + STRUCT_OR_UNION_95 -> VAR_393 ; } return VAR_394 ; } STRUCT_OR_UNION_96 -> VAR_395 = ( TYPE_24 * ) METHOD_49 ( STRUCT_OR_UNION_97 -> VAR_396 , VAR_397 + 1 ) ; METHOD_50 ( STRUCT_OR_UNION_98 -> VAR_398 , STRUCT_OR_UNION_99 -> VAR_399 , VAR_400 + 1 ) ; STRUCT_OR_UNION_100 -> VAR_401 = VAR_402 ; METHOD_51 ( STRUCT_OR_UNION_101 -> VAR_403 ) ; if ( ( STRUCT_OR_UNION_102 -> VAR_404 = METHOD_52 ( 1 , sizeof ( * STRUCT_OR_UNION_103 -> VAR_405 ) ) ) == VAR_406 ) { METHOD_53 ( & VAR_407 -> VAR_408 , VAR_409 , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( VAR_410 ) ; } STRUCT_OR_UNION_104 -> VAR_411 [ 0 ] . VAR_412 = VAR_413 ; STRUCT_OR_UNION_105 -> VAR_414 [ 0 ] . VAR_415 = - 1 ; STRUCT_OR_UNION_106 -> VAR_416 [ 0 ] . VAR_417 = - 1 ; STRUCT_OR_UNION_107 -> VAR_418 = 0 ; STRUCT_OR_UNION_108 -> VAR_419 = 1 ; if ( STRUCT_OR_UNION_109 -> VAR_420 & VAR_421 ) { if ( VAR_422 + 8 > VAR_423 ) { METHOD_54 ( & VAR_424 -> VAR_425 , VAR_426 , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( VAR_427 ) ; } METHOD_55 ( STRUCT_OR_UNION_110 -> VAR_428 , VAR_429 , 8 ) ; VAR_430 += 8 ; } if ( STRUCT_OR_UNION_111 -> VAR_431 & VAR_432 ) { if ( METHOD_56 ( VAR_433 , STRUCT_OR_UNION_112 , VAR_434 ) < 0 ) { METHOD_57 ( & VAR_435 -> VAR_436 , VAR_437 , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( VAR_438 ) ; } } METHOD_58 ( VAR_439 , VAR_440 - 7 ) ; STRUCT_OR_UNION_113 -> VAR_441 [ 0 ] . VAR_442 = VAR_443 -> VAR_444 -> VAR_445 ; STRUCT_OR_UNION_114 -> VAR_446 [ 0 ] . VAR_447 = STRUCT_OR_UNION_115 -> VAR_448 [ 0 ] . VAR_449 + STRUCT_OR_UNION_116 -> VAR_450 ; switch ( VAR_451 . VAR_452 ) { case VAR_453 : case VAR_454 : case VAR_455 : STRUCT_OR_UNION_117 -> VAR_456 = METHOD_59 ( VAR_457 . VAR_458 ) ; if ( STRUCT_OR_UNION_118 -> VAR_459 & VAR_460 ) STRUCT_OR_UNION_119 -> VAR_461 = VAR_462 | VAR_463 | VAR_464 | VAR_465 ; else STRUCT_OR_UNION_120 -> VAR_466 = VAR_467 ; STRUCT_OR_UNION_121 -> VAR_468 |= VAR_469 | VAR_470 | VAR_471 | VAR_472 ; break ; case VAR_473 : case VAR_474 : case VAR_475 : STRUCT_OR_UNION_122 -> VAR_476 = METHOD_60 ( VAR_477 . VAR_478 ) ; break ; default : METHOD_61 ( & VAR_479 -> VAR_480 , VAR_481 , ""Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\'s<S2SV_blank>host<S2SV_blank>OS"" ) ; return ( VAR_482 ) ; } STRUCT_OR_UNION_123 -> VAR_483 = STRUCT_OR_UNION_124 -> VAR_484 = 0 ; STRUCT_OR_UNION_125 -> VAR_485 . VAR_486 = STRUCT_OR_UNION_126 -> VAR_487 = 0 ; STRUCT_OR_UNION_127 -> VAR_488 = 0 ; STRUCT_OR_UNION_128 -> VAR_489 = 0 ; STRUCT_OR_UNION_129 -> VAR_490 = 0 ; STRUCT_OR_UNION_130 -> VAR_491 . VAR_492 = 0 ; STRUCT_OR_UNION_131 -> VAR_493 . VAR_494 = 0 ; STRUCT_OR_UNION_132 -> VAR_495 = 0 ; STRUCT_OR_UNION_133 -> VAR_496 = 0 ; STRUCT_OR_UNION_134 -> VAR_497 = 1 ; STRUCT_OR_UNION_135 -> VAR_498 = 0 ; STRUCT_OR_UNION_136 -> VAR_499 = 1 ; METHOD_62 ( STRUCT_OR_UNION_137 -> VAR_500 ) ; STRUCT_OR_UNION_138 -> VAR_501 = VAR_502 ; STRUCT_OR_UNION_139 -> VAR_503 = 0 ; STRUCT_OR_UNION_140 -> VAR_504 = VAR_505 ; METHOD_63 ( STRUCT_OR_UNION_141 -> VAR_506 , 0 , sizeof ( STRUCT_OR_UNION_142 -> VAR_507 ) ) ; VAR_508 . METHOD_64 ( & STRUCT_OR_UNION_143 -> VAR_509 , & VAR_510 ) ; STRUCT_OR_UNION_144 -> VAR_511 = STRUCT_OR_UNION_145 -> VAR_512 = 0 ; if ( VAR_513 == VAR_514 ) return VAR_515 ; METHOD_65 ( VAR_516 , STRUCT_OR_UNION_146 -> VAR_517 , STRUCT_OR_UNION_147 -> VAR_518 ) ; METHOD_66 ( VAR_519 , STRUCT_OR_UNION_148 -> VAR_520 , STRUCT_OR_UNION_149 -> VAR_521 ) ; METHOD_67 ( VAR_522 , STRUCT_OR_UNION_150 -> VAR_523 , STRUCT_OR_UNION_151 -> VAR_524 ) ; METHOD_68 ( VAR_525 , STRUCT_OR_UNION_152 -> VAR_526 ) ; METHOD_69 ( VAR_527 , STRUCT_OR_UNION_153 -> VAR_528 ) ; if ( METHOD_70 ( VAR_529 , VAR_530 , VAR_531 , VAR_532 ) ) { if ( VAR_533 == VAR_534 ) { METHOD_71 ( & VAR_535 -> VAR_536 , VAR_537 , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname"" ) ; return ( VAR_538 ) ; } METHOD_72 ( & VAR_539 -> VAR_540 , VAR_541 , ""Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale."" , METHOD_73 ( VAR_542 ) ) ; VAR_543 = ( VAR_544 ) ; } if ( ( ( STRUCT_OR_UNION_154 -> VAR_545 ) & VAR_546 ) == VAR_547 ) { STRUCT_OR_UNION_155 -> VAR_548 = 0 ; METHOD_74 ( VAR_549 , 0 ) ; if ( ( VAR_550 = METHOD_75 ( VAR_551 , VAR_552 , VAR_553 ) ) < ( VAR_554 ) ) return VAR_555 ; if ( VAR_556 > VAR_557 ) VAR_558 = VAR_559 ; } if ( STRUCT_OR_UNION_156 -> VAR_560 == 0 ) STRUCT_OR_UNION_157 -> VAR_561 = 1 ; return VAR_562 ; }",<S2SV_ModStart> VAR_530 [ VAR_531 <S2SV_ModEnd> ] = '\\0',"CWE-125 static int read_header ( struct archive_read * a , struct archive_entry * entry , char head_type ) { const void * h ; const char * p , * endp ; struct rar * rar ; struct rar_header rar_header ; struct rar_file_header file_header ; int64_t header_size ; unsigned filename_size , end ; char * filename ; char * strp ; char packed_size [ 8 ] ; char unp_size [ 8 ] ; int ttime ; struct archive_string_conv * sconv , * fn_sconv ; unsigned long crc32_val ; int ret = ( ARCHIVE_OK ) , ret2 ; rar = ( struct rar * ) ( a -> format -> data ) ; sconv = rar -> opt_sconv ; if ( sconv == NULL ) { if ( ! rar -> init_default_conversion ) { rar -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; rar -> init_default_conversion = 1 ; } sconv = rar -> sconv_default ; } if ( ( h = __archive_read_ahead ( a , 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; memcpy ( & rar_header , p , sizeof ( rar_header ) ) ; rar -> file_flags = archive_le16dec ( rar_header . flags ) ; header_size = archive_le16dec ( rar_header . size ) ; if ( header_size < ( int64_t ) sizeof ( file_header ) + 7 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } crc32_val = crc32 ( 0 , ( const unsigned char * ) p + 2 , 7 - 2 ) ; __archive_read_consume ( a , 7 ) ; if ( ! ( rar -> file_flags & FHD_SOLID ) ) { rar -> compression_method = 0 ; rar -> packed_size = 0 ; rar -> unp_size = 0 ; rar -> mtime = 0 ; rar -> ctime = 0 ; rar -> atime = 0 ; rar -> arctime = 0 ; rar -> mode = 0 ; memset ( & rar -> salt , 0 , sizeof ( rar -> salt ) ) ; rar -> atime = 0 ; rar -> ansec = 0 ; rar -> ctime = 0 ; rar -> cnsec = 0 ; rar -> mtime = 0 ; rar -> mnsec = 0 ; rar -> arctime = 0 ; rar -> arcnsec = 0 ; } else { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable."" ) ; return ( ARCHIVE_FATAL ) ; } if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; crc32_val = crc32 ( crc32_val , h , ( unsigned ) ( header_size - 7 ) ) ; if ( ( crc32_val & 0xffff ) != archive_le16dec ( rar_header . crc ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Header<S2SV_blank>CRC<S2SV_blank>error"" ) ; return ( ARCHIVE_FATAL ) ; } p = h ; endp = p + header_size - 7 ; memcpy ( & file_header , p , sizeof ( file_header ) ) ; p += sizeof ( file_header ) ; rar -> compression_method = file_header . method ; ttime = archive_le32dec ( file_header . file_time ) ; rar -> mtime = get_time ( ttime ) ; rar -> file_crc = archive_le32dec ( file_header . file_crc ) ; if ( rar -> file_flags & FHD_PASSWORD ) { archive_entry_set_is_data_encrypted ( entry , 1 ) ; rar -> has_encrypted_entries = 1 ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable."" ) ; } if ( rar -> file_flags & FHD_LARGE ) { memcpy ( packed_size , file_header . pack_size , 4 ) ; memcpy ( packed_size + 4 , p , 4 ) ; p += 4 ; memcpy ( unp_size , file_header . unp_size , 4 ) ; memcpy ( unp_size + 4 , p , 4 ) ; p += 4 ; rar -> packed_size = archive_le64dec ( & packed_size ) ; rar -> unp_size = archive_le64dec ( & unp_size ) ; } else { rar -> packed_size = archive_le32dec ( file_header . pack_size ) ; rar -> unp_size = archive_le32dec ( file_header . unp_size ) ; } if ( rar -> packed_size < 0 || rar -> unp_size < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>sizes<S2SV_blank>specified."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_remaining = rar -> packed_size ; if ( head_type == NEWSUB_HEAD ) { size_t distance = p - ( const char * ) h ; header_size += rar -> packed_size ; if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; endp = p + header_size - 7 ; p += distance ; } filename_size = archive_le16dec ( file_header . name_size ) ; if ( p + filename_size > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>filename<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if ( rar -> filename_allocated < filename_size * 2 + 2 ) { char * newptr ; size_t newsize = filename_size * 2 + 2 ; newptr = realloc ( rar -> filename , newsize ) ; if ( newptr == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> filename = newptr ; rar -> filename_allocated = newsize ; } filename = rar -> filename ; memcpy ( filename , p , filename_size ) ; filename [ filename_size ] = '\\0' ; if ( rar -> file_flags & FHD_UNICODE ) { if ( filename_size != strlen ( filename ) ) { unsigned char highbyte , flagbits , flagbyte ; unsigned fn_end , offset ; end = filename_size ; fn_end = filename_size * 2 ; filename_size = 0 ; offset = ( unsigned ) strlen ( filename ) + 1 ; highbyte = * ( p + offset ++ ) ; flagbits = 0 ; flagbyte = 0 ; while ( offset < end && filename_size < fn_end ) { if ( ! flagbits ) { flagbyte = * ( p + offset ++ ) ; flagbits = 8 ; } flagbits -= 2 ; switch ( ( flagbyte >> flagbits ) & 3 ) { case 0 : filename [ filename_size ++ ] = '\\0' ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 1 : filename [ filename_size ++ ] = highbyte ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 2 : filename [ filename_size ++ ] = * ( p + offset + 1 ) ; filename [ filename_size ++ ] = * ( p + offset ) ; offset += 2 ; break ; case 3 : { char extra , high ; uint8_t length = * ( p + offset ++ ) ; if ( length & 0x80 ) { extra = * ( p + offset ++ ) ; high = ( char ) highbyte ; } else extra = high = 0 ; length = ( length & 0x7f ) + 2 ; while ( length && filename_size < fn_end ) { unsigned cp = filename_size >> 1 ; filename [ filename_size ++ ] = high ; filename [ filename_size ++ ] = p [ cp ] + extra ; length -- ; } } break ; } } if ( filename_size > fn_end ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>filename"" ) ; return ( ARCHIVE_FATAL ) ; } filename [ filename_size ++ ] = '\\0' ; <S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> if ( rar -> sconv_utf16be == NULL ) { rar -> sconv_utf16be = archive_string_conversion_from_charset ( & a -> archive , ""UTF-16BE"" , 1 ) ; if ( rar -> sconv_utf16be == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf16be ; strp = filename ; while ( memcmp ( strp , ""\\x00\\x00"" , 2 ) ) { if ( ! memcmp ( strp , ""\\x00\\\\"" , 2 ) ) * ( strp + 1 ) = '/' ; strp += 2 ; } p += offset ; } else { if ( rar -> sconv_utf8 == NULL ) { rar -> sconv_utf8 = archive_string_conversion_from_charset ( & a -> archive , ""UTF-8"" , 1 ) ; if ( rar -> sconv_utf8 == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf8 ; while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } } else { fn_sconv = sconv ; while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } if ( rar -> filename_save && filename_size == rar -> filename_save_size && ! memcmp ( rar -> filename , rar -> filename_save , filename_size + 1 ) ) { __archive_read_consume ( a , header_size - 7 ) ; rar -> cursor ++ ; if ( rar -> cursor >= rar -> nodes ) { rar -> nodes ++ ; if ( ( rar -> dbo = realloc ( rar -> dbo , sizeof ( * rar -> dbo ) * rar -> nodes ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ rar -> cursor ] . header_size = header_size ; rar -> dbo [ rar -> cursor ] . start_offset = - 1 ; rar -> dbo [ rar -> cursor ] . end_offset = - 1 ; } if ( rar -> dbo [ rar -> cursor ] . start_offset < 0 ) { rar -> dbo [ rar -> cursor ] . start_offset = a -> filter -> position ; rar -> dbo [ rar -> cursor ] . end_offset = rar -> dbo [ rar -> cursor ] . start_offset + rar -> packed_size ; } return ret ; } rar -> filename_save = ( char * ) realloc ( rar -> filename_save , filename_size + 1 ) ; memcpy ( rar -> filename_save , rar -> filename , filename_size + 1 ) ; rar -> filename_save_size = filename_size ; free ( rar -> dbo ) ; if ( ( rar -> dbo = calloc ( 1 , sizeof ( * rar -> dbo ) ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ 0 ] . header_size = header_size ; rar -> dbo [ 0 ] . start_offset = - 1 ; rar -> dbo [ 0 ] . end_offset = - 1 ; rar -> cursor = 0 ; rar -> nodes = 1 ; if ( rar -> file_flags & FHD_SALT ) { if ( p + 8 > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( rar -> salt , p , 8 ) ; p += 8 ; } if ( rar -> file_flags & FHD_EXTTIME ) { if ( read_exttime ( p , rar , endp ) < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } } __archive_read_consume ( a , header_size - 7 ) ; rar -> dbo [ 0 ] . start_offset = a -> filter -> position ; rar -> dbo [ 0 ] . end_offset = rar -> dbo [ 0 ] . start_offset + rar -> packed_size ; switch ( file_header . host_os ) { case OS_MSDOS : case OS_OS2 : case OS_WIN32 : rar -> mode = archive_le32dec ( file_header . file_attr ) ; if ( rar -> mode & FILE_ATTRIBUTE_DIRECTORY ) rar -> mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH ; else rar -> mode = AE_IFREG ; rar -> mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ; break ; case OS_UNIX : case OS_MAC_OS : case OS_BEOS : rar -> mode = archive_le32dec ( file_header . file_attr ) ; break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\'s<S2SV_blank>host<S2SV_blank>OS"" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_uncopied = rar -> bytes_unconsumed = 0 ; rar -> lzss . position = rar -> offset = 0 ; rar -> offset_seek = 0 ; rar -> dictionary_size = 0 ; rar -> offset_outgoing = 0 ; rar -> br . cache_avail = 0 ; rar -> br . avail_in = 0 ; rar -> crc_calculated = 0 ; rar -> entry_eof = 0 ; rar -> valid = 1 ; rar -> is_ppmd_block = 0 ; rar -> start_new_table = 1 ; free ( rar -> unp_buffer ) ; rar -> unp_buffer = NULL ; rar -> unp_offset = 0 ; rar -> unp_buffer_size = UNP_BUFFER_SIZE ; memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> ppmd_valid = rar -> ppmd_eod = 0 ; if ( head_type == NEWSUB_HEAD ) return ret ; archive_entry_set_mtime ( entry , rar -> mtime , rar -> mnsec ) ; archive_entry_set_ctime ( entry , rar -> ctime , rar -> cnsec ) ; archive_entry_set_atime ( entry , rar -> atime , rar -> ansec ) ; archive_entry_set_size ( entry , rar -> unp_size ) ; archive_entry_set_mode ( entry , rar -> mode ) ; if ( archive_entry_copy_pathname_l ( entry , filename , filename_size , fn_sconv ) ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname"" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale."" , archive_string_conversion_charset_name ( fn_sconv ) ) ; ret = ( ARCHIVE_WARN ) ; } if ( ( ( rar -> mode ) & AE_IFMT ) == AE_IFLNK ) { rar -> bytes_remaining = 0 ; archive_entry_set_size ( entry , 0 ) ; if ( ( ret2 = read_symlink_stored ( a , entry , sconv ) ) < ( ARCHIVE_WARN ) ) return ret2 ; if ( ret > ret2 ) ret = ret2 ; } if ( rar -> bytes_remaining == 0 ) rar -> entry_eof = 1 ; return ret ; }",<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\0'
446,"CWE-401 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 ; struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 ; TYPE_1 VAR_4 ; TYPE_2 VAR_5 ; STRUCT_OR_UNION_4 = METHOD_1 ( 0 , VAR_6 ) ; if ( ! STRUCT_OR_UNION_5 ) return - VAR_7 ; METHOD_2 ( STRUCT_OR_UNION_6 , VAR_8 -> VAR_9 , VAR_10 -> VAR_11 , VAR_12 -> VAR_13 , VAR_14 , VAR_15 , VAR_16 , 1 ) ; METHOD_3 ( STRUCT_OR_UNION_7 , & VAR_17 -> VAR_18 ) ; VAR_19 = METHOD_4 ( STRUCT_OR_UNION_8 , VAR_20 ) ; if ( VAR_21 ) { METHOD_5 ( STRUCT_OR_UNION_9 ) ; <S2SV_StartBug> goto VAR_22 ; <S2SV_EndBug> } VAR_23 = METHOD_6 ( VAR_24 , VAR_25 ) ; VAR_26 |= VAR_27 ; METHOD_7 ( VAR_28 , VAR_29 , VAR_30 ) ; VAR_31 : return VAR_32 ; }",<S2SV_ModStart> STRUCT_OR_UNION_9 ) ; METHOD_8 ( STRUCT_OR_UNION_9 ) ;,"CWE-401 static int rtl8xxxu_submit_int_urb ( struct ieee80211_hw * hw ) { struct rtl8xxxu_priv * priv = hw -> priv ; struct urb * urb ; u32 val32 ; int ret ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; usb_fill_int_urb ( urb , priv -> udev , priv -> pipe_interrupt , priv -> int_buf , USB_INTR_CONTENT_LENGTH , rtl8xxxu_int_complete , priv , 1 ) ; usb_anchor_urb ( urb , & priv -> int_anchor ) ; ret = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( ret ) { usb_unanchor_urb ( urb ) ; <S2SV_StartBug> goto error ; <S2SV_EndBug> } val32 = rtl8xxxu_read32 ( priv , REG_USB_HIMR ) ; val32 |= USB_HIMR_CPWM ; rtl8xxxu_write32 ( priv , REG_USB_HIMR , val32 ) ; error : return ret ; }",<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
447,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , struct STRUCT_OR_UNION_4 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_5 * VAR_3 = STRUCT_OR_UNION_6 -> VAR_4 ; struct STRUCT_OR_UNION_7 * VAR_5 = METHOD_1 ( VAR_6 ) ; struct STRUCT_OR_UNION_8 * VAR_7 ; TYPE_3 VAR_8 , VAR_9 ; VAR_10 = - VAR_11 ; if ( VAR_12 & ~ ( VAR_13 | VAR_14 | VAR_15 | VAR_16 ) ) goto VAR_17 ; <S2SV_StartBug> VAR_18 -> VAR_19 = 0 ; <S2SV_EndBug> VAR_20 = METHOD_2 ( VAR_21 , VAR_22 , VAR_23 & VAR_24 , & VAR_25 ) ; if ( VAR_26 == VAR_27 ) goto VAR_28 ; VAR_29 = VAR_30 -> VAR_31 ; if ( VAR_32 > VAR_33 ) { VAR_34 -> VAR_35 |= VAR_36 ; VAR_37 = VAR_38 ; } METHOD_3 ( VAR_39 ) ; VAR_40 = METHOD_4 ( VAR_41 , 0 , VAR_42 -> VAR_43 , VAR_44 ) ; if ( VAR_45 ) goto VAR_46 ; METHOD_5 ( VAR_47 , VAR_48 , VAR_49 ) ; VAR_50 = ( VAR_51 & VAR_52 ) ? VAR_53 -> VAR_54 : VAR_55 ; if ( VAR_56 -> VAR_57 . VAR_58 != VAR_59 && 3 * METHOD_6 ( & VAR_60 -> VAR_61 ) <= VAR_62 -> VAR_63 ) METHOD_7 ( VAR_64 ) ; VAR_65 : METHOD_8 ( VAR_66 , VAR_67 ) ; VAR_68 : return VAR_69 ; }",<S2SV_ModStart> goto VAR_68 ; <S2SV_ModEnd> VAR_67 = METHOD_2,"CWE-20 static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }",<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
448,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_StartBug> TYPE_3 * VAR_2 , <S2SV_EndBug> const TYPE_4 * VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 ( VAR_5 != 00 ) ; TYPE_7 ( VAR_6 != 00 ) ; TYPE_8 ( VAR_7 != 00 ) ; METHOD_1 ( VAR_8 ) ; METHOD_2 ( VAR_9 ) ; <S2SV_StartBug> METHOD_3 ( VAR_10 , VAR_11 , <S2SV_EndBug> 2 ) ; VAR_12 += 2 ; METHOD_4 ( VAR_13 , 10 , 2 ) ; VAR_14 += 2 ; METHOD_5 ( VAR_15 , VAR_16 -> VAR_17 , 2 ) ; VAR_18 += 2 ; VAR_19 += 4 ; METHOD_6 ( VAR_20 , VAR_21 -> VAR_22 . VAR_23 . VAR_24 , 1 ) ; ++ VAR_25 ; METHOD_7 ( VAR_26 , VAR_27 -> VAR_28 . VAR_29 [ VAR_30 -> VAR_31 ] . VAR_32 , 1 ) ; ++ VAR_33 ; TYPE_9 TYPE_10 TYPE_11 ( 0 && ""TODO"" ) ; * VAR_34 = 12 ; return VAR_35 ; }","<S2SV_ModStart> VAR_33 , TYPE_3 VAR_36 , TYPE_3 <S2SV_ModStart> VAR_9 ) ; if ( VAR_36 < 12 ) { METHOD_8 ( VAR_9 , VAR_37 , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return VAR_38 ; }","CWE-119 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , <S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ;  ifdef USE_JPWL assert ( 0 && ""TODO"" ) ;   * p_data_written = 12 ; return OPJ_TRUE ; }","<S2SV_ModStart> p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 <S2SV_ModStart> p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; }"
449,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_EndBug> METHOD_1 ( VAR_2 ) ; METHOD_2 ( VAR_3 ) ; METHOD_3 ( VAR_4 , VAR_5 ) ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,"CWE-119 <S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fadst16_8col ( in0 ) ; fadst16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
450,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { const unsigned TYPE_5 * VAR_4 = VAR_5 ; TYPE_6 VAR_6 ; unsigned TYPE_7 VAR_7 , VAR_8 , VAR_9 ; if ! METHOD_1 ( VAR_10 ) && VAR_11 unsigned TYPE_8 VAR_12 , VAR_13 ; unsigned TYPE_9 VAR_14 = ( unsigned TYPE_10 ) VAR_15 ; TYPE_11 * VAR_16 = & VAR_17 -> VAR_18 . VAR_19 [ 0 ] ; TYPE_12 VAR_20 ; if ( VAR_21 < 0 ) { METHOD_2 ( VAR_22 , VAR_23 ) ; return - 1 ; } VAR_24 -> VAR_25 = VAR_26 ; VAR_27 = VAR_28 -> VAR_29 . VAR_30 ; if ( ( unsigned TYPE_13 ) VAR_31 < VAR_32 -> VAR_33 . VAR_34 ) { METHOD_3 ( VAR_35 , VAR_36 ) ; return - 1 ; } VAR_37 -> VAR_38 . VAR_39 = 0 ; if ( METHOD_4 ( VAR_40 ) && ! METHOD_5 ( VAR_41 ) ) { VAR_42 = VAR_43 -> METHOD_6 ( VAR_44 ) ; if ( VAR_45 < 0 ) return ( VAR_46 ) ; if ( VAR_47 == 0 ) { METHOD_7 ( VAR_48 , VAR_49 ) ; return - 1 ; } } if ( VAR_50 -> VAR_51 != 0 ) { VAR_52 = METHOD_8 ( VAR_53 , VAR_54 , & VAR_55 [ VAR_56 ] , VAR_57 -> VAR_58 . VAR_59 ) ; if ( VAR_60 <= 0 ) { VAR_61 -> VAR_62 . VAR_63 = VAR_64 ; return VAR_65 ; } VAR_66 += VAR_67 ; } if ! METHOD_9 ( VAR_68 ) && VAR_69 if ( VAR_70 == VAR_71 && VAR_72 >= 4 * ( VAR_73 = VAR_74 -> VAR_75 ) && VAR_76 -> VAR_77 == VAR_78 && VAR_79 -> VAR_80 == VAR_81 && <S2SV_StartBug> ! METHOD_10 ( VAR_82 ) && METHOD_11 ( VAR_83 ) && <S2SV_EndBug> METHOD_12 ( METHOD_13 ( VAR_84 -> VAR_85 ) ) & VAR_86 ) { unsigned TYPE_14 VAR_87 [ 13 ] ; TYPE_15 VAR_88 ; TYPE_16 VAR_89 ; if ( ( VAR_90 & 0xfff ) == 0 ) VAR_91 -= 512 ; if ( VAR_92 == 0 || VAR_93 -> VAR_94 == VAR_95 ) { METHOD_14 ( VAR_96 ) ; VAR_97 = METHOD_15 ( VAR_98 -> VAR_99 , VAR_100 , VAR_101 , VAR_102 ) ; if ( VAR_103 >= 8 * VAR_104 ) VAR_105 *= 8 ; else VAR_106 *= 4 ; if ( ! METHOD_16 ( VAR_107 , 1 , VAR_108 ) ) { METHOD_17 ( VAR_109 , VAR_110 ) ; return - 1 ; } } else if ( VAR_111 == VAR_112 ) { METHOD_18 ( VAR_113 ) ; return VAR_114 ; } VAR_115 = ( VAR_116 - VAR_117 ) ; for ( ; ; ) { if ( VAR_118 < 4 * VAR_119 ) { METHOD_19 ( VAR_120 ) ; break ; } if ( VAR_121 -> VAR_122 -> VAR_123 ) { VAR_124 = VAR_125 -> VAR_126 -> METHOD_20 ( VAR_127 ) ; if ( VAR_128 <= 0 ) { VAR_129 -> VAR_130 . VAR_131 = VAR_132 ; return VAR_133 ; } } if ( VAR_134 >= 8 * VAR_135 ) VAR_136 = VAR_137 * ( VAR_138 . VAR_139 = 8 ) ; else VAR_140 = VAR_141 * ( VAR_142 . VAR_143 = 4 ) ; METHOD_21 ( VAR_144 , VAR_145 -> VAR_146 . VAR_147 , 8 ) ; VAR_148 [ 8 ] = VAR_149 ; VAR_150 [ 9 ] = ( unsigned TYPE_17 ) ( VAR_151 -> VAR_152 >> 8 ) ; VAR_153 [ 10 ] = ( unsigned TYPE_18 ) ( VAR_154 -> VAR_155 ) ; VAR_156 [ 11 ] = 0 ; VAR_157 [ 12 ] = 0 ; VAR_158 . VAR_159 = VAR_160 ; VAR_161 . VAR_162 = VAR_163 ; VAR_164 . VAR_165 = VAR_166 ; VAR_167 = METHOD_22 ( VAR_168 -> VAR_169 , VAR_170 , sizeof ( VAR_171 ) , & VAR_172 ) ; if ( VAR_173 <= 0 || VAR_174 > ( TYPE_19 ) VAR_175 -> VAR_176 ) { METHOD_23 ( VAR_177 ) ; break ; } VAR_178 . VAR_179 = VAR_180 -> VAR_181 ; VAR_182 . VAR_183 = & VAR_184 [ VAR_185 ] ; VAR_186 . VAR_187 = VAR_188 ; if ( METHOD_24 ( VAR_189 -> VAR_190 , VAR_191 , sizeof ( VAR_192 ) , & VAR_193 ) <= 0 ) return - 1 ; VAR_194 -> VAR_195 . VAR_196 [ 7 ] += VAR_197 . VAR_198 ; if ( VAR_199 -> VAR_200 . VAR_201 [ 7 ] < VAR_202 . VAR_203 ) { TYPE_20 VAR_204 = 6 ; while ( VAR_205 >= 0 && ( ++ VAR_206 -> VAR_207 . VAR_208 [ VAR_209 -- ] ) == 0 ) ; } VAR_210 -> VAR_211 = 0 ; VAR_212 -> VAR_213 = VAR_214 ; VAR_215 -> VAR_216 . VAR_217 = VAR_218 ; VAR_219 -> VAR_220 . VAR_221 = & VAR_222 [ VAR_223 ] ; VAR_224 -> VAR_225 . VAR_226 = VAR_227 ; VAR_228 -> VAR_229 . VAR_230 = VAR_231 ; VAR_232 = METHOD_25 ( VAR_233 , VAR_234 , & VAR_235 [ VAR_236 ] , VAR_237 ) ; if ( VAR_238 <= 0 ) { if ( VAR_239 < 0 && ( ! VAR_240 -> VAR_241 || ! METHOD_26 ( VAR_242 -> VAR_243 ) ) ) { METHOD_27 ( VAR_244 ) ; } VAR_245 -> VAR_246 . VAR_247 = VAR_248 ; return VAR_249 ; } if ( VAR_250 == ( TYPE_21 ) VAR_251 ) { METHOD_28 ( VAR_252 ) ; return VAR_253 + VAR_254 ; } VAR_255 -= VAR_256 ; VAR_257 += VAR_258 ; } } else if ( VAR_259 == VAR_260 ) { if ( VAR_261 -> VAR_262 & VAR_263 && ! METHOD_29 ( VAR_264 ) ) METHOD_30 ( VAR_265 ) ; return VAR_266 ; } VAR_267 = ( VAR_268 - VAR_269 ) ; VAR_270 = VAR_271 -> VAR_272 ; VAR_273 = VAR_274 -> VAR_275 ; if ( VAR_276 > VAR_277 ) { METHOD_31 ( VAR_278 , VAR_279 ) ; return - 1 ; } if ( VAR_280 == 0 || VAR_281 -> VAR_282 == VAR_283 || ! ( METHOD_32 ( METHOD_33 ( VAR_284 -> VAR_285 ) ) & VAR_286 ) || ! METHOD_34 ( VAR_287 ) ) VAR_288 = 1 ; if ( VAR_289 -> VAR_290 == 0 || VAR_291 > VAR_292 -> VAR_293 || VAR_294 == 0 ) { METHOD_35 ( VAR_295 , VAR_296 ) ; return - 1 ; } for ( ; ; ) { unsigned TYPE_22 VAR_297 [ VAR_298 ] , VAR_299 , VAR_300 ; unsigned TYPE_23 VAR_301 , VAR_302 ; if ( VAR_303 == 0 ) VAR_304 = 1 ; else VAR_305 = ( ( VAR_306 - 1 ) / VAR_307 ) + 1 ; if ( VAR_308 > VAR_309 ) VAR_310 = VAR_311 ; if ( VAR_312 / VAR_313 >= VAR_314 -> VAR_315 ) { for ( VAR_316 = 0 ; VAR_317 < VAR_318 ; VAR_319 ++ ) { VAR_320 [ VAR_321 ] = VAR_322 -> VAR_323 ; } } else { VAR_324 = VAR_325 / VAR_326 ; VAR_327 = VAR_328 % VAR_329 ; for ( VAR_330 = 0 ; VAR_331 < VAR_332 ; VAR_333 ++ ) { VAR_334 [ VAR_335 ] = VAR_336 ; if ( VAR_337 < VAR_338 ) VAR_339 [ VAR_340 ] ++ ; } } VAR_341 = METHOD_36 ( VAR_342 , VAR_343 , & ( VAR_344 [ VAR_345 ] ) , VAR_346 , VAR_347 , 0 ) ; if ( VAR_348 <= 0 ) { VAR_349 -> VAR_350 . VAR_351 = VAR_352 ; return VAR_353 ; } if ( ( VAR_354 == ( TYPE_24 ) VAR_355 ) || ( VAR_356 == VAR_357 && ( VAR_358 -> VAR_359 & VAR_360 ) ) ) { VAR_361 -> VAR_362 -> VAR_363 = 0 ; if ( ( VAR_364 == ( TYPE_25 ) VAR_365 ) && VAR_366 -> VAR_367 & VAR_368 && ! METHOD_37 ( VAR_369 ) ) METHOD_38 ( VAR_370 ) ; return VAR_371 + VAR_372 ; } VAR_373 -= VAR_374 ; VAR_375 += VAR_376 ; } }",<S2SV_ModStart> VAR_283 && ! METHOD_39 <S2SV_ModEnd> ( VAR_370 ),"CWE-20 int ssl3_write_bytes ( SSL * s , int type , const void * buf_ , int len ) { const unsigned char * buf = buf_ ; int tot ; unsigned int n , split_send_fragment , maxpipes ;  if ! d ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK unsigned int max_send_fragment , nw ; unsigned int u_len = ( unsigned int ) len ;   SSL3_BUFFER * wb = & s -> rlayer . wbuf [ 0 ] ; int i ; if ( len < 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_NEGATIVE_LENGTH ) ; return - 1 ; } s -> rwstate = SSL_NOTHING ; tot = s -> rlayer . wnum ; if ( ( unsigned int ) len < s -> rlayer . wnum ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_BAD_LENGTH ) ; return - 1 ; } s -> rlayer . wnum = 0 ; if ( SSL_in_init ( s ) && ! ossl_statem_get_in_handshake ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return - 1 ; } } if ( wb -> left != 0 ) { i = ssl3_write_pending ( s , type , & buf [ tot ] , s -> rlayer . wpend_tot ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } tot += i ; }  if ! d ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && <S2SV_StartBug> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <S2SV_EndBug> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { unsigned char aad [ 13 ] ; EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param ; int packlen ; if ( ( max_send_fragment & 0xfff ) == 0 ) max_send_fragment -= 512 ; if ( tot == 0 || wb -> buf == NULL ) { ssl3_release_write_buffer ( s ) ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE , max_send_fragment , NULL ) ; if ( u_len >= 8 * max_send_fragment ) packlen *= 8 ; else packlen *= 4 ; if ( ! ssl3_setup_write_buffer ( s , 1 , packlen ) ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_MALLOC_FAILURE ) ; return - 1 ; } } else if ( tot == len ) { ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; for ( ; ; ) { if ( n < 4 * max_send_fragment ) { ssl3_release_write_buffer ( s ) ; break ; } if ( s -> s3 -> alert_dispatch ) { i = s -> method -> ssl_dispatch_alert ( s ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } } if ( n >= 8 * max_send_fragment ) nw = max_send_fragment * ( mb_param . interleave = 8 ) ; else nw = max_send_fragment * ( mb_param . interleave = 4 ) ; memcpy ( aad , s -> rlayer . write_sequence , 8 ) ; aad [ 8 ] = type ; aad [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ; aad [ 10 ] = ( unsigned char ) ( s -> version ) ; aad [ 11 ] = 0 ; aad [ 12 ] = 0 ; mb_param . out = NULL ; mb_param . inp = aad ; mb_param . len = nw ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_AAD , sizeof ( mb_param ) , & mb_param ) ; if ( packlen <= 0 || packlen > ( int ) wb -> len ) { ssl3_release_write_buffer ( s ) ; break ; } mb_param . out = wb -> buf ; mb_param . inp = & buf [ tot ] ; mb_param . len = nw ; if ( EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT , sizeof ( mb_param ) , & mb_param ) <= 0 ) return - 1 ; s -> rlayer . write_sequence [ 7 ] += mb_param . interleave ; if ( s -> rlayer . write_sequence [ 7 ] < mb_param . interleave ) { int j = 6 ; while ( j >= 0 && ( ++ s -> rlayer . write_sequence [ j -- ] ) == 0 ) ; } wb -> offset = 0 ; wb -> left = packlen ; s -> rlayer . wpend_tot = nw ; s -> rlayer . wpend_buf = & buf [ tot ] ; s -> rlayer . wpend_type = type ; s -> rlayer . wpend_ret = nw ; i = ssl3_write_pending ( s , type , & buf [ tot ] , nw ) ; if ( i <= 0 ) { if ( i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) ) ) { ssl3_release_write_buffer ( s ) ; } s -> rlayer . wnum = tot ; return i ; } if ( i == ( int ) n ) { ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } } else   if ( tot == len ) { if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; split_send_fragment = s -> split_send_fragment ; maxpipes = s -> max_pipelines ; if ( maxpipes > SSL_MAX_PIPELINES ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( maxpipes == 0 || s -> enc_write_ctx == NULL || ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) || ! SSL_USE_EXPLICIT_IV ( s ) ) maxpipes = 1 ; if ( s -> max_send_fragment == 0 || split_send_fragment > s -> max_send_fragment || split_send_fragment == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } for ( ; ; ) { unsigned int pipelens [ SSL_MAX_PIPELINES ] , tmppipelen , remain ; unsigned int numpipes , j ; if ( n == 0 ) numpipes = 1 ; else numpipes = ( ( n - 1 ) / split_send_fragment ) + 1 ; if ( numpipes > maxpipes ) numpipes = maxpipes ; if ( n / numpipes >= s -> max_send_fragment ) { for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = s -> max_send_fragment ; } } else { tmppipelen = n / numpipes ; remain = n % numpipes ; for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = tmppipelen ; if ( j < remain ) pipelens [ j ] ++ ; } } i = do_ssl3_write ( s , type , & ( buf [ tot ] ) , pipelens , numpipes , 0 ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } if ( ( i == ( int ) n ) || ( type == SSL3_RT_APPLICATION_DATA && ( s -> mode & SSL_MODE_ENABLE_PARTIAL_WRITE ) ) ) { s -> s3 -> empty_fragment_done = 0 ; if ( ( i == ( int ) n ) && s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } }",<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )
451,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { TYPE_3 VAR_4 = VAR_5 & VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 = STRUCT_OR_UNION_5 -> VAR_8 ; struct STRUCT_OR_UNION_6 * VAR_9 = METHOD_1 ( VAR_10 ) ; unsigned TYPE_4 VAR_11 , VAR_12 ; struct STRUCT_OR_UNION_7 * VAR_13 , * VAR_14 , * VAR_15 ; TYPE_5 VAR_16 = 0 ; <S2SV_StartBug> TYPE_6 VAR_17 ; <S2SV_EndBug> VAR_18 -> VAR_19 = 0 ; if ( ( VAR_20 -> VAR_21 == VAR_22 ) && METHOD_2 ( & VAR_23 -> VAR_24 ) && METHOD_3 ( & VAR_25 -> VAR_26 ) && METHOD_4 ( & VAR_27 -> VAR_28 . VAR_29 ) ) return 0 ; if ( VAR_30 & ( VAR_31 ) ) return - VAR_32 ; VAR_33 = METHOD_5 ( VAR_34 , VAR_35 , VAR_36 , & VAR_37 ) ; if ( ! VAR_38 ) { if ( VAR_39 -> VAR_40 & VAR_41 ) return 0 ; return VAR_42 ; } VAR_43 = METHOD_6 ( VAR_44 ) -> VAR_45 ; VAR_46 = VAR_47 -> VAR_48 - VAR_49 ; VAR_50 = min_t ( unsigned TYPE_7 , VAR_51 , VAR_52 ) ; if ( ! VAR_53 ) VAR_54 -> VAR_55 = VAR_56 -> VAR_57 | VAR_58 ; VAR_59 = VAR_60 ; if ( METHOD_7 ( VAR_61 , VAR_62 , VAR_63 -> VAR_64 , VAR_65 ) ) { if ( ! ( VAR_66 & VAR_67 ) ) METHOD_8 ( & VAR_68 -> VAR_69 , VAR_70 ) ; return - VAR_71 ; } if ( VAR_72 -> VAR_73 == VAR_74 ) { if ( VAR_75 < VAR_76 ) VAR_77 -> VAR_78 |= VAR_79 ; VAR_80 -> VAR_81 |= VAR_82 ; } VAR_83 = METHOD_9 ( VAR_84 , VAR_85 , VAR_86 , sizeof ( METHOD_10 ( VAR_87 ) -> VAR_88 ) , ( TYPE_8 * ) & METHOD_11 ( VAR_89 ) -> VAR_90 ) ; if ( VAR_91 ) { if ( ! ( VAR_92 & VAR_93 ) ) METHOD_12 ( & VAR_94 -> VAR_95 , VAR_96 ) ; return VAR_97 ; } if ( ! ( VAR_98 & VAR_99 ) ) { if ( VAR_100 -> VAR_101 == VAR_102 ) { if ( VAR_103 < VAR_104 ) { METHOD_13 ( VAR_105 ) -> VAR_106 = VAR_107 + VAR_108 ; goto VAR_109 ; } } METHOD_14 ( VAR_110 ) ; if ( VAR_111 -> VAR_112 == VAR_113 ) { METHOD_15 ( & VAR_114 -> VAR_115 ) ; if ( METHOD_16 ( & VAR_116 -> VAR_117 ) > VAR_118 -> VAR_119 ) { METHOD_17 ( 1 ) ; METHOD_18 ( VAR_120 ) ; return - VAR_121 ; } } METHOD_19 ( & VAR_122 -> VAR_123 . VAR_124 ) ; VAR_125 = METHOD_20 ( & VAR_126 -> VAR_127 ) ; while ( VAR_128 ) { METHOD_21 ( VAR_129 ) -> VAR_130 = 0 ; if ( METHOD_22 ( VAR_131 , VAR_132 ) ) { METHOD_23 ( & VAR_133 -> VAR_134 , VAR_135 ) ; break ; } else { VAR_136 = METHOD_24 ( & VAR_137 -> VAR_138 ) ; } } if ( METHOD_25 ( & VAR_139 -> VAR_140 ) ) { if ( ! METHOD_26 ( & VAR_141 -> VAR_142 . VAR_143 ) ) METHOD_27 ( VAR_144 ) ; if ( METHOD_28 ( & VAR_145 -> VAR_146 ) >= VAR_147 -> VAR_148 / 2 ) { VAR_149 = METHOD_29 ( VAR_150 , VAR_151 ) ; if ( VAR_152 ) { VAR_153 -> VAR_154 = VAR_155 ; VAR_156 -> METHOD_30 ( VAR_157 ) ; } } } METHOD_31 ( & VAR_158 -> VAR_159 . VAR_160 ) ; } VAR_161 : if ( VAR_162 -> VAR_163 == VAR_164 && ( VAR_165 & VAR_166 ) ) VAR_167 = VAR_168 ; return VAR_169 ; }",<S2SV_ModStart> ; TYPE_6 VAR_130 <S2SV_ModEnd> ; if (,"CWE-20 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; <S2SV_StartBug> u32 offset ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }",<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
452,CWE-476 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) <S2SV_StartBug> { <S2SV_EndBug> if ( VAR_1 -> VAR_2 == 0 ) { METHOD_1 ( VAR_3 ) ; VAR_4 -> VAR_5 = VAR_6 -> VAR_7 -> VAR_8 ; METHOD_2 ( VAR_9 ) ; } else { TYPE_2 VAR_10 = VAR_11 -> VAR_12 ; VAR_13 -> VAR_14 = VAR_15 -> VAR_16 -> VAR_17 ; METHOD_3 ( VAR_18 ) ; } if METHOD_4 ( VAR_19 ) || METHOD_5 ( VAR_20 ) if ( ! VAR_21 -> VAR_22 ) while ( VAR_23 -> VAR_24 && VAR_25 -> VAR_26 -> VAR_27 < 0 ) VAR_28 -> VAR_29 = VAR_30 -> VAR_31 -> VAR_32 ; if ( VAR_33 -> VAR_34 ) METHOD_6 ( VAR_35 -> VAR_36 ) ; return VAR_37 -> VAR_38 ; },<S2SV_ModStart> VAR_37 ) { if ( ! VAR_37 ) return VAR_39 ;,CWE-476 rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) <S2SV_StartBug> { <S2SV_EndBug> if ( i -> next == 0 ) { LOCK ( rfbClientListMutex ) ; i -> next = i -> screen -> clientHead ; UNLOCK ( rfbClientListMutex ) ; } else { rfbClientPtr cl = i -> next ; i -> next = i -> next -> next ; rfbDecrClientRef ( cl ) ; }  if d ( LIBVNCSERVER_HAVE_LIBPTHREAD ) || d ( LIBVNCSERVER_HAVE_WIN32THREADS ) if ( ! i -> closedToo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ; if ( i -> next ) rfbIncrClientRef ( i -> next ) ;   return i -> next ; },<S2SV_ModStart> i ) { if ( ! i ) return NULL ;
453,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 = VAR_5 ; const TYPE_6 * VAR_6 = VAR_7 -> VAR_8 ; TYPE_7 VAR_9 , VAR_10 , VAR_11 = VAR_12 -> VAR_13 ; TYPE_8 VAR_14 , VAR_15 , VAR_16 , VAR_17 ; TYPE_9 VAR_18 , VAR_19 , VAR_20 , VAR_21 , VAR_22 ; TYPE_10 VAR_23 , VAR_24 , VAR_25 , VAR_26 , VAR_27 ; TYPE_11 VAR_28 [ 3 ] ; TYPE_12 * VAR_29 ; TYPE_13 VAR_30 ; if ( VAR_31 < VAR_32 ) return VAR_33 ; METHOD_1 ( & VAR_34 , VAR_35 , VAR_36 ) ; VAR_37 = METHOD_2 ( & VAR_38 ) ; VAR_39 = METHOD_3 ( & VAR_40 ) ; if ( VAR_41 != VAR_42 ) { METHOD_4 ( VAR_43 , VAR_44 , ""unsupported<S2SV_blank>version\\n"" ) ; return VAR_45 ; } if ( VAR_46 < VAR_47 || VAR_48 < VAR_49 ) { METHOD_5 ( VAR_50 , VAR_51 , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return VAR_52 ; } VAR_53 = METHOD_6 ( & VAR_54 ) ; VAR_55 = METHOD_7 ( & VAR_56 ) ; VAR_57 -> VAR_58 = METHOD_8 ( & VAR_59 ) ; VAR_60 -> VAR_61 = METHOD_9 ( & VAR_62 ) ; VAR_63 = METHOD_10 ( & VAR_64 ) ; VAR_65 = METHOD_11 ( & VAR_66 ) ; VAR_67 = METHOD_12 ( & VAR_68 ) ; VAR_69 = METHOD_13 ( & VAR_70 ) ; VAR_71 = METHOD_14 ( & VAR_72 ) ; VAR_73 = METHOD_15 ( & VAR_74 ) ; VAR_75 = METHOD_16 ( & VAR_76 ) ; VAR_77 = METHOD_17 ( & VAR_78 ) ; VAR_79 [ 0 ] = METHOD_18 ( & VAR_80 ) ; VAR_81 [ 1 ] = METHOD_19 ( & VAR_82 ) ; VAR_83 [ 2 ] = METHOD_20 ( & VAR_84 ) ; METHOD_21 ( & VAR_85 , 8 ) ; VAR_86 = METHOD_22 ( & VAR_87 ) ; METHOD_23 ( & VAR_88 , VAR_89 - ( VAR_90 - 20 ) ) ; METHOD_24 ( VAR_91 , VAR_92 , ""pixformat<S2SV_blank>%"" VAR_93 "",<S2SV_blank>pixdepth<S2SV_blank>%"" VAR_94 "",<S2SV_blank>bunit<S2SV_blank>%"" VAR_95 "",<S2SV_blank>bitorder<S2SV_blank>%"" VAR_96 "",<S2SV_blank>bpad<S2SV_blank>%"" VAR_97 ""\\n"" , VAR_98 , VAR_99 , VAR_100 , VAR_101 , VAR_102 ) ; METHOD_25 ( VAR_103 , VAR_104 , ""vclass<S2SV_blank>%"" VAR_105 "",<S2SV_blank>ncolors<S2SV_blank>%"" VAR_106 "",<S2SV_blank>bpp<S2SV_blank>%"" VAR_107 "",<S2SV_blank>be<S2SV_blank>%"" VAR_108 "",<S2SV_blank>lsize<S2SV_blank>%"" VAR_109 "",<S2SV_blank>xoffset<S2SV_blank>%"" VAR_110 ""\\n"" , VAR_111 , VAR_112 , VAR_113 , VAR_114 , VAR_115 , VAR_116 ) ; METHOD_26 ( VAR_117 , VAR_118 , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , VAR_119 [ 0 ] , VAR_120 [ 1 ] , VAR_121 [ 2 ] ) ; if ( VAR_122 > VAR_123 ) { METHOD_27 ( VAR_124 , VAR_125 , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return VAR_126 ; } if ( VAR_127 == 0 || VAR_128 > 32 ) { METHOD_28 ( VAR_129 , VAR_130 , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return VAR_131 ; } if ( VAR_132 ) { avpriv_request_sample ( VAR_133 , ""xoffset<S2SV_blank>%"" VAR_134 """" , VAR_135 ) ; return VAR_136 ; } if ( VAR_137 > 1 ) { METHOD_29 ( VAR_138 , VAR_139 , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return VAR_140 ; } if ( VAR_141 > 1 ) { METHOD_30 ( VAR_142 , VAR_143 , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return VAR_144 ; } if ( VAR_145 != 8 && VAR_146 != 16 && VAR_147 != 32 ) { METHOD_31 ( VAR_148 , VAR_149 , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return VAR_150 ; } if ( VAR_151 != 8 && VAR_152 != 16 && VAR_153 != 32 ) { METHOD_32 ( VAR_154 , VAR_155 , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return VAR_156 ; } if ( VAR_157 == 0 || VAR_158 > 32 ) { METHOD_33 ( VAR_159 , VAR_160 , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return VAR_161 ; } if ( VAR_162 > 256 ) { METHOD_34 ( VAR_163 , VAR_164 , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return VAR_165 ; } if ( ( VAR_166 = METHOD_35 ( VAR_167 -> VAR_168 , VAR_169 -> VAR_170 , 0 , VAR_171 ) ) < 0 ) return VAR_172 ; VAR_173 = METHOD_36 ( VAR_174 -> VAR_175 * VAR_176 , VAR_177 ) / 8 ; if ( VAR_178 < VAR_179 ) { METHOD_37 ( VAR_180 , VAR_181 , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return VAR_182 ; } if ( METHOD_38 ( & VAR_183 ) < VAR_184 * VAR_185 + ( TYPE_14 ) VAR_186 -> VAR_187 * VAR_188 ) { METHOD_39 ( VAR_189 , VAR_190 , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return VAR_191 ; } if ( VAR_192 != VAR_193 ) { avpriv_report_missing_feature ( VAR_194 , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" VAR_195 , VAR_196 ) ; return VAR_197 ; } VAR_198 -> VAR_199 = VAR_200 ; switch ( VAR_201 ) { case VAR_202 : case VAR_203 : if ( VAR_204 != 1 && VAR_205 != 8 ) return VAR_206 ; <S2SV_StartBug> if ( VAR_207 == 1 ) { <S2SV_EndBug> VAR_208 -> VAR_209 = VAR_210 ; <S2SV_StartBug> } else if ( VAR_211 == 8 ) { <S2SV_EndBug> VAR_212 -> VAR_213 = VAR_214 ; } break ; case VAR_215 : case VAR_216 : if ( VAR_217 == 8 ) VAR_218 -> VAR_219 = VAR_220 ; break ; case VAR_221 : case VAR_222 : if ( VAR_223 != 16 && VAR_224 != 24 && VAR_225 != 32 ) return VAR_226 ; if ( VAR_227 == 16 && VAR_228 == 15 ) { if ( VAR_229 [ 0 ] == 0x7C00 && VAR_230 [ 1 ] == 0x3E0 && VAR_231 [ 2 ] == 0x1F ) VAR_232 -> VAR_233 = VAR_234 ? VAR_235 : VAR_236 ; else if ( VAR_237 [ 0 ] == 0x1F && VAR_238 [ 1 ] == 0x3E0 && VAR_239 [ 2 ] == 0x7C00 ) VAR_240 -> VAR_241 = VAR_242 ? VAR_243 : VAR_244 ; } else if ( VAR_245 == 16 && VAR_246 == 16 ) { if ( VAR_247 [ 0 ] == 0xF800 && VAR_248 [ 1 ] == 0x7E0 && VAR_249 [ 2 ] == 0x1F ) VAR_250 -> VAR_251 = VAR_252 ? VAR_253 : VAR_254 ; else if ( VAR_255 [ 0 ] == 0x1F && VAR_256 [ 1 ] == 0x7E0 && VAR_257 [ 2 ] == 0xF800 ) VAR_258 -> VAR_259 = VAR_260 ? VAR_261 : VAR_262 ; } else if ( VAR_263 == 24 ) { if ( VAR_264 [ 0 ] == 0xFF0000 && VAR_265 [ 1 ] == 0xFF00 && VAR_266 [ 2 ] == 0xFF ) VAR_267 -> VAR_268 = VAR_269 ? VAR_270 : VAR_271 ; else if ( VAR_272 [ 0 ] == 0xFF && VAR_273 [ 1 ] == 0xFF00 && VAR_274 [ 2 ] == 0xFF0000 ) VAR_275 -> VAR_276 = VAR_277 ? VAR_278 : VAR_279 ; } else if ( VAR_280 == 32 ) { if ( VAR_281 [ 0 ] == 0xFF0000 && VAR_282 [ 1 ] == 0xFF00 && VAR_283 [ 2 ] == 0xFF ) VAR_284 -> VAR_285 = VAR_286 ? VAR_287 : VAR_288 ; else if ( VAR_289 [ 0 ] == 0xFF && VAR_290 [ 1 ] == 0xFF00 && VAR_291 [ 2 ] == 0xFF0000 ) VAR_292 -> VAR_293 = VAR_294 ? VAR_295 : VAR_296 ; } METHOD_40 ( & VAR_297 , VAR_298 * VAR_299 ) ; break ; default : METHOD_41 ( VAR_300 , VAR_301 , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return VAR_302 ; } if ( VAR_303 -> VAR_304 == VAR_305 ) { avpriv_request_sample ( VAR_306 , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" VAR_307 "",<S2SV_blank>pixdepth<S2SV_blank>%"" VAR_308 "",<S2SV_blank>vclass<S2SV_blank>%"" VAR_309 """" , VAR_310 , VAR_311 , VAR_312 ) ; return VAR_313 ; } if ( ( VAR_314 = METHOD_42 ( VAR_315 , VAR_316 , 0 ) ) < 0 ) return VAR_317 ; VAR_318 -> VAR_319 = 1 ; VAR_320 -> VAR_321 = VAR_322 ; if ( VAR_323 -> VAR_324 == VAR_325 ) { TYPE_15 * VAR_326 = ( TYPE_16 * ) VAR_327 -> VAR_328 [ 1 ] ; TYPE_17 VAR_329 , VAR_330 , VAR_331 ; for ( VAR_332 = 0 ; VAR_333 < VAR_334 ; VAR_335 ++ ) { METHOD_43 ( & VAR_336 , 4 ) ; VAR_337 = METHOD_44 ( & VAR_338 ) ; METHOD_45 ( & VAR_339 , 1 ) ; VAR_340 = METHOD_46 ( & VAR_341 ) ; METHOD_47 ( & VAR_342 , 1 ) ; VAR_343 = METHOD_48 ( & VAR_344 ) ; METHOD_49 ( & VAR_345 , 3 ) ; VAR_346 [ VAR_347 ] = VAR_348 << 16 | VAR_349 << 8 | VAR_350 ; } } VAR_351 = VAR_352 -> VAR_353 [ 0 ] ; for ( VAR_354 = 0 ; VAR_355 < VAR_356 -> VAR_357 ; VAR_358 ++ ) { METHOD_50 ( & VAR_359 , VAR_360 , VAR_361 ) ; METHOD_51 ( & VAR_362 , VAR_363 - VAR_364 ) ; VAR_365 += VAR_366 -> VAR_367 [ 0 ] ; } * VAR_368 = 1 ; return VAR_369 ; }",<S2SV_ModStart> ; if ( VAR_310 == 1 && <S2SV_ModStart> else if ( VAR_310 == 8 &&,"CWE-119 static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported<S2SV_blank>version\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , ""pixformat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bunit<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bitorder<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpad<S2SV_blank>%"" PRIu32 ""\\n"" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , ""vclass<S2SV_blank>%"" PRIu32 "",<S2SV_blank>ncolors<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>be<S2SV_blank>%"" PRIu32 "",<S2SV_blank>lsize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>xoffset<S2SV_blank>%"" PRIu32 ""\\n"" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , ""xoffset<S2SV_blank>%"" PRIu32 """" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>vclass<S2SV_blank>%"" PRIu32 """" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }",<S2SV_ModStart> ; if ( bpp == 1 && <S2SV_ModStart> else if ( bpp == 8 &&
454,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_EndBug> TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { TYPE_6 VAR_5 , VAR_6 , VAR_7 ; if ( ! VAR_8 ) return ; VAR_9 = 0 ; VAR_10 = VAR_11 -> VAR_12 ; if ( VAR_13 && VAR_14 -> VAR_15 > 8 ) { VAR_16 = VAR_17 -> VAR_18 >> 1 ; VAR_19 &= 0xfffffff8 ; VAR_20 = METHOD_1 ( VAR_21 -> VAR_22 / 8 , 8 ) ; } VAR_23 = VAR_24 + VAR_25 ; METHOD_2 ( VAR_26 , VAR_27 ) ; <S2SV_StartBug> METHOD_3 ( VAR_28 -> VAR_29 , VAR_30 , VAR_31 , <S2SV_EndBug> VAR_32 , VAR_33 , VAR_34 ) ; }","<S2SV_ModStart> TYPE_0 METHOD_0 ( TYPE_7 * VAR_35 , <S2SV_ModStart> ; METHOD_3 ( VAR_35 <S2SV_ModEnd> , VAR_30 , <S2SV_ModStart> VAR_30 , VAR_31 -> VAR_36","CWE-119 <S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int frame_filter_level , int y_only , int partial_frame ) { int start_mi_row , end_mi_row , mi_rows_to_filter ; if ( ! frame_filter_level ) return ; start_mi_row = 0 ; mi_rows_to_filter = cm -> mi_rows ; if ( partial_frame && cm -> mi_rows > 8 ) { start_mi_row = cm -> mi_rows >> 1 ; start_mi_row &= 0xfffffff8 ; mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ; } end_mi_row = start_mi_row + mi_rows_to_filter ; vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> start_mi_row , end_mi_row , y_only ) ; }","<S2SV_ModStart> void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> ; vp9_loop_filter_rows ( frame <S2SV_ModEnd> , cm , <S2SV_ModStart> cm , xd -> plane"
455,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; VAR_8 * VAR_9 ; VAR_10 * VAR_11 ; VAR_12 * VAR_13 ; TYPE_9 * VAR_14 ; VAR_15 = METHOD_1 ( VAR_16 ) - VAR_17 ; if ( VAR_18 < sizeof ( VAR_19 ) ) { METHOD_2 ( VAR_20 . VAR_21 , 1 ) ; METHOD_3 ( VAR_22 , 1 ) ; return VAR_23 ; } VAR_24 = METHOD_4 ( VAR_25 , VAR_26 ) ; if ( VAR_27 == VAR_28 ) return VAR_29 ; TRACE_INFO ( ""UDP<S2SV_blank>datagram<S2SV_blank>received<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , VAR_30 ) ; METHOD_5 ( VAR_31 ) ; if ( VAR_32 -> VAR_33 != 0x0000 || VAR_34 -> VAR_35 == sizeof ( VAR_36 ) ) { if ( METHOD_6 ( VAR_37 -> VAR_38 , VAR_39 -> VAR_40 , VAR_41 , VAR_42 , VAR_43 ) != 0x0000 ) { METHOD_7 ( ""Wrong<S2SV_blank>UDP<S2SV_blank>header<S2SV_blank>checksum!\\r\\n"" ) ; METHOD_8 ( VAR_44 . VAR_45 , 1 ) ; METHOD_9 ( VAR_46 , 1 ) ; return VAR_47 ; } } for ( VAR_48 = 0 ; VAR_49 < VAR_50 ; VAR_51 ++ ) { VAR_52 = VAR_53 + VAR_54 ; if ( VAR_55 -> VAR_56 != VAR_57 ) continue ; if ( VAR_58 -> VAR_59 && VAR_60 -> VAR_61 != VAR_62 ) continue ; if ( VAR_63 -> VAR_64 == 0 || VAR_65 -> VAR_66 != METHOD_10 ( VAR_67 -> VAR_68 ) ) continue ; if ( VAR_69 -> VAR_70 != 0 && VAR_71 -> VAR_72 != METHOD_11 ( VAR_73 -> VAR_74 ) ) continue ; if ( VAR_75 == VAR_76 ) if ( VAR_77 -> VAR_78 == sizeof ( VAR_79 ) ) { if ( VAR_80 -> VAR_81 . VAR_82 != 0 ) { if ( VAR_83 -> VAR_84 . VAR_85 != sizeof ( VAR_86 ) ) continue ; if ( VAR_87 -> VAR_88 . VAR_89 != VAR_90 -> VAR_91 . VAR_92 ) continue ; } if ( VAR_93 -> VAR_94 . VAR_95 != 0 ) { if ( VAR_96 -> VAR_97 . VAR_98 != sizeof ( VAR_99 ) ) continue ; if ( VAR_100 -> VAR_101 . VAR_102 != VAR_103 -> VAR_104 . VAR_105 ) continue ; } } else if ( VAR_106 == VAR_107 ) if ( VAR_108 -> VAR_109 == sizeof ( VAR_110 ) ) { if ( VAR_111 -> VAR_112 . VAR_113 != 0 ) { if ( VAR_114 -> VAR_115 . VAR_116 != sizeof ( VAR_117 ) ) continue ; if ( ! METHOD_12 ( & VAR_118 -> VAR_119 . VAR_120 , & VAR_121 -> VAR_122 . VAR_123 ) ) continue ; } if ( VAR_124 -> VAR_125 . VAR_126 != 0 ) { if ( VAR_127 -> VAR_128 . VAR_129 != sizeof ( VAR_130 ) ) continue ; if ( ! METHOD_13 ( & VAR_131 -> VAR_132 . VAR_133 , & VAR_134 -> VAR_135 . VAR_136 ) ) continue ; } } else { continue ; } break ; } VAR_137 += sizeof ( VAR_138 ) ; VAR_139 -= sizeof ( VAR_140 ) ; if ( VAR_141 >= VAR_142 ) { VAR_143 = METHOD_14 ( VAR_144 , VAR_145 , VAR_146 , VAR_147 , VAR_148 , VAR_149 ) ; return VAR_150 ; } if ( VAR_151 -> VAR_152 == VAR_153 ) { VAR_154 = METHOD_15 ( sizeof ( VAR_155 ) + VAR_156 ) ; if ( VAR_157 != VAR_158 ) { VAR_159 = METHOD_16 ( VAR_160 , 0 ) ; VAR_161 -> VAR_162 = VAR_163 ; VAR_164 -> VAR_165 = VAR_166 ; } else { VAR_167 = VAR_168 ; } } else { VAR_169 = VAR_170 -> VAR_171 ; for ( VAR_172 = 1 ; VAR_173 -> VAR_174 ; VAR_175 ++ ) { VAR_176 = VAR_177 -> VAR_178 ; } if ( VAR_179 >= VAR_180 ) { METHOD_17 ( VAR_181 . VAR_182 [ VAR_183 -> VAR_184 ] . VAR_185 , 1 ) ; METHOD_18 ( VAR_186 [ VAR_187 -> VAR_188 ] . VAR_189 , 1 ) ; return VAR_190 ; } VAR_191 = METHOD_19 ( sizeof ( VAR_192 ) + VAR_193 ) ; if ( VAR_194 != VAR_195 ) { VAR_196 -> VAR_197 = METHOD_20 ( VAR_198 , 0 ) ; VAR_199 = VAR_200 -> VAR_201 ; VAR_202 -> VAR_203 = VAR_204 ; } else { VAR_205 = VAR_206 ; } } if ( VAR_207 == VAR_208 ) { METHOD_21 ( VAR_209 . VAR_210 [ VAR_211 -> VAR_212 ] . VAR_213 , 1 ) ; METHOD_22 ( VAR_214 [ VAR_215 -> VAR_216 ] . VAR_217 , 1 ) ; return VAR_218 ; } VAR_219 -> VAR_220 = VAR_221 ; <S2SV_StartBug> VAR_222 -> VAR_223 = METHOD_23 ( VAR_224 -> VAR_225 ) ; <S2SV_EndBug> if ( VAR_226 == VAR_227 ) if ( VAR_228 -> VAR_229 == sizeof ( VAR_230 ) ) { VAR_231 -> VAR_232 . VAR_233 = sizeof ( VAR_234 ) ; VAR_235 -> VAR_236 . VAR_237 = VAR_238 -> VAR_239 . VAR_240 ; VAR_241 -> VAR_242 . VAR_243 = sizeof ( VAR_244 ) ; VAR_245 -> VAR_246 . VAR_247 = VAR_248 -> VAR_249 . VAR_250 ; } if ( VAR_251 == VAR_252 ) if ( VAR_253 -> VAR_254 == sizeof ( VAR_255 ) ) { VAR_256 -> VAR_257 . VAR_258 = sizeof ( VAR_259 ) ; VAR_260 -> VAR_261 . VAR_262 = VAR_263 -> VAR_264 . VAR_265 ; VAR_266 -> VAR_267 . VAR_268 = sizeof ( VAR_269 ) ; VAR_270 -> VAR_271 . VAR_272 = VAR_273 -> VAR_274 . VAR_275 ; } VAR_276 -> VAR_277 = sizeof ( VAR_278 ) ; METHOD_24 ( VAR_279 -> VAR_280 , VAR_281 -> VAR_282 , VAR_283 , VAR_284 , VAR_285 ) ; VAR_286 -> VAR_287 = * VAR_288 ; METHOD_25 ( VAR_289 ) ; METHOD_26 ( VAR_290 . VAR_291 , 1 ) ; METHOD_27 ( VAR_292 , 1 ) ; METHOD_28 ( VAR_293 , 1 ) ; return VAR_294 ; }",<S2SV_ModStart> ; VAR_286 -> VAR_215 = VAR_215 ; VAR_286 ->,"CWE-20 error_t udpProcessDatagram ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { error_t error ; uint_t i ; size_t length ; UdpHeader * header ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; if ( length < sizeof ( UdpHeader ) ) { MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_INVALID_HEADER ; } header = netBufferAt ( buffer , offset ) ; if ( header == NULL ) return ERROR_FAILURE ; TRACE_INFO ( ""UDP<S2SV_blank>datagram<S2SV_blank>received<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , length ) ; udpDumpHeader ( header ) ; if ( header -> checksum != 0x0000 || pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( ipCalcUpperLayerChecksumEx ( pseudoHeader -> data , pseudoHeader -> length , buffer , offset , length ) != 0x0000 ) { TRACE_WARNING ( ""Wrong<S2SV_blank>UDP<S2SV_blank>header<S2SV_blank>checksum!\\r\\n"" ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_WRONG_CHECKSUM ; } } for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_DGRAM ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> localPort == 0 || socket -> localPort != ntohs ( header -> destPort ) ) continue ; if ( socket -> remotePort != 0 && socket -> remotePort != ntohs ( header -> srcPort ) ) continue ;  if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else    if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else   { continue ; } break ; } offset += sizeof ( UdpHeader ) ; length -= sizeof ( UdpHeader ) ; if ( i >= SOCKET_MAX_COUNT ) { error = udpInvokeRxCallback ( interface , pseudoHeader , header , buffer , offset , ancillary ) ; return error ; } if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= UDP_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = ntohs ( header -> srcPort ) ; <S2SV_EndBug>  if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; }    if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; }   queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; udpUpdateEvents ( socket ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER64 ( udpHCInDatagrams , 1 ) ; return NO_ERROR ; }",<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
456,"CWE-20 TYPE_0 METHOD_0 ( ) { VAR_0 . VAR_1 = VAR_2 ; VAR_3 . VAR_4 = VAR_5 ; VAR_6 . VAR_7 = VAR_8 ; VAR_9 . VAR_10 = - 1 ; VAR_11 . VAR_12 = - 1 ; VAR_13 . VAR_14 = VAR_15 ; VAR_16 . VAR_17 = VAR_18 ; VAR_19 . VAR_20 = VAR_21 ; VAR_22 . VAR_23 = VAR_24 ; VAR_25 . VAR_26 = 0 ; VAR_27 . VAR_28 = VAR_29 ; VAR_30 . VAR_31 = 0 ; VAR_32 . VAR_33 = METHOD_1 ( ""redis"" ) ; VAR_34 . VAR_35 = VAR_36 ; VAR_37 . VAR_38 = 1 ; VAR_39 . VAR_40 = 0 ; VAR_41 . VAR_42 = 0 ; VAR_43 . VAR_44 = VAR_45 ; VAR_46 . VAR_47 = 0 ; VAR_48 . VAR_49 = METHOD_2 ( VAR_50 ) ; VAR_51 . VAR_52 = - 1 ; VAR_53 . VAR_54 = - 1 ; VAR_55 . VAR_56 = METHOD_3 ( ""/var/run/redis.pid"" ) ; VAR_57 . VAR_58 = METHOD_4 ( ""dump.rdb"" ) ; VAR_59 . VAR_60 = METHOD_5 ( ""appendonly.aof"" ) ; VAR_61 . VAR_62 = VAR_63 ; VAR_64 . VAR_65 = 1 ; VAR_66 . VAR_67 = 1 ; VAR_68 . VAR_69 = 0 ; VAR_70 . VAR_71 = 0 ; VAR_72 . VAR_73 = 0 ; VAR_74 . VAR_75 = VAR_76 ; VAR_77 . VAR_78 = 3 ; <S2SV_StartBug> VAR_79 . VAR_80 = 0 ; <S2SV_EndBug> <S2SV_StartBug> VAR_81 . VAR_82 = METHOD_6 ( ""/tmp/redis-%p.vm"" ) ; <S2SV_EndBug> VAR_83 . VAR_84 = 256 ; VAR_85 . VAR_86 = 1024 * 1024 * 100 ; <S2SV_StartBug> VAR_87 . VAR_88 = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> VAR_89 . VAR_90 = 4 ; VAR_91 . VAR_92 = 0 ; VAR_93 . VAR_94 = VAR_95 ; VAR_96 . VAR_97 = VAR_98 ; VAR_99 . VAR_100 = VAR_101 ; VAR_102 . VAR_103 = VAR_104 ; VAR_105 . VAR_106 = VAR_107 ; VAR_108 . VAR_109 = 0 ; METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_9 ( 60 * 60 , 1 ) ; METHOD_10 ( 300 , 100 ) ; METHOD_11 ( 60 , 10000 ) ; VAR_110 . VAR_111 = 0 ; VAR_112 . VAR_113 = VAR_114 ; VAR_115 . VAR_116 = VAR_117 ; VAR_118 . VAR_119 = 6379 ; VAR_120 . VAR_121 = VAR_122 ; VAR_123 . VAR_124 = VAR_125 ; VAR_126 . VAR_127 = 1 ; VAR_128 = 0.0 ; VAR_129 = 1.0 / VAR_130 ; VAR_131 = - 1.0 / VAR_132 ; VAR_133 = VAR_134 / VAR_135 ; VAR_136 . VAR_137 = METHOD_12 ( & VAR_138 , VAR_139 ) ; METHOD_13 ( ) ; VAR_140 . VAR_141 = METHOD_14 ( ""del"" ) ; VAR_142 . VAR_143 = METHOD_15 ( ""multi"" ) ; }","<S2SV_ModStart> ; VAR_142 . VAR_144 = 0 ; VAR_142 . VAR_145 <S2SV_ModEnd> = METHOD_6 ( <S2SV_ModStart> = METHOD_6 ( ""/tmp/redis.ds"" ) ; VAR_142 . VAR_146 = 64LL <S2SV_ModEnd> * 1024 * <S2SV_ModStart> 1024 * 1024 ; VAR_142 . cache_blocked_clients <S2SV_ModEnd> = 0 ;","CWE-20 void initServerConfig ( ) { server . port = REDIS_SERVERPORT ; server . bindaddr = NULL ; server . unixsocket = NULL ; server . ipfd = - 1 ; server . sofd = - 1 ; server . dbnum = REDIS_DEFAULT_DBNUM ; server . verbosity = REDIS_VERBOSE ; server . maxidletime = REDIS_MAXIDLETIME ; server . saveparams = NULL ; server . loading = 0 ; server . logfile = NULL ; server . syslog_enabled = 0 ; server . syslog_ident = zstrdup ( ""redis"" ) ; server . syslog_facility = LOG_LOCAL0 ; server . glueoutputbuf = 1 ; server . daemonize = 0 ; server . appendonly = 0 ; server . appendfsync = APPENDFSYNC_EVERYSEC ; server . no_appendfsync_on_rewrite = 0 ; server . lastfsync = time ( NULL ) ; server . appendfd = - 1 ; server . appendseldb = - 1 ; server . pidfile = zstrdup ( ""/var/run/redis.pid"" ) ; server . dbfilename = zstrdup ( ""dump.rdb"" ) ; server . appendfilename = zstrdup ( ""appendonly.aof"" ) ; server . requirepass = NULL ; server . rdbcompression = 1 ; server . activerehashing = 1 ; server . maxclients = 0 ; server . bpop_blocked_clients = 0 ; server . maxmemory = 0 ; server . maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU ; server . maxmemory_samples = 3 ; <S2SV_StartBug> server . vm_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ; <S2SV_EndBug> server . vm_page_size = 256 ; server . vm_pages = 1024 * 1024 * 100 ; <S2SV_StartBug> server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> server . vm_max_threads = 4 ; server . vm_blocked_clients = 0 ; server . hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES ; server . hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE ; server . list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES ; server . list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE ; server . set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES ; server . shutdown_asap = 0 ; updateLRUClock ( ) ; resetServerSaveParams ( ) ; appendServerSaveParams ( 60 * 60 , 1 ) ; appendServerSaveParams ( 300 , 100 ) ; appendServerSaveParams ( 60 , 10000 ) ; server . isslave = 0 ; server . masterauth = NULL ; server . masterhost = NULL ; server . masterport = 6379 ; server . master = NULL ; server . replstate = REDIS_REPL_NONE ; server . repl_serve_stale_data = 1 ; R_Zero = 0.0 ; R_PosInf = 1.0 / R_Zero ; R_NegInf = - 1.0 / R_Zero ; R_Nan = R_Zero / R_Zero ; server . commands = dictCreate ( & commandTableDictType , NULL ) ; populateCommandTable ( ) ; server . delCommand = lookupCommandByCString ( ""del"" ) ; server . multiCommand = lookupCommandByCString ( ""multi"" ) ; }","<S2SV_ModStart> ; server . ds_enabled = 0 ; server . ds_path <S2SV_ModEnd> = zstrdup ( <S2SV_ModStart> = zstrdup ( ""/tmp/redis.ds"" ) ; server . cache_max_memory = 64LL <S2SV_ModEnd> * 1024 * <S2SV_ModStart> 1024 * 1024 ; server . cache_blocked_clients <S2SV_ModEnd> = 0 ;"
457,"CWE-401 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const unsigned TYPE_1 * VAR_1 ) { struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 = METHOD_1 ( VAR_2 ) ; const struct STRUCT_OR_UNION_3 * VAR_3 ; unsigned TYPE_2 VAR_4 ; unsigned TYPE_3 VAR_5 , VAR_6 ; VAR_7 * VAR_8 , * VAR_9 ; METHOD_2 ( STRUCT_OR_UNION_4 -> VAR_10 ) ; METHOD_3 ( STRUCT_OR_UNION_5 -> VAR_11 ) ; if ( STRUCT_OR_UNION_6 -> VAR_12 && STRUCT_OR_UNION_7 -> VAR_13 -> VAR_14 ) return METHOD_4 ( VAR_15 , VAR_16 ) ; VAR_17 = VAR_18 -> VAR_19 / 2 ; STRUCT_OR_UNION_8 -> VAR_20 = METHOD_5 ( VAR_21 + 1 , sizeof ( * STRUCT_OR_UNION_9 -> VAR_22 ) , VAR_23 ) ; if ( ! STRUCT_OR_UNION_10 -> VAR_24 ) return - VAR_25 ; STRUCT_OR_UNION_11 -> VAR_26 = METHOD_6 ( VAR_27 -> VAR_28 , 2 , VAR_29 ) ; <S2SV_StartBug> if ( ! STRUCT_OR_UNION_12 -> VAR_30 ) <S2SV_EndBug> return - VAR_31 ; <S2SV_StartBug> VAR_32 = STRUCT_OR_UNION_13 -> VAR_33 ; <S2SV_EndBug> VAR_34 = VAR_35 + VAR_36 ; METHOD_7 ( & STRUCT_OR_UNION_14 -> VAR_37 ) ; for ( VAR_38 = 0 ; VAR_39 <= VAR_40 ; VAR_41 ++ ) { STRUCT_OR_UNION_15 -> VAR_42 [ VAR_43 ] . VAR_44 = 8 ; if ( VAR_45 != VAR_46 ) STRUCT_OR_UNION_16 -> VAR_47 [ VAR_48 ] . VAR_49 = 1 ; STRUCT_OR_UNION_17 -> VAR_50 [ VAR_51 ] . VAR_52 = 2 ; STRUCT_OR_UNION_18 -> VAR_53 [ VAR_54 ] . VAR_55 = STRUCT_OR_UNION_19 -> VAR_56 -> VAR_57 ; if ( VAR_58 < VAR_59 ) STRUCT_OR_UNION_20 -> VAR_60 [ VAR_61 ] . VAR_62 = & VAR_63 [ VAR_64 ] ; if ( VAR_65 >= 1 ) STRUCT_OR_UNION_21 -> VAR_66 [ VAR_67 ] . VAR_68 = & VAR_69 [ VAR_70 - 1 ] ; METHOD_8 ( & STRUCT_OR_UNION_22 -> VAR_71 [ VAR_72 ] , & STRUCT_OR_UNION_23 -> VAR_73 ) ; } VAR_74 = VAR_75 -> VAR_76 ; for ( VAR_77 = 0 ; VAR_78 < VAR_79 -> VAR_80 ; VAR_81 ++ , VAR_82 ++ ) { if ( ! METHOD_9 ( VAR_83 -> VAR_84 , VAR_85 ) ) continue ; if ( VAR_86 -> VAR_87 . VAR_88 == 32 ) * VAR_89 ++ = METHOD_10 ( ( VAR_90 -> VAR_91 + 2 ) << 8 ) ; * VAR_92 ++ = METHOD_11 ( VAR_93 -> VAR_94 << 8 ) ; } return 0 ; }",<S2SV_ModStart> -> VAR_33 ) { METHOD_3 ( STRUCT_OR_UNION_23 -> VAR_71 ) ; STRUCT_OR_UNION_23 -> VAR_71 = VAR_95 ; <S2SV_ModStart> - VAR_31 ; },"CWE-401 int adis_update_scan_mode ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; const struct iio_chan_spec * chan ; unsigned int scan_count ; unsigned int i , j ; __be16 * tx , * rx ; kfree ( adis -> xfer ) ; kfree ( adis -> buffer ) ; if ( adis -> burst && adis -> burst -> en ) return adis_update_scan_mode_burst ( indio_dev , scan_mask ) ; scan_count = indio_dev -> scan_bytes / 2 ; adis -> xfer = kcalloc ( scan_count + 1 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kcalloc ( indio_dev -> scan_bytes , 2 , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> rx = adis -> buffer ; <S2SV_EndBug> tx = rx + scan_count ; spi_message_init ( & adis -> msg ) ; for ( j = 0 ; j <= scan_count ; j ++ ) { adis -> xfer [ j ] . bits_per_word = 8 ; if ( j != scan_count ) adis -> xfer [ j ] . cs_change = 1 ; adis -> xfer [ j ] . len = 2 ; adis -> xfer [ j ] . delay_usecs = adis -> data -> read_delay ; if ( j < scan_count ) adis -> xfer [ j ] . tx_buf = & tx [ j ] ; if ( j >= 1 ) adis -> xfer [ j ] . rx_buf = & rx [ j - 1 ] ; spi_message_add_tail ( & adis -> xfer [ j ] , & adis -> msg ) ; } chan = indio_dev -> channels ; for ( i = 0 ; i < indio_dev -> num_channels ; i ++ , chan ++ ) { if ( ! test_bit ( chan -> scan_index , scan_mask ) ) continue ; if ( chan -> scan_type . storagebits == 32 ) * tx ++ = cpu_to_be16 ( ( chan -> address + 2 ) << 8 ) ; * tx ++ = cpu_to_be16 ( chan -> address << 8 ) ; } return 0 ; }",<S2SV_ModStart> -> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
458,"CWE-264 <S2SV_StartBug> static VAR_0 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_1 VAR_2 ) <S2SV_EndBug> { <S2SV_StartBug> METHOD_1 ( VAR_3 , VAR_4 -> VAR_5 + VAR_6 ) ; <S2SV_EndBug> }",<S2SV_ModStart> <S2SV_null> static VAR_0 TYPE_1 <S2SV_ModEnd> METHOD_0 ( struct <S2SV_ModStart> VAR_6 ) { return,"CWE-264 <S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> { <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> }",<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct <S2SV_ModStart> rel ) { return
459,"CWE-401 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 = * VAR_6 ; if ( VAR_7 == 13 ) { TYPE_7 VAR_8 ; TYPE_8 VAR_9 = METHOD_1 ( & VAR_10 , * VAR_11 , VAR_12 , VAR_13 ) ; if ( VAR_14 != 0 ) { METHOD_2 ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> VAR_15 += VAR_16 ; <S2SV_EndBug> * VAR_17 = METHOD_3 ( VAR_18 , VAR_19 , VAR_20 , 1 ) ; } } else if ( VAR_21 == 14 ) { TYPE_9 VAR_22 = METHOD_4 ( & VAR_23 , * VAR_24 , VAR_25 , VAR_26 ) ; if ( VAR_27 != 0 ) { METHOD_5 ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> VAR_28 += 269 ; <S2SV_EndBug> * VAR_29 = METHOD_6 ( VAR_30 , VAR_31 , VAR_32 , 2 ) ; } } else if ( VAR_33 == 15 ) { METHOD_7 ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>number(15)!"" ) ; return - 1 ; } * VAR_34 = VAR_35 ; return 0 ; }","<S2SV_ModStart> } else { if ( METHOD_8 ( VAR_35 , VAR_16 , & VAR_35 ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * VAR_29 = <S2SV_ModStart> } else { if ( METHOD_8 ( VAR_35 , 269 , & VAR_35 ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * VAR_29 =","CWE-401 static int8_t parse_ext_option ( uint16_t * dst , uint8_t * * packet_data_pptr , uint8_t * packet_data_start_ptr , uint16_t packet_len , uint16_t * message_left ) { uint16_t option_number = * dst ; if ( option_number == 13 ) { uint8_t option_ext ; int8_t read_result = sn_coap_parser_read_packet_u8 ( & option_ext , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; } } else if ( option_number == 14 ) { int8_t read_result = sn_coap_parser_read_packet_u16 ( & option_number , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ; } } else if ( option_number == 15 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>number(15)!"" ) ; return - 1 ; } * dst = option_number ; return 0 ; }","<S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left = <S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left ="
460,"CWE-416 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { unsigned TYPE_1 VAR_1 ; TYPE_2 VAR_2 , VAR_3 ; METHOD_1 ( & VAR_4 -> VAR_5 , VAR_6 ) ; <S2SV_StartBug> if ( VAR_7 -> VAR_8 ) { <S2SV_EndBug> METHOD_2 ( & VAR_9 -> VAR_10 , VAR_11 ) ; return ; } VAR_12 -> VAR_13 = - VAR_14 ; <S2SV_StartBug> METHOD_3 ( & VAR_15 -> VAR_16 , VAR_17 ) ; <S2SV_EndBug> for ( VAR_18 = VAR_19 -> VAR_20 - 1 ; VAR_21 >= 0 ; -- VAR_22 ) { METHOD_4 ( VAR_23 -> VAR_24 [ VAR_25 ] ) ; VAR_26 = METHOD_5 ( VAR_27 -> VAR_28 [ VAR_29 ] ) ; if ( VAR_30 != - VAR_31 && VAR_32 != - VAR_33 && VAR_34 != - VAR_35 && VAR_36 != - VAR_37 ) METHOD_6 ( & VAR_38 -> VAR_39 -> VAR_40 , ""%s,<S2SV_blank>unlink<S2SV_blank>--><S2SV_blank>%d\\n"" , VAR_41 , VAR_42 ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> VAR_38 -> VAR_13 || VAR_38 -> VAR_43 == 0 <S2SV_ModStart> - VAR_14 ; VAR_38 -> VAR_43 ++ ; <S2SV_ModStart> ) ; } METHOD_1 ( & VAR_38 -> VAR_16 , VAR_17 ) ; VAR_38 -> VAR_43 -- ; if ( ! VAR_38 -> VAR_43 ) METHOD_7 ( & VAR_38 -> METHOD_7 ) ; METHOD_3 ( & VAR_38 -> VAR_16 , VAR_17 ) ;","CWE-416 void usb_sg_cancel ( struct usb_sg_request * io ) { unsigned long flags ; int i , retval ; spin_lock_irqsave ( & io -> lock , flags ) ; <S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; return ; } io -> status = - ECONNRESET ; <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> for ( i = io -> entries - 1 ; i >= 0 ; -- i ) { usb_block_urb ( io -> urbs [ i ] ) ; retval = usb_unlink_urb ( io -> urbs [ i ] ) ; if ( retval != - EINPROGRESS && retval != - ENODEV && retval != - EBUSY && retval != - EIDRM ) dev_warn ( & io -> dev -> dev , ""%s,<S2SV_blank>unlink<S2SV_blank>--><S2SV_blank>%d\\n"" , __func__ , retval ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> io -> status || io -> count == 0 <S2SV_ModStart> - ECONNRESET ; io -> count ++ ; <S2SV_ModStart> ) ; } spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ;"
461,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; if ( VAR_7 == VAR_8 ) VAR_9 = VAR_10 ; else if ( VAR_11 == VAR_12 ) VAR_13 = VAR_14 ; else VAR_15 = VAR_16 ; if ( VAR_17 == VAR_18 ) VAR_19 = VAR_20 ; else if ( VAR_21 == VAR_22 ) VAR_23 = VAR_24 ; else if ( VAR_25 == VAR_26 ) VAR_27 = VAR_28 ; else if ( VAR_29 == VAR_30 ) VAR_31 = VAR_32 ; else VAR_33 = VAR_34 ; if ( VAR_35 == VAR_36 || VAR_37 == VAR_38 ) return VAR_39 ; if ( VAR_40 == VAR_41 ) VAR_42 = METHOD_1 ( ) ; VAR_43 = METHOD_2 ( VAR_44 , VAR_45 ) ; if ( VAR_46 ) { if ( VAR_47 & VAR_48 ) VAR_49 = VAR_50 ; else if ( VAR_51 & VAR_52 ) VAR_53 = VAR_54 ; if ( VAR_55 & VAR_56 ) { VAR_57 = VAR_58 ; } else if ( VAR_59 & VAR_60 ) { VAR_61 = VAR_62 ; } else if ( VAR_63 & VAR_64 ) { VAR_65 = VAR_66 ; } else if ( VAR_67 & VAR_68 ) { VAR_69 = VAR_70 ; } else { TYPE_8 VAR_71 = METHOD_3 ( VAR_72 ) ; if ( VAR_73 >= 6 && ! METHOD_4 ( VAR_74 + VAR_75 - 6 , "".local"" ) ) { if ( VAR_76 == VAR_77 ) VAR_78 = VAR_79 ; } <S2SV_StartBug> else if ( VAR_80 <= 15 && ! METHOD_5 ( VAR_81 , '.' ) && VAR_82 == VAR_83 ) <S2SV_EndBug> { if ( VAR_84 == VAR_85 ) VAR_86 = VAR_87 ; } <S2SV_StartBug> else if ( ! METHOD_6 ( VAR_88 , '.' ) ) <S2SV_EndBug> { if ( VAR_89 == VAR_90 ) VAR_91 = VAR_92 ; } } if ( VAR_93 == VAR_94 ) if ( VAR_95 == VAR_96 ) { VAR_97 = METHOD_7 ( VAR_98 , VAR_99 , VAR_100 , VAR_101 ) ; } else if ( VAR_102 == VAR_103 ) if ( VAR_104 == VAR_105 ) { VAR_106 = METHOD_8 ( VAR_107 , VAR_108 , VAR_109 , VAR_110 ) ; } else if ( VAR_111 == VAR_112 && VAR_113 == VAR_114 ) if ( VAR_115 == VAR_116 ) { VAR_117 = METHOD_9 ( VAR_118 , VAR_119 , VAR_120 ) ; } else if ( VAR_121 == VAR_122 ) if ( VAR_123 == VAR_124 ) { VAR_125 = METHOD_10 ( VAR_126 , VAR_127 , VAR_128 , VAR_129 ) ; } else { VAR_130 = VAR_131 ; } } return VAR_132 ; }","<S2SV_ModStart> 15 && ! METHOD_11 <S2SV_ModEnd> ( VAR_127 , <S2SV_ModStart> if ( ! METHOD_11 <S2SV_ModEnd> ( VAR_127 ,","CWE-20 error_t getHostByName ( NetInterface * interface , const char_t * name , IpAddr * ipAddr , uint_t flags ) { error_t error ; HostType type ; HostnameResolver protocol ;  if ( IPV4_SUPPORT == ENABLED ) type = HOST_TYPE_IPV4 ;  else if ( IPV6_SUPPORT == ENABLED ) type = HOST_TYPE_IPV6 ;  else type = HOST_TYPE_ANY ;    if ( DNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_DNS ;  else if ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ;  else if ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ;  else if ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ;  else protocol = HOST_NAME_RESOLVER_ANY ;   if ( name == NULL || ipAddr == NULL ) return ERROR_INVALID_PARAMETER ; if ( interface == NULL ) interface = netGetDefaultInterface ( ) ; error = ipStringToAddr ( name , ipAddr ) ; if ( error ) { if ( flags & HOST_TYPE_IPV4 ) type = HOST_TYPE_IPV4 ; else if ( flags & HOST_TYPE_IPV6 ) type = HOST_TYPE_IPV6 ; if ( flags & HOST_NAME_RESOLVER_DNS ) { protocol = HOST_NAME_RESOLVER_DNS ; } else if ( flags & HOST_NAME_RESOLVER_MDNS ) { protocol = HOST_NAME_RESOLVER_MDNS ; } else if ( flags & HOST_NAME_RESOLVER_NBNS ) { protocol = HOST_NAME_RESOLVER_NBNS ; } else if ( flags & HOST_NAME_RESOLVER_LLMNR ) { protocol = HOST_NAME_RESOLVER_LLMNR ; } else { size_t n = osStrlen ( name ) ; if ( n >= 6 && ! osStrcasecmp ( name + n - 6 , "".local"" ) ) {  if ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ;   } <S2SV_StartBug> else if ( n <= 15 && ! strchr ( name , '.' ) && type == HOST_TYPE_IPV4 ) <S2SV_EndBug> {  if ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ;   } <S2SV_StartBug> else if ( ! strchr ( name , '.' ) ) <S2SV_EndBug> {  if ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ;   } }  if ( DNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_DNS ) { error = dnsResolve ( interface , name , type , ipAddr ) ; } else    if ( MDNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_MDNS ) { error = mdnsClientResolve ( interface , name , type , ipAddr ) ; } else    if ( NBNS_CLIENT_SUPPORT == ENABLED && IPV4_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_NBNS ) { error = nbnsResolve ( interface , name , ipAddr ) ; } else    if ( LLMNR_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_LLMNR ) { error = llmnrResolve ( interface , name , type , ipAddr ) ; } else   { error = ERROR_INVALID_PARAMETER ; } } return error ; }","<S2SV_ModStart> 15 && ! osStrchr <S2SV_ModEnd> ( name , <S2SV_ModStart> if ( ! osStrchr <S2SV_ModEnd> ( name ,"
462,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 ( * METHOD_1 ) ( struct STRUCT_OR_UNION_4 * , struct STRUCT_OR_UNION_5 * , struct STRUCT_OR_UNION_6 * ) ) { struct STRUCT_OR_UNION_7 * VAR_2 ; struct STRUCT_OR_UNION_8 * VAR_3 = ( struct STRUCT_OR_UNION_9 * ) METHOD_2 ( VAR_4 ) ; struct STRUCT_OR_UNION_10 * VAR_5 = VAR_6 -> VAR_7 && ! METHOD_3 ( ) ? METHOD_4 ( VAR_8 -> VAR_9 ) : VAR_10 ; struct STRUCT_OR_UNION_11 * VAR_11 ; struct STRUCT_OR_UNION_12 * VAR_12 ; unsigned TYPE_2 VAR_13 , VAR_14 , VAR_15 , VAR_16 ; TYPE_3 VAR_17 , VAR_18 ; TYPE_4 VAR_19 ; TYPE_5 VAR_20 , VAR_21 = 0 , VAR_22 = 0 ; VAR_23 * VAR_24 , VAR_25 = 0 ; <S2SV_StartBug> VAR_26 = METHOD_5 ( VAR_27 , & VAR_28 ) ; <S2SV_EndBug> VAR_29 = * VAR_30 ; VAR_31 = METHOD_6 ( VAR_32 ) ; if ( METHOD_7 ( ! VAR_33 -> VAR_34 && VAR_35 -> VAR_36 > VAR_37 ) ) goto VAR_38 ; if ( METHOD_8 ( VAR_39 ) -> VAR_40 ) { if ( METHOD_9 ( VAR_41 ) -> VAR_42 > VAR_43 ) goto VAR_44 ; VAR_45 = METHOD_10 ( VAR_46 ) -> VAR_47 ; if ( VAR_48 < VAR_49 ) VAR_50 = VAR_51 ; } if ( VAR_52 && VAR_53 -> VAR_54 < VAR_55 ) { if ( VAR_56 -> VAR_57 ) VAR_58 = VAR_59 -> VAR_60 ; } if ( VAR_61 < VAR_62 + sizeof ( struct STRUCT_OR_UNION_13 ) + 8 ) goto VAR_63 ; VAR_64 -= VAR_65 + sizeof ( struct STRUCT_OR_UNION_14 ) ; VAR_66 = METHOD_11 ( STRUCT_OR_UNION_15 , & METHOD_12 ( VAR_67 ) -> VAR_68 , & METHOD_13 ( VAR_69 ) -> VAR_70 ) ; if ( VAR_71 -> VAR_72 == VAR_73 && ( VAR_74 = METHOD_14 ( VAR_75 ) ) ) goto VAR_76 ; VAR_77 = METHOD_15 ( VAR_78 -> VAR_79 . VAR_80 ) ; if ( METHOD_16 ( VAR_81 ) ) { unsigned TYPE_6 VAR_82 = METHOD_17 ( VAR_83 ) ; struct STRUCT_OR_UNION_16 * VAR_84 ; if ( VAR_85 - VAR_86 > VAR_87 || ( ( VAR_88 - VAR_89 ) & 7 ) || METHOD_18 ( VAR_90 ) || METHOD_19 ( VAR_91 ) < ( VAR_92 + sizeof ( struct STRUCT_OR_UNION_17 ) ) ) goto VAR_93 ; METHOD_20 ( VAR_94 , VAR_95 ) { if ( VAR_96 -> VAR_97 > VAR_98 || ( ( VAR_99 -> VAR_100 & 7 ) && VAR_101 -> VAR_102 ) || METHOD_21 ( VAR_103 ) < ( VAR_104 + VAR_105 + sizeof ( struct STRUCT_OR_UNION_18 ) ) ) goto VAR_106 ; if ( METHOD_22 ( VAR_107 ) ) goto VAR_108 ; METHOD_23 ( VAR_109 -> VAR_110 ) ; if ( VAR_111 -> VAR_112 ) { VAR_113 -> VAR_114 = VAR_115 -> VAR_116 ; VAR_117 -> VAR_118 = VAR_119 ; } VAR_120 -> VAR_121 -= VAR_122 -> VAR_123 ; } VAR_124 = 0 ; VAR_125 = 0 ; * VAR_126 = VAR_127 ; VAR_128 = METHOD_24 ( METHOD_25 ( VAR_129 ) , VAR_130 , VAR_131 ) ; if ( ! VAR_132 ) { METHOD_26 ( STRUCT_OR_UNION_19 , METHOD_27 ( METHOD_28 ( VAR_133 ) ) , VAR_134 ) ; VAR_135 = - VAR_136 ; goto VAR_137 ; } VAR_138 = METHOD_29 ( VAR_139 ) -> VAR_140 ; METHOD_30 ( VAR_141 ) ; METHOD_31 ( VAR_142 , VAR_143 ) ; VAR_144 = ( struct STRUCT_OR_UNION_20 * ) METHOD_32 ( VAR_145 , sizeof ( struct STRUCT_OR_UNION_21 ) ) ; METHOD_33 ( VAR_146 , VAR_147 ) ; METHOD_34 ( VAR_148 ) ; METHOD_35 ( METHOD_36 ( VAR_149 ) , VAR_150 , VAR_151 ) ; VAR_152 -> VAR_153 = VAR_154 ; VAR_155 -> VAR_156 = 0 ; VAR_157 -> VAR_158 = METHOD_37 ( VAR_159 ) ; VAR_160 -> VAR_161 = VAR_162 ; VAR_163 = METHOD_38 ( VAR_164 ) ; VAR_165 -> VAR_166 = VAR_167 - METHOD_39 ( VAR_168 ) ; VAR_169 -> VAR_170 = VAR_171 ; METHOD_40 ( VAR_172 ) -> VAR_173 = METHOD_41 ( VAR_174 - sizeof ( struct STRUCT_OR_UNION_22 ) ) ; METHOD_42 ( & VAR_175 -> VAR_176 ) ; for ( ; ; ) { if ( VAR_177 ) { VAR_178 -> VAR_179 = VAR_180 ; METHOD_43 ( VAR_181 ) ; VAR_182 = ( struct STRUCT_OR_UNION_23 * ) METHOD_44 ( VAR_183 , sizeof ( struct STRUCT_OR_UNION_24 ) ) ; METHOD_45 ( VAR_184 , VAR_185 ) ; METHOD_46 ( VAR_186 ) ; METHOD_47 ( METHOD_48 ( VAR_187 ) , VAR_188 , VAR_189 ) ; VAR_190 += VAR_191 -> VAR_192 - VAR_193 - sizeof ( struct STRUCT_OR_UNION_25 ) ; VAR_194 -> VAR_195 = VAR_196 ; VAR_197 -> VAR_198 = 0 ; VAR_199 -> VAR_200 = METHOD_49 ( VAR_201 ) ; if ( VAR_202 -> VAR_203 ) VAR_204 -> VAR_205 |= METHOD_50 ( VAR_206 ) ; VAR_207 -> VAR_208 = VAR_209 ; METHOD_51 ( VAR_210 ) -> VAR_211 = METHOD_52 ( VAR_212 -> VAR_213 - sizeof ( struct STRUCT_OR_UNION_26 ) ) ; METHOD_53 ( VAR_214 , VAR_215 ) ; } VAR_216 = METHOD_54 ( STRUCT_OR_UNION_27 , VAR_217 , VAR_218 ) ; if ( ! VAR_219 ) METHOD_55 ( STRUCT_OR_UNION_28 , METHOD_56 ( & VAR_220 -> VAR_221 ) , VAR_222 ) ; if ( VAR_223 || ! VAR_224 ) break ; VAR_225 = VAR_226 ; VAR_227 = VAR_228 -> VAR_229 ; VAR_230 -> VAR_231 = VAR_232 ; } METHOD_57 ( VAR_233 ) ; if ( VAR_234 == 0 ) { METHOD_58 ( STRUCT_OR_UNION_29 , METHOD_59 ( & VAR_235 -> VAR_236 ) , VAR_237 ) ; METHOD_60 ( VAR_238 ) ; return 0 ; } METHOD_61 ( VAR_239 ) ; METHOD_62 ( STRUCT_OR_UNION_30 , METHOD_63 ( & VAR_240 -> VAR_241 ) , VAR_242 ) ; METHOD_64 ( VAR_243 ) ; return VAR_244 ; VAR_245 : METHOD_65 ( VAR_246 , VAR_247 ) { if ( VAR_248 == VAR_249 ) break ; VAR_250 -> VAR_251 = VAR_252 ; VAR_253 -> VAR_254 = VAR_255 ; VAR_256 -> VAR_257 += VAR_258 -> VAR_259 ; } } VAR_260 : VAR_261 = VAR_262 -> VAR_263 - VAR_264 ; VAR_265 = VAR_266 ; VAR_267 = VAR_268 -> VAR_269 . VAR_270 -> VAR_271 ; while ( VAR_272 > 0 ) { VAR_273 * VAR_274 ; VAR_275 = VAR_276 ; if ( VAR_277 > VAR_278 ) VAR_279 = VAR_280 ; if ( VAR_281 < VAR_282 ) { VAR_283 &= ~ 7 ; } VAR_284 = METHOD_66 ( VAR_285 + VAR_286 + sizeof ( struct STRUCT_OR_UNION_31 ) + VAR_287 + VAR_288 , VAR_289 ) ; if ( ! VAR_290 ) { METHOD_67 ( STRUCT_OR_UNION_32 , METHOD_68 ( METHOD_69 ( VAR_291 ) ) , VAR_292 ) ; VAR_293 = - VAR_294 ; goto VAR_295 ; } METHOD_70 ( VAR_296 , VAR_297 ) ; METHOD_71 ( VAR_298 , VAR_299 ) ; METHOD_72 ( VAR_300 , VAR_301 + VAR_302 + sizeof ( struct STRUCT_OR_UNION_33 ) ) ; METHOD_73 ( VAR_303 ) ; VAR_304 = ( struct STRUCT_OR_UNION_34 * ) ( METHOD_74 ( VAR_305 ) + VAR_306 ) ; VAR_307 -> VAR_308 = ( VAR_309 -> VAR_310 + VAR_311 + sizeof ( struct STRUCT_OR_UNION_35 ) ) ; if ( VAR_312 -> VAR_313 ) METHOD_75 ( VAR_314 , VAR_315 -> VAR_316 ) ; METHOD_76 ( VAR_317 , METHOD_77 ( VAR_318 ) , VAR_319 ) ; VAR_320 = METHOD_78 ( VAR_321 ) ; VAR_322 += VAR_323 - METHOD_79 ( VAR_324 ) ; * VAR_325 = VAR_326 ; VAR_327 -> VAR_328 = VAR_329 ; VAR_330 -> VAR_331 = 0 ; VAR_332 -> VAR_333 = VAR_334 ; METHOD_80 ( METHOD_81 ( VAR_335 , VAR_336 , METHOD_82 ( VAR_337 ) , VAR_338 ) ) ; VAR_339 -= VAR_340 ; VAR_341 -> VAR_342 = METHOD_83 ( VAR_343 ) ; if ( VAR_344 > 0 ) VAR_345 -> VAR_346 |= METHOD_84 ( VAR_347 ) ; METHOD_85 ( VAR_348 ) -> VAR_349 = METHOD_86 ( VAR_350 -> VAR_351 - sizeof ( struct STRUCT_OR_UNION_36 ) ) ; VAR_352 += VAR_353 ; VAR_354 += VAR_355 ; VAR_356 = METHOD_87 ( STRUCT_OR_UNION_37 , VAR_357 , VAR_358 ) ; if ( VAR_359 ) goto VAR_360 ; METHOD_88 ( STRUCT_OR_UNION_38 , METHOD_89 ( METHOD_90 ( VAR_361 ) ) , VAR_362 ) ; } METHOD_91 ( STRUCT_OR_UNION_39 , METHOD_92 ( METHOD_93 ( VAR_363 ) ) , VAR_364 ) ; METHOD_94 ( VAR_365 ) ; return VAR_366 ; VAR_367 : if ( VAR_368 -> VAR_369 && METHOD_95 ( METHOD_96 ( VAR_370 ) ) ) METHOD_97 ( VAR_371 -> VAR_372 , VAR_373 ) ; VAR_374 -> VAR_375 = METHOD_98 ( VAR_376 ) -> VAR_377 ; METHOD_99 ( VAR_378 , VAR_379 , 0 , VAR_380 ) ; VAR_381 = - VAR_382 ; VAR_383 : METHOD_100 ( STRUCT_OR_UNION_40 , METHOD_101 ( METHOD_102 ( VAR_384 ) ) , VAR_385 ) ; METHOD_103 ( VAR_386 ) ; return VAR_387 ; }",<S2SV_ModStart> VAR_323 ) ; if ( VAR_319 < 0 ) { VAR_387 = VAR_319 ; goto VAR_383 ; },"CWE-125 int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }",<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
463,"CWE-200 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; TYPE_3 VAR_8 ; TYPE_4 VAR_9 = 0 , VAR_10 = VAR_11 & VAR_12 ; struct STRUCT_OR_UNION_7 * VAR_13 ; struct STRUCT_OR_UNION_8 * VAR_14 = VAR_15 ; VAR_16 = METHOD_2 ( VAR_17 , VAR_18 ) ; <S2SV_StartBug> METHOD_3 ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , VAR_19 , VAR_20 , VAR_21 ) ; <S2SV_EndBug> if ( VAR_22 & VAR_23 ) goto VAR_24 ; while ( 1 ) { if ( ! METHOD_4 ( & VAR_25 -> VAR_26 ) ) { VAR_27 = METHOD_5 ( VAR_28 , VAR_29 ) ; break ; } if ( VAR_30 -> VAR_31 ) { VAR_32 = METHOD_6 ( VAR_33 , VAR_34 ) ; break ; } if ( ! METHOD_7 ( VAR_35 , & VAR_36 ) ) { if ( VAR_37 ) { VAR_38 = - VAR_39 ; break ; } VAR_40 = METHOD_8 ( * METHOD_9 ( VAR_41 ) , ( ! METHOD_10 ( & VAR_42 -> VAR_43 ) || VAR_44 -> VAR_45 || METHOD_11 ( VAR_46 , & VAR_47 ) ) , VAR_48 ) ; METHOD_12 ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , VAR_49 , VAR_50 ) ; if ( VAR_51 > 0 || VAR_52 == VAR_53 ) continue ; VAR_54 = VAR_55 ; if ( VAR_56 == 0 ) VAR_57 = - VAR_58 ; break ; } METHOD_13 ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , VAR_59 , & VAR_60 -> VAR_61 -> VAR_62 , METHOD_14 ( VAR_63 -> VAR_64 . VAR_65 ) ) ; VAR_66 = VAR_67 -> VAR_68 -> VAR_69 -> METHOD_15 ( VAR_70 , VAR_71 -> VAR_72 , VAR_73 ) ; if ( VAR_74 < 0 ) break ; if ( ! METHOD_16 ( VAR_75 , VAR_76 , ! ( VAR_77 & VAR_78 ) ) ) { METHOD_17 ( VAR_79 ) ; VAR_80 = VAR_81 ; METHOD_18 ( VAR_82 ) ; continue ; } if ( VAR_83 < METHOD_19 ( VAR_84 -> VAR_85 . VAR_86 ) ) { if ( VAR_87 & VAR_88 ) VAR_89 = METHOD_20 ( VAR_90 -> VAR_91 . VAR_92 ) ; VAR_93 -> VAR_94 |= VAR_95 ; } if ( METHOD_21 ( VAR_96 , VAR_97 ) ) { VAR_98 = - VAR_99 ; goto VAR_100 ; } METHOD_22 ( VAR_101 ) ; VAR_102 = ( struct STRUCT_OR_UNION_9 * ) VAR_103 -> VAR_104 ; if ( VAR_105 ) { VAR_106 -> VAR_107 = VAR_108 ; VAR_109 -> VAR_110 = VAR_111 -> VAR_112 . VAR_113 ; VAR_114 -> VAR_115 . VAR_116 = VAR_117 -> VAR_118 ; METHOD_23 ( VAR_119 -> VAR_120 , 0 , sizeof ( VAR_121 -> VAR_122 ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( VAR_123 ) METHOD_24 ( VAR_124 ) ; VAR_125 : return VAR_126 ; }","<S2SV_ModStart> , VAR_55 ) ; VAR_103 -> VAR_127 = 0 <S2SV_ModStart> ) ) ; VAR_103 -> VAR_127 = sizeof ( * VAR_121 ) ;","CWE-200 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }","<S2SV_ModStart> , timeo ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ) ; msg -> msg_namelen = sizeof ( * sin ) ;"
464,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , TYPE_4 * VAR_6 ) { TYPE_5 VAR_7 = 0 ; TYPE_6 VAR_8 = - VAR_9 ; struct STRUCT_OR_UNION_3 * VAR_10 ; struct STRUCT_OR_UNION_4 * VAR_11 ; VAR_12 = ( struct STRUCT_OR_UNION_5 * ) VAR_13 -> VAR_14 ; VAR_15 = METHOD_1 ( VAR_16 , VAR_17 , VAR_18 , & VAR_19 ) ; if ( ! VAR_20 ) goto VAR_21 ; VAR_22 = VAR_23 -> VAR_24 ; if ( VAR_25 < VAR_26 ) { VAR_27 -> VAR_28 |= VAR_29 ; VAR_30 = VAR_31 ; } VAR_32 = METHOD_2 ( VAR_33 , 0 , VAR_34 -> VAR_35 , VAR_36 ) ; if ( VAR_37 ) goto VAR_38 ; METHOD_3 ( VAR_39 , VAR_40 , VAR_41 ) ; if ( VAR_42 ) { VAR_43 -> VAR_44 = VAR_45 ; VAR_46 -> VAR_47 = METHOD_4 ( VAR_48 ) -> VAR_49 ; <S2SV_StartBug> } <S2SV_EndBug> if ( VAR_50 ) * VAR_51 = sizeof ( * VAR_52 ) ; if ( VAR_53 & VAR_54 ) VAR_55 = VAR_56 -> VAR_57 ; VAR_58 : METHOD_5 ( VAR_59 , VAR_60 ) ; VAR_61 : if ( VAR_62 ) return VAR_63 ; return VAR_64 ; }",<S2SV_ModStart> -> VAR_49 ; * VAR_51 = sizeof ( * VAR_52 ) ; } <S2SV_ModEnd> if ( VAR_53,"CWE-200 static int dgram_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; struct sockaddr_ieee802154 * saddr ; saddr = ( struct sockaddr_ieee802154 * ) msg -> msg_name ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( saddr ) { saddr -> family = AF_IEEE802154 ; saddr -> addr = mac_cb ( skb ) -> sa ; <S2SV_StartBug> } <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * saddr ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }",<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
465,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_EndBug> const TYPE_2 VAR_1 = METHOD_1 ( VAR_2 , VAR_3 ) ; const TYPE_3 VAR_4 = METHOD_2 ( VAR_5 , - VAR_6 ) ; const TYPE_4 VAR_7 = METHOD_3 ( VAR_8 , VAR_9 ) ; const TYPE_5 VAR_10 = METHOD_4 ( VAR_11 , - VAR_12 ) ; const TYPE_6 VAR_13 = METHOD_5 ( VAR_14 , VAR_15 ) ; const TYPE_7 VAR_16 = METHOD_6 ( VAR_17 , - VAR_18 ) ; const TYPE_8 VAR_19 = METHOD_7 ( VAR_20 , VAR_21 ) ; const TYPE_9 VAR_22 = METHOD_8 ( VAR_23 , - VAR_24 ) ; const TYPE_10 VAR_25 = METHOD_9 ( VAR_26 , VAR_27 ) ; const TYPE_11 VAR_28 = METHOD_10 ( VAR_29 , - VAR_30 ) ; const TYPE_12 VAR_31 = METHOD_11 ( - VAR_32 , VAR_33 ) ; const TYPE_13 VAR_34 = METHOD_12 ( VAR_35 , - VAR_36 ) ; <S2SV_StartBug> const TYPE_14 VAR_37 = METHOD_13 ( VAR_38 ) ; <S2SV_EndBug> const TYPE_15 VAR_39 = METHOD_14 ( 0 ) ; const TYPE_16 VAR_40 = METHOD_15 ( VAR_41 ) ; TYPE_17 VAR_42 , VAR_43 , VAR_44 , VAR_45 , VAR_46 , VAR_47 , VAR_48 , VAR_49 , VAR_50 , VAR_51 , VAR_52 , VAR_53 , VAR_54 , VAR_55 , VAR_56 , VAR_57 ; TYPE_18 VAR_58 , VAR_59 , VAR_60 , VAR_61 , VAR_62 , VAR_63 , VAR_64 , VAR_65 , VAR_66 , VAR_67 , VAR_68 , VAR_69 , VAR_70 , VAR_71 , VAR_72 , VAR_73 ; TYPE_19 VAR_74 , VAR_75 , VAR_76 , VAR_77 , VAR_78 , VAR_79 , VAR_80 , VAR_81 , VAR_82 , VAR_83 , VAR_84 , VAR_85 , VAR_86 , VAR_87 , VAR_88 , VAR_89 ; TYPE_20 VAR_90 , VAR_91 , VAR_92 , VAR_93 , VAR_94 , VAR_95 , VAR_96 , VAR_97 ; TYPE_21 VAR_98 , VAR_99 , VAR_100 , VAR_101 , VAR_102 , VAR_103 , VAR_104 , VAR_105 ; VAR_106 = VAR_107 [ 7 ] ; VAR_108 = VAR_109 [ 0 ] ; VAR_110 = VAR_111 [ 5 ] ; VAR_112 = VAR_113 [ 2 ] ; VAR_114 = VAR_115 [ 3 ] ; VAR_116 = VAR_117 [ 4 ] ; VAR_118 = VAR_119 [ 1 ] ; VAR_120 = VAR_121 [ 6 ] ; VAR_122 = METHOD_16 ( VAR_123 , VAR_124 ) ; VAR_125 = METHOD_17 ( VAR_126 , VAR_127 ) ; VAR_128 = METHOD_18 ( VAR_129 , VAR_130 ) ; VAR_131 = METHOD_19 ( VAR_132 , VAR_133 ) ; VAR_134 = METHOD_20 ( VAR_135 , VAR_136 ) ; VAR_137 = METHOD_21 ( VAR_138 , VAR_139 ) ; VAR_140 = METHOD_22 ( VAR_141 , VAR_142 ) ; VAR_143 = METHOD_23 ( VAR_144 , VAR_145 ) ; VAR_146 = METHOD_24 ( VAR_147 , VAR_148 ) ; VAR_149 = METHOD_25 ( VAR_150 , VAR_151 ) ; VAR_152 = METHOD_26 ( VAR_153 , VAR_154 ) ; VAR_155 = METHOD_27 ( VAR_156 , VAR_157 ) ; VAR_158 = METHOD_28 ( VAR_159 , VAR_160 ) ; VAR_161 = METHOD_29 ( VAR_162 , VAR_163 ) ; VAR_164 = METHOD_30 ( VAR_165 , VAR_166 ) ; VAR_167 = METHOD_31 ( VAR_168 , VAR_169 ) ; VAR_170 = METHOD_32 ( VAR_171 , VAR_172 ) ; VAR_173 = METHOD_33 ( VAR_174 , VAR_175 ) ; VAR_176 = METHOD_34 ( VAR_177 , VAR_178 ) ; VAR_179 = METHOD_35 ( VAR_180 , VAR_181 ) ; VAR_182 = METHOD_36 ( VAR_183 , VAR_184 ) ; VAR_185 = METHOD_37 ( VAR_186 , VAR_187 ) ; VAR_188 = METHOD_38 ( VAR_189 , VAR_190 ) ; VAR_191 = METHOD_39 ( VAR_192 , VAR_193 ) ; VAR_194 = METHOD_40 ( VAR_195 , VAR_196 ) ; VAR_197 = METHOD_41 ( VAR_198 , VAR_199 ) ; VAR_200 = METHOD_42 ( VAR_201 , VAR_202 ) ; VAR_203 = METHOD_43 ( VAR_204 , VAR_205 ) ; VAR_206 = METHOD_44 ( VAR_207 , VAR_208 ) ; VAR_209 = METHOD_45 ( VAR_210 , VAR_211 ) ; VAR_212 = METHOD_46 ( VAR_213 , VAR_214 ) ; VAR_215 = METHOD_47 ( VAR_216 , VAR_217 ) ; VAR_218 = METHOD_48 ( VAR_219 , VAR_220 ) ; VAR_221 = METHOD_49 ( VAR_222 , VAR_223 ) ; VAR_224 = METHOD_50 ( VAR_225 , VAR_226 ) ; VAR_227 = METHOD_51 ( VAR_228 , VAR_229 ) ; VAR_230 = METHOD_52 ( VAR_231 , VAR_232 ) ; VAR_233 = METHOD_53 ( VAR_234 , VAR_235 ) ; VAR_236 = METHOD_54 ( VAR_237 , VAR_238 ) ; VAR_239 = METHOD_55 ( VAR_240 , VAR_241 ) ; VAR_242 = METHOD_56 ( VAR_243 , VAR_244 ) ; VAR_245 = METHOD_57 ( VAR_246 , VAR_247 ) ; VAR_248 = METHOD_58 ( VAR_249 , VAR_250 ) ; VAR_251 = METHOD_59 ( VAR_252 , VAR_253 ) ; VAR_254 = METHOD_60 ( VAR_255 , VAR_256 ) ; VAR_257 = METHOD_61 ( VAR_258 , VAR_259 ) ; VAR_260 = METHOD_62 ( VAR_261 , VAR_262 ) ; VAR_263 = METHOD_63 ( VAR_264 , VAR_265 ) ; VAR_266 = METHOD_64 ( VAR_267 , VAR_268 ) ; VAR_269 = METHOD_65 ( VAR_270 , VAR_271 ) ; VAR_272 = METHOD_66 ( VAR_273 , VAR_274 ) ; VAR_275 = METHOD_67 ( VAR_276 , VAR_277 ) ; VAR_278 = METHOD_68 ( VAR_279 , VAR_280 ) ; VAR_281 = METHOD_69 ( VAR_282 , VAR_283 ) ; VAR_284 = METHOD_70 ( VAR_285 , VAR_286 ) ; VAR_287 = METHOD_71 ( VAR_288 , VAR_289 ) ; VAR_290 = METHOD_72 ( VAR_291 , VAR_292 ) ; VAR_293 = METHOD_73 ( VAR_294 , VAR_295 ) ; VAR_296 = METHOD_74 ( VAR_297 , VAR_298 ) ; VAR_299 = METHOD_75 ( VAR_300 , VAR_301 ) ; VAR_302 = METHOD_76 ( VAR_303 , VAR_304 ) ; VAR_305 = METHOD_77 ( VAR_306 , VAR_307 ) ; VAR_308 = METHOD_78 ( VAR_309 , VAR_310 ) ; VAR_311 = METHOD_79 ( VAR_312 , VAR_313 ) ; VAR_314 = METHOD_80 ( VAR_315 , VAR_316 ) ; VAR_317 = METHOD_81 ( VAR_318 , VAR_319 ) ; VAR_320 = METHOD_82 ( VAR_321 , VAR_322 ) ; VAR_323 = METHOD_83 ( VAR_324 , VAR_325 ) ; VAR_326 = METHOD_84 ( VAR_327 , VAR_328 ) ; VAR_329 = METHOD_85 ( VAR_330 , VAR_331 ) ; VAR_332 = METHOD_86 ( VAR_333 , VAR_334 ) ; VAR_335 = METHOD_87 ( VAR_336 , VAR_337 ) ; VAR_338 [ 0 ] = METHOD_88 ( VAR_339 , VAR_340 ) ; VAR_341 [ 1 ] = METHOD_89 ( VAR_342 , VAR_343 ) ; VAR_344 [ 2 ] = METHOD_90 ( VAR_345 , VAR_346 ) ; VAR_347 [ 3 ] = METHOD_91 ( VAR_348 , VAR_349 ) ; VAR_350 [ 4 ] = METHOD_92 ( VAR_351 , VAR_352 ) ; VAR_353 [ 5 ] = METHOD_93 ( VAR_354 , VAR_355 ) ; VAR_356 [ 6 ] = METHOD_94 ( VAR_357 , VAR_358 ) ; VAR_359 [ 7 ] = METHOD_95 ( VAR_360 , VAR_361 ) ; VAR_362 = METHOD_96 ( VAR_363 [ 0 ] , VAR_364 [ 2 ] ) ; VAR_365 = METHOD_97 ( VAR_366 [ 1 ] , VAR_367 [ 3 ] ) ; VAR_368 = METHOD_98 ( VAR_369 [ 0 ] , VAR_370 [ 2 ] ) ; VAR_371 = METHOD_99 ( VAR_372 [ 1 ] , VAR_373 [ 3 ] ) ; VAR_374 = METHOD_100 ( VAR_375 [ 4 ] , VAR_376 [ 5 ] ) ; VAR_377 = METHOD_101 ( VAR_378 [ 4 ] , VAR_379 [ 5 ] ) ; VAR_380 = METHOD_102 ( VAR_381 [ 6 ] , VAR_382 [ 7 ] ) ; VAR_383 = METHOD_103 ( VAR_384 [ 6 ] , VAR_385 [ 7 ] ) ; VAR_386 = METHOD_104 ( VAR_387 , VAR_388 ) ; VAR_389 = METHOD_105 ( VAR_390 , VAR_391 ) ; VAR_392 = METHOD_106 ( VAR_393 , VAR_394 ) ; VAR_395 = METHOD_107 ( VAR_396 , VAR_397 ) ; VAR_398 = METHOD_108 ( VAR_399 , VAR_400 ) ; VAR_401 = METHOD_109 ( VAR_402 , VAR_403 ) ; VAR_404 = METHOD_110 ( VAR_405 , VAR_406 ) ; VAR_407 = METHOD_111 ( VAR_408 , VAR_409 ) ; VAR_410 = METHOD_112 ( VAR_411 , VAR_412 ) ; VAR_413 = METHOD_113 ( VAR_414 , VAR_415 ) ; VAR_416 = METHOD_114 ( VAR_417 , VAR_418 ) ; VAR_419 = METHOD_115 ( VAR_420 , VAR_421 ) ; VAR_422 = METHOD_116 ( VAR_423 , VAR_424 ) ; VAR_425 = METHOD_117 ( VAR_426 , VAR_427 ) ; VAR_428 = METHOD_118 ( VAR_429 , VAR_430 ) ; VAR_431 = METHOD_119 ( VAR_432 , VAR_433 ) ; VAR_434 = METHOD_120 ( VAR_435 , VAR_436 ) ; VAR_437 = METHOD_121 ( VAR_438 , VAR_439 ) ; VAR_440 = METHOD_122 ( VAR_441 , VAR_442 ) ; VAR_443 = METHOD_123 ( VAR_444 , VAR_445 ) ; VAR_446 = METHOD_124 ( VAR_447 , VAR_448 ) ; VAR_449 = METHOD_125 ( VAR_450 , VAR_451 ) ; VAR_452 = METHOD_126 ( VAR_453 , VAR_454 ) ; VAR_455 = METHOD_127 ( VAR_456 , VAR_457 ) ; VAR_458 = METHOD_128 ( VAR_459 , VAR_460 ) ; VAR_461 = METHOD_129 ( VAR_462 , VAR_463 ) ; VAR_464 = METHOD_130 ( VAR_465 , VAR_466 ) ; VAR_467 = METHOD_131 ( VAR_468 , VAR_469 ) ; VAR_470 = METHOD_132 ( VAR_471 , VAR_472 ) ; VAR_473 = METHOD_133 ( VAR_474 , VAR_475 ) ; VAR_476 = METHOD_134 ( VAR_477 , VAR_478 ) ; VAR_479 = METHOD_135 ( VAR_480 , VAR_481 ) ; VAR_482 = METHOD_136 ( VAR_483 , VAR_484 ) ; VAR_485 = METHOD_137 ( VAR_486 , VAR_487 ) ; VAR_488 = METHOD_138 ( VAR_489 , VAR_490 ) ; VAR_491 = METHOD_139 ( VAR_492 , VAR_493 ) ; VAR_494 = METHOD_140 ( VAR_495 , VAR_496 ) ; VAR_497 = METHOD_141 ( VAR_498 , VAR_499 ) ; VAR_500 = METHOD_142 ( VAR_501 , VAR_502 ) ; VAR_503 = METHOD_143 ( VAR_504 , VAR_505 ) ; VAR_506 = METHOD_144 ( VAR_507 , VAR_508 ) ; VAR_509 = METHOD_145 ( VAR_510 , VAR_511 ) ; VAR_512 = METHOD_146 ( VAR_513 , VAR_514 ) ; VAR_515 = METHOD_147 ( VAR_516 , VAR_517 ) ; VAR_518 = METHOD_148 ( VAR_519 , VAR_520 ) ; VAR_521 = METHOD_149 ( VAR_522 , VAR_523 ) ; VAR_524 = METHOD_150 ( VAR_525 , VAR_526 ) ; VAR_527 = METHOD_151 ( VAR_528 , VAR_529 ) ; VAR_530 = METHOD_152 ( VAR_531 , VAR_532 ) ; VAR_533 = METHOD_153 ( VAR_534 , VAR_535 ) ; VAR_536 = METHOD_154 ( VAR_537 , VAR_538 ) ; VAR_539 = METHOD_155 ( VAR_540 , VAR_541 ) ; VAR_542 = METHOD_156 ( VAR_543 , VAR_544 ) ; VAR_545 = METHOD_157 ( VAR_546 , VAR_547 ) ; VAR_548 = METHOD_158 ( VAR_549 , VAR_550 ) ; VAR_551 = METHOD_159 ( VAR_552 , VAR_553 ) ; VAR_554 = METHOD_160 ( VAR_555 , VAR_556 ) ; VAR_557 = METHOD_161 ( VAR_558 , VAR_559 ) ; VAR_560 = METHOD_162 ( VAR_561 , VAR_562 ) ; VAR_563 = METHOD_163 ( VAR_564 , VAR_565 ) ; VAR_566 = METHOD_164 ( VAR_567 , VAR_568 ) ; VAR_569 = METHOD_165 ( VAR_570 , VAR_571 ) ; VAR_572 = METHOD_166 ( VAR_573 , VAR_574 ) ; VAR_575 = METHOD_167 ( VAR_576 , VAR_577 ) ; VAR_578 = METHOD_168 ( VAR_579 , VAR_580 ) ; VAR_581 = METHOD_169 ( VAR_582 , VAR_583 ) ; VAR_584 = METHOD_170 ( VAR_585 , VAR_586 ) ; VAR_587 = METHOD_171 ( VAR_588 , VAR_589 ) ; VAR_590 [ 0 ] = VAR_591 ; VAR_592 [ 1 ] = METHOD_172 ( VAR_593 , VAR_594 ) ; VAR_595 [ 2 ] = VAR_596 ; VAR_597 [ 3 ] = METHOD_173 ( VAR_598 , VAR_599 ) ; VAR_600 [ 4 ] = VAR_601 ; VAR_602 [ 5 ] = METHOD_174 ( VAR_603 , VAR_604 ) ; VAR_605 [ 6 ] = VAR_606 ; VAR_607 [ 7 ] = METHOD_175 ( VAR_608 , VAR_609 ) ; METHOD_176 ( VAR_610 , VAR_611 ) ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = METHOD_14 ( ( TYPE_22 ),"CWE-119 <S2SV_StartBug> void fadst8_sse2 ( __m128i * in ) { <S2SV_EndBug> const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_p30_m02 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ; const __m128i k__cospi_p10_p22 = pair_set_epi16 ( cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_p22_m10 = pair_set_epi16 ( cospi_22_64 , - cospi_10_64 ) ; const __m128i k__cospi_p18_p14 = pair_set_epi16 ( cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p14_m18 = pair_set_epi16 ( cospi_14_64 , - cospi_18_64 ) ; const __m128i k__cospi_p26_p06 = pair_set_epi16 ( cospi_26_64 , cospi_6_64 ) ; const __m128i k__cospi_p06_m26 = pair_set_epi16 ( cospi_6_64 , - cospi_26_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u0 , u1 , u2 , u3 , u4 , u5 , u6 , u7 , u8 , u9 , u10 , u11 , u12 , u13 , u14 , u15 ; __m128i v0 , v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 ; __m128i w0 , w1 , w2 , w3 , w4 , w5 , w6 , w7 , w8 , w9 , w10 , w11 , w12 , w13 , w14 , w15 ; __m128i s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; __m128i in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7 ; in0 = in [ 7 ] ; in1 = in [ 0 ] ; in2 = in [ 5 ] ; in3 = in [ 2 ] ; in4 = in [ 3 ] ; in5 = in [ 4 ] ; in6 = in [ 1 ] ; in7 = in [ 6 ] ; s0 = _mm_unpacklo_epi16 ( in0 , in1 ) ; s1 = _mm_unpackhi_epi16 ( in0 , in1 ) ; s2 = _mm_unpacklo_epi16 ( in2 , in3 ) ; s3 = _mm_unpackhi_epi16 ( in2 , in3 ) ; s4 = _mm_unpacklo_epi16 ( in4 , in5 ) ; s5 = _mm_unpackhi_epi16 ( in4 , in5 ) ; s6 = _mm_unpacklo_epi16 ( in6 , in7 ) ; s7 = _mm_unpackhi_epi16 ( in6 , in7 ) ; u0 = _mm_madd_epi16 ( s0 , k__cospi_p02_p30 ) ; u1 = _mm_madd_epi16 ( s1 , k__cospi_p02_p30 ) ; u2 = _mm_madd_epi16 ( s0 , k__cospi_p30_m02 ) ; u3 = _mm_madd_epi16 ( s1 , k__cospi_p30_m02 ) ; u4 = _mm_madd_epi16 ( s2 , k__cospi_p10_p22 ) ; u5 = _mm_madd_epi16 ( s3 , k__cospi_p10_p22 ) ; u6 = _mm_madd_epi16 ( s2 , k__cospi_p22_m10 ) ; u7 = _mm_madd_epi16 ( s3 , k__cospi_p22_m10 ) ; u8 = _mm_madd_epi16 ( s4 , k__cospi_p18_p14 ) ; u9 = _mm_madd_epi16 ( s5 , k__cospi_p18_p14 ) ; u10 = _mm_madd_epi16 ( s4 , k__cospi_p14_m18 ) ; u11 = _mm_madd_epi16 ( s5 , k__cospi_p14_m18 ) ; u12 = _mm_madd_epi16 ( s6 , k__cospi_p26_p06 ) ; u13 = _mm_madd_epi16 ( s7 , k__cospi_p26_p06 ) ; u14 = _mm_madd_epi16 ( s6 , k__cospi_p06_m26 ) ; u15 = _mm_madd_epi16 ( s7 , k__cospi_p06_m26 ) ; w0 = _mm_add_epi32 ( u0 , u8 ) ; w1 = _mm_add_epi32 ( u1 , u9 ) ; w2 = _mm_add_epi32 ( u2 , u10 ) ; w3 = _mm_add_epi32 ( u3 , u11 ) ; w4 = _mm_add_epi32 ( u4 , u12 ) ; w5 = _mm_add_epi32 ( u5 , u13 ) ; w6 = _mm_add_epi32 ( u6 , u14 ) ; w7 = _mm_add_epi32 ( u7 , u15 ) ; w8 = _mm_sub_epi32 ( u0 , u8 ) ; w9 = _mm_sub_epi32 ( u1 , u9 ) ; w10 = _mm_sub_epi32 ( u2 , u10 ) ; w11 = _mm_sub_epi32 ( u3 , u11 ) ; w12 = _mm_sub_epi32 ( u4 , u12 ) ; w13 = _mm_sub_epi32 ( u5 , u13 ) ; w14 = _mm_sub_epi32 ( u6 , u14 ) ; w15 = _mm_sub_epi32 ( u7 , u15 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; v8 = _mm_add_epi32 ( w8 , k__DCT_CONST_ROUNDING ) ; v9 = _mm_add_epi32 ( w9 , k__DCT_CONST_ROUNDING ) ; v10 = _mm_add_epi32 ( w10 , k__DCT_CONST_ROUNDING ) ; v11 = _mm_add_epi32 ( w11 , k__DCT_CONST_ROUNDING ) ; v12 = _mm_add_epi32 ( w12 , k__DCT_CONST_ROUNDING ) ; v13 = _mm_add_epi32 ( w13 , k__DCT_CONST_ROUNDING ) ; v14 = _mm_add_epi32 ( w14 , k__DCT_CONST_ROUNDING ) ; v15 = _mm_add_epi32 ( w15 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; u8 = _mm_srai_epi32 ( v8 , DCT_CONST_BITS ) ; u9 = _mm_srai_epi32 ( v9 , DCT_CONST_BITS ) ; u10 = _mm_srai_epi32 ( v10 , DCT_CONST_BITS ) ; u11 = _mm_srai_epi32 ( v11 , DCT_CONST_BITS ) ; u12 = _mm_srai_epi32 ( v12 , DCT_CONST_BITS ) ; u13 = _mm_srai_epi32 ( v13 , DCT_CONST_BITS ) ; u14 = _mm_srai_epi32 ( v14 , DCT_CONST_BITS ) ; u15 = _mm_srai_epi32 ( v15 , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u0 , u1 ) ; in [ 1 ] = _mm_packs_epi32 ( u2 , u3 ) ; in [ 2 ] = _mm_packs_epi32 ( u4 , u5 ) ; in [ 3 ] = _mm_packs_epi32 ( u6 , u7 ) ; in [ 4 ] = _mm_packs_epi32 ( u8 , u9 ) ; in [ 5 ] = _mm_packs_epi32 ( u10 , u11 ) ; in [ 6 ] = _mm_packs_epi32 ( u12 , u13 ) ; in [ 7 ] = _mm_packs_epi32 ( u14 , u15 ) ; s0 = _mm_add_epi16 ( in [ 0 ] , in [ 2 ] ) ; s1 = _mm_add_epi16 ( in [ 1 ] , in [ 3 ] ) ; s2 = _mm_sub_epi16 ( in [ 0 ] , in [ 2 ] ) ; s3 = _mm_sub_epi16 ( in [ 1 ] , in [ 3 ] ) ; u0 = _mm_unpacklo_epi16 ( in [ 4 ] , in [ 5 ] ) ; u1 = _mm_unpackhi_epi16 ( in [ 4 ] , in [ 5 ] ) ; u2 = _mm_unpacklo_epi16 ( in [ 6 ] , in [ 7 ] ) ; u3 = _mm_unpackhi_epi16 ( in [ 6 ] , in [ 7 ] ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p08_p24 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p08_p24 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p24_m08 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p24_m08 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_m24_p08 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_m24_p08 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p08_p24 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p08_p24 ) ; w0 = _mm_add_epi32 ( v0 , v4 ) ; w1 = _mm_add_epi32 ( v1 , v5 ) ; w2 = _mm_add_epi32 ( v2 , v6 ) ; w3 = _mm_add_epi32 ( v3 , v7 ) ; w4 = _mm_sub_epi32 ( v0 , v4 ) ; w5 = _mm_sub_epi32 ( v1 , v5 ) ; w6 = _mm_sub_epi32 ( v2 , v6 ) ; w7 = _mm_sub_epi32 ( v3 , v7 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; s4 = _mm_packs_epi32 ( u0 , u1 ) ; s5 = _mm_packs_epi32 ( u2 , u3 ) ; s6 = _mm_packs_epi32 ( u4 , u5 ) ; s7 = _mm_packs_epi32 ( u6 , u7 ) ; u0 = _mm_unpacklo_epi16 ( s2 , s3 ) ; u1 = _mm_unpackhi_epi16 ( s2 , s3 ) ; u2 = _mm_unpacklo_epi16 ( s6 , s7 ) ; u3 = _mm_unpackhi_epi16 ( s6 , s7 ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p16_p16 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p16_p16 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p16_m16 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p16_m16 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_p16_p16 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_p16_p16 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p16_m16 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p16_m16 ) ; u0 = _mm_add_epi32 ( v0 , k__DCT_CONST_ROUNDING ) ; u1 = _mm_add_epi32 ( v1 , k__DCT_CONST_ROUNDING ) ; u2 = _mm_add_epi32 ( v2 , k__DCT_CONST_ROUNDING ) ; u3 = _mm_add_epi32 ( v3 , k__DCT_CONST_ROUNDING ) ; u4 = _mm_add_epi32 ( v4 , k__DCT_CONST_ROUNDING ) ; u5 = _mm_add_epi32 ( v5 , k__DCT_CONST_ROUNDING ) ; u6 = _mm_add_epi32 ( v6 , k__DCT_CONST_ROUNDING ) ; u7 = _mm_add_epi32 ( v7 , k__DCT_CONST_ROUNDING ) ; v0 = _mm_srai_epi32 ( u0 , DCT_CONST_BITS ) ; v1 = _mm_srai_epi32 ( u1 , DCT_CONST_BITS ) ; v2 = _mm_srai_epi32 ( u2 , DCT_CONST_BITS ) ; v3 = _mm_srai_epi32 ( u3 , DCT_CONST_BITS ) ; v4 = _mm_srai_epi32 ( u4 , DCT_CONST_BITS ) ; v5 = _mm_srai_epi32 ( u5 , DCT_CONST_BITS ) ; v6 = _mm_srai_epi32 ( u6 , DCT_CONST_BITS ) ; v7 = _mm_srai_epi32 ( u7 , DCT_CONST_BITS ) ; s2 = _mm_packs_epi32 ( v0 , v1 ) ; s3 = _mm_packs_epi32 ( v2 , v3 ) ; s6 = _mm_packs_epi32 ( v4 , v5 ) ; s7 = _mm_packs_epi32 ( v6 , v7 ) ; in [ 0 ] = s0 ; in [ 1 ] = _mm_sub_epi16 ( k__const_0 , s4 ) ; in [ 2 ] = s6 ; in [ 3 ] = _mm_sub_epi16 ( k__const_0 , s2 ) ; in [ 4 ] = s3 ; in [ 5 ] = _mm_sub_epi16 ( k__const_0 , s7 ) ; in [ 6 ] = s5 ; in [ 7 ] = _mm_sub_epi16 ( k__const_0 , s1 ) ; array_transpose_8x8 ( in , in ) ; }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
466,"CWE-264 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , TYPE_0 VAR_1 , const TYPE_1 * VAR_2 , TYPE_2 * VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 ; struct STRUCT_OR_UNION_3 * VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 ; const TYPE_3 * VAR_7 = ""Getting<S2SV_blank>sb<S2SV_blank>failed"" ; struct STRUCT_OR_UNION_5 * STRUCT_OR_UNION_6 ; struct STRUCT_OR_UNION_7 STRUCT_OR_UNION_8 ; <S2SV_StartBug> TYPE_4 VAR_8 ; <S2SV_EndBug> VAR_9 = METHOD_1 ( VAR_10 , VAR_11 ) ; if ( ! VAR_12 ) { VAR_13 = - VAR_14 ; goto VAR_15 ; } <S2SV_StartBug> VAR_16 = METHOD_2 ( VAR_17 , VAR_18 ) ; <S2SV_EndBug> if ( VAR_19 ) { VAR_20 = ""Error<S2SV_blank>parsing<S2SV_blank>options"" ; goto VAR_21 ; } VAR_22 = METHOD_3 ( VAR_23 , VAR_24 , VAR_25 , VAR_26 ) ; if ( METHOD_4 ( VAR_27 ) ) { VAR_28 = METHOD_5 ( VAR_29 ) ; goto VAR_30 ; } VAR_31 -> VAR_32 = VAR_33 ; VAR_34 = METHOD_6 ( & VAR_35 -> VAR_36 , ""ecryptfs"" , VAR_37 ) ; if ( VAR_38 ) goto VAR_39 ; METHOD_7 ( VAR_40 , VAR_41 ) ; VAR_42 -> VAR_43 = & VAR_44 -> VAR_45 ; VAR_46 = VAR_47 ; VAR_48 -> VAR_49 = & VAR_50 ; VAR_51 -> VAR_52 = & VAR_53 ; VAR_54 = ""Reading<S2SV_blank>sb<S2SV_blank>failed"" ; VAR_55 = METHOD_8 ( VAR_56 , VAR_57 | VAR_58 , & STRUCT_OR_UNION_9 ) ; if ( VAR_59 ) { METHOD_9 ( VAR_60 , ""kern_path()<S2SV_blank>failed\\n"" ) ; goto VAR_61 ; } if ( STRUCT_OR_UNION_10 . STRUCT_OR_UNION_11 -> VAR_62 -> VAR_63 == & VAR_64 ) { VAR_65 = - VAR_66 ; printk ( KERN_ERR ""Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>"" ""eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>"" ""known<S2SV_blank>incompatibilities\\n"" ) ; goto VAR_67 ; } <S2SV_StartBug> METHOD_10 ( VAR_68 , STRUCT_OR_UNION_12 . STRUCT_OR_UNION_13 -> VAR_69 ) ; <S2SV_EndBug> VAR_70 -> VAR_71 = STRUCT_OR_UNION_14 . STRUCT_OR_UNION_15 -> VAR_72 -> VAR_73 ; VAR_74 -> VAR_75 = STRUCT_OR_UNION_16 . STRUCT_OR_UNION_17 -> VAR_76 -> VAR_77 ; VAR_78 -> VAR_79 = VAR_80 ; STRUCT_OR_UNION_18 = METHOD_11 ( STRUCT_OR_UNION_19 . STRUCT_OR_UNION_20 -> VAR_81 , VAR_82 ) ; VAR_83 = METHOD_12 ( STRUCT_OR_UNION_21 ) ; if ( METHOD_13 ( STRUCT_OR_UNION_22 ) ) goto VAR_84 ; VAR_85 -> VAR_86 = METHOD_14 ( STRUCT_OR_UNION_23 ) ; if ( ! VAR_87 -> VAR_88 ) { METHOD_15 ( STRUCT_OR_UNION_24 ) ; VAR_89 = - VAR_90 ; goto VAR_91 ; } VAR_92 = - VAR_93 ; VAR_94 = METHOD_16 ( VAR_95 , VAR_96 ) ; if ( ! VAR_97 ) goto VAR_98 ; METHOD_17 ( VAR_99 -> VAR_100 , VAR_101 ) ; METHOD_18 ( VAR_102 -> VAR_103 , STRUCT_OR_UNION_25 . STRUCT_OR_UNION_26 ) ; METHOD_19 ( VAR_104 -> VAR_105 , STRUCT_OR_UNION_27 . VAR_106 ) ; VAR_107 -> VAR_108 |= VAR_109 ; return METHOD_20 ( VAR_110 -> VAR_111 ) ; VAR_112 : METHOD_21 ( & STRUCT_OR_UNION_28 ) ; VAR_113 : METHOD_22 ( VAR_114 ) ; VAR_115 : if ( VAR_116 ) { METHOD_23 ( & VAR_117 -> VAR_118 ) ; METHOD_24 ( VAR_119 , VAR_120 ) ; } printk ( KERN_ERR ""%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , VAR_121 , VAR_122 ) ; return METHOD_25 ( VAR_123 ) ; }","<S2SV_ModStart> STRUCT_OR_UNION_28 STRUCT_OR_UNION_28 ; TYPE_5 VAR_124 ; <S2SV_ModStart> VAR_120 , VAR_18 , & VAR_124 <S2SV_ModStart> VAR_112 ; } if ( VAR_124 && STRUCT_OR_UNION_28 . STRUCT_OR_UNION_26 -> VAR_81 -> VAR_125 != METHOD_26 ( ) ) { VAR_123 = - VAR_126 ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , STRUCT_OR_UNION_28 . STRUCT_OR_UNION_26 -> VAR_81 -> VAR_125 , METHOD_26 ( ) ) ; goto VAR_112 ; }","CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = ""Getting<S2SV_blank>sb<S2SV_blank>failed"" ; struct inode * inode ; struct path path ; <S2SV_StartBug> int rc ; <S2SV_EndBug> sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> if ( rc ) { err = ""Error<S2SV_blank>parsing<S2SV_blank>options"" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } s -> s_flags = flags ; rc = bdi_setup_and_register ( & sbi -> bdi , ""ecryptfs"" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = ""Reading<S2SV_blank>sb<S2SV_blank>failed"" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , ""kern_path()<S2SV_blank>failed\\n"" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR ""Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>"" ""eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>"" ""known<S2SV_blank>incompatibilities\\n"" ) ; goto out_free ; } <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_alloc_root ( inode ) ; if ( ! s -> s_root ) { iput ( inode ) ; rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; ecryptfs_set_dentry_lower ( s -> s_root , path . dentry ) ; ecryptfs_set_dentry_lower_mnt ( s -> s_root , path . mnt ) ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR ""%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , err , rc ) ; return ERR_PTR ( rc ) ; }","<S2SV_ModStart> path path ; uid_t check_ruid ; <S2SV_ModStart> sbi , raw_data , & check_ruid <S2SV_ModStart> out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }"
467,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { struct STRUCT_OR_UNION_3 * VAR_1 = VAR_2 ; struct STRUCT_OR_UNION_4 * VAR_3 ; TYPE_1 VAR_4 = VAR_5 -> VAR_6 & VAR_7 ; TYPE_2 VAR_8 ; if ( VAR_9 -> VAR_10 >= METHOD_1 ( VAR_11 ) ) return - VAR_12 ; VAR_13 = VAR_14 [ VAR_15 -> VAR_16 ] ; if ( VAR_17 == VAR_18 ) return - VAR_19 ; if ( VAR_20 ) return 0 ; VAR_21 = METHOD_2 ( sizeof ( * VAR_22 ) , VAR_23 ) ; if ( ! VAR_24 ) return - VAR_25 ; VAR_26 -> VAR_27 = VAR_28 ; VAR_29 -> STRUCT_OR_UNION_5 = STRUCT_OR_UNION_6 ; METHOD_3 ( & STRUCT_OR_UNION_7 -> VAR_30 ) ; VAR_31 = VAR_32 -> METHOD_4 ( VAR_33 , VAR_34 -> VAR_35 ) ; if ( VAR_36 < 0 ) { METHOD_5 ( & STRUCT_OR_UNION_8 -> VAR_37 ) ; METHOD_6 ( VAR_38 ) ; return VAR_39 ; } METHOD_7 ( & VAR_40 -> VAR_41 , & STRUCT_OR_UNION_9 -> VAR_42 ) ; METHOD_8 ( & STRUCT_OR_UNION_10 -> VAR_43 ) ; if ( VAR_44 -> METHOD_9 ) VAR_45 -> METHOD_10 ( VAR_46 ) ; <S2SV_StartBug> VAR_47 = METHOD_11 ( VAR_48 -> VAR_49 , & VAR_50 , VAR_51 , VAR_52 | VAR_53 ) ; <S2SV_EndBug> if ( VAR_54 < 0 ) { <S2SV_StartBug> METHOD_12 ( & STRUCT_OR_UNION_11 -> VAR_55 ) ; <S2SV_EndBug> METHOD_13 ( & VAR_56 -> VAR_57 ) ; METHOD_14 ( & STRUCT_OR_UNION_12 -> VAR_58 ) ; VAR_59 -> METHOD_15 ( VAR_60 ) ; return VAR_61 ; } <S2SV_StartBug> METHOD_16 ( STRUCT_OR_UNION_13 ) ; <S2SV_EndBug> VAR_62 -> VAR_63 = VAR_64 ; return 0 ; }",<S2SV_ModStart> VAR_60 ) ; METHOD_16 ( STRUCT_OR_UNION_13 ) ; <S2SV_ModStart> 0 ) { kvm_put_kvm ( STRUCT_OR_UNION_13 ) ; <S2SV_ModStart> VAR_64 ; } <S2SV_ModEnd> VAR_62 -> VAR_63,"CWE-362 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }",<S2SV_ModStart> dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> cd -> fd
468,"CWE-835 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 VAR_1 = 0 ; TYPE_3 unsigned TYPE_4 VAR_2 ; VAR_3 * VAR_4 ; TYPE_5 * VAR_5 = & VAR_6 ; if ( VAR_7 && VAR_8 -> VAR_9 ) { VAR_10 = VAR_11 -> VAR_12 ; VAR_13 -> VAR_14 = VAR_15 -> VAR_16 . VAR_17 ; } else return ; if ( VAR_18 -> VAR_19 == VAR_20 || VAR_21 -> VAR_22 . VAR_23 == VAR_24 ) return ; VAR_25 -> VAR_26 = VAR_27 -> VAR_28 ; if ( VAR_29 -> VAR_30 == VAR_31 ) goto VAR_32 ; switch ( VAR_33 -> VAR_34 ) { case VAR_35 : METHOD_1 ( VAR_36 , VAR_37 ) ; break ; case VAR_38 : METHOD_2 ( VAR_39 , VAR_40 ) ; break ; case VAR_41 : METHOD_3 ( VAR_42 , VAR_43 ) ; break ; case VAR_44 : METHOD_4 ( VAR_45 , VAR_46 ) ; break ; case VAR_47 : METHOD_5 ( VAR_48 , VAR_49 ) ; break ; case VAR_50 : METHOD_6 ( VAR_51 , VAR_52 ) ; break ; case VAR_53 : METHOD_7 ( VAR_54 , VAR_55 ) ; break ; case VAR_56 : METHOD_8 ( VAR_57 , VAR_58 ) ; break ; case VAR_59 : METHOD_9 ( VAR_60 , VAR_61 ) ; break ; case VAR_62 : METHOD_10 ( VAR_63 , VAR_64 ) ; break ; case VAR_65 : METHOD_11 ( VAR_66 , VAR_67 ) ; break ; case VAR_68 : METHOD_12 ( VAR_69 , VAR_70 ) ; break ; case VAR_71 : METHOD_13 ( VAR_72 , VAR_73 ) ; break ; case VAR_74 : METHOD_14 ( VAR_75 , VAR_76 ) ; break ; case VAR_77 : METHOD_15 ( VAR_78 , VAR_79 ) ; break ; case VAR_80 : METHOD_16 ( VAR_81 , VAR_82 ) ; break ; case VAR_83 : METHOD_17 ( VAR_84 , VAR_85 ) ; break ; case VAR_86 : METHOD_18 ( VAR_87 , VAR_88 ) ; break ; case VAR_89 : METHOD_19 ( VAR_90 , VAR_91 ) ; break ; case VAR_92 : METHOD_20 ( VAR_93 , VAR_94 ) ; break ; case VAR_95 : METHOD_21 ( VAR_96 , VAR_97 ) ; break ; case VAR_98 : METHOD_22 ( VAR_99 , VAR_100 ) ; break ; case VAR_101 : METHOD_23 ( VAR_102 , VAR_103 ) ; break ; case VAR_104 : METHOD_24 ( VAR_105 , VAR_106 ) ; break ; case VAR_107 : METHOD_25 ( VAR_108 , VAR_109 ) ; break ; case VAR_110 : METHOD_26 ( VAR_111 , VAR_112 ) ; break ; case VAR_113 : METHOD_27 ( VAR_114 , VAR_115 ) ; break ; case VAR_116 : METHOD_28 ( VAR_117 , VAR_118 ) ; break ; case VAR_119 : METHOD_29 ( VAR_120 , VAR_121 ) ; break ; case VAR_122 : METHOD_30 ( VAR_123 , VAR_124 ) ; break ; case VAR_125 : METHOD_31 ( VAR_126 , VAR_127 ) ; break ; case VAR_128 : METHOD_32 ( VAR_129 , VAR_130 ) ; break ; case VAR_131 : METHOD_33 ( VAR_132 , VAR_133 ) ; break ; case VAR_134 : METHOD_34 ( VAR_135 , VAR_136 ) ; break ; case VAR_137 : METHOD_35 ( VAR_138 , VAR_139 ) ; break ; case VAR_140 : METHOD_36 ( VAR_141 , VAR_142 ) ; break ; case VAR_143 : METHOD_37 ( VAR_144 , VAR_145 ) ; break ; case VAR_146 : METHOD_38 ( VAR_147 , VAR_148 ) ; break ; case VAR_149 : METHOD_39 ( VAR_150 , VAR_151 ) ; break ; case VAR_152 : METHOD_40 ( VAR_153 , VAR_154 ) ; break ; case VAR_155 : METHOD_41 ( VAR_156 , VAR_157 ) ; break ; case VAR_158 : METHOD_42 ( VAR_159 , VAR_160 ) ; break ; case VAR_161 : METHOD_43 ( VAR_162 , VAR_163 ) ; break ; case VAR_164 : METHOD_44 ( VAR_165 , VAR_166 ) ; break ; case VAR_167 : METHOD_45 ( VAR_168 , VAR_169 ) ; break ; case VAR_170 : METHOD_46 ( VAR_171 , VAR_172 ) ; break ; case VAR_173 : METHOD_47 ( VAR_174 , VAR_175 ) ; break ; case VAR_176 : METHOD_48 ( VAR_177 , VAR_178 ) ; break ; case VAR_179 : METHOD_49 ( VAR_180 , VAR_181 ) ; break ; case VAR_182 : METHOD_50 ( VAR_183 , VAR_184 ) ; break ; case VAR_185 : METHOD_51 ( VAR_186 , VAR_187 ) ; break ; case VAR_188 : METHOD_52 ( VAR_189 , VAR_190 ) ; break ; case VAR_191 : METHOD_53 ( VAR_192 , VAR_193 ) ; break ; case VAR_194 : METHOD_54 ( VAR_195 , VAR_196 ) ; break ; case VAR_197 : METHOD_55 ( VAR_198 , VAR_199 ) ; break ; case VAR_200 : METHOD_56 ( VAR_201 , VAR_202 ) ; break ; case VAR_203 : METHOD_57 ( VAR_204 , VAR_205 ) ; break ; case VAR_206 : METHOD_58 ( VAR_207 , VAR_208 ) ; break ; case VAR_209 : METHOD_59 ( VAR_210 , VAR_211 ) ; break ; case VAR_212 : METHOD_60 ( VAR_213 , VAR_214 ) ; break ; case VAR_215 : METHOD_61 ( VAR_216 , VAR_217 ) ; break ; case VAR_218 : METHOD_62 ( VAR_219 , VAR_220 ) ; break ; case VAR_221 : METHOD_63 ( VAR_222 , VAR_223 ) ; break ; case VAR_224 : METHOD_64 ( VAR_225 , VAR_226 ) ; break ; case VAR_227 : METHOD_65 ( VAR_228 , VAR_229 ) ; break ; case VAR_230 : METHOD_66 ( VAR_231 , VAR_232 ) ; break ; case VAR_233 : METHOD_67 ( VAR_234 , VAR_235 ) ; break ; case VAR_236 : METHOD_68 ( VAR_237 , VAR_238 ) ; break ; case VAR_239 : METHOD_69 ( VAR_240 , VAR_241 ) ; break ; case VAR_242 : METHOD_70 ( VAR_243 , VAR_244 ) ; break ; case VAR_245 : METHOD_71 ( VAR_246 , VAR_247 ) ; break ; case VAR_248 : METHOD_72 ( VAR_249 , VAR_250 ) ; break ; case VAR_251 : METHOD_73 ( VAR_252 , VAR_253 ) ; break ; case VAR_254 : METHOD_74 ( VAR_255 , VAR_256 ) ; break ; case VAR_257 : METHOD_75 ( VAR_258 , VAR_259 ) ; break ; TYPE_6 TYPE_7 case VAR_260 : METHOD_76 ( VAR_261 , VAR_262 ) ; break ; case VAR_263 : METHOD_77 ( VAR_264 , VAR_265 ) ; break ; case VAR_266 : METHOD_78 ( VAR_267 , VAR_268 ) ; break ; case VAR_269 : METHOD_79 ( VAR_270 , VAR_271 ) ; break ; default : if ( VAR_272 -> VAR_273 == VAR_274 -> VAR_275 -> VAR_276 ) { SINCE ( R_13 ) { METHOD_80 ( VAR_277 , VAR_278 ) ; } } else if ( ( VAR_279 = METHOD_81 ( VAR_280 -> VAR_281 , VAR_282 ) ) & VAR_283 ) { <S2SV_StartBug> TYPE_8 VAR_284 ; <S2SV_EndBug> TYPE_9 VAR_285 ; VAR_286 * VAR_287 ; VAR_288 : VAR_289 = 0 ; VAR_290 = VAR_291 -> VAR_292 - 500 ; VAR_293 = VAR_294 ; VAR_295 = VAR_296 -> VAR_297 ; if ( VAR_298 -> VAR_299 && VAR_300 >= 0 && VAR_301 < ( TYPE_10 ) VAR_302 -> VAR_303 ) { VAR_304 = & VAR_305 -> VAR_306 [ VAR_307 ] ; VAR_308 = VAR_309 ? METHOD_82 ( VAR_310 ) : 0 ; } <S2SV_StartBug> if ( VAR_311 -> VAR_312 == VAR_313 ) <S2SV_EndBug> { METHOD_83 ( VAR_314 , VAR_315 ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( VAR_316 -> VAR_317 == VAR_318 ) <S2SV_EndBug> { METHOD_84 ( VAR_319 , VAR_320 ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( VAR_321 && ! VAR_322 ) { METHOD_85 ( VAR_323 , VAR_324 ) ; } else if ( VAR_325 && VAR_326 ) { METHOD_86 ( VAR_327 , VAR_328 ) ; } else { METHOD_87 ( VAR_329 -> VAR_330 . VAR_331 ) ; } } } if ( VAR_332 -> VAR_333 & VAR_334 ) METHOD_88 ( VAR_335 -> VAR_336 ) ; VAR_337 -> VAR_338 = VAR_339 ; }",<S2SV_ModStart> VAR_283 ) { VAR_288 : <S2SV_ModEnd> if ( VAR_337 <S2SV_ModStart> -> VAR_317 == DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> METHOD_86 ( VAR_327 <S2SV_ModStart> VAR_337 ) ; <S2SV_ModEnd> else if ( <S2SV_ModStart> -> VAR_317 == DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> METHOD_85 ( VAR_327 <S2SV_ModStart> VAR_337 ) ; <S2SV_ModEnd> } } if,"CWE-835 void dwg_free_object ( Dwg_Object * obj ) { int error = 0 ; long unsigned int j ; Dwg_Data * dwg ; Bit_Chain * dat = & pdat ; if ( obj && obj -> parent ) { dwg = obj -> parent ; dat -> version = dwg -> header . version ; } else return ; if ( obj -> type == DWG_TYPE_FREED || obj -> tio . object == NULL ) return ; dat -> from_version = dat -> version ; if ( obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) goto unhandled ; switch ( obj -> type ) { case DWG_TYPE_TEXT : dwg_free_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : dwg_free_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : dwg_free_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : dwg_free_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : dwg_free_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : dwg_free_SEQEND ( dat , obj ) ; break ; case DWG_TYPE_INSERT : dwg_free_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : dwg_free_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : dwg_free_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : dwg_free_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : dwg_free_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : dwg_free_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : dwg_free_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : dwg_free_POLYLINE_2D ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_3D : dwg_free_POLYLINE_3D ( dat , obj ) ; break ; case DWG_TYPE_ARC : dwg_free_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : dwg_free_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : dwg_free_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : dwg_free_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : dwg_free_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : dwg_free_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : dwg_free_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : dwg_free_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : dwg_free_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : dwg_free_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : dwg_free_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : dwg_free__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : dwg_free_POLYLINE_PFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : dwg_free_POLYLINE_MESH ( dat , obj ) ; break ; case DWG_TYPE_SOLID : dwg_free_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : dwg_free_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : dwg_free_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : dwg_free_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : dwg_free_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : dwg_free_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : dwg_free_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : dwg_free__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : dwg_free_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : dwg_free_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : dwg_free_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : dwg_free_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : dwg_free_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : dwg_free_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : dwg_free_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : dwg_free_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : dwg_free_BLOCK_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_HEADER : dwg_free_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : dwg_free_LAYER_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LAYER : dwg_free_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : dwg_free_STYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_STYLE : dwg_free_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : dwg_free_LTYPE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LTYPE : dwg_free_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : dwg_free_VIEW_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VIEW : dwg_free_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : dwg_free_UCS_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_UCS : dwg_free_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : dwg_free_VPORT_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT : dwg_free_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : dwg_free_APPID_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_APPID : dwg_free_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : dwg_free_DIMSTYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE : dwg_free_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : dwg_free_VPORT_ENTITY_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_HEADER : dwg_free_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : dwg_free_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : dwg_free_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : dwg_free_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : dwg_free_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : dwg_free_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : dwg_free_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : dwg_free_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : dwg_free_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : dwg_free_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : dwg_free_OLEFRAME ( dat , obj ) ; break ;  ifdef DEBUG_VBA_PROJECT case DWG_TYPE_VBA_PROJECT : dwg_free_VBA_PROJECT ( dat , obj ) ; break ;   case DWG_TYPE_LAYOUT : dwg_free_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : dwg_free_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : dwg_free_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type ) { SINCE ( R_13 ) { dwg_free_LAYOUT ( dat , obj ) ; } } else if ( ( error = dwg_free_variable_type ( obj -> parent , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { <S2SV_StartBug> int is_entity ; <S2SV_EndBug> int i ; Dwg_Class * klass ; unhandled : is_entity = 0 ; i = obj -> type - 500 ; klass = NULL ; dwg = obj -> parent ; if ( dwg -> dwg_class && i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = klass ? dwg_class_is_entity ( klass ) : 0 ; } <S2SV_StartBug> if ( obj -> fixedtype == DWG_TYPE_TABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_ENT ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( klass && ! is_entity ) { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; } else if ( klass && is_entity ) { dwg_free_UNKNOWN_ENT ( dat , obj ) ; } else { FREE_IF ( obj -> tio . unknown ) ; } } } if ( dwg -> opts & DWG_OPTS_INDXF ) FREE_IF ( obj -> dxfname ) ; obj -> type = DWG_TYPE_FREED ; }",<S2SV_ModStart> DWG_ERR_UNHANDLEDCLASS ) { unhandled : <S2SV_ModEnd> if ( obj <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> dwg_free_UNKNOWN_ENT ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> else if ( <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> dwg_free_UNKNOWN_OBJ ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
469,"CWE-362 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , unsigned TYPE_2 VAR_1 ) { unsigned VAR_2 ; unsigned VAR_3 ; if ( VAR_4 >= METHOD_1 ( ) ) return - VAR_5 ; VAR_6 = METHOD_2 ( VAR_7 ) ; VAR_8 = METHOD_3 ( VAR_9 ) ; if ( VAR_10 [ VAR_11 ] == VAR_12 ) { if ( VAR_13 == - 1 ) return 0 ; VAR_14 [ VAR_15 ] = ( TYPE_3 * ) METHOD_4 ( VAR_16 ) ; if ( VAR_17 [ VAR_18 ] == VAR_19 ) return - VAR_20 ; METHOD_5 ( VAR_21 ) ; } <S2SV_StartBug> VAR_22 [ VAR_23 ] [ VAR_24 ] = VAR_25 ; <S2SV_EndBug> return 0 ; }","<S2SV_ModStart> ) ; } METHOD_6 ( <S2SV_ModStart> [ VAR_24 ] , VAR_25 ) <S2SV_ModEnd> ; return 0","CWE-362 static int set_evtchn_to_irq ( evtchn_port_t evtchn , unsigned int irq ) { unsigned row ; unsigned col ; if ( evtchn >= xen_evtchn_max_channels ( ) ) return - EINVAL ; row = EVTCHN_ROW ( evtchn ) ; col = EVTCHN_COL ( evtchn ) ; if ( evtchn_to_irq [ row ] == NULL ) { if ( irq == - 1 ) return 0 ; evtchn_to_irq [ row ] = ( int * ) get_zeroed_page ( GFP_KERNEL ) ; if ( evtchn_to_irq [ row ] == NULL ) return - ENOMEM ; clear_evtchn_to_irq_row ( row ) ; } <S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> return 0 ; }","<S2SV_ModStart> ) ; } WRITE_ONCE ( <S2SV_ModStart> [ col ] , irq ) <S2SV_ModEnd> ; return 0"
470,"CWE-310 TYPE_0 METHOD_0 ( TYPE_1 * METHOD_1 , TYPE_2 * VAR_0 , TYPE_3 * VAR_1 , TYPE_4 * VAR_2 , TYPE_5 * VAR_3 ) { TYPE_6 VAR_4 ; const TYPE_7 * VAR_5 ; unsigned TYPE_8 * VAR_6 , * VAR_7 = VAR_8 ; TYPE_9 VAR_9 = - 1 , VAR_10 , VAR_11 ; METHOD_2 ( & VAR_12 ) ; VAR_13 = METHOD_3 ( VAR_14 -> VAR_15 ) ; VAR_16 = METHOD_4 ( METHOD_5 ( VAR_17 ) ) ; if ( VAR_18 == VAR_19 ) { METHOD_6 ( VAR_20 , VAR_21 ) ; goto VAR_22 ; } <S2SV_StartBug> VAR_23 = METHOD_7 ( VAR_24 , VAR_25 ) ; <S2SV_EndBug> VAR_26 = METHOD_8 ( ( unsigned TYPE_10 ) VAR_27 ) ; if ( VAR_28 == VAR_29 ) { METHOD_9 ( VAR_30 , VAR_31 ) ; goto VAR_32 ; } VAR_33 = VAR_34 ; METHOD_10 ( VAR_35 , & VAR_36 ) ; VAR_37 = METHOD_11 ( & VAR_38 , VAR_39 , VAR_40 ) && METHOD_12 ( & VAR_41 , ( unsigned TYPE_11 * ) VAR_42 , VAR_43 ) ; METHOD_13 ( VAR_44 , ( unsigned TYPE_12 ) VAR_45 ) ; METHOD_14 ( VAR_46 ) ; if ( ! VAR_47 ) { METHOD_15 ( VAR_48 , VAR_49 ) ; goto VAR_50 ; } VAR_51 = - 1 ; if ( METHOD_16 ( & VAR_52 , ( unsigned TYPE_13 * ) VAR_53 -> VAR_54 , ( unsigned TYPE_14 ) VAR_55 -> VAR_56 , VAR_57 ) <= 0 ) { METHOD_17 ( VAR_58 , VAR_59 ) ; VAR_60 = 0 ; goto VAR_61 ; } VAR_62 = 1 ; VAR_63 : METHOD_18 ( & VAR_64 ) ; return ( VAR_65 ) ; }","<S2SV_ModStart> VAR_63 ; } if ( VAR_55 -> VAR_39 == VAR_66 && VAR_55 -> VAR_67 & 0x7 ) { METHOD_17 ( VAR_58 , VAR_68 ) ; goto VAR_63 ; }","CWE-310 int ASN1_verify ( i2d_of_void * i2d , X509_ALGOR * a , ASN1_BIT_STRING * signature , char * data , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; const EVP_MD * type ; unsigned char * p , * buf_in = NULL ; int ret = - 1 , i , inl ; EVP_MD_CTX_init ( & ctx ) ; i = OBJ_obj2nid ( a -> algorithm ) ; type = EVP_get_digestbyname ( OBJ_nid2sn ( i ) ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } <S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } p = buf_in ; i2d ( data , & p ) ; ret = EVP_VerifyInit_ex ( & ctx , type , NULL ) && EVP_VerifyUpdate ( & ctx , ( unsigned char * ) buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_VerifyFinal ( & ctx , ( unsigned char * ) signature -> data , ( unsigned int ) signature -> length , pkey ) <= 0 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }","<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }"
471,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { if ( ( VAR_2 & VAR_3 ) == VAR_4 && ( VAR_5 & VAR_6 ) == VAR_7 ) { METHOD_1 ( VAR_8 , <S2SV_StartBug> 1 , 0 , VAR_9 , 0 ) ; <S2SV_EndBug> return 0 ; } return - 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> VAR_9 , 0","CWE-400 static int simulate_sync ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == SPEC0 && ( opcode & FUNC ) == SYNC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return 0 ; } return - 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0"
472,"CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 ( * METHOD_1 ) ( TYPE_2 * VAR_2 , TYPE_3 * VAR_3 ) , TYPE_4 * VAR_4 ) { struct STRUCT_OR_UNION_2 * VAR_5 , * VAR_6 ; struct STRUCT_OR_UNION_3 * VAR_7 , * VAR_8 ; struct STRUCT_OR_UNION_4 * VAR_9 ; struct STRUCT_OR_UNION_5 * VAR_10 , * VAR_11 ; struct STRUCT_OR_UNION_6 * VAR_12 , * VAR_13 , * * VAR_14 ; unsigned TYPE_5 VAR_15 ; TYPE_6 VAR_16 , VAR_17 , VAR_18 , VAR_19 , VAR_20 ; METHOD_2 ( ""-->%s()\\n"" , VAR_21 ) ; if ( ! VAR_22 -> VAR_23 ) return 0 ; VAR_24 = METHOD_3 ( sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_25 ) ; if ( ! VAR_26 ) return - VAR_27 ; VAR_28 -> VAR_29 = VAR_30 ; VAR_31 -> VAR_32 = VAR_33 ; VAR_34 -> VAR_35 = VAR_36 ; VAR_37 -> VAR_38 [ 0 ] . VAR_39 = & VAR_40 -> VAR_41 ; VAR_42 -> VAR_43 = VAR_44 -> VAR_45 ; VAR_46 = VAR_47 = VAR_48 ; VAR_49 = & VAR_50 ; VAR_51 = VAR_52 -> VAR_53 ; VAR_54 : if ( METHOD_4 ( VAR_55 ) ) { VAR_56 = METHOD_5 ( VAR_57 ) ; VAR_58 = METHOD_6 ( VAR_59 -> VAR_60 , VAR_61 ) ; VAR_62 >>= VAR_63 ; VAR_64 = METHOD_7 ( sizeof ( struct STRUCT_OR_UNION_8 ) + VAR_65 * sizeof ( unsigned TYPE_7 ) , VAR_66 ) ; if ( ! VAR_67 ) goto VAR_68 ; METHOD_8 ( ""dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , VAR_69 , VAR_70 ) ; METHOD_9 ( VAR_71 , VAR_72 , ( sizeof ( struct STRUCT_OR_UNION_9 ) + VAR_73 * sizeof ( unsigned TYPE_8 ) ) ) ; VAR_74 -> VAR_75 = VAR_76 ; VAR_77 -> VAR_78 = VAR_79 -> VAR_80 ; * VAR_81 = VAR_82 = METHOD_10 ( VAR_83 ) ; VAR_84 = & VAR_85 -> VAR_86 ; VAR_87 = VAR_88 -> VAR_89 ; } VAR_90 = METHOD_11 ( VAR_91 ) ; VAR_92 = METHOD_12 ( sizeof ( struct STRUCT_OR_UNION_10 ) , VAR_93 ) ; if ( ! VAR_94 ) goto VAR_95 ; METHOD_13 ( ""dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , VAR_96 , VAR_97 ) ; VAR_98 -> VAR_99 = VAR_100 ; VAR_101 -> VAR_102 = VAR_103 -> VAR_104 ; * VAR_105 = VAR_106 = METHOD_14 ( VAR_107 ) ; VAR_108 = VAR_109 ; VAR_110 = 0 ; VAR_111 : for ( ; VAR_112 < VAR_113 ; VAR_114 ++ ) { VAR_115 = VAR_116 -> VAR_117 [ VAR_118 ] ; if ( ! VAR_119 ) continue ; if ( METHOD_15 ( VAR_120 ) ) { if ( METHOD_16 ( METHOD_17 ( VAR_121 ) , VAR_122 ) ) VAR_123 -> VAR_124 [ VAR_125 ] = VAR_126 ; continue ; } VAR_127 = & VAR_128 -> VAR_129 [ VAR_130 ] ; VAR_131 = VAR_132 ; goto VAR_133 ; } METHOD_18 ( ""--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\n"" , VAR_134 ) ; VAR_135 -> VAR_136 = 0 ; VAR_137 = 0 ; for ( VAR_138 = 0 ; VAR_139 < VAR_140 ; VAR_141 ++ ) { VAR_142 = VAR_143 -> VAR_144 [ VAR_145 ] ; if ( ! VAR_146 ) VAR_147 ++ ; else if ( METHOD_19 ( VAR_148 ) ) VAR_149 -> VAR_150 ++ ; } METHOD_20 ( ""free=%d,<S2SV_blank>leaves=%lu\\n"" , VAR_151 , VAR_152 -> VAR_153 ) ; VAR_154 = 0 ; for ( VAR_155 = 0 ; VAR_156 < VAR_157 ; VAR_158 ++ ) { struct STRUCT_OR_UNION_11 * VAR_159 ; struct STRUCT_OR_UNION_12 * VAR_160 ; VAR_161 = VAR_162 -> VAR_163 [ VAR_164 ] ; if ( ! VAR_165 || METHOD_21 ( VAR_166 ) ) continue ; VAR_167 = VAR_168 ; if ( METHOD_22 ( VAR_169 ) ) { VAR_170 = METHOD_23 ( VAR_171 ) ; VAR_172 = VAR_173 -> VAR_174 ; } VAR_175 = METHOD_24 ( VAR_176 ) ; VAR_177 -> VAR_178 += VAR_179 -> VAR_180 ; if ( VAR_181 -> VAR_182 <= VAR_183 + 1 ) { METHOD_25 ( ""[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , VAR_184 , VAR_185 -> VAR_186 , VAR_187 + 1 , VAR_188 ) ; METHOD_26 ( VAR_189 ) ; VAR_190 -> VAR_191 [ VAR_192 ] = VAR_193 ; VAR_194 ++ ; if ( VAR_195 < VAR_196 ) VAR_197 = VAR_198 ; for ( VAR_199 = 0 ; VAR_200 < VAR_201 ; VAR_202 ++ ) { struct STRUCT_OR_UNION_13 * VAR_203 = VAR_204 -> VAR_205 [ VAR_206 ] ; if ( ! VAR_207 ) continue ; METHOD_27 ( METHOD_28 ( VAR_208 ) ) ; while ( VAR_209 -> VAR_210 [ VAR_211 ] ) VAR_212 ++ ; METHOD_29 ( VAR_213 >= VAR_214 ) ; VAR_215 -> VAR_216 [ VAR_217 ++ ] = VAR_218 ; VAR_219 -- ; } METHOD_30 ( VAR_220 ) ; } else { METHOD_31 ( ""[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , VAR_221 , VAR_222 -> VAR_223 , VAR_224 + 1 , VAR_225 ) ; } } METHOD_32 ( ""after:<S2SV_blank>%lu\\n"" , VAR_226 -> VAR_227 ) ; VAR_228 = VAR_229 -> VAR_230 ; if ( VAR_231 == VAR_232 - 1 ) { for ( VAR_233 = 0 ; VAR_234 < VAR_235 ; VAR_236 ++ ) if ( ( VAR_237 = VAR_238 -> VAR_239 [ VAR_240 ] ) ) break ; if ( METHOD_33 ( VAR_241 ) && METHOD_34 ( VAR_242 ) ) { METHOD_35 ( ""excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\n"" , VAR_243 ) ; VAR_244 = METHOD_36 ( VAR_245 ) ; VAR_246 = VAR_247 -> VAR_248 ; VAR_249 = VAR_250 -> VAR_251 ; METHOD_37 ( VAR_252 ) ; if ( ! VAR_253 ) { VAR_254 -> VAR_255 = VAR_256 ; VAR_257 -> VAR_258 = 0 ; VAR_259 = VAR_260 ; goto VAR_261 ; } if ( METHOD_38 ( VAR_262 ) ) { struct STRUCT_OR_UNION_14 * VAR_263 = METHOD_39 ( VAR_264 ) ; METHOD_40 ( ""excise<S2SV_blank>preceding<S2SV_blank>shortcut\\n"" ) ; VAR_265 = VAR_266 -> VAR_267 = VAR_268 -> VAR_269 ; VAR_270 = VAR_271 -> VAR_272 = VAR_273 -> VAR_274 ; METHOD_41 ( VAR_275 ) ; if ( ! VAR_276 ) { VAR_277 -> VAR_278 = VAR_279 ; VAR_280 -> VAR_281 = 0 ; VAR_282 = VAR_283 ; goto VAR_284 ; } } VAR_285 -> VAR_286 = VAR_287 ; VAR_288 -> VAR_289 = VAR_290 ; VAR_291 = METHOD_42 ( VAR_292 ) ; VAR_293 -> VAR_294 [ VAR_295 ] = VAR_296 ; goto VAR_297 ; } } VAR_298 = VAR_299 -> VAR_300 ; if ( ! VAR_301 ) goto VAR_302 ; if ( METHOD_43 ( VAR_303 ) ) { VAR_304 = METHOD_44 ( VAR_305 ) ; VAR_306 = VAR_307 -> VAR_308 ; VAR_309 = VAR_310 -> VAR_311 ; if ( VAR_312 -> VAR_313 <= VAR_314 ) { struct STRUCT_OR_UNION_15 * VAR_315 ; METHOD_45 ( ""excise<S2SV_blank>shortcut\\n"" ) ; VAR_316 -> VAR_317 = VAR_318 ; VAR_319 -> VAR_320 = VAR_321 ; METHOD_46 ( VAR_322 ) ; if ( ! VAR_323 ) { VAR_324 = METHOD_47 ( VAR_325 ) ; goto VAR_326 ; } VAR_327 = METHOD_48 ( VAR_328 ) ; VAR_329 -> VAR_330 [ VAR_331 ] = METHOD_49 ( VAR_332 ) ; } } else { VAR_333 = VAR_334 ; } VAR_335 = METHOD_50 ( VAR_336 ) ; VAR_337 : VAR_338 = VAR_339 -> VAR_340 ; if ( METHOD_51 ( VAR_341 ) ) { VAR_342 = METHOD_52 ( VAR_343 ) ; VAR_344 = VAR_345 -> VAR_346 ; VAR_347 = VAR_348 -> VAR_349 ; <S2SV_StartBug> } else { <S2SV_EndBug> VAR_350 = VAR_351 -> VAR_352 ; VAR_353 = VAR_354 ; } <S2SV_StartBug> METHOD_53 ( ! VAR_355 ) ; <S2SV_EndBug> VAR_356 = METHOD_54 ( VAR_357 ) ; VAR_358 ++ ; goto VAR_359 ; VAR_360 : VAR_361 -> VAR_362 [ 0 ] . VAR_363 = VAR_364 ; METHOD_55 ( VAR_365 ) ; VAR_366 -> VAR_367 = VAR_368 ; return 0 ; VAR_369 : METHOD_56 ( ""enomem\\n"" ) ; METHOD_57 ( VAR_370 , VAR_371 -> VAR_372 ) ; METHOD_58 ( VAR_373 ) ; return - VAR_374 ; }",<S2SV_ModStart> -> VAR_349 ; if ( ! VAR_357 ) goto VAR_360 ; <S2SV_ModStart> METHOD_53 ( ! VAR_357 <S2SV_ModEnd> ) ; VAR_356,"CWE-000 int assoc_array_gc ( struct assoc_array * array , const struct assoc_array_ops * ops , bool ( * iterator ) ( void * object , void * iterator_data ) , void * iterator_data ) { struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; unsigned long nr_leaves_on_tree ; int keylen , slot , nr_free , next_slot , i ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; if ( ! array -> root ) return 0 ; edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; if ( ! edit ) return - ENOMEM ; edit -> array = array ; edit -> ops = ops ; edit -> ops_for_excised_subtree = ops ; edit -> set [ 0 ] . ptr = & array -> root ; edit -> excised_subtree = array -> root ; new_root = new_parent = NULL ; new_ptr_pp = & new_root ; cursor = array -> root ; descend : if ( assoc_array_ptr_is_shortcut ( cursor ) ) { shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s ) goto enomem ; pr_devel ( ""dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , shortcut , new_s ) ; memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ) ; new_s -> back_pointer = new_parent ; new_s -> parent_slot = shortcut -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; new_ptr_pp = & new_s -> next_node ; cursor = shortcut -> next_node ; } node = assoc_array_ptr_to_node ( cursor ) ; new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n ) goto enomem ; pr_devel ( ""dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , node , new_n ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = node -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; new_ptr_pp = NULL ; slot = 0 ; continue_node : for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = node -> slots [ slot ] ; if ( ! ptr ) continue ; if ( assoc_array_ptr_is_leaf ( ptr ) ) { if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) ) new_n -> slots [ slot ] = ptr ; continue ; } new_ptr_pp = & new_n -> slots [ slot ] ; cursor = ptr ; goto descend ; } pr_devel ( ""--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\n"" , new_n ) ; new_n -> nr_leaves_on_branch = 0 ; nr_free = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = new_n -> slots [ slot ] ; if ( ! ptr ) nr_free ++ ; else if ( assoc_array_ptr_is_leaf ( ptr ) ) new_n -> nr_leaves_on_branch ++ ; } pr_devel ( ""free=%d,<S2SV_blank>leaves=%lu\\n"" , nr_free , new_n -> nr_leaves_on_branch ) ; next_slot = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ] ; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) continue ; s = NULL ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { s = assoc_array_ptr_to_shortcut ( ptr ) ; ptr = s -> next_node ; } child = assoc_array_ptr_to_node ( ptr ) ; new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { pr_devel ( ""[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; BUG_ON ( s ) ; new_n -> slots [ slot ] = NULL ; nr_free ++ ; if ( slot < next_slot ) next_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p ) continue ; BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; while ( new_n -> slots [ next_slot ] ) next_slot ++ ; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n -> slots [ next_slot ++ ] = p ; nr_free -- ; } kfree ( child ) ; } else { pr_devel ( ""[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; } } pr_devel ( ""after:<S2SV_blank>%lu\\n"" , new_n -> nr_leaves_on_branch ) ; nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) if ( ( ptr = new_n -> slots [ slot ] ) ) break ; if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) ) { pr_devel ( ""excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\n"" , new_n ) ; new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_n -> back_pointer ; slot = new_n -> parent_slot ; kfree ( new_n ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; pr_devel ( ""excise<S2SV_blank>preceding<S2SV_blank>shortcut\\n"" ) ; new_parent = new_s -> back_pointer = s -> back_pointer ; slot = new_s -> parent_slot = s -> parent_slot ; kfree ( s ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } } new_s -> back_pointer = new_parent ; new_s -> parent_slot = slot ; new_n = assoc_array_ptr_to_node ( new_parent ) ; new_n -> slots [ slot ] = ptr ; goto ascend_old_tree ; } } ptr = new_n -> back_pointer ; if ( ! ptr ) goto gc_complete ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_s -> back_pointer ; slot = new_s -> parent_slot ; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { struct assoc_array_node * n ; pr_devel ( ""excise<S2SV_blank>shortcut\\n"" ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = slot ; kfree ( new_s ) ; if ( ! new_parent ) { new_root = assoc_array_node_to_ptr ( new_n ) ; goto gc_complete ; } n = assoc_array_ptr_to_node ( new_parent ) ; n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; } } else { new_parent = ptr ; } new_n = assoc_array_ptr_to_node ( new_parent ) ; ascend_old_tree : ptr = node -> back_pointer ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; slot = shortcut -> parent_slot ; cursor = shortcut -> back_pointer ; <S2SV_StartBug> } else { <S2SV_EndBug> slot = node -> parent_slot ; cursor = ptr ; } <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> node = assoc_array_ptr_to_node ( cursor ) ; slot ++ ; goto continue_node ; gc_complete : edit -> set [ 0 ] . to = new_root ; assoc_array_apply_edit ( edit ) ; array -> nr_leaves_on_tree = nr_leaves_on_tree ; return 0 ; enomem : pr_devel ( ""enomem\\n"" ) ; assoc_array_destroy_subtree ( new_root , edit -> ops ) ; kfree ( edit ) ; return - ENOMEM ; }",<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node
473,"CWE-362 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { struct STRUCT_OR_UNION_1 * VAR_2 = VAR_3 -> VAR_4 ; struct STRUCT_OR_UNION_2 * VAR_5 , * VAR_6 , * VAR_7 ; TYPE_2 VAR_8 ; struct STRUCT_OR_UNION_3 STRUCT_OR_UNION_4 ; struct STRUCT_OR_UNION_5 TYPE_3 * VAR_9 ; unsigned TYPE_4 VAR_10 , VAR_11 ; TYPE_5 VAR_12 ; TYPE_6 VAR_13 ; unsigned TYPE_7 VAR_14 , VAR_15 , VAR_16 ; VAR_17 = ( struct STRUCT_OR_UNION_6 TYPE_8 * ) VAR_18 ; VAR_19 = - VAR_20 ; if ( METHOD_1 ( & STRUCT_OR_UNION_7 , VAR_21 , sizeof ( STRUCT_OR_UNION_8 ) - sizeof ( VAR_22 ) ) ) goto VAR_23 ; VAR_24 = - VAR_25 ; if ( ! STRUCT_OR_UNION_9 . VAR_26 ) goto VAR_27 ; if ( STRUCT_OR_UNION_10 . VAR_28 & ~ ( VAR_29 | VAR_30 ) ) goto VAR_31 ; VAR_32 = 0 ; if ( STRUCT_OR_UNION_11 . VAR_33 & VAR_34 ) VAR_35 |= VAR_36 ; if ( STRUCT_OR_UNION_12 . VAR_37 & VAR_38 ) { VAR_39 |= VAR_40 ; VAR_41 = - VAR_42 ; goto VAR_43 ; } VAR_44 = METHOD_2 ( VAR_45 , STRUCT_OR_UNION_13 . VAR_46 . VAR_47 , STRUCT_OR_UNION_14 . VAR_48 . VAR_49 ) ; if ( VAR_50 ) goto VAR_51 ; VAR_52 = STRUCT_OR_UNION_15 . VAR_53 . VAR_54 ; VAR_55 = VAR_56 + STRUCT_OR_UNION_16 . VAR_57 . VAR_58 ; VAR_59 = - VAR_60 ; if ( ! METHOD_3 ( VAR_61 ) ) goto VAR_62 ; <S2SV_StartBug> METHOD_4 ( & VAR_63 -> VAR_64 ) ; <S2SV_EndBug> VAR_65 = METHOD_5 ( VAR_66 , VAR_67 , & VAR_68 ) ; if ( ! VAR_69 ) goto VAR_70 ; VAR_71 = - VAR_72 ; if ( VAR_73 -> VAR_74 >= VAR_75 ) goto VAR_76 ; if ( METHOD_6 ( VAR_77 ) ) { unsigned TYPE_9 VAR_78 = METHOD_7 ( VAR_79 ) ; if ( VAR_80 & ( VAR_81 - 1 ) ) goto VAR_82 ; } VAR_83 = VAR_84 ; VAR_85 = VAR_86 ; for ( VAR_87 = VAR_88 ; VAR_89 && VAR_90 -> VAR_91 < VAR_92 ; VAR_93 = VAR_94 -> VAR_95 ) { METHOD_8 ( ) ; METHOD_9 ( ! ! VAR_96 -> STRUCT_OR_UNION_17 . VAR_97 ^ ! ! ( VAR_98 -> VAR_99 & ( VAR_100 | VAR_101 ) ) ) ; VAR_102 = - VAR_103 ; if ( ! METHOD_10 ( VAR_104 ) ) goto VAR_105 ; VAR_106 = - VAR_107 ; if ( METHOD_11 ( ! ( VAR_108 -> VAR_109 & VAR_110 ) ) ) goto VAR_111 ; if ( METHOD_12 ( VAR_112 ) && VAR_113 <= VAR_114 -> VAR_115 && VAR_116 > VAR_117 -> VAR_118 ) { unsigned TYPE_10 VAR_119 = METHOD_13 ( VAR_120 ) ; VAR_121 = - VAR_122 ; if ( VAR_123 & ( VAR_124 - 1 ) ) goto VAR_125 ; } VAR_126 = - VAR_127 ; if ( VAR_128 -> STRUCT_OR_UNION_18 . VAR_129 && VAR_130 -> STRUCT_OR_UNION_19 . VAR_131 != VAR_132 ) goto VAR_133 ; if ( METHOD_14 ( VAR_134 ) ) VAR_135 = VAR_136 ; VAR_137 = VAR_138 ; } METHOD_15 ( ! VAR_139 ) ; if ( VAR_140 -> VAR_141 < VAR_142 ) VAR_143 = VAR_144 ; VAR_145 = 0 ; do { METHOD_16 ( ) ; METHOD_17 ( ! METHOD_18 ( VAR_146 ) ) ; METHOD_19 ( VAR_147 -> STRUCT_OR_UNION_20 . VAR_148 && VAR_149 -> STRUCT_OR_UNION_21 . VAR_150 != VAR_151 ) ; METHOD_20 ( ! ( VAR_152 -> VAR_153 & VAR_154 ) ) ; if ( VAR_155 -> STRUCT_OR_UNION_22 . VAR_156 == VAR_157 && ( VAR_158 -> VAR_159 & VAR_160 ) == VAR_161 ) goto VAR_162 ; if ( VAR_163 -> VAR_164 > VAR_165 ) VAR_166 = VAR_167 -> VAR_168 ; VAR_169 = METHOD_21 ( VAR_170 , VAR_171 -> VAR_172 ) ; VAR_173 = ( VAR_174 -> VAR_175 & ~ VAR_176 ) | VAR_177 ; VAR_178 = METHOD_22 ( VAR_179 , VAR_180 , VAR_181 , VAR_182 , VAR_183 , VAR_184 -> VAR_185 , VAR_186 -> VAR_187 , VAR_188 -> VAR_189 , METHOD_23 ( VAR_190 ) , ( ( struct STRUCT_OR_UNION_23 ) { VAR_191 } ) ) ; if ( VAR_192 ) { VAR_193 = VAR_194 ; goto VAR_195 ; } if ( VAR_196 -> VAR_197 < VAR_198 ) { VAR_199 = METHOD_24 ( VAR_200 , VAR_201 , VAR_202 , 1 ) ; if ( VAR_203 ) break ; } if ( VAR_204 -> VAR_205 > VAR_206 ) { VAR_207 = METHOD_25 ( VAR_208 , VAR_209 , VAR_210 , 0 ) ; if ( VAR_211 ) break ; } VAR_212 : VAR_213 -> VAR_214 = VAR_215 ; VAR_216 -> STRUCT_OR_UNION_24 . VAR_217 = VAR_218 ; VAR_219 : VAR_220 = VAR_221 ; VAR_222 = VAR_223 -> VAR_224 ; VAR_225 = VAR_226 -> VAR_227 ; } while ( VAR_228 && VAR_229 -> VAR_230 < VAR_231 ) ; VAR_232 : METHOD_26 ( & VAR_233 -> VAR_234 ) ; METHOD_27 ( VAR_235 ) ; if ( ! VAR_236 ) { if ( METHOD_28 ( VAR_237 ? VAR_238 : VAR_239 , & VAR_240 -> VAR_241 ) ) VAR_242 = - VAR_243 ; } VAR_244 : return VAR_245 ; }",<S2SV_ModStart> -> VAR_234 ) ; if ( ! METHOD_29 ( VAR_235 ) ) goto VAR_232,"CWE-362 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }",<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
474,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , const TYPE_1 * VAR_2 , struct STRUCT_OR_UNION_2 * VAR_3 ) { struct STRUCT_OR_UNION_3 * VAR_4 , * VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 , * VAR_7 , * VAR_8 , * VAR_9 ; struct STRUCT_OR_UNION_5 * VAR_10 ; unsigned TYPE_2 VAR_11 , VAR_12 , VAR_13 ; TYPE_3 VAR_14 ; TYPE_4 VAR_15 ; TYPE_5 VAR_16 , VAR_17 ; TYPE_6 VAR_18 , VAR_19 , VAR_20 , VAR_21 , VAR_22 ; VAR_23 = VAR_24 -> VAR_25 . VAR_26 ; VAR_27 = VAR_28 -> VAR_29 . VAR_30 ; VAR_31 -> VAR_32 [ VAR_33 ] = VAR_34 -> VAR_35 . VAR_36 ; METHOD_1 ( ""-->%s()\\n"" , VAR_37 ) ; VAR_38 = - 1 ; for ( VAR_39 = 0 ; VAR_40 < VAR_41 ; VAR_42 ++ ) { VAR_43 = VAR_44 -> VAR_45 [ VAR_46 ] ; if ( ! VAR_47 ) { VAR_48 = VAR_49 ; continue ; } if ( METHOD_2 ( VAR_50 ) && VAR_51 -> METHOD_3 ( METHOD_4 ( VAR_52 ) , VAR_53 ) ) { METHOD_5 ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n"" , VAR_54 ) ; VAR_55 -> VAR_56 = & VAR_57 -> VAR_58 [ VAR_59 ] ; VAR_60 -> VAR_61 = VAR_62 -> VAR_63 [ VAR_64 ] ; METHOD_6 ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n"" , VAR_65 ) ; return VAR_66 ; } } if ( VAR_67 >= 0 ) { METHOD_7 ( ""insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n"" , VAR_68 ) ; VAR_69 -> VAR_70 = & VAR_71 -> VAR_72 [ VAR_73 ] ; VAR_74 -> VAR_75 = VAR_76 ; METHOD_8 ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n"" , VAR_77 ) ; return VAR_78 ; } VAR_79 = METHOD_9 ( sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_80 ) ; if ( ! VAR_81 ) return VAR_82 ; VAR_83 -> VAR_84 [ 0 ] = METHOD_10 ( VAR_85 ) ; VAR_86 = METHOD_11 ( sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_87 ) ; if ( ! VAR_88 ) return VAR_89 ; VAR_90 -> VAR_91 [ 1 ] = METHOD_12 ( VAR_92 ) ; METHOD_13 ( ""no<S2SV_blank>spare<S2SV_blank>slots\\n"" ) ; VAR_93 = VAR_94 ; for ( VAR_95 = 0 ; VAR_96 < VAR_97 ; VAR_98 ++ ) { VAR_99 = VAR_100 -> VAR_101 [ VAR_102 ] ; if ( METHOD_14 ( VAR_103 ) ) { VAR_104 -> VAR_105 [ VAR_106 ] = 0xff ; VAR_107 = VAR_108 ; continue ; } VAR_109 = VAR_110 -> METHOD_15 ( METHOD_16 ( VAR_111 ) , VAR_112 ) ; VAR_113 >>= VAR_114 & VAR_115 ; VAR_116 -> VAR_117 [ VAR_118 ] = VAR_119 & VAR_120 ; } if ( VAR_121 ) { METHOD_17 ( ""have<S2SV_blank>meta\\n"" ) ; goto VAR_122 ; } VAR_123 = 0 ; VAR_124 = VAR_125 -> VAR_126 [ 0 ] ; for ( VAR_127 = 1 ; VAR_128 < VAR_129 ; VAR_130 ++ ) VAR_131 |= VAR_132 -> VAR_133 [ VAR_134 ] ^ VAR_135 ; METHOD_18 ( ""only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n"" , VAR_136 ) ; if ( ( VAR_137 & VAR_138 ) == 0 ) { if ( ( VAR_139 -> VAR_140 [ VAR_141 ] ^ VAR_142 ) == 0 ) goto VAR_143 ; <S2SV_StartBug> goto VAR_144 ; <S2SV_EndBug> } VAR_145 : METHOD_19 ( ""split<S2SV_blank>node\\n"" ) ; VAR_146 -> VAR_147 [ 0 ] . VAR_148 = METHOD_20 ( VAR_149 ) ; VAR_150 -> VAR_151 = VAR_152 -> VAR_153 ; VAR_154 -> VAR_155 = VAR_156 -> VAR_157 ; VAR_158 -> VAR_159 = METHOD_21 ( VAR_160 ) ; VAR_161 -> VAR_162 = - 1 ; VAR_163 : METHOD_22 ( ""do_split_node\\n"" ) ; VAR_164 -> VAR_165 = VAR_166 -> VAR_167 ; VAR_168 -> VAR_169 = 0 ; for ( VAR_170 = 0 ; VAR_171 < VAR_172 ; VAR_173 ++ ) { VAR_174 = VAR_175 -> VAR_176 [ VAR_177 ] ; if ( VAR_178 != 0xff ) for ( VAR_179 = VAR_180 + 1 ; VAR_181 < VAR_182 + 1 ; VAR_183 ++ ) if ( VAR_184 -> VAR_185 [ VAR_186 ] == VAR_187 ) goto VAR_188 ; } VAR_189 : METHOD_23 ( ""same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n"" , VAR_190 , VAR_191 , VAR_192 ) ; METHOD_24 ( VAR_193 >= VAR_194 ) ; METHOD_25 ( VAR_195 >= VAR_196 + 1 ) ; METHOD_26 ( VAR_197 >= VAR_198 ) ; VAR_199 -> VAR_200 = VAR_201 ; for ( VAR_202 = 0 ; VAR_203 < VAR_204 ; VAR_205 ++ ) if ( METHOD_27 ( VAR_206 -> VAR_207 [ VAR_208 ] ) ) VAR_209 -> VAR_210 [ VAR_211 ] = VAR_212 -> VAR_213 [ VAR_214 ] ; else VAR_215 -> VAR_216 [ VAR_217 ] = VAR_218 ; METHOD_28 ( VAR_219 -> VAR_220 [ VAR_221 ] != VAR_222 ) ; VAR_223 -> VAR_224 [ VAR_225 ] = METHOD_29 ( VAR_226 ) ; VAR_227 = - 1 ; VAR_228 = 0 ; for ( VAR_229 = 0 ; VAR_230 < VAR_231 ; VAR_232 ++ ) { if ( METHOD_30 ( VAR_233 -> VAR_234 [ VAR_235 ] ) ) continue ; if ( VAR_236 -> VAR_237 [ VAR_238 ] == VAR_239 ) { VAR_240 -> VAR_241 [ VAR_242 ++ ] = VAR_243 -> VAR_244 [ VAR_245 ] ; VAR_246 -> VAR_247 ++ ; } else { do { VAR_248 ++ ; } while ( VAR_249 -> VAR_250 [ VAR_251 ] != VAR_252 ) ; VAR_253 -> VAR_254 [ VAR_255 ] = VAR_256 -> VAR_257 [ VAR_258 ] ; } } METHOD_31 ( ""filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n"" , VAR_259 , VAR_260 ) ; if ( VAR_261 -> VAR_262 [ VAR_263 ] != VAR_264 ) { do { VAR_265 ++ ; } while ( VAR_266 -> VAR_267 [ VAR_268 ] != VAR_269 ) ; VAR_270 -> VAR_271 = & VAR_272 -> VAR_273 [ VAR_274 ] ; VAR_275 -> VAR_276 = VAR_277 ; } else { VAR_278 -> VAR_279 = & VAR_280 -> VAR_281 [ VAR_282 ++ ] ; VAR_283 -> VAR_284 = VAR_285 ; } METHOD_32 ( VAR_286 <= 1 ) ; VAR_287 -> VAR_288 = METHOD_33 ( VAR_289 ) ; for ( VAR_290 = 0 ; VAR_291 < VAR_292 ; VAR_293 ++ ) { if ( VAR_294 -> VAR_295 [ VAR_296 ] == 0xff ) { VAR_297 = VAR_298 -> VAR_299 [ VAR_300 ] ; METHOD_34 ( METHOD_35 ( VAR_301 ) ) ; if ( METHOD_36 ( VAR_302 ) ) { VAR_303 = METHOD_37 ( VAR_304 ) ; VAR_305 -> VAR_306 [ VAR_307 ] = & VAR_308 -> VAR_309 ; } else { VAR_310 = METHOD_38 ( VAR_311 ) ; VAR_312 -> VAR_313 [ VAR_314 ] = & VAR_315 -> VAR_316 ; } } } VAR_317 = VAR_318 -> VAR_319 ; if ( ! VAR_320 ) VAR_321 -> VAR_322 [ 0 ] . VAR_323 = & VAR_324 -> VAR_325 -> VAR_326 ; else if ( METHOD_39 ( VAR_327 ) ) VAR_328 -> VAR_329 [ 0 ] . VAR_330 = & METHOD_40 ( VAR_331 ) -> VAR_332 [ VAR_333 -> VAR_334 ] ; else VAR_335 -> VAR_336 [ 0 ] . VAR_337 = & METHOD_41 ( VAR_338 ) -> VAR_339 ; VAR_340 -> VAR_341 [ 0 ] = METHOD_42 ( VAR_342 ) ; METHOD_43 ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n"" , VAR_343 ) ; return VAR_344 ; <S2SV_StartBug> VAR_345 : <S2SV_EndBug> METHOD_44 ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) ; VAR_346 -> VAR_347 = VAR_348 -> VAR_349 ; VAR_350 -> VAR_351 = VAR_352 -> VAR_353 ; VAR_354 -> VAR_355 = VAR_356 -> VAR_357 ; VAR_358 -> VAR_359 = METHOD_45 ( VAR_360 ) ; VAR_361 -> VAR_362 = VAR_363 -> VAR_364 [ 0 ] ; VAR_365 -> VAR_366 = VAR_367 -> VAR_368 ; VAR_369 -> VAR_370 = VAR_371 ; for ( VAR_372 = 0 ; VAR_373 < VAR_374 ; VAR_375 ++ ) VAR_376 -> VAR_377 [ VAR_378 ] = VAR_379 -> VAR_380 [ VAR_381 ] ; VAR_382 -> VAR_383 [ VAR_384 -> VAR_385 [ 0 ] ] = METHOD_46 ( VAR_386 ) ; VAR_387 -> VAR_388 = & VAR_389 -> VAR_390 [ VAR_391 -> VAR_392 [ VAR_393 ] ] ; VAR_394 -> VAR_395 [ 0 ] . VAR_396 = & METHOD_47 ( VAR_397 -> VAR_398 ) -> VAR_399 [ VAR_400 -> VAR_401 ] ; VAR_402 -> VAR_403 [ 0 ] . VAR_404 = METHOD_48 ( VAR_405 ) ; VAR_406 -> VAR_407 [ 0 ] = METHOD_49 ( VAR_408 ) ; METHOD_50 ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n"" , VAR_409 ) ; return VAR_410 ; VAR_411 : METHOD_51 ( ""all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n"" ) ; VAR_412 = VAR_413 ; for ( VAR_414 = 0 ; VAR_415 < VAR_416 ; VAR_417 ++ ) { TYPE_7 VAR_418 = VAR_419 -> METHOD_52 ( METHOD_53 ( VAR_420 -> VAR_421 [ VAR_422 ] ) , VAR_423 ) ; if ( VAR_424 < VAR_425 ) { METHOD_54 ( VAR_426 < 0 ) ; VAR_427 = VAR_428 ; } } METHOD_55 ( VAR_429 == VAR_430 ) ; METHOD_56 ( VAR_431 < VAR_432 + VAR_433 ) ; VAR_434 = METHOD_57 ( VAR_435 , VAR_436 ) ; VAR_437 >>= VAR_438 ; VAR_439 = METHOD_58 ( sizeof ( struct STRUCT_OR_UNION_8 ) + VAR_440 * sizeof ( unsigned TYPE_8 ) , VAR_441 ) ; if ( ! VAR_442 ) return VAR_443 ; VAR_444 -> VAR_445 [ 2 ] = METHOD_59 ( VAR_446 ) ; VAR_447 -> VAR_448 [ 0 ] . VAR_449 = METHOD_60 ( VAR_450 ) ; VAR_451 -> VAR_452 = VAR_453 -> VAR_454 ; VAR_455 -> VAR_456 = VAR_457 -> VAR_458 ; VAR_459 -> VAR_460 = METHOD_61 ( VAR_461 ) ; VAR_462 -> VAR_463 = METHOD_62 ( VAR_464 ) ; VAR_465 -> VAR_466 = 0 ; VAR_467 -> VAR_468 = METHOD_63 ( VAR_469 ) ; VAR_470 -> VAR_471 = - 1 ; VAR_472 -> VAR_473 = VAR_474 = VAR_475 & ~ VAR_476 ; METHOD_64 ( ""skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n"" , VAR_477 , VAR_478 ) ; METHOD_65 ( VAR_479 <= 0 ) ; for ( VAR_480 = 0 ; VAR_481 < VAR_482 ; VAR_483 ++ ) VAR_484 -> VAR_485 [ VAR_486 ] = VAR_487 -> METHOD_66 ( VAR_488 , VAR_489 * VAR_490 ) ; VAR_491 = VAR_492 << ( VAR_493 & VAR_494 ) ; METHOD_67 ( ""blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n"" , VAR_495 - 1 , VAR_496 , VAR_497 ) ; VAR_498 -> VAR_499 [ VAR_500 - 1 ] &= ~ VAR_501 ; for ( VAR_502 = 0 ; VAR_503 < VAR_504 ; VAR_505 ++ ) { VAR_506 = VAR_507 -> VAR_508 [ VAR_509 ] ; VAR_510 = VAR_511 -> METHOD_68 ( METHOD_69 ( VAR_512 ) , VAR_513 ) ; VAR_514 >>= VAR_515 & VAR_516 ; VAR_517 -> VAR_518 [ VAR_519 ] = VAR_520 & VAR_521 ; } VAR_522 = VAR_523 -> METHOD_70 ( VAR_524 , VAR_525 ) ; VAR_526 >>= VAR_527 & VAR_528 ; VAR_529 -> VAR_530 [ VAR_531 ] = VAR_532 & VAR_533 ; goto VAR_534 ; }","<S2SV_ModStart> goto VAR_411 ; METHOD_67 ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> ; } VAR_145 <S2SV_ModStart> return VAR_410 ; <S2SV_ModEnd> VAR_411 : METHOD_67","CWE-476 static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( ""no<S2SV_blank>spare<S2SV_blank>slots\\n"" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( ""have<S2SV_blank>meta\\n"" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( ""only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n"" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; <S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> } split_node : pr_devel ( ""split<S2SV_blank>node\\n"" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( ""do_split_node\\n"" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( ""same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n"" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( ""filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n"" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n"" , __func__ ) ; return true ; <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n"" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( ""all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n"" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( ""skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n"" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( ""blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n"" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }","<S2SV_ModStart> goto all_leaves_cluster_together ; pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> ; } split_node <S2SV_ModStart> return true ; <S2SV_ModEnd> all_leaves_cluster_together : pr_devel"
475,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_7 * VAR_8 = VAR_9 -> VAR_10 ; unsigned VAR_11 = METHOD_2 ( METHOD_3 ( & VAR_12 -> VAR_13 ) ) ; struct STRUCT_OR_UNION_8 * VAR_14 ; struct STRUCT_OR_UNION_9 * VAR_15 ; unsigned TYPE_3 VAR_16 ; struct STRUCT_OR_UNION_10 * VAR_17 ; TYPE_4 VAR_18 = - VAR_19 ; TYPE_5 VAR_20 ; TYPE_6 VAR_21 = 0 ; <S2SV_StartBug> METHOD_4 ( VAR_22 ) ; <S2SV_EndBug> for ( VAR_23 = VAR_24 -> VAR_25 , VAR_26 = VAR_27 -> VAR_28 ; VAR_29 > 0 ; VAR_30 -- , VAR_31 ++ ) { unsigned TYPE_7 VAR_32 = VAR_33 -> VAR_34 ; TYPE_8 TYPE_9 * VAR_35 = VAR_36 -> VAR_37 ; while ( VAR_38 ) { VAR_39 = list_first_entry ( & VAR_40 -> VAR_41 , struct STRUCT_OR_UNION_11 , VAR_42 ) ; VAR_43 = VAR_44 -> VAR_45 ; while ( ! VAR_46 -> VAR_47 ) VAR_48 ++ ; VAR_49 = VAR_50 -> VAR_51 ; if ( ! VAR_52 ) { VAR_53 = METHOD_5 ( VAR_54 , VAR_55 ) ; if ( VAR_56 ) goto VAR_57 ; } VAR_58 = min_t ( unsigned TYPE_10 , VAR_59 , VAR_60 ) ; VAR_61 = METHOD_6 ( & VAR_62 -> VAR_63 , VAR_64 , VAR_65 , 1 ) ; VAR_66 = VAR_67 ; if ( VAR_68 < 0 ) goto VAR_69 ; if ( VAR_70 -> VAR_71 || VAR_72 < VAR_73 -> VAR_74 ) VAR_75 -= VAR_76 % VAR_77 ; VAR_78 = - VAR_79 ; if ( ! VAR_80 ) goto VAR_81 ; METHOD_7 ( & VAR_82 -> VAR_83 , VAR_84 , VAR_85 -> VAR_86 . VAR_87 , VAR_88 , VAR_89 -> VAR_90 ) ; VAR_91 = METHOD_8 ( VAR_92 -> VAR_93 ? METHOD_9 ( & VAR_94 -> VAR_95 ) : METHOD_10 ( & VAR_96 -> VAR_97 ) , & VAR_98 -> VAR_99 ) ; VAR_100 : METHOD_11 ( & VAR_101 -> VAR_102 ) ; if ( VAR_103 ) goto VAR_104 ; VAR_105 += VAR_106 ; VAR_107 += VAR_108 ; VAR_109 -= VAR_110 ; METHOD_12 ( VAR_111 , VAR_112 ) ; } } VAR_113 = 0 ; VAR_114 : METHOD_13 ( VAR_115 ) ; METHOD_14 ( VAR_116 ) ; return VAR_117 ? : VAR_118 ; }",<S2SV_ModStart> ( VAR_116 ) ; VAR_27 -> VAR_119 = 0,"CWE-200 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0
476,"CWE-264 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 * VAR_3 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_4 * VAR_4 , * VAR_5 ; <S2SV_EndBug> TYPE_1 VAR_6 = 0 ; struct STRUCT_OR_UNION_5 * VAR_7 = VAR_8 ; struct STRUCT_OR_UNION_6 * VAR_9 = VAR_10 ; METHOD_1 ( VAR_11 ) ; METHOD_2 ( VAR_12 ) ; for ( VAR_13 = METHOD_3 ( VAR_14 , VAR_15 ) ; VAR_16 ; VAR_17 = METHOD_4 ( VAR_18 , VAR_19 ) ) { TYPE_2 VAR_20 ; struct STRUCT_OR_UNION_7 * VAR_21 ; if ( METHOD_5 ( VAR_22 ) ) continue ; <S2SV_StartBug> VAR_23 = METHOD_6 ( VAR_24 , VAR_25 , VAR_26 , & VAR_27 ) ; <S2SV_EndBug> VAR_28 = METHOD_7 ( VAR_29 , VAR_30 -> VAR_31 . VAR_32 , VAR_33 ) ; if ( METHOD_8 ( VAR_34 ) ) { VAR_35 = METHOD_9 ( VAR_36 ) ; METHOD_10 ( VAR_37 , VAR_38 . VAR_39 ) ; goto VAR_40 ; } if ( METHOD_11 ( VAR_41 , VAR_42 -> VAR_43 . VAR_44 ) ) { METHOD_12 ( VAR_45 , VAR_46 , VAR_47 ) ; METHOD_13 ( & VAR_48 -> VAR_49 , VAR_50 ) ; } else { METHOD_14 ( & VAR_51 -> VAR_52 , & VAR_53 ) ; } VAR_54 = VAR_55 ; VAR_56 = VAR_57 ; } VAR_58 : METHOD_15 ( & VAR_59 ) ; while ( ! METHOD_16 ( & VAR_60 ) ) { VAR_61 = list_first_entry ( & VAR_62 , struct STRUCT_OR_UNION_8 , VAR_63 ) ; METHOD_17 ( VAR_64 , 0 , & VAR_65 ) ; } METHOD_18 ( & VAR_66 ) ; METHOD_19 ( & VAR_67 ) ; return VAR_68 ; }",<S2SV_ModStart> ) { struct STRUCT_OR_UNION_9 * VAR_69 = VAR_70 -> VAR_71 -> VAR_72 -> VAR_69 ; struct <S2SV_ModStart> & VAR_33 ) ; if ( VAR_55 -> VAR_72 -> VAR_69 != VAR_69 ) VAR_33 |= VAR_73,"CWE-264 int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , struct mount * source_mnt , struct list_head * tree_list ) { <S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> int ret = 0 ; struct mount * prev_dest_mnt = dest_mnt ; struct mount * prev_src_mnt = source_mnt ; LIST_HEAD ( tmp_list ) ; LIST_HEAD ( umount_list ) ; for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; m = propagation_next ( m , dest_mnt ) ) { int type ; struct mount * source ; if ( IS_MNT_NEW ( m ) ) continue ; <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> child = copy_tree ( source , source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) { ret = PTR_ERR ( child ) ; list_splice ( tree_list , tmp_list . prev ) ; goto out ; } if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { mnt_set_mountpoint ( m , dest_dentry , child ) ; list_add_tail ( & child -> mnt_hash , tree_list ) ; } else { list_add_tail ( & child -> mnt_hash , & tmp_list ) ; } prev_dest_mnt = m ; prev_src_mnt = child ; } out : br_write_lock ( & vfsmount_lock ) ; while ( ! list_empty ( & tmp_list ) ) { child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; umount_tree ( child , 0 , & umount_list ) ; } br_write_unlock ( & vfsmount_lock ) ; release_mounts ( & umount_list ) ; return ret ; }",<S2SV_ModStart> ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
477,"CWE-835 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { if ( VAR_1 -> VAR_2 -> VAR_3 > 0 ) { METHOD_1 ( VAR_4 -> VAR_5 -> VAR_6 ) ; } if ( VAR_7 -> VAR_8 -> VAR_9 != VAR_10 ) { METHOD_2 ( VAR_11 -> VAR_12 -> VAR_13 ) ; } if ( VAR_14 -> VAR_15 -> VAR_16 != VAR_17 ) { METHOD_3 ( VAR_18 -> VAR_19 -> VAR_20 , VAR_21 ) ; METHOD_4 ( VAR_22 -> VAR_23 -> VAR_24 ) ; } <S2SV_StartBug> if ( VAR_25 -> VAR_26 -> VAR_27 > 0 ) { <S2SV_EndBug> METHOD_5 ( VAR_28 -> VAR_29 -> VAR_30 ) ; } }",<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,"CWE-835 static void gsm_xsmp_client_disconnect ( GsmXSMPClient * client ) { if ( client -> priv -> watch_id > 0 ) { g_source_remove ( client -> priv -> watch_id ) ; } if ( client -> priv -> conn != NULL ) { SmsCleanUp ( client -> priv -> conn ) ; } if ( client -> priv -> ice_connection != NULL ) { IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ; IceCloseConnection ( client -> priv -> ice_connection ) ; } <S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> g_source_remove ( client -> priv -> protocol_timeout ) ; } }",<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
478,"CWE-19 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; struct STRUCT_OR_UNION_3 VAR_3 ; struct STRUCT_OR_UNION_4 * VAR_4 ; struct STRUCT_OR_UNION_5 * VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 ; struct STRUCT_OR_UNION_7 * VAR_7 ; TYPE_1 VAR_8 ; TYPE_2 VAR_9 ; TYPE_3 VAR_10 ; METHOD_1 ( VAR_11 ) ; VAR_12 = VAR_13 -> VAR_14 ; METHOD_2 ( & VAR_15 , VAR_16 ) ; VAR_17 = METHOD_3 ( VAR_18 ) ; METHOD_4 ( VAR_19 . VAR_20 < METHOD_5 ( VAR_21 -> VAR_22 -> VAR_23 ) / 8 ) ; VAR_24 = VAR_25 -> VAR_26 ; VAR_27 = VAR_28 = VAR_29 . VAR_30 / 2 ; for ( VAR_31 = & VAR_32 [ VAR_33 ] ; VAR_34 > 4 ; VAR_35 = & VAR_36 [ VAR_37 ] ) { VAR_38 /= 2 ; if ( METHOD_6 ( VAR_39 -> VAR_40 ) < VAR_41 ) VAR_42 += VAR_43 ; else if ( METHOD_7 ( VAR_44 -> VAR_45 ) > VAR_46 ) VAR_47 -= VAR_48 ; else break ; } METHOD_8 ( VAR_49 >= 0 && ( ! VAR_50 . VAR_51 || VAR_52 < VAR_53 . VAR_54 ) ) ; METHOD_9 ( VAR_55 <= 4 || METHOD_10 ( VAR_56 -> VAR_57 ) == VAR_58 ) ; while ( VAR_59 > 0 && METHOD_11 ( VAR_60 -> VAR_61 ) >= VAR_62 ) { VAR_63 -- ; VAR_64 -- ; } while ( VAR_65 < VAR_66 . VAR_67 && METHOD_12 ( VAR_68 -> VAR_69 ) < VAR_70 ) { VAR_71 ++ ; VAR_72 ++ ; } if ( VAR_73 == VAR_74 . VAR_75 || METHOD_13 ( VAR_76 -> VAR_77 ) != VAR_78 ) { VAR_79 -> VAR_80 = VAR_81 ; return METHOD_14 ( VAR_82 ) ; } for ( ; VAR_83 < VAR_84 . VAR_85 && ( METHOD_15 ( VAR_86 -> VAR_87 ) == VAR_88 ) ; VAR_89 ++ , VAR_90 ++ ) { if ( ( VAR_91 -> VAR_92 & VAR_93 ) != ( VAR_94 -> VAR_95 & VAR_96 ) ) { continue ; } if ( VAR_97 -> VAR_98 & VAR_99 ) { VAR_100 = METHOD_16 ( VAR_101 , VAR_102 ) ; if ( VAR_103 -> VAR_104 != VAR_105 -> VAR_106 ) continue ; if ( METHOD_17 ( VAR_107 -> VAR_108 , VAR_109 -> VAR_110 , VAR_111 -> VAR_112 ) != 0 ) continue ; if ( ! METHOD_18 ( VAR_113 -> VAR_114 , VAR_115 -> VAR_116 ) ) continue ; VAR_117 -> VAR_118 = VAR_119 ; return METHOD_19 ( VAR_120 ) ; } else { VAR_121 = METHOD_20 ( VAR_122 , VAR_123 ) ; if ( VAR_124 -> VAR_125 != VAR_126 -> VAR_127 ) continue ; if ( METHOD_21 ( VAR_128 -> VAR_129 , VAR_130 -> VAR_131 , VAR_132 -> VAR_133 ) != 0 ) continue ; if ( ! METHOD_22 ( VAR_134 -> VAR_135 , VAR_136 -> VAR_137 ) ) continue ; VAR_138 -> VAR_139 = VAR_140 ; <S2SV_StartBug> VAR_141 -> VAR_142 = METHOD_23 ( VAR_143 -> VAR_144 ) ; <S2SV_EndBug> VAR_145 -> VAR_146 = METHOD_24 ( VAR_147 -> VAR_148 ) ; VAR_149 -> VAR_150 = METHOD_25 ( VAR_151 -> VAR_152 -> VAR_153 , <S2SV_StartBug> VAR_154 -> VAR_155 ) ; <S2SV_EndBug> return METHOD_26 ( VAR_156 ) ; } } VAR_157 -> VAR_158 = VAR_159 ; return METHOD_27 ( VAR_160 ) ; }","<S2SV_ModStart> ; VAR_157 -> VAR_161 = METHOD_24 ( VAR_147 -> VAR_155 ) ; VAR_157 -> VAR_146 <S2SV_ModEnd> = METHOD_24 ( <S2SV_ModStart> ( VAR_147 -> <S2SV_ModEnd> VAR_148 ) ; <S2SV_ModStart> , VAR_157 -> VAR_161 <S2SV_ModEnd> ) ; return","CWE-19 int xfs_attr3_leaf_lookup_int ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; xfs_dahash_t hashval ; int probe ; int span ; trace_xfs_attr_leaf_lookup ( args ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; hashval = args -> hashval ; probe = span = ichdr . count / 2 ; for ( entry = & entries [ probe ] ; span > 4 ; entry = & entries [ probe ] ) { span /= 2 ; if ( be32_to_cpu ( entry -> hashval ) < hashval ) probe += span ; else if ( be32_to_cpu ( entry -> hashval ) > hashval ) probe -= span ; else break ; } ASSERT ( probe >= 0 && ( ! ichdr . count || probe < ichdr . count ) ) ; ASSERT ( span <= 4 || be32_to_cpu ( entry -> hashval ) == hashval ) ; while ( probe > 0 && be32_to_cpu ( entry -> hashval ) >= hashval ) { entry -- ; probe -- ; } while ( probe < ichdr . count && be32_to_cpu ( entry -> hashval ) < hashval ) { entry ++ ; probe ++ ; } if ( probe == ichdr . count || be32_to_cpu ( entry -> hashval ) != hashval ) { args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; } for ( ; probe < ichdr . count && ( be32_to_cpu ( entry -> hashval ) == hashval ) ; entry ++ , probe ++ ) { if ( ( args -> flags & XFS_ATTR_INCOMPLETE ) != ( entry -> flags & XFS_ATTR_INCOMPLETE ) ) { continue ; } if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , probe ) ; if ( name_loc -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; return XFS_ERROR ( EEXIST ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ; if ( name_rmt -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; <S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> return XFS_ERROR ( EEXIST ) ; } } args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; }","<S2SV_ModStart> ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> ( name_rmt -> <S2SV_ModEnd> valueblk ) ; <S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; return"
479,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { <S2SV_EndBug> METHOD_1 ( VAR_3 -> VAR_4 + VAR_5 -> VAR_6 , <S2SV_StartBug> VAR_7 -> VAR_8 + VAR_9 -> VAR_10 , VAR_11 -> VAR_12 + VAR_13 -> VAR_14 , VAR_15 ) ; <S2SV_EndBug> }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> VAR_15 ) { METHOD_2 ( VAR_11 -> VAR_16 == VAR_13 -> VAR_16 ) ; <S2SV_ModStart> , VAR_11 -> VAR_16 + 1 <S2SV_ModEnd> , VAR_15 )","CWE-119 <S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> fill_variance ( a -> sum_square_error + b -> sum_square_error , <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> r ) { assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> , a -> log2_count + 1 <S2SV_ModEnd> , r )"
480,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 = VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 = VAR_7 ; struct STRUCT_OR_UNION_4 * VAR_8 = VAR_9 ; struct STRUCT_OR_UNION_5 * VAR_10 = VAR_11 ; struct STRUCT_OR_UNION_6 * VAR_12 = VAR_13 ; unsigned TYPE_3 VAR_14 ; TYPE_4 VAR_15 = 0 ; METHOD_1 ( VAR_16 , 0x00 , sizeof ( struct STRUCT_OR_UNION_7 ) ) ; VAR_17 -> VAR_18 = VAR_19 ; while ( VAR_20 > 0 ) { VAR_21 = VAR_22 [ 0 ] ; if ( ! VAR_23 ) { METHOD_2 ( & VAR_24 -> VAR_25 , ""skipping<S2SV_blank>garbage<S2SV_blank>byte\\n"" ) ; VAR_26 = 1 ; <S2SV_StartBug> goto VAR_27 ; <S2SV_EndBug> } if ( VAR_28 [ 1 ] != VAR_29 ) { METHOD_3 ( & VAR_30 -> VAR_31 , ""skipping<S2SV_blank>garbage\\n"" ) ; goto VAR_32 ; } switch ( VAR_33 [ 2 ] ) { case VAR_34 : if ( VAR_35 < sizeof ( struct STRUCT_OR_UNION_8 ) ) goto VAR_36 ; if ( VAR_37 ) { METHOD_4 ( & VAR_38 -> VAR_39 , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n"" ) ; goto VAR_40 ; } VAR_41 = ( struct STRUCT_OR_UNION_9 * ) VAR_42 ; break ; case VAR_43 : if ( VAR_44 < sizeof ( struct STRUCT_OR_UNION_10 ) ) goto VAR_45 ; VAR_46 -> STRUCT_OR_UNION_11 = ( struct STRUCT_OR_UNION_12 * ) VAR_47 ; break ; case VAR_48 : if ( VAR_49 != sizeof ( struct STRUCT_OR_UNION_13 ) ) goto VAR_50 ; if ( VAR_51 ) return - VAR_52 ; VAR_53 = ( struct STRUCT_OR_UNION_14 * ) VAR_54 ; break ; case VAR_55 : if ( VAR_56 < sizeof ( struct STRUCT_OR_UNION_15 ) ) goto VAR_57 ; VAR_58 -> STRUCT_OR_UNION_16 = ( struct STRUCT_OR_UNION_17 * ) VAR_59 ; break ; case VAR_60 : if ( VAR_61 != sizeof ( struct STRUCT_OR_UNION_18 ) ) goto VAR_62 ; if ( VAR_63 ) return - VAR_64 ; VAR_65 = ( struct STRUCT_OR_UNION_19 * ) VAR_66 ; break ; case VAR_67 : if ( VAR_68 < sizeof ( struct STRUCT_OR_UNION_20 ) ) goto VAR_69 ; VAR_70 -> STRUCT_OR_UNION_21 = ( struct STRUCT_OR_UNION_22 * ) VAR_71 ; break ; case VAR_72 : if ( VAR_73 < sizeof ( struct STRUCT_OR_UNION_23 ) ) goto VAR_74 ; VAR_75 -> STRUCT_OR_UNION_24 = ( struct STRUCT_OR_UNION_25 * ) VAR_76 ; break ; case VAR_77 : if ( VAR_78 < sizeof ( struct STRUCT_OR_UNION_26 * ) ) goto VAR_79 ; if ( VAR_80 ) return - VAR_81 ; VAR_82 = ( struct STRUCT_OR_UNION_27 * ) VAR_83 ; break ; case VAR_84 : if ( VAR_85 < sizeof ( struct STRUCT_OR_UNION_28 * ) ) goto VAR_86 ; if ( VAR_87 ) return - VAR_88 ; VAR_89 = ( struct STRUCT_OR_UNION_29 * ) VAR_90 ; break ; case VAR_91 : if ( VAR_92 < sizeof ( struct STRUCT_OR_UNION_30 ) ) goto VAR_93 ; VAR_94 -> STRUCT_OR_UNION_31 = ( struct STRUCT_OR_UNION_32 * ) VAR_95 ; break ; case VAR_96 : if ( VAR_97 < sizeof ( struct STRUCT_OR_UNION_33 ) ) goto VAR_98 ; VAR_99 -> STRUCT_OR_UNION_34 = ( struct STRUCT_OR_UNION_35 * ) VAR_100 ; break ; case VAR_101 : if ( VAR_102 < sizeof ( struct STRUCT_OR_UNION_36 ) ) break ; VAR_103 -> STRUCT_OR_UNION_37 = ( struct STRUCT_OR_UNION_38 * ) VAR_104 ; break ; case VAR_105 : VAR_106 -> VAR_107 = VAR_108 ; break ; default : METHOD_5 ( & VAR_109 -> VAR_110 , ""Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n"" , VAR_111 [ 2 ] , VAR_112 ) ; goto VAR_113 ; } VAR_114 ++ ; VAR_115 : VAR_116 -= VAR_117 ; VAR_118 += VAR_119 ; } VAR_120 -> STRUCT_OR_UNION_39 = VAR_121 ; VAR_122 -> STRUCT_OR_UNION_40 = VAR_123 ; VAR_124 -> STRUCT_OR_UNION_41 = VAR_125 ; VAR_126 -> STRUCT_OR_UNION_42 = VAR_127 ; VAR_128 -> STRUCT_OR_UNION_43 = VAR_129 ; return VAR_130 ; }","<S2SV_ModStart> ; goto VAR_115 ; } if ( ( VAR_116 < VAR_119 ) || ( VAR_119 < 3 ) ) { METHOD_4 ( & VAR_109 -> VAR_110 , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break","CWE-119 int cdc_parse_cdc_header ( struct usb_cdc_parsed_header * hdr , struct usb_interface * intf , u8 * buffer , int buflen ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_header_desc * header = NULL ; struct usb_cdc_ether_desc * ether = NULL ; struct usb_cdc_mdlm_detail_desc * detail = NULL ; struct usb_cdc_mdlm_desc * desc = NULL ; unsigned int elength ; int cnt = 0 ; memset ( hdr , 0x00 , sizeof ( struct usb_cdc_parsed_header ) ) ; hdr -> phonet_magic_present = false ; while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage<S2SV_blank>byte\\n"" ) ; elength = 1 ; <S2SV_StartBug> goto next_desc ; <S2SV_EndBug> } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage\\n"" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n"" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; hdr -> usb_cdc_country_functional_desc = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : if ( elength != sizeof ( struct usb_cdc_header_desc ) ) goto next_desc ; if ( header ) return - EINVAL ; header = ( struct usb_cdc_header_desc * ) buffer ; break ; case USB_CDC_ACM_TYPE : if ( elength < sizeof ( struct usb_cdc_acm_descriptor ) ) goto next_desc ; hdr -> usb_cdc_acm_descriptor = ( struct usb_cdc_acm_descriptor * ) buffer ; break ; case USB_CDC_ETHERNET_TYPE : if ( elength != sizeof ( struct usb_cdc_ether_desc ) ) goto next_desc ; if ( ether ) return - EINVAL ; ether = ( struct usb_cdc_ether_desc * ) buffer ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < sizeof ( struct usb_cdc_call_mgmt_descriptor ) ) goto next_desc ; hdr -> usb_cdc_call_mgmt_descriptor = ( struct usb_cdc_call_mgmt_descriptor * ) buffer ; break ; case USB_CDC_DMM_TYPE : if ( elength < sizeof ( struct usb_cdc_dmm_desc ) ) goto next_desc ; hdr -> usb_cdc_dmm_desc = ( struct usb_cdc_dmm_desc * ) buffer ; break ; case USB_CDC_MDLM_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_desc * ) ) goto next_desc ; if ( desc ) return - EINVAL ; desc = ( struct usb_cdc_mdlm_desc * ) buffer ; break ; case USB_CDC_MDLM_DETAIL_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_detail_desc * ) ) goto next_desc ; if ( detail ) return - EINVAL ; detail = ( struct usb_cdc_mdlm_detail_desc * ) buffer ; break ; case USB_CDC_NCM_TYPE : if ( elength < sizeof ( struct usb_cdc_ncm_desc ) ) goto next_desc ; hdr -> usb_cdc_ncm_desc = ( struct usb_cdc_ncm_desc * ) buffer ; break ; case USB_CDC_MBIM_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_desc ) ) goto next_desc ; hdr -> usb_cdc_mbim_desc = ( struct usb_cdc_mbim_desc * ) buffer ; break ; case USB_CDC_MBIM_EXTENDED_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_extended_desc ) ) break ; hdr -> usb_cdc_mbim_extended_desc = ( struct usb_cdc_mbim_extended_desc * ) buffer ; break ; case CDC_PHONET_MAGIC_NUMBER : hdr -> phonet_magic_present = true ; break ; default : dev_dbg ( & intf -> dev , ""Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n"" , buffer [ 2 ] , elength ) ; goto next_desc ; } cnt ++ ; next_desc : buflen -= elength ; buffer += elength ; } hdr -> usb_cdc_union_desc = union_header ; hdr -> usb_cdc_header_desc = header ; hdr -> usb_cdc_mdlm_detail_desc = detail ; hdr -> usb_cdc_mdlm_desc = desc ; hdr -> usb_cdc_ether_desc = ether ; return cnt ; }","<S2SV_ModStart> ; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break"
481,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 = VAR_4 -> VAR_5 ; TYPE_3 TYPE_4 * VAR_6 = ( TYPE_5 TYPE_6 * ) VAR_7 ; struct STRUCT_OR_UNION_2 * VAR_8 = VAR_9 -> VAR_10 ; TYPE_7 VAR_11 = VAR_12 ; TYPE_8 VAR_13 = 0 ; struct STRUCT_OR_UNION_3 VAR_14 ; TYPE_9 VAR_15 ; METHOD_1 ( VAR_16 , VAR_17 , VAR_18 , VAR_19 , ""Parameters<S2SV_blank>Passed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>IOCTL<S2SV_blank>cmd=0x%X<S2SV_blank>arg=0x%lX"" , VAR_20 , VAR_21 ) ; if ( METHOD_2 ( VAR_22 ) != VAR_23 ) return - VAR_24 ; if ( METHOD_3 ( VAR_25 ) & VAR_26 ) VAR_27 = ! METHOD_4 ( VAR_28 , VAR_29 , METHOD_5 ( VAR_30 ) ) ; else if ( METHOD_6 ( VAR_31 ) & VAR_32 ) VAR_33 = ! METHOD_7 ( VAR_34 , VAR_35 , METHOD_8 ( VAR_36 ) ) ; else if ( VAR_37 == ( METHOD_9 ( VAR_38 ) & VAR_39 ) ) VAR_40 = VAR_41 ; if ( VAR_42 ) return - VAR_43 ; if ( VAR_44 -> VAR_45 ) return - VAR_46 ; if ( VAR_47 == VAR_48 -> VAR_49 ) { switch ( VAR_50 ) { case VAR_51 : case VAR_52 : case VAR_53 : case VAR_54 : case VAR_55 : case VAR_56 : case VAR_57 : case VAR_58 : return - VAR_59 ; default : break ; } } VAR_60 = METHOD_10 ( VAR_61 , VAR_62 , VAR_63 ) ; if ( VAR_64 != VAR_65 ) return VAR_66 ; switch ( VAR_67 ) { case VAR_68 : { struct STRUCT_OR_UNION_4 VAR_69 = { 0 } ; TYPE_10 VAR_70 ; TYPE_11 VAR_71 ; TYPE_12 VAR_72 ; if ( METHOD_11 ( & VAR_73 , VAR_74 , sizeof ( struct STRUCT_OR_UNION_5 ) ) ) return - VAR_75 ; if ( VAR_76 . VAR_77 > sizeof ( VAR_78 ) ) return - VAR_79 ; if ( METHOD_12 ( & VAR_80 , VAR_81 . VAR_82 , VAR_83 . VAR_84 ) ) return - VAR_85 ; if ( VAR_86 . VAR_87 > VAR_88 || VAR_89 . VAR_90 == 0 ) { return - VAR_91 ; } VAR_92 = VAR_93 . VAR_94 ; VAR_95 = 4 - ( VAR_96 % 4 ) ; VAR_97 += VAR_98 % 4 ; VAR_99 = METHOD_13 ( VAR_100 , VAR_101 ) ; if ( ! VAR_102 ) return - VAR_103 ; VAR_104 = METHOD_14 ( VAR_105 , ( TYPE_13 ) VAR_106 . VAR_107 , ( TYPE_14 ) VAR_108 , VAR_109 ) ; if ( VAR_110 > 0 ) { VAR_111 = VAR_112 ; if ( METHOD_15 ( VAR_113 . VAR_114 , VAR_115 , VAR_116 ) ) { METHOD_16 ( VAR_117 ) ; return - VAR_118 ; } } else { VAR_119 = VAR_120 ; } METHOD_17 ( VAR_121 ) ; break ; } case VAR_122 : { struct STRUCT_OR_UNION_6 VAR_123 = { 0 } ; TYPE_15 VAR_124 = 0 ; if ( METHOD_18 ( & VAR_125 , VAR_126 , sizeof ( struct STRUCT_OR_UNION_7 ) ) ) return - VAR_127 ; if ( VAR_128 . VAR_129 > sizeof ( VAR_130 ) ) return - VAR_131 ; if ( METHOD_19 ( & VAR_132 , VAR_133 . VAR_134 , VAR_135 . VAR_136 ) ) return - VAR_137 ; VAR_138 = VAR_139 . VAR_140 & VAR_141 ; if ( ! ( ( VAR_142 -> VAR_143 -> VAR_144 ) & VAR_145 ) && ( ( VAR_146 == VAR_147 ) || ( VAR_148 == VAR_149 ) || ( VAR_150 == VAR_151 ) || ( VAR_152 == VAR_153 ) ) ) { METHOD_20 ( VAR_154 , VAR_155 , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - VAR_156 ; } VAR_157 = METHOD_21 ( VAR_158 , ( TYPE_16 ) VAR_159 . VAR_160 , ( TYPE_17 ) VAR_161 . VAR_162 , sizeof ( TYPE_18 ) ) ; if ( VAR_163 == VAR_164 ) { METHOD_22 ( VAR_165 , VAR_166 , VAR_167 , VAR_168 , ""WRM<S2SV_blank>Done\\n"" ) ; } else { METHOD_23 ( VAR_169 , VAR_170 , VAR_171 , VAR_172 , ""WRM<S2SV_blank>Failed\\n"" ) ; VAR_173 = - VAR_174 ; } break ; } case VAR_175 : case VAR_176 : { struct STRUCT_OR_UNION_8 VAR_177 = { 0 } ; TYPE_19 VAR_178 = VAR_179 ; TYPE_20 VAR_180 = 0 ; if ( ( VAR_181 -> VAR_182 == VAR_183 ) || ( VAR_184 -> VAR_185 == VAR_186 ) || ( VAR_187 -> VAR_188 == VAR_189 ) ) { METHOD_24 ( VAR_190 , VAR_191 , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Rdms\\n"" ) ; return - VAR_192 ; } if ( METHOD_25 ( & VAR_193 , VAR_194 , sizeof ( struct STRUCT_OR_UNION_9 ) ) ) return - VAR_195 ; if ( VAR_196 . VAR_197 > sizeof ( VAR_198 ) ) return - VAR_199 ; if ( METHOD_26 ( & VAR_200 , VAR_201 . VAR_202 , VAR_203 . VAR_204 ) ) return - VAR_205 ; if ( VAR_206 . VAR_207 > VAR_208 || VAR_209 . VAR_210 == 0 ) { return - VAR_211 ; } VAR_212 = METHOD_27 ( VAR_213 . VAR_214 , VAR_215 ) ; if ( ! VAR_216 ) return VAR_217 ; if ( ( ( ( TYPE_21 ) VAR_218 . VAR_219 & 0x0F000000 ) != 0x0F000000 ) || ( ( TYPE_22 ) VAR_220 . VAR_221 & 0x3 ) ) { METHOD_28 ( VAR_222 , VAR_223 , 0 , 0 , ""RDM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( TYPE_23 ) VAR_224 . VAR_225 ) ; METHOD_29 ( VAR_226 ) ; return - VAR_227 ; } VAR_228 = VAR_229 . VAR_230 & VAR_231 ; VAR_232 = METHOD_30 ( VAR_233 , ( TYPE_24 ) VAR_234 . VAR_235 , ( TYPE_25 ) VAR_236 , VAR_237 . VAR_238 ) ; if ( VAR_239 > 0 ) { VAR_240 = VAR_241 ; if ( METHOD_31 ( VAR_242 . VAR_243 , VAR_244 , VAR_245 ) ) { METHOD_32 ( VAR_246 ) ; return - VAR_247 ; } } else { VAR_248 = VAR_249 ; } METHOD_33 ( VAR_250 ) ; break ; } case VAR_251 : case VAR_252 : { struct STRUCT_OR_UNION_10 VAR_253 = { 0 } ; TYPE_26 VAR_254 = 0 ; if ( ( VAR_255 -> VAR_256 == VAR_257 ) || ( VAR_258 -> VAR_259 == VAR_260 ) || ( VAR_261 -> VAR_262 == VAR_263 ) ) { METHOD_34 ( VAR_264 , VAR_265 , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; return - VAR_266 ; } if ( METHOD_35 ( & VAR_267 , VAR_268 , sizeof ( struct STRUCT_OR_UNION_11 ) ) ) return - VAR_269 ; if ( VAR_270 . VAR_271 > sizeof ( VAR_272 ) ) return - VAR_273 ; if ( METHOD_36 ( & VAR_274 , VAR_275 . VAR_276 , VAR_277 . VAR_278 ) ) return - VAR_279 ; if ( ( ( ( TYPE_27 ) VAR_280 . VAR_281 & 0x0F000000 ) != 0x0F000000 ) || ( ( TYPE_28 ) VAR_282 . VAR_283 & 0x3 ) ) { METHOD_37 ( VAR_284 , VAR_285 , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( TYPE_29 ) VAR_286 . VAR_287 ) ; return - VAR_288 ; } VAR_289 = VAR_290 . VAR_291 & VAR_292 ; if ( ! ( ( VAR_293 -> VAR_294 -> VAR_295 ) & VAR_296 ) && ( ( VAR_297 == VAR_298 ) || ( VAR_299 == VAR_300 ) || ( VAR_301 == VAR_302 ) || ( VAR_303 == VAR_304 ) ) && ( VAR_305 == VAR_306 ) ) { METHOD_38 ( VAR_307 , VAR_308 , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - VAR_309 ; } VAR_310 = METHOD_39 ( VAR_311 , ( TYPE_30 ) VAR_312 . VAR_313 , ( TYPE_31 ) VAR_314 . VAR_315 , VAR_316 . VAR_317 ) ; if ( VAR_318 == VAR_319 ) { METHOD_40 ( VAR_320 , VAR_321 , VAR_322 , VAR_323 , ""WRM<S2SV_blank>Done\\n"" ) ; } else { METHOD_41 ( VAR_324 , VAR_325 , VAR_326 , VAR_327 , ""WRM<S2SV_blank>Failed\\n"" ) ; VAR_328 = - VAR_329 ; } break ; } case VAR_330 : { TYPE_32 VAR_331 [ 4 ] ; TYPE_33 VAR_332 = 0 ; TYPE_34 VAR_333 = 0 ; TYPE_35 VAR_334 = 0 ; struct STRUCT_OR_UNION_12 VAR_335 = { 0 } ; if ( ( VAR_336 -> VAR_337 == VAR_338 ) || ( VAR_339 -> VAR_340 == VAR_341 ) || ( VAR_342 -> VAR_343 == VAR_344 ) ) { METHOD_42 ( VAR_345 , VAR_346 , VAR_347 , VAR_348 , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; return - VAR_349 ; } if ( METHOD_43 ( & VAR_350 , VAR_351 , sizeof ( struct STRUCT_OR_UNION_13 ) ) ) return - VAR_352 ; if ( VAR_353 . VAR_354 > sizeof ( VAR_355 ) ) return - VAR_356 ; if ( METHOD_44 ( & VAR_357 , VAR_358 . VAR_359 , VAR_360 . VAR_361 ) ) return - VAR_362 ; VAR_363 = VAR_364 . VAR_365 ; VAR_366 = VAR_367 . VAR_368 ; VAR_369 = ( 1 << VAR_370 ) ; if ( METHOD_45 ( VAR_371 , VAR_372 ) == VAR_373 ) { METHOD_46 ( VAR_374 , VAR_375 , VAR_376 , VAR_377 , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>LED<S2SV_blank>!!!"" , VAR_378 ) ; VAR_379 = - VAR_380 ; break ; } if ( VAR_381 ) { VAR_382 = METHOD_47 ( VAR_383 , VAR_384 , ( TYPE_36 ) ( & VAR_385 ) , sizeof ( TYPE_37 ) ) ; if ( VAR_386 == VAR_387 ) { METHOD_48 ( VAR_388 , VAR_389 , VAR_390 , VAR_391 , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { METHOD_49 ( VAR_392 , VAR_393 , VAR_394 , VAR_395 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , VAR_396 ) ; break ; } } else { VAR_397 = METHOD_50 ( VAR_398 , VAR_399 , ( TYPE_38 ) ( & VAR_400 ) , sizeof ( TYPE_39 ) ) ; if ( VAR_401 == VAR_402 ) { METHOD_51 ( VAR_403 , VAR_404 , VAR_405 , VAR_406 , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { METHOD_52 ( VAR_407 , VAR_408 , VAR_409 , VAR_410 , ""Failed<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , VAR_411 ) ; break ; } } VAR_412 = METHOD_53 ( VAR_413 , ( TYPE_40 ) VAR_414 , ( TYPE_41 ) VAR_415 , sizeof ( TYPE_42 ) ) ; if ( VAR_416 < 0 ) { VAR_417 = VAR_418 ; METHOD_54 ( VAR_419 , VAR_420 , VAR_421 , VAR_422 , ""GPIO_MODE_REGISTER<S2SV_blank>read<S2SV_blank>failed"" ) ; break ; } else { VAR_423 = VAR_424 ; } * ( TYPE_43 * ) VAR_425 |= ( 1 << VAR_426 ) ; VAR_427 = METHOD_55 ( VAR_428 , VAR_429 , ( TYPE_44 ) VAR_430 , sizeof ( TYPE_45 ) ) ; if ( VAR_431 == VAR_432 ) { METHOD_56 ( VAR_433 , VAR_434 , VAR_435 , VAR_436 , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>to<S2SV_blank>output<S2SV_blank>Mode\\n"" ) ; } else { METHOD_57 ( VAR_437 , VAR_438 , VAR_439 , VAR_440 , ""Failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>GPIO<S2SV_blank>in<S2SV_blank>Output<S2SV_blank>Mode\\n"" ) ; break ; } } break ; case VAR_441 : { struct STRUCT_OR_UNION_14 VAR_442 = { 0 } ; METHOD_58 ( VAR_443 , VAR_444 , VAR_445 , VAR_446 , ""User<S2SV_blank>made<S2SV_blank>LED<S2SV_blank>thread<S2SV_blank>InActive"" ) ; if ( ( VAR_447 -> VAR_448 == VAR_449 ) || ( VAR_450 -> VAR_451 == VAR_452 ) || ( VAR_453 -> VAR_454 == VAR_455 ) ) { METHOD_59 ( VAR_456 , VAR_457 , VAR_458 , VAR_459 , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; VAR_460 = - VAR_461 ; break ; } if ( METHOD_60 ( & VAR_462 , VAR_463 , sizeof ( struct STRUCT_OR_UNION_15 ) ) ) return - VAR_464 ; if ( VAR_465 . VAR_466 > sizeof ( VAR_467 ) ) return - VAR_468 ; if ( METHOD_61 ( & VAR_469 , VAR_470 . VAR_471 , VAR_472 . VAR_473 ) ) return - VAR_474 ; if ( VAR_475 -> VAR_476 . VAR_477 ) { if ( VAR_478 . VAR_479 == VAR_480 ) { METHOD_62 ( VAR_481 , VAR_482 , VAR_483 , VAR_484 , ""Activating<S2SV_blank>thread<S2SV_blank>req"" ) ; VAR_485 -> VAR_486 = VAR_487 ; } else { METHOD_63 ( VAR_488 , VAR_489 , VAR_490 , VAR_491 , ""DeActivating<S2SV_blank>Thread<S2SV_blank>req....."" ) ; VAR_492 -> VAR_493 = VAR_494 ; } METHOD_64 ( & VAR_495 -> VAR_496 . VAR_497 ) ; } } break ; case VAR_498 : { TYPE_46 VAR_499 = 0 ; TYPE_47 VAR_500 [ 4 ] ; struct STRUCT_OR_UNION_16 VAR_501 = { 0 } ; if ( ( VAR_502 -> VAR_503 == VAR_504 ) || ( VAR_505 -> VAR_506 == VAR_507 ) || ( VAR_508 -> VAR_509 == VAR_510 ) ) return - VAR_511 ; if ( METHOD_65 ( & VAR_512 , VAR_513 , sizeof ( struct STRUCT_OR_UNION_17 ) ) ) return - VAR_514 ; if ( VAR_515 . VAR_516 > sizeof ( VAR_517 ) ) return - VAR_518 ; if ( METHOD_66 ( & VAR_519 , VAR_520 . VAR_521 , VAR_522 . VAR_523 ) ) return - VAR_524 ; VAR_525 = VAR_526 . VAR_527 ; VAR_528 = METHOD_67 ( VAR_529 , ( TYPE_48 ) VAR_530 , ( TYPE_49 ) VAR_531 , sizeof ( TYPE_50 ) ) ; if ( VAR_532 < 0 ) { VAR_533 = VAR_534 ; METHOD_68 ( VAR_535 , VAR_536 , 0 , 0 , ""RDM<S2SV_blank>Failed\\n"" ) ; return VAR_537 ; } else { VAR_538 = VAR_539 ; } } break ; case VAR_540 : { TYPE_51 VAR_541 [ 4 ] ; struct STRUCT_OR_UNION_18 VAR_542 [ VAR_543 ] ; struct STRUCT_OR_UNION_19 * VAR_544 = ( struct STRUCT_OR_UNION_20 * ) VAR_545 ; METHOD_69 ( VAR_546 , 0 , VAR_547 * sizeof ( struct STRUCT_OR_UNION_21 ) ) ; if ( ( VAR_548 -> VAR_549 == VAR_550 ) || ( VAR_551 -> VAR_552 == VAR_553 ) || ( VAR_554 -> VAR_555 == VAR_556 ) ) return - VAR_557 ; if ( METHOD_70 ( & VAR_558 , VAR_559 , sizeof ( struct STRUCT_OR_UNION_22 ) ) ) return - VAR_560 ; if ( VAR_561 . VAR_562 > sizeof ( VAR_563 ) ) return - VAR_564 ; if ( METHOD_71 ( & VAR_565 , VAR_566 . VAR_567 , VAR_568 . VAR_569 ) ) return - VAR_570 ; if ( METHOD_72 ( VAR_571 , VAR_572 [ VAR_573 ] . VAR_574 ) == VAR_575 ) { METHOD_73 ( VAR_576 , VAR_577 , VAR_578 , VAR_579 , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , VAR_580 [ VAR_581 ] . VAR_582 , VAR_583 -> VAR_584 ) ; VAR_585 = - VAR_586 ; break ; } if ( ( VAR_587 [ VAR_588 ] . VAR_589 ) & ( VAR_590 [ VAR_591 ] . VAR_592 ) ) { * ( TYPE_52 * ) VAR_593 = VAR_594 [ VAR_595 ] . VAR_596 & VAR_597 [ VAR_598 ] . VAR_599 & VAR_600 [ VAR_601 ] . VAR_602 ; if ( * ( TYPE_53 * ) VAR_603 ) VAR_604 = METHOD_74 ( VAR_605 , VAR_606 , ( TYPE_54 ) VAR_607 , sizeof ( TYPE_55 ) ) ; if ( VAR_608 != VAR_609 ) { METHOD_75 ( VAR_610 , VAR_611 , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_SET_REG<S2SV_blank>Failed."" ) ; return VAR_612 ; } * ( TYPE_56 * ) VAR_613 = ( VAR_614 [ VAR_615 ] . VAR_616 & VAR_617 [ VAR_618 ] . VAR_619 & ( ~ ( VAR_620 [ VAR_621 ] . VAR_622 ) ) ) ; if ( * ( TYPE_57 * ) VAR_623 ) VAR_624 = METHOD_76 ( VAR_625 , VAR_626 , ( TYPE_58 ) VAR_627 , sizeof ( TYPE_59 ) ) ; if ( VAR_628 != VAR_629 ) { METHOD_77 ( VAR_630 , VAR_631 , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_CLR_REG<S2SV_blank>Failed."" ) ; return VAR_632 ; } } if ( VAR_633 [ VAR_634 ] . VAR_635 ) { VAR_636 = METHOD_78 ( VAR_637 , ( TYPE_60 ) VAR_638 , ( TYPE_61 ) VAR_639 , sizeof ( TYPE_62 ) ) ; if ( VAR_640 < 0 ) { VAR_641 = VAR_642 ; METHOD_79 ( VAR_643 , VAR_644 , 0 , 0 , ""RDM<S2SV_blank>to<S2SV_blank>GPIO_PIN_STATE_REGISTER<S2SV_blank>Failed."" ) ; return VAR_645 ; } else { VAR_646 = VAR_647 ; } VAR_648 [ VAR_649 ] . VAR_650 = ( * ( TYPE_63 * ) VAR_651 & VAR_652 [ VAR_653 ] . VAR_654 ) ; } VAR_655 = METHOD_80 ( VAR_656 . VAR_657 , & VAR_658 , VAR_659 . VAR_660 ) ; if ( VAR_661 ) { METHOD_81 ( VAR_662 , VAR_663 , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , VAR_664 ) ; return - VAR_665 ; } } break ; case VAR_666 : { TYPE_64 VAR_667 [ 4 ] ; struct STRUCT_OR_UNION_23 VAR_668 [ VAR_669 ] ; struct STRUCT_OR_UNION_24 * VAR_670 = ( struct STRUCT_OR_UNION_25 * ) VAR_671 ; if ( ( VAR_672 -> VAR_673 == VAR_674 ) || ( VAR_675 -> VAR_676 == VAR_677 ) || ( VAR_678 -> VAR_679 == VAR_680 ) ) return - VAR_681 ; if ( METHOD_82 ( & VAR_682 , VAR_683 , sizeof ( struct STRUCT_OR_UNION_26 ) ) ) return - VAR_684 ; if ( VAR_685 . VAR_686 > sizeof ( VAR_687 ) ) return - VAR_688 ; if ( METHOD_83 ( & VAR_689 , VAR_690 . VAR_691 , VAR_692 . VAR_693 ) ) return - VAR_694 ; VAR_695 = METHOD_84 ( VAR_696 , ( TYPE_65 ) VAR_697 , ( TYPE_66 ) VAR_698 , sizeof ( TYPE_67 ) ) ; if ( VAR_699 < 0 ) { VAR_700 = VAR_701 ; METHOD_85 ( VAR_702 , VAR_703 , 0 , 0 , ""Read<S2SV_blank>of<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>failed"" ) ; return VAR_704 ; } else { VAR_705 = VAR_706 ; } if ( METHOD_86 ( VAR_707 , VAR_708 [ VAR_709 ] . VAR_710 ) == VAR_711 ) { METHOD_87 ( VAR_712 , VAR_713 , VAR_714 , VAR_715 , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , VAR_716 [ VAR_717 ] . VAR_718 , VAR_719 -> VAR_720 ) ; VAR_721 = - VAR_722 ; break ; } if ( VAR_723 [ VAR_724 ] . VAR_725 ) { * ( TYPE_68 * ) VAR_726 |= ( VAR_727 [ VAR_728 ] . VAR_729 & VAR_730 [ VAR_731 ] . VAR_732 ) ; * ( TYPE_69 * ) VAR_733 &= ~ ( ( ~ VAR_734 [ VAR_735 ] . VAR_736 ) & VAR_737 [ VAR_738 ] . VAR_739 ) ; VAR_740 [ VAR_741 ] . VAR_742 = * ( TYPE_70 * ) VAR_743 ; VAR_744 = METHOD_88 ( VAR_745 , VAR_746 , ( TYPE_71 ) VAR_747 , sizeof ( TYPE_72 ) ) ; if ( VAR_748 == VAR_749 ) { METHOD_89 ( VAR_750 , VAR_751 , VAR_752 , VAR_753 , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Done"" ) ; } else { METHOD_90 ( VAR_754 , VAR_755 , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Failed"" ) ; VAR_756 = - VAR_757 ; break ; } } else { VAR_758 [ VAR_759 ] . VAR_760 = * ( TYPE_73 * ) VAR_761 ; } VAR_762 = METHOD_91 ( VAR_763 . VAR_764 , & VAR_765 , VAR_766 . VAR_767 ) ; if ( VAR_768 ) { METHOD_92 ( VAR_769 , VAR_770 , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , VAR_771 ) ; return - VAR_772 ; } } break ; case VAR_773 : case VAR_774 : case VAR_775 : case VAR_776 : case VAR_777 : case VAR_778 : { TYPE_74 VAR_779 = VAR_780 ; if ( METHOD_93 ( & VAR_781 , VAR_782 , sizeof ( struct STRUCT_OR_UNION_27 ) ) ) return - VAR_783 ; if ( VAR_784 . VAR_785 < sizeof ( struct STRUCT_OR_UNION_28 ) ) return - VAR_786 ; if ( VAR_787 . VAR_788 > VAR_789 ) return - VAR_790 ; VAR_791 = METHOD_94 ( VAR_792 . VAR_793 , VAR_794 . VAR_795 ) ; if ( METHOD_95 ( VAR_796 ) ) return METHOD_96 ( VAR_797 ) ; METHOD_97 ( & VAR_798 -> VAR_799 ) ; VAR_800 = METHOD_98 ( VAR_801 -> VAR_802 , ! VAR_803 -> VAR_804 , ( 1 * VAR_805 ) ) ; if ( VAR_806 == - VAR_807 ) goto VAR_808 ; if ( VAR_809 -> VAR_810 ) { METHOD_99 ( VAR_811 , VAR_812 , VAR_813 , VAR_814 , ""Preparing<S2SV_blank>Idle<S2SV_blank>Mode<S2SV_blank>is<S2SV_blank>still<S2SV_blank>True<S2SV_blank>-<S2SV_blank>Hence<S2SV_blank>Rejecting<S2SV_blank>control<S2SV_blank>message\\n"" ) ; VAR_815 = VAR_816 ; goto VAR_817 ; } VAR_818 = METHOD_100 ( VAR_819 , ( TYPE_75 ) VAR_820 ) ; VAR_821 : METHOD_101 ( & VAR_822 -> VAR_823 ) ; METHOD_102 ( VAR_824 ) ; break ; } case VAR_825 : { if ( METHOD_103 ( & VAR_826 -> VAR_827 ) ) { METHOD_104 ( VAR_828 , VAR_829 , VAR_830 , VAR_831 , ""IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - VAR_832 ; } METHOD_105 ( VAR_833 , VAR_834 , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , VAR_835 -> VAR_836 ) ; if ( METHOD_106 ( & VAR_837 -> VAR_838 ) ) return - VAR_839 ; VAR_840 -> VAR_841 = VAR_842 ; VAR_843 -> VAR_844 = VAR_845 -> VAR_846 ; VAR_847 -> VAR_848 = VAR_849 ; VAR_850 -> VAR_851 = VAR_852 ; METHOD_107 ( VAR_853 -> VAR_854 ) ; METHOD_108 ( VAR_855 -> VAR_856 ) ; VAR_857 = METHOD_109 ( VAR_858 ) ; if ( VAR_859 ) { pr_err ( PFX ""%s:<S2SV_blank>reset_card_proc<S2SV_blank>Failed!\\n"" , VAR_860 -> VAR_861 -> VAR_862 ) ; METHOD_110 ( & VAR_863 -> VAR_864 ) ; METHOD_111 ( & VAR_865 -> VAR_866 ) ; return VAR_867 ; } METHOD_112 ( 10 ) ; METHOD_113 ( & VAR_868 -> VAR_869 ) ; return VAR_870 ; } case VAR_871 : { struct STRUCT_OR_UNION_29 * VAR_872 = VAR_873 ; METHOD_114 ( VAR_874 , VAR_875 , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , VAR_876 -> VAR_877 ) ; if ( ! METHOD_115 ( & VAR_878 -> VAR_879 ) ) { METHOD_116 ( VAR_880 , VAR_881 , 0 , 0 , ""Invalid<S2SV_blank>way<S2SV_blank>to<S2SV_blank>download<S2SV_blank>buffer.<S2SV_blank>Use<S2SV_blank>Start<S2SV_blank>and<S2SV_blank>then<S2SV_blank>call<S2SV_blank>this!!!\\n"" ) ; METHOD_117 ( & VAR_882 -> VAR_883 ) ; VAR_884 = - VAR_885 ; return VAR_886 ; } if ( METHOD_118 ( & VAR_887 , VAR_888 , sizeof ( struct STRUCT_OR_UNION_30 ) ) ) { METHOD_119 ( & VAR_889 -> VAR_890 ) ; return - VAR_891 ; } METHOD_120 ( VAR_892 , VAR_893 , 0 , 0 , ""Length<S2SV_blank>for<S2SV_blank>FW<S2SV_blank>DLD<S2SV_blank>is<S2SV_blank>:<S2SV_blank>%lx\\n"" , VAR_894 . VAR_895 ) ; if ( VAR_896 . VAR_897 > sizeof ( struct STRUCT_OR_UNION_31 ) ) { METHOD_121 ( & VAR_898 -> VAR_899 ) ; return - VAR_900 ; } VAR_901 = METHOD_122 ( sizeof ( * VAR_902 ) , VAR_903 ) ; if ( ! VAR_904 ) { METHOD_123 ( & VAR_905 -> VAR_906 ) ; return - VAR_907 ; } if ( METHOD_124 ( VAR_908 , VAR_909 . VAR_910 , VAR_911 . VAR_912 ) ) { METHOD_125 ( & VAR_913 -> VAR_914 ) ; METHOD_126 ( VAR_915 ) ; return - VAR_916 ; } if ( ! VAR_917 -> VAR_918 || ( VAR_919 -> VAR_920 == 0 ) ) { METHOD_127 ( VAR_921 , VAR_922 , 0 , 0 , ""Something<S2SV_blank>else<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>%lu\\n"" , VAR_923 -> VAR_924 ) ; METHOD_128 ( & VAR_925 -> VAR_926 ) ; METHOD_129 ( VAR_927 ) ; VAR_928 = - VAR_929 ; return VAR_930 ; } VAR_931 = METHOD_130 ( VAR_932 , VAR_933 ) ; if ( VAR_934 != VAR_935 ) { if ( VAR_936 -> VAR_937 == VAR_938 ) METHOD_131 ( VAR_939 , VAR_940 , 0 , 0 , ""IOCTL:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; else METHOD_132 ( VAR_941 , VAR_942 , 0 , 0 , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; if ( VAR_943 -> VAR_944 . VAR_945 & VAR_946 ) { VAR_947 -> VAR_948 = VAR_949 ; VAR_950 -> VAR_951 . VAR_952 = VAR_953 ; METHOD_133 ( & VAR_954 -> VAR_955 . VAR_956 ) ; } } if ( VAR_957 != VAR_958 ) METHOD_134 ( & VAR_959 -> VAR_960 ) ; METHOD_135 ( VAR_961 , VAR_962 , VAR_963 , VAR_964 , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Uploaded\\n"" ) ; METHOD_136 ( VAR_965 ) ; return VAR_966 ; } case VAR_967 : { if ( ! METHOD_137 ( & VAR_968 -> VAR_969 ) ) { METHOD_138 ( & VAR_970 -> VAR_971 ) ; return - VAR_972 ; } if ( METHOD_139 ( & VAR_973 -> VAR_974 ) ) { METHOD_140 ( VAR_975 , VAR_976 , 0 , 0 , ""FW<S2SV_blank>download<S2SV_blank>blocked<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; METHOD_141 ( & VAR_977 -> VAR_978 ) ; return - VAR_979 ; } VAR_980 -> VAR_981 = VAR_982 ; VAR_983 -> VAR_984 = VAR_985 ; METHOD_142 ( & VAR_986 -> VAR_987 , 0 ) ; VAR_988 -> VAR_989 = 0 ; VAR_990 -> VAR_991 = 0 ; VAR_992 = METHOD_143 ( VAR_993 ) ; if ( VAR_994 ) { METHOD_144 ( VAR_995 , VAR_996 , 0 , 0 , ""Firm<S2SV_blank>Download<S2SV_blank>Failed\\n"" ) ; METHOD_145 ( & VAR_997 -> VAR_998 ) ; METHOD_146 ( & VAR_999 -> VAR_1000 ) ; return VAR_1001 ; } else { METHOD_147 ( VAR_1002 , VAR_1003 , VAR_1004 , VAR_1005 , ""Firm<S2SV_blank>Download<S2SV_blank>Over...\\n"" ) ; } METHOD_148 ( 10 ) ; if ( METHOD_149 ( ( struct STRUCT_OR_UNION_32 * ) VAR_1006 -> VAR_1007 ) ) METHOD_150 ( VAR_1008 , VAR_1009 , 0 , 0 , ""Unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>interrupt...\\n"" ) ; VAR_1010 = 5 * VAR_1011 ; VAR_1012 -> VAR_1013 = VAR_1014 ; METHOD_151 ( VAR_1015 -> VAR_1016 , VAR_1017 -> VAR_1018 , VAR_1019 ) ; VAR_1020 -> VAR_1021 = VAR_1022 ; VAR_1023 -> VAR_1024 = VAR_1025 ; METHOD_152 ( & VAR_1026 -> VAR_1027 , 0 ) ; VAR_1028 -> VAR_1029 = 0 ; VAR_1030 -> VAR_1031 = 0 ; METHOD_153 ( & VAR_1032 -> VAR_1033 , 0 ) ; VAR_1034 -> VAR_1035 = 0 ; VAR_1036 -> VAR_1037 = 0 ; if ( VAR_1038 -> VAR_1039 . VAR_1040 & VAR_1041 ) { VAR_1042 -> VAR_1043 = VAR_1044 ; METHOD_154 ( & VAR_1045 -> VAR_1046 . VAR_1047 ) ; } if ( ! VAR_1048 ) VAR_1049 = - VAR_1050 ; METHOD_155 ( & VAR_1051 -> VAR_1052 ) ; METHOD_156 ( & VAR_1053 -> VAR_1054 ) ; return VAR_1055 ; } case VAR_1056 : VAR_1057 = 0 ; if ( METHOD_157 ( VAR_1058 -> VAR_1059 , ( unsigned TYPE_76 TYPE_77 * ) VAR_1060 ) ) VAR_1061 = - VAR_1062 ; break ; case VAR_1063 : VAR_1064 = 0 ; if ( METHOD_158 ( VAR_1065 -> VAR_1066 , ( unsigned TYPE_78 TYPE_79 * ) VAR_1067 ) ) VAR_1068 = - VAR_1069 ; break ; case VAR_1070 : { TYPE_80 VAR_1071 = METHOD_159 ( & VAR_1072 -> VAR_1073 ) ; if ( VAR_1074 ) { METHOD_160 ( VAR_1075 , VAR_1076 , 0 , 0 , ""<S2SV_blank>IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - VAR_1077 ; } METHOD_161 ( & VAR_1078 -> VAR_1079 ) ; VAR_1080 = METHOD_162 ( VAR_1081 ) ; METHOD_163 ( ) ; METHOD_164 ( & VAR_1082 -> VAR_1083 ) ; METHOD_165 ( & VAR_1084 -> VAR_1085 ) ; METHOD_166 ( VAR_1086 ) ; break ; } case VAR_1087 : { TYPE_81 VAR_1088 ; VAR_1089 = 0 ; for ( VAR_1090 = 0 ; VAR_1091 < VAR_1092 ; VAR_1093 ++ ) { if ( METHOD_167 ( VAR_1094 -> VAR_1095 [ VAR_1096 ] . VAR_1097 , ( unsigned TYPE_82 TYPE_83 * ) VAR_1098 ) ) { VAR_1099 = - VAR_1100 ; break ; } } break ; } case VAR_1101 : METHOD_168 ( VAR_1102 ) ; METHOD_169 ( & VAR_1103 -> VAR_1104 ) ; VAR_1105 = VAR_1106 ; break ; case VAR_1107 : if ( METHOD_170 ( VAR_1108 , & VAR_1109 -> VAR_1110 , sizeof ( struct STRUCT_OR_UNION_33 ) * VAR_1111 ) ) return - VAR_1112 ; VAR_1113 = VAR_1114 ; break ; case VAR_1115 : { TYPE_84 VAR_1116 = 0 ; if ( METHOD_171 ( & VAR_1117 , VAR_1118 , sizeof ( TYPE_85 ) ) ) return - VAR_1119 ; if ( VAR_1120 ) { METHOD_172 ( VAR_1121 , VAR_1122 , VAR_1123 , VAR_1124 , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>ETH_PACKET_TUNNELING_MODE\\n"" ) ; VAR_1125 -> VAR_1126 = VAR_1127 ; } else { METHOD_173 ( VAR_1128 , VAR_1129 , VAR_1130 , VAR_1131 , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>IP_PACKET_ONLY_MODE\\n"" ) ; VAR_1132 -> VAR_1133 = VAR_1134 ; } VAR_1135 = VAR_1136 ; break ; } case VAR_1137 : { TYPE_86 VAR_1138 ; if ( METHOD_174 ( & VAR_1139 , VAR_1140 , sizeof ( struct STRUCT_OR_UNION_34 ) ) ) return - VAR_1141 ; VAR_1142 = METHOD_175 ( TYPE_87 , VAR_1143 . VAR_1144 , METHOD_176 ( VAR_1145 ) + 1 ) ; if ( METHOD_177 ( VAR_1146 . VAR_1147 , VAR_1148 , VAR_1149 ) ) return - VAR_1150 ; VAR_1151 = VAR_1152 ; break ; } case VAR_1153 : { struct STRUCT_OR_UNION_35 VAR_1154 ; if ( METHOD_178 ( & VAR_1155 , VAR_1156 , sizeof ( struct STRUCT_OR_UNION_36 ) ) ) { METHOD_179 ( VAR_1157 , VAR_1158 , 0 , 0 , ""copy_from_user<S2SV_blank>failed..\\n"" ) ; return - VAR_1159 ; } if ( VAR_1160 . VAR_1161 != sizeof ( VAR_1162 ) ) { VAR_1163 = - VAR_1164 ; break ; } METHOD_180 ( & VAR_1165 , 0 , sizeof ( VAR_1166 ) ) ; VAR_1167 . VAR_1168 = VAR_1169 -> VAR_1170 ; VAR_1171 . VAR_1172 = VAR_1173 -> VAR_1174 ; VAR_1175 . VAR_1176 = VAR_1177 -> VAR_1178 ; if ( METHOD_181 ( VAR_1179 . VAR_1180 , & VAR_1181 , METHOD_182 ( VAR_1182 , sizeof ( VAR_1183 ) , VAR_1184 . VAR_1185 ) ) ) { METHOD_183 ( VAR_1186 , VAR_1187 , 0 , 0 , ""Copy_to_user<S2SV_blank>Failed..\\n"" ) ; return - VAR_1188 ; } VAR_1189 = VAR_1190 ; break ; } case VAR_1191 : { TYPE_88 VAR_1192 ; if ( METHOD_184 ( & VAR_1193 , VAR_1194 , sizeof ( struct STRUCT_OR_UNION_37 ) ) ) return - VAR_1195 ; if ( METHOD_185 ( & VAR_1196 , VAR_1197 . VAR_1198 , sizeof ( TYPE_89 ) ) ) return - VAR_1199 ; if ( VAR_1200 ) VAR_1201 -> VAR_1202 -> VAR_1203 = VAR_1204 ; else VAR_1205 -> VAR_1206 -> VAR_1207 = VAR_1208 ; break ; } case VAR_1209 : { TYPE_90 VAR_1210 = 0 ; if ( METHOD_186 ( & VAR_1211 , VAR_1212 , sizeof ( struct STRUCT_OR_UNION_38 ) ) ) return - VAR_1213 ; if ( VAR_1214 . VAR_1215 < sizeof ( struct STRUCT_OR_UNION_39 ) ) { METHOD_187 ( VAR_1216 , VAR_1217 , 0 , 0 , ""Mismatch<S2SV_blank>req:<S2SV_blank>%lx<S2SV_blank>needed<S2SV_blank>is<S2SV_blank>=0x%zx!!!"" , VAR_1218 . VAR_1219 , sizeof ( struct STRUCT_OR_UNION_40 ) ) ; return - VAR_1220 ; } if ( METHOD_188 ( & VAR_1221 , VAR_1222 . VAR_1223 , sizeof ( VAR_1224 ) ) ) return - VAR_1225 ; METHOD_189 ( VAR_1226 , VAR_1227 , VAR_1228 , VAR_1229 , ""Get<S2SV_blank>DSX<S2SV_blank>Data<S2SV_blank>SF<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>=%lx\\n"" , VAR_1230 ) ; METHOD_190 ( VAR_1231 , VAR_1232 , VAR_1233 . VAR_1234 ) ; VAR_1235 = VAR_1236 ; } break ; case VAR_1237 : { TYPE_91 VAR_1238 ; if ( METHOD_191 ( & VAR_1239 , VAR_1240 , sizeof ( struct STRUCT_OR_UNION_41 ) ) ) return - VAR_1241 ; if ( VAR_1242 . VAR_1243 != sizeof ( struct STRUCT_OR_UNION_42 ) ) { METHOD_192 ( VAR_1244 , VAR_1245 , 0 , 0 , ""Length<S2SV_blank>Check<S2SV_blank>failed<S2SV_blank>%lu<S2SV_blank>%zd\\n"" , VAR_1246 . VAR_1247 , sizeof ( struct STRUCT_OR_UNION_43 ) ) ; return - VAR_1248 ; } VAR_1249 = METHOD_193 ( sizeof ( struct STRUCT_OR_UNION_44 ) , VAR_1250 ) ; if ( ! VAR_1251 ) return VAR_1252 ; VAR_1253 = METHOD_194 ( VAR_1254 , VAR_1255 ) ; METHOD_195 ( VAR_1256 , VAR_1257 ) ; if ( VAR_1258 != VAR_1259 ) if ( METHOD_196 ( VAR_1260 . VAR_1261 , VAR_1262 , sizeof ( struct STRUCT_OR_UNION_45 ) ) ) { METHOD_197 ( VAR_1263 ) ; return - VAR_1264 ; } METHOD_198 ( VAR_1265 ) ; break ; } case VAR_1266 : if ( ( VAR_1267 == VAR_1268 -> VAR_1269 ) && ( VAR_1270 == VAR_1271 -> VAR_1272 ) ) { VAR_1273 -> VAR_1274 = VAR_1275 ; VAR_1276 -> VAR_1277 = VAR_1278 ; METHOD_199 ( & VAR_1279 -> VAR_1280 ) ; } VAR_1281 = VAR_1282 ; break ; case VAR_1283 : { struct STRUCT_OR_UNION_46 * VAR_1284 ; TYPE_92 VAR_1285 = 0 ; TYPE_93 VAR_1286 = VAR_1287 ; if ( ( VAR_1288 -> VAR_1289 == VAR_1290 ) || ( VAR_1291 -> VAR_1292 == VAR_1293 ) || ( VAR_1294 -> VAR_1295 == VAR_1296 ) ) { METHOD_200 ( VAR_1297 , VAR_1298 , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; VAR_1299 = - VAR_1300 ; break ; } if ( METHOD_201 ( & VAR_1301 , VAR_1302 , sizeof ( struct STRUCT_OR_UNION_47 ) ) ) return - VAR_1303 ; if ( VAR_1304 . VAR_1305 < sizeof ( TYPE_94 ) * 2 ) return - VAR_1306 ; VAR_1307 = METHOD_202 ( VAR_1308 . VAR_1309 , VAR_1310 . VAR_1311 ) ; if ( METHOD_203 ( VAR_1312 ) ) return METHOD_204 ( VAR_1313 ) ; VAR_1314 = ( struct STRUCT_OR_UNION_48 * ) VAR_1315 ; if ( ( ( TYPE_95 ) VAR_1316 -> VAR_1317 & 0x0F000000 ) != 0x0F000000 || ( ( TYPE_96 ) VAR_1318 -> VAR_1319 & 0x3 ) ) { METHOD_205 ( VAR_1320 , VAR_1321 , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( TYPE_97 ) VAR_1322 -> VAR_1323 ) ; METHOD_206 ( VAR_1324 ) ; VAR_1325 = - VAR_1326 ; break ; } VAR_1327 = VAR_1328 -> VAR_1329 & VAR_1330 ; if ( ! ( ( VAR_1331 -> VAR_1332 -> VAR_1333 ) & VAR_1334 ) && ( ( VAR_1335 == VAR_1336 ) || ( VAR_1337 == VAR_1338 ) || ( VAR_1339 == VAR_1340 ) || ( VAR_1341 == VAR_1342 ) ) && ( VAR_1343 == VAR_1344 ) ) { METHOD_207 ( VAR_1345 ) ; METHOD_208 ( VAR_1346 , VAR_1347 , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; VAR_1348 = - VAR_1349 ; break ; } if ( VAR_1350 -> VAR_1351 == VAR_1352 ) VAR_1353 = METHOD_209 ( VAR_1354 , ( TYPE_98 ) VAR_1355 -> VAR_1356 , ( TYPE_99 ) VAR_1357 -> VAR_1358 , VAR_1359 . VAR_1360 - 2 * sizeof ( TYPE_100 ) ) ; else VAR_1361 = METHOD_210 ( VAR_1362 , ( TYPE_101 ) VAR_1363 -> VAR_1364 , ( TYPE_102 ) VAR_1365 -> VAR_1366 , VAR_1367 . VAR_1368 - 2 * sizeof ( TYPE_103 ) ) ; if ( VAR_1369 != VAR_1370 ) METHOD_211 ( VAR_1371 , VAR_1372 , 0 , 0 , ""WRM<S2SV_blank>Failed\\n"" ) ; METHOD_212 ( VAR_1373 ) ; break ; } case VAR_1374 : if ( METHOD_213 ( & VAR_1375 , VAR_1376 , sizeof ( struct STRUCT_OR_UNION_49 ) ) ) return - VAR_1377 ; if ( VAR_1378 -> VAR_1379 == VAR_1380 || VAR_1381 -> VAR_1382 == VAR_1383 ) { if ( METHOD_214 ( VAR_1384 . VAR_1385 , & VAR_1386 -> VAR_1387 , sizeof ( TYPE_104 ) ) ) return - VAR_1388 ; } VAR_1389 = VAR_1390 ; break ; case VAR_1391 : { TYPE_105 VAR_1392 = 0 ; if ( VAR_1393 -> VAR_1394 == VAR_1395 ) { if ( METHOD_215 ( & VAR_1396 , VAR_1397 , sizeof ( struct STRUCT_OR_UNION_50 ) ) ) return - VAR_1398 ; if ( METHOD_216 ( & VAR_1399 , VAR_1400 . VAR_1401 , sizeof ( TYPE_106 ) ) ) return - VAR_1402 ; if ( ( VAR_1403 < VAR_1404 ) || ( VAR_1405 > VAR_1406 ) ) { if ( METHOD_217 ( VAR_1407 . VAR_1408 , & VAR_1409 -> VAR_1410 , sizeof ( TYPE_107 ) ) ) return - VAR_1411 ; } else { if ( METHOD_218 ( VAR_1412 ) ) { if ( METHOD_219 ( VAR_1413 . VAR_1414 , & VAR_1415 -> VAR_1416 , sizeof ( TYPE_108 ) ) ) return - VAR_1417 ; } else { if ( ( VAR_1418 == VAR_1419 -> VAR_1420 ) || ( VAR_1421 == VAR_1422 -> VAR_1423 ) ) { METHOD_220 ( VAR_1424 , VAR_1425 , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; return - VAR_1426 ; } VAR_1427 -> VAR_1428 = VAR_1429 ; METHOD_221 ( VAR_1430 , VAR_1431 -> VAR_1432 ) ; } } VAR_1433 = VAR_1434 ; } else { VAR_1435 = VAR_1436 ; } } break ; case VAR_1437 : TYPE_109 VAR_1438 { struct STRUCT_OR_UNION_51 VAR_1439 ; METHOD_222 ( VAR_1440 , VAR_1441 , VAR_1442 , VAR_1443 , ""In<S2SV_blank>SET_DEBUG<S2SV_blank>ioctl\\n"" ) ; if ( METHOD_223 ( & VAR_1444 , VAR_1445 , sizeof ( struct STRUCT_OR_UNION_52 ) ) ) return - VAR_1446 ; if ( METHOD_224 ( & VAR_1447 , VAR_1448 . VAR_1449 , sizeof ( struct STRUCT_OR_UNION_53 ) ) ) return - VAR_1450 ; METHOD_225 ( VAR_1451 , VAR_1452 , 0 , 0 , ""IOCTL_BCM_SET_DEBUG:<S2SV_blank>OnOff=%d<S2SV_blank>Type<S2SV_blank>=<S2SV_blank>0x%x<S2SV_blank>"" , VAR_1453 . VAR_1454 , VAR_1455 . VAR_1456 ) ; VAR_1457 . VAR_1458 = 1 << VAR_1459 . VAR_1460 ; METHOD_226 ( VAR_1461 , VAR_1462 , 0 , 0 , ""actual<S2SV_blank>Subtype=0x%x\\n"" , VAR_1463 . VAR_1464 ) ; VAR_1465 -> VAR_1466 . VAR_1467 |= VAR_1468 . VAR_1469 ; if ( VAR_1470 . VAR_1471 ) VAR_1472 -> VAR_1473 . VAR_1474 [ VAR_1475 . VAR_1476 ] |= VAR_1477 . VAR_1478 ; else VAR_1479 -> VAR_1480 . VAR_1481 [ VAR_1482 . VAR_1483 ] &= ~ VAR_1484 . VAR_1485 ; METHOD_227 ( VAR_1486 ) ; } break ; case VAR_1487 : case VAR_1488 : { struct STRUCT_OR_UNION_54 VAR_1489 ; TYPE_110 VAR_1490 = VAR_1491 ; TYPE_111 VAR_1492 = 0 ; struct STRUCT_OR_UNION_55 VAR_1493 , VAR_1494 ; METHOD_228 ( & VAR_1495 , 0 , sizeof ( struct STRUCT_OR_UNION_56 ) ) ; METHOD_229 ( & VAR_1496 , 0 , sizeof ( struct STRUCT_OR_UNION_57 ) ) ; if ( ( VAR_1497 -> VAR_1498 == VAR_1499 ) && ( VAR_1500 -> VAR_1501 == 0 ) ) { METHOD_230 ( VAR_1502 , VAR_1503 , 0 , 0 , ""The<S2SV_blank>Flash<S2SV_blank>Control<S2SV_blank>Section<S2SV_blank>is<S2SV_blank>Corrupted.<S2SV_blank>Hence<S2SV_blank>Rejection<S2SV_blank>on<S2SV_blank>NVM<S2SV_blank>Read/Write\\n"" ) ; return - VAR_1504 ; } if ( METHOD_231 ( VAR_1505 ) ) { if ( ( VAR_1506 -> VAR_1507 != VAR_1508 ) && ( VAR_1509 -> VAR_1510 != VAR_1511 ) && ( VAR_1512 -> VAR_1513 != VAR_1514 ) ) { METHOD_232 ( VAR_1515 , VAR_1516 , 0 , 0 , ""No<S2SV_blank>DSD<S2SV_blank>is<S2SV_blank>active..hence<S2SV_blank>NVM<S2SV_blank>Command<S2SV_blank>is<S2SV_blank>blocked"" ) ; return VAR_1517 ; } } if ( METHOD_233 ( & VAR_1518 , VAR_1519 , sizeof ( struct STRUCT_OR_UNION_58 ) ) ) return - VAR_1520 ; if ( METHOD_234 ( & VAR_1521 , ( VAR_1522 == VAR_1523 ) ? VAR_1524 . VAR_1525 : VAR_1526 . VAR_1527 , sizeof ( struct STRUCT_OR_UNION_59 ) ) ) return - VAR_1528 ; if ( VAR_1529 . VAR_1530 > VAR_1531 -> VAR_1532 ) return VAR_1533 ; if ( VAR_1534 . VAR_1535 > VAR_1536 -> VAR_1537 - VAR_1538 . VAR_1539 ) { return VAR_1540 ; } VAR_1541 = METHOD_235 ( VAR_1542 . VAR_1543 , VAR_1544 . VAR_1545 ) ; if ( METHOD_236 ( VAR_1546 ) ) return METHOD_237 ( VAR_1547 ) ; METHOD_238 ( & VAR_1548 ) ; if ( VAR_1549 == VAR_1550 ) { METHOD_239 ( & VAR_1551 -> VAR_1552 ) ; if ( ( VAR_1553 -> VAR_1554 == VAR_1555 ) || ( VAR_1556 -> VAR_1557 == VAR_1558 ) || ( VAR_1559 -> VAR_1560 == VAR_1561 ) ) { METHOD_240 ( VAR_1562 , VAR_1563 , VAR_1564 , VAR_1565 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_241 ( & VAR_1566 -> VAR_1567 ) ; METHOD_242 ( VAR_1568 ) ; return - VAR_1569 ; } VAR_1570 = METHOD_243 ( VAR_1571 , ( TYPE_112 ) VAR_1572 , VAR_1573 . VAR_1574 , VAR_1575 . VAR_1576 ) ; METHOD_244 ( & VAR_1577 -> VAR_1578 ) ; if ( VAR_1579 != VAR_1580 ) { METHOD_245 ( VAR_1581 ) ; return VAR_1582 ; } if ( METHOD_246 ( VAR_1583 . VAR_1584 , VAR_1585 , VAR_1586 . VAR_1587 ) ) { METHOD_247 ( VAR_1588 ) ; return - VAR_1589 ; } } else { METHOD_248 ( & VAR_1590 -> VAR_1591 ) ; if ( ( VAR_1592 -> VAR_1593 == VAR_1594 ) || ( VAR_1595 -> VAR_1596 == VAR_1597 ) || ( VAR_1598 -> VAR_1599 == VAR_1600 ) ) { METHOD_249 ( VAR_1601 , VAR_1602 , VAR_1603 , VAR_1604 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_250 ( & VAR_1605 -> VAR_1606 ) ; METHOD_251 ( VAR_1607 ) ; return - VAR_1608 ; } VAR_1609 -> VAR_1610 = VAR_1611 ; if ( METHOD_252 ( VAR_1612 ) ) { VAR_1613 = METHOD_253 ( VAR_1614 , VAR_1615 -> VAR_1616 ) ; if ( VAR_1617 != VAR_1618 ) { if ( ( ( VAR_1619 . VAR_1620 + VAR_1621 . VAR_1622 ) != VAR_1623 -> VAR_1624 ) || ( VAR_1625 . VAR_1626 < VAR_1627 ) ) { METHOD_254 ( VAR_1628 , VAR_1629 , VAR_1630 , VAR_1631 , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; METHOD_255 ( & VAR_1632 -> VAR_1633 ) ; METHOD_256 ( VAR_1634 ) ; return VAR_1635 ; } VAR_1636 = METHOD_257 ( * ( TYPE_113 ) ( VAR_1637 + VAR_1638 . VAR_1639 - VAR_1640 ) ) ; if ( VAR_1641 != VAR_1642 ) { METHOD_258 ( VAR_1643 , VAR_1644 , VAR_1645 , VAR_1646 , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; METHOD_259 ( & VAR_1647 -> VAR_1648 ) ; METHOD_260 ( VAR_1649 ) ; return VAR_1650 ; } } } VAR_1651 = METHOD_261 ( VAR_1652 , ( TYPE_114 ) VAR_1653 , VAR_1654 . VAR_1655 , VAR_1656 . VAR_1657 , VAR_1658 . VAR_1659 ) ; if ( METHOD_262 ( VAR_1660 ) ) METHOD_263 ( VAR_1661 , VAR_1662 -> VAR_1663 ) ; VAR_1664 -> VAR_1665 = VAR_1666 ; METHOD_264 ( & VAR_1667 -> VAR_1668 ) ; if ( VAR_1669 != VAR_1670 ) { METHOD_265 ( VAR_1671 ) ; return VAR_1672 ; } } METHOD_266 ( & VAR_1673 ) ; METHOD_267 ( VAR_1674 , VAR_1675 , VAR_1676 , VAR_1677 , ""<S2SV_blank>timetaken<S2SV_blank>by<S2SV_blank>Write/read<S2SV_blank>:%ld<S2SV_blank>msec\\n"" , ( VAR_1678 . VAR_1679 - VAR_1680 . VAR_1681 ) * 1000 + ( VAR_1682 . VAR_1683 - VAR_1684 . VAR_1685 ) / 1000 ) ; METHOD_268 ( VAR_1686 ) ; return VAR_1687 ; } case VAR_1688 : { struct STRUCT_OR_UNION_60 VAR_1689 = { 0 } ; TYPE_115 VAR_1690 = VAR_1691 ; TYPE_116 VAR_1692 = 0 ; TYPE_117 VAR_1693 = 0 ; TYPE_118 VAR_1694 = 0 ; TYPE_119 VAR_1695 = 0 ; TYPE_120 TYPE_121 * VAR_1696 ; if ( METHOD_269 ( VAR_1697 ) != VAR_1698 ) { METHOD_270 ( VAR_1699 , VAR_1700 , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - VAR_1701 ; } METHOD_271 ( VAR_1702 , VAR_1703 , VAR_1704 , VAR_1705 , ""IOCTL_BCM_FLASH2X_SECTION_READ<S2SV_blank>Called"" ) ; if ( METHOD_272 ( & VAR_1706 , VAR_1707 , sizeof ( struct STRUCT_OR_UNION_61 ) ) ) return - VAR_1708 ; if ( METHOD_273 ( & VAR_1709 , VAR_1710 . VAR_1711 , sizeof ( struct STRUCT_OR_UNION_62 ) ) ) return - VAR_1712 ; METHOD_274 ( VAR_1713 , VAR_1714 , VAR_1715 , VAR_1716 , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , VAR_1717 . VAR_1718 ) ; METHOD_275 ( VAR_1719 , VAR_1720 , VAR_1721 , VAR_1722 , ""\\nsFlash2xRead.offset<S2SV_blank>:%x"" , VAR_1723 . VAR_1724 ) ; METHOD_276 ( VAR_1725 , VAR_1726 , VAR_1727 , VAR_1728 , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , VAR_1729 . VAR_1730 ) ; METHOD_277 ( VAR_1731 , VAR_1732 , VAR_1733 , VAR_1734 , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , VAR_1735 . VAR_1736 ) ; if ( METHOD_278 ( VAR_1737 , & VAR_1738 ) == VAR_1739 ) return VAR_1740 ; VAR_1741 = VAR_1742 . VAR_1743 ; if ( VAR_1744 > VAR_1745 -> VAR_1746 ) VAR_1747 = VAR_1748 -> VAR_1749 ; else VAR_1750 = VAR_1751 ; VAR_1752 = VAR_1753 . VAR_1754 ; VAR_1755 = VAR_1756 . VAR_1757 ; VAR_1758 = ( TYPE_122 ) METHOD_279 ( VAR_1759 , VAR_1760 ) ; if ( VAR_1761 == VAR_1762 ) { METHOD_280 ( VAR_1763 , VAR_1764 , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; return - VAR_1765 ; } METHOD_281 ( & VAR_1766 -> VAR_1767 ) ; if ( ( VAR_1768 -> VAR_1769 == VAR_1770 ) || ( VAR_1771 -> VAR_1772 == VAR_1773 ) || ( VAR_1774 -> VAR_1775 == VAR_1776 ) ) { METHOD_282 ( VAR_1777 , VAR_1778 , VAR_1779 , VAR_1780 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_283 ( & VAR_1781 -> VAR_1782 ) ; METHOD_284 ( VAR_1783 ) ; return - VAR_1784 ; } while ( VAR_1785 ) { if ( VAR_1786 > VAR_1787 -> VAR_1788 ) VAR_1789 = VAR_1790 -> VAR_1791 ; else VAR_1792 = VAR_1793 ; VAR_1794 = METHOD_285 ( VAR_1795 , ( TYPE_123 ) VAR_1796 , VAR_1797 . VAR_1798 , VAR_1799 , VAR_1800 ) ; if ( VAR_1801 ) { METHOD_286 ( VAR_1802 , VAR_1803 , VAR_1804 , VAR_1805 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , VAR_1806 ) ; break ; } METHOD_287 ( VAR_1807 , VAR_1808 , VAR_1809 , VAR_1810 , VAR_1811 , VAR_1812 ) ; VAR_1813 = METHOD_288 ( VAR_1814 , VAR_1815 , VAR_1816 ) ; if ( VAR_1817 ) { METHOD_289 ( VAR_1818 , VAR_1819 , VAR_1820 , VAR_1821 , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , VAR_1822 ) ; METHOD_290 ( & VAR_1823 -> VAR_1824 ) ; METHOD_291 ( VAR_1825 ) ; return - VAR_1826 ; } VAR_1827 = VAR_1828 - VAR_1829 ; if ( VAR_1830 ) { VAR_1831 = VAR_1832 + VAR_1833 ; VAR_1834 = VAR_1835 + VAR_1836 ; } } METHOD_292 ( & VAR_1837 -> VAR_1838 ) ; METHOD_293 ( VAR_1839 ) ; } break ; case VAR_1840 : { struct STRUCT_OR_UNION_63 VAR_1841 = { 0 } ; TYPE_124 VAR_1842 ; TYPE_125 TYPE_126 * VAR_1843 ; TYPE_127 VAR_1844 = 0 ; TYPE_128 VAR_1845 = 0 ; TYPE_129 VAR_1846 = 0 ; TYPE_130 VAR_1847 = 0 ; if ( METHOD_294 ( VAR_1848 ) != VAR_1849 ) { METHOD_295 ( VAR_1850 , VAR_1851 , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - VAR_1852 ; } VAR_1853 -> VAR_1854 = VAR_1855 ; METHOD_296 ( VAR_1856 , VAR_1857 , VAR_1858 , VAR_1859 , ""IOCTL_BCM_FLASH2X_SECTION_WRITE<S2SV_blank>Called"" ) ; if ( METHOD_297 ( & VAR_1860 , VAR_1861 , sizeof ( struct STRUCT_OR_UNION_64 ) ) ) return - VAR_1862 ; if ( METHOD_298 ( & VAR_1863 , VAR_1864 . VAR_1865 , sizeof ( struct STRUCT_OR_UNION_65 ) ) ) return - VAR_1866 ; METHOD_299 ( VAR_1867 , VAR_1868 , VAR_1869 , VAR_1870 , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , VAR_1871 . VAR_1872 ) ; METHOD_300 ( VAR_1873 , VAR_1874 , VAR_1875 , VAR_1876 , ""\\nsFlash2xRead.offset<S2SV_blank>:%d"" , VAR_1877 . VAR_1878 ) ; METHOD_301 ( VAR_1879 , VAR_1880 , VAR_1881 , VAR_1882 , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , VAR_1883 . VAR_1884 ) ; METHOD_302 ( VAR_1885 , VAR_1886 , VAR_1887 , VAR_1888 , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , VAR_1889 . VAR_1890 ) ; if ( ( VAR_1891 . VAR_1892 != VAR_1893 ) && ( VAR_1894 . VAR_1895 != VAR_1896 ) && ( VAR_1897 . VAR_1898 != VAR_1899 ) ) { METHOD_303 ( VAR_1900 , VAR_1901 , VAR_1902 , VAR_1903 , ""Only<S2SV_blank>VSA<S2SV_blank>write<S2SV_blank>is<S2SV_blank>allowed"" ) ; return - VAR_1904 ; } if ( METHOD_304 ( VAR_1905 , & VAR_1906 ) == VAR_1907 ) return VAR_1908 ; VAR_1909 = VAR_1910 . VAR_1911 ; VAR_1912 = VAR_1913 . VAR_1914 ; VAR_1915 = VAR_1916 . VAR_1917 ; if ( VAR_1918 > VAR_1919 -> VAR_1920 ) VAR_1921 = VAR_1922 -> VAR_1923 ; else VAR_1924 = VAR_1925 ; VAR_1926 = METHOD_305 ( VAR_1927 , VAR_1928 ) ; if ( VAR_1929 == VAR_1930 ) return - VAR_1931 ; VAR_1932 = VAR_1933 -> VAR_1934 ; if ( VAR_1935 % VAR_1936 -> VAR_1937 ) VAR_1938 = VAR_1939 -> VAR_1940 - ( VAR_1941 % VAR_1942 -> VAR_1943 ) ; if ( VAR_1944 < VAR_1945 ) VAR_1946 = VAR_1947 ; METHOD_306 ( & VAR_1948 -> VAR_1949 ) ; if ( ( VAR_1950 -> VAR_1951 == VAR_1952 ) || ( VAR_1953 -> VAR_1954 == VAR_1955 ) || ( VAR_1956 -> VAR_1957 == VAR_1958 ) ) { METHOD_307 ( VAR_1959 , VAR_1960 , VAR_1961 , VAR_1962 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_308 ( & VAR_1963 -> VAR_1964 ) ; METHOD_309 ( VAR_1965 ) ; return - VAR_1966 ; } METHOD_310 ( VAR_1967 , VAR_1968 . VAR_1969 ) ; do { VAR_1970 = METHOD_311 ( VAR_1971 , VAR_1972 , VAR_1973 ) ; if ( VAR_1974 ) { METHOD_312 ( VAR_1975 , VAR_1976 , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>user<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , VAR_1977 ) ; METHOD_313 ( & VAR_1978 -> VAR_1979 ) ; METHOD_314 ( VAR_1980 ) ; return - VAR_1981 ; } METHOD_315 ( VAR_1982 , VAR_1983 , VAR_1984 , VAR_1985 , VAR_1986 , VAR_1987 ) ; VAR_1988 = METHOD_316 ( VAR_1989 , ( TYPE_131 ) VAR_1990 , VAR_1991 . VAR_1992 , VAR_1993 , VAR_1994 , VAR_1995 . VAR_1996 ) ; if ( VAR_1997 ) { METHOD_317 ( VAR_1998 , VAR_1999 , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , VAR_2000 ) ; break ; } VAR_2001 = VAR_2002 - VAR_2003 ; if ( VAR_2004 ) { VAR_2005 = VAR_2006 + VAR_2007 ; VAR_2008 = VAR_2009 + VAR_2010 ; if ( VAR_2011 > VAR_2012 -> VAR_2013 ) VAR_2014 = VAR_2015 -> VAR_2016 ; else VAR_2017 = VAR_2018 ; } } while ( VAR_2019 > 0 ) ; METHOD_318 ( VAR_2020 , VAR_2021 . VAR_2022 ) ; METHOD_319 ( & VAR_2023 -> VAR_2024 ) ; METHOD_320 ( VAR_2025 ) ; } break ; case VAR_2026 : { struct STRUCT_OR_UNION_66 * VAR_2027 ; METHOD_321 ( VAR_2028 , VAR_2029 , VAR_2030 , VAR_2031 , ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP<S2SV_blank>Called"" ) ; if ( METHOD_322 ( & VAR_2032 , VAR_2033 , sizeof ( struct STRUCT_OR_UNION_67 ) ) ) return - VAR_2034 ; if ( VAR_2035 . VAR_2036 != sizeof ( struct STRUCT_OR_UNION_68 ) ) return - VAR_2037 ; VAR_2038 = METHOD_323 ( sizeof ( struct STRUCT_OR_UNION_69 ) , VAR_2039 ) ; if ( VAR_2040 == VAR_2041 ) { METHOD_324 ( VAR_2042 , VAR_2043 , 0 , 0 , ""Memory<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ) ; return - VAR_2044 ; } METHOD_325 ( & VAR_2045 -> VAR_2046 ) ; if ( ( VAR_2047 -> VAR_2048 == VAR_2049 ) || ( VAR_2050 -> VAR_2051 == VAR_2052 ) || ( VAR_2053 -> VAR_2054 == VAR_2055 ) ) { METHOD_326 ( VAR_2056 , VAR_2057 , VAR_2058 , VAR_2059 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_327 ( & VAR_2060 -> VAR_2061 ) ; METHOD_328 ( VAR_2062 ) ; return - VAR_2063 ; } METHOD_329 ( VAR_2064 , VAR_2065 ) ; METHOD_330 ( & VAR_2066 -> VAR_2067 ) ; if ( METHOD_331 ( VAR_2068 . VAR_2069 , VAR_2070 , sizeof ( struct STRUCT_OR_UNION_70 ) ) ) { METHOD_332 ( VAR_2071 ) ; return - VAR_2072 ; } METHOD_333 ( VAR_2073 ) ; } break ; case VAR_2074 : { enum VAR_2075 VAR_2076 = 0 ; METHOD_334 ( VAR_2077 , VAR_2078 , VAR_2079 , VAR_2080 , ""IOCTL_BCM_SET_ACTIVE_SECTION<S2SV_blank>Called"" ) ; if ( METHOD_335 ( VAR_2081 ) != VAR_2082 ) { METHOD_336 ( VAR_2083 , VAR_2084 , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - VAR_2085 ; } VAR_2086 = METHOD_337 ( & VAR_2087 , VAR_2088 , sizeof ( struct STRUCT_OR_UNION_71 ) ) ; if ( VAR_2089 ) { METHOD_338 ( VAR_2090 , VAR_2091 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - VAR_2092 ; } VAR_2093 = METHOD_339 ( & VAR_2094 , VAR_2095 . VAR_2096 , sizeof ( TYPE_132 ) ) ; if ( VAR_2097 ) { METHOD_340 ( VAR_2098 , VAR_2099 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - VAR_2100 ; } METHOD_341 ( & VAR_2101 -> VAR_2102 ) ; if ( ( VAR_2103 -> VAR_2104 == VAR_2105 ) || ( VAR_2106 -> VAR_2107 == VAR_2108 ) || ( VAR_2109 -> VAR_2110 == VAR_2111 ) ) { METHOD_342 ( VAR_2112 , VAR_2113 , VAR_2114 , VAR_2115 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_343 ( & VAR_2116 -> VAR_2117 ) ; return - VAR_2118 ; } VAR_2119 = METHOD_344 ( VAR_2120 , VAR_2121 ) ; if ( VAR_2122 ) METHOD_345 ( VAR_2123 , VAR_2124 , 0 , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>it\'s<S2SV_blank>priority<S2SV_blank>Highest.<S2SV_blank>Status<S2SV_blank>%d"" , VAR_2125 ) ; METHOD_346 ( & VAR_2126 -> VAR_2127 ) ; } break ; case VAR_2128 : { VAR_2129 -> VAR_2130 = VAR_2131 ; METHOD_347 ( VAR_2132 , VAR_2133 , VAR_2134 , VAR_2135 , ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION<S2SV_blank>called"" ) ; VAR_2136 = VAR_2137 ; } break ; case VAR_2138 : { struct STRUCT_OR_UNION_72 VAR_2139 = { 0 } ; VAR_2140 = VAR_2141 ; METHOD_348 ( VAR_2142 , VAR_2143 , VAR_2144 , VAR_2145 , ""IOCTL_BCM_COPY_SECTION<S2SV_blank><S2SV_blank>Called"" ) ; VAR_2146 -> VAR_2147 = VAR_2148 ; if ( METHOD_349 ( VAR_2149 ) != VAR_2150 ) { METHOD_350 ( VAR_2151 , VAR_2152 , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - VAR_2153 ; } VAR_2154 = METHOD_351 ( & VAR_2155 , VAR_2156 , sizeof ( struct STRUCT_OR_UNION_73 ) ) ; if ( VAR_2157 ) { METHOD_352 ( VAR_2158 , VAR_2159 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed<S2SV_blank>Status<S2SV_blank>:%d"" , VAR_2160 ) ; return - VAR_2161 ; } VAR_2162 = METHOD_353 ( & VAR_2163 , VAR_2164 . VAR_2165 , sizeof ( struct STRUCT_OR_UNION_74 ) ) ; if ( VAR_2166 ) { METHOD_354 ( VAR_2167 , VAR_2168 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>Copy_Section_Struct<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , VAR_2169 ) ; return - VAR_2170 ; } METHOD_355 ( VAR_2171 , VAR_2172 , VAR_2173 , VAR_2174 , ""Source<S2SV_blank>SEction<S2SV_blank>:%x"" , VAR_2175 . VAR_2176 ) ; METHOD_356 ( VAR_2177 , VAR_2178 , VAR_2179 , VAR_2180 , ""Destination<S2SV_blank>SEction<S2SV_blank>:%x"" , VAR_2181 . VAR_2182 ) ; METHOD_357 ( VAR_2183 , VAR_2184 , VAR_2185 , VAR_2186 , ""offset<S2SV_blank>:%x"" , VAR_2187 . VAR_2188 ) ; METHOD_358 ( VAR_2189 , VAR_2190 , VAR_2191 , VAR_2192 , ""NOB<S2SV_blank>:%x"" , VAR_2193 . VAR_2194 ) ; if ( METHOD_359 ( VAR_2195 , VAR_2196 . VAR_2197 ) == VAR_2198 ) { METHOD_360 ( VAR_2199 , VAR_2200 , 0 , 0 , ""Source<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , VAR_2201 . VAR_2202 ) ; return - VAR_2203 ; } if ( METHOD_361 ( VAR_2204 , VAR_2205 . VAR_2206 ) == VAR_2207 ) { METHOD_362 ( VAR_2208 , VAR_2209 , 0 , 0 , ""Destinatio<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , VAR_2210 . VAR_2211 ) ; return - VAR_2212 ; } if ( VAR_2213 . VAR_2214 == VAR_2215 . VAR_2216 ) { METHOD_363 ( VAR_2217 , VAR_2218 , VAR_2219 , VAR_2220 , ""Source<S2SV_blank>and<S2SV_blank>Destination<S2SV_blank>section<S2SV_blank>should<S2SV_blank>be<S2SV_blank>different"" ) ; return - VAR_2221 ; } METHOD_364 ( & VAR_2222 -> VAR_2223 ) ; if ( ( VAR_2224 -> VAR_2225 == VAR_2226 ) || ( VAR_2227 -> VAR_2228 == VAR_2229 ) || ( VAR_2230 -> VAR_2231 == VAR_2232 ) ) { METHOD_365 ( VAR_2233 , VAR_2234 , VAR_2235 , VAR_2236 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_366 ( & VAR_2237 -> VAR_2238 ) ; return - VAR_2239 ; } if ( VAR_2240 . VAR_2241 == VAR_2242 || VAR_2243 . VAR_2244 == VAR_2245 ) { if ( METHOD_367 ( VAR_2246 ) ) { METHOD_368 ( VAR_2247 , VAR_2248 , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>Non-CDLess<S2SV_blank>hence<S2SV_blank>won\'t<S2SV_blank>have<S2SV_blank>ISO<S2SV_blank>!!"" ) ; VAR_2249 = - VAR_2250 ; } else if ( VAR_2251 . VAR_2252 == 0 ) { VAR_2253 = METHOD_369 ( VAR_2254 , VAR_2255 ) ; } else { METHOD_370 ( VAR_2256 , VAR_2257 , 0 , 0 , ""Partial<S2SV_blank>Copy<S2SV_blank>of<S2SV_blank>ISO<S2SV_blank>section<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Allowed.."" ) ; VAR_2258 = VAR_2259 ; } METHOD_371 ( & VAR_2260 -> VAR_2261 ) ; return VAR_2262 ; } VAR_2263 = METHOD_372 ( VAR_2264 , VAR_2265 . VAR_2266 , VAR_2267 . VAR_2268 , VAR_2269 . VAR_2270 , VAR_2271 . VAR_2272 ) ; METHOD_373 ( & VAR_2273 -> VAR_2274 ) ; } break ; case VAR_2275 : { VAR_2276 = VAR_2277 ; METHOD_374 ( VAR_2278 , VAR_2279 , VAR_2280 , VAR_2281 , ""<S2SV_blank>IOCTL_BCM_GET_FLASH_CS_INFO<S2SV_blank>Called"" ) ; VAR_2282 = METHOD_375 ( & VAR_2283 , VAR_2284 , sizeof ( struct STRUCT_OR_UNION_75 ) ) ; if ( VAR_2285 ) { METHOD_376 ( VAR_2286 , VAR_2287 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - VAR_2288 ; } if ( VAR_2289 -> VAR_2290 != VAR_2291 ) { METHOD_377 ( VAR_2292 , VAR_2293 , 0 , 0 , ""Connected<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>flash"" ) ; VAR_2294 = - VAR_2295 ; break ; } if ( METHOD_378 ( VAR_2296 ) == VAR_2297 ) { if ( VAR_2298 . VAR_2299 < sizeof ( struct STRUCT_OR_UNION_76 ) ) return - VAR_2300 ; if ( METHOD_379 ( VAR_2301 . VAR_2302 , VAR_2303 -> VAR_2304 , sizeof ( struct STRUCT_OR_UNION_77 ) ) ) return - VAR_2305 ; } else { if ( VAR_2306 . VAR_2307 < sizeof ( struct STRUCT_OR_UNION_78 ) ) return - VAR_2308 ; if ( METHOD_380 ( VAR_2309 . VAR_2310 , VAR_2311 -> VAR_2312 , sizeof ( struct STRUCT_OR_UNION_79 ) ) ) return - VAR_2313 ; } } break ; case VAR_2314 : { TYPE_133 VAR_2315 = 0 ; enum VAR_2316 VAR_2317 ; VAR_2318 = VAR_2319 ; METHOD_381 ( VAR_2320 , VAR_2321 , VAR_2322 , VAR_2323 , ""IOCTL_BCM_SELECT_DSD<S2SV_blank>Called"" ) ; if ( METHOD_382 ( VAR_2324 ) != VAR_2325 ) { METHOD_383 ( VAR_2326 , VAR_2327 , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - VAR_2328 ; } VAR_2329 = METHOD_384 ( & VAR_2330 , VAR_2331 , sizeof ( struct STRUCT_OR_UNION_80 ) ) ; if ( VAR_2332 ) { METHOD_385 ( VAR_2333 , VAR_2334 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - VAR_2335 ; } VAR_2336 = METHOD_386 ( & VAR_2337 , VAR_2338 . VAR_2339 , sizeof ( TYPE_134 ) ) ; if ( VAR_2340 ) { METHOD_387 ( VAR_2341 , VAR_2342 , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - VAR_2343 ; } METHOD_388 ( VAR_2344 , VAR_2345 , VAR_2346 , VAR_2347 , ""Read<S2SV_blank>Section<S2SV_blank>:%d"" , VAR_2348 ) ; if ( ( VAR_2349 != VAR_2350 ) && ( VAR_2351 != VAR_2352 ) && ( VAR_2353 != VAR_2354 ) ) { METHOD_389 ( VAR_2355 , VAR_2356 , 0 , 0 , ""Passed<S2SV_blank>section<%x><S2SV_blank>is<S2SV_blank>not<S2SV_blank>DSD<S2SV_blank>section"" , VAR_2357 ) ; return VAR_2358 ; } VAR_2359 = METHOD_390 ( VAR_2360 , VAR_2361 ) ; if ( VAR_2362 == VAR_2363 ) { METHOD_391 ( VAR_2364 , VAR_2365 , 0 , 0 , ""Provided<S2SV_blank>Section<S2SV_blank>val<S2SV_blank><%d><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>2.x"" , VAR_2366 ) ; return - VAR_2367 ; } VAR_2368 -> VAR_2369 = VAR_2370 ; VAR_2371 -> VAR_2372 = VAR_2373 ; VAR_2374 -> VAR_2375 = VAR_2376 ; } VAR_2377 = VAR_2378 ; break ; case VAR_2379 : { struct STRUCT_OR_UNION_81 VAR_2380 ; TYPE_135 VAR_2381 ; TYPE_136 VAR_2382 ; TYPE_137 VAR_2383 = 0 ; TYPE_138 VAR_2384 = 0 ; TYPE_139 VAR_2385 ; TYPE_140 TYPE_141 * VAR_2386 ; if ( VAR_2387 -> VAR_2388 != VAR_2389 ) { METHOD_392 ( VAR_2390 , VAR_2391 , 0 , 0 , ""NVM<S2SV_blank>TYPE<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Flash"" ) ; return - VAR_2392 ; } if ( METHOD_393 ( & VAR_2393 , VAR_2394 , sizeof ( struct STRUCT_OR_UNION_82 ) ) ) { METHOD_394 ( VAR_2395 , VAR_2396 , 0 , 0 , ""copy_from_user<S2SV_blank>1<S2SV_blank>failed\\n"" ) ; return - VAR_2397 ; } if ( METHOD_395 ( & VAR_2398 , VAR_2399 . VAR_2400 , sizeof ( struct STRUCT_OR_UNION_83 ) ) ) return - VAR_2401 ; VAR_2402 = VAR_2403 . VAR_2404 ; if ( VAR_2405 > VAR_2406 ) VAR_2407 = VAR_2408 ; else VAR_2409 = VAR_2410 ; VAR_2411 = VAR_2412 . VAR_2413 ; VAR_2414 = VAR_2415 . VAR_2416 ; VAR_2417 = METHOD_396 ( VAR_2418 , VAR_2419 ) ; if ( VAR_2420 == VAR_2421 ) { METHOD_397 ( VAR_2422 , VAR_2423 , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; VAR_2424 = - VAR_2425 ; break ; } METHOD_398 ( & VAR_2426 -> VAR_2427 ) ; if ( ( VAR_2428 -> VAR_2429 == VAR_2430 ) || ( VAR_2431 -> VAR_2432 == VAR_2433 ) || ( VAR_2434 -> VAR_2435 == VAR_2436 ) ) { METHOD_399 ( VAR_2437 , VAR_2438 , VAR_2439 , VAR_2440 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; METHOD_400 ( VAR_2441 ) ; METHOD_401 ( & VAR_2442 -> VAR_2443 ) ; return - VAR_2444 ; } VAR_2445 -> VAR_2446 = VAR_2447 ; while ( VAR_2448 ) { if ( VAR_2449 > VAR_2450 ) VAR_2451 = VAR_2452 ; else VAR_2453 = VAR_2454 ; VAR_2455 = METHOD_402 ( VAR_2456 , ( TYPE_142 ) VAR_2457 , VAR_2458 , VAR_2459 ) ; if ( VAR_2460 ) { METHOD_403 ( VAR_2461 , VAR_2462 , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , VAR_2463 ) ; break ; } METHOD_404 ( VAR_2464 , VAR_2465 , VAR_2466 , VAR_2467 , VAR_2468 , VAR_2469 ) ; VAR_2470 = METHOD_405 ( VAR_2471 , VAR_2472 , VAR_2473 ) ; if ( VAR_2474 ) { METHOD_406 ( VAR_2475 , VAR_2476 , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , VAR_2477 ) ; METHOD_407 ( & VAR_2478 -> VAR_2479 ) ; METHOD_408 ( VAR_2480 ) ; return - VAR_2481 ; } VAR_2482 = VAR_2483 - VAR_2484 ; if ( VAR_2485 ) { VAR_2486 = VAR_2487 + VAR_2488 ; VAR_2489 = VAR_2490 + VAR_2491 ; } } VAR_2492 -> VAR_2493 = VAR_2494 ; METHOD_409 ( & VAR_2495 -> VAR_2496 ) ; METHOD_410 ( VAR_2497 ) ; break ; } case VAR_2498 : { TYPE_143 VAR_2499 = 0 ; VAR_2500 = METHOD_411 ( & VAR_2501 , VAR_2502 , sizeof ( struct STRUCT_OR_UNION_84 ) ) ; if ( VAR_2503 ) { METHOD_412 ( VAR_2504 , VAR_2505 , VAR_2506 , VAR_2507 , ""copy<S2SV_blank>of<S2SV_blank>Ioctl<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - VAR_2508 ; } if ( VAR_2509 . VAR_2510 != sizeof ( unsigned TYPE_144 ) ) { VAR_2511 = - VAR_2512 ; break ; } VAR_2513 = METHOD_413 ( & VAR_2514 , VAR_2515 . VAR_2516 , VAR_2517 . VAR_2518 ) ; if ( VAR_2519 ) { METHOD_414 ( VAR_2520 , VAR_2521 , VAR_2522 , VAR_2523 , ""copy<S2SV_blank>of<S2SV_blank>control<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - VAR_2524 ; } METHOD_415 ( VAR_2525 , VAR_2526 , VAR_2527 , VAR_2528 , ""\\n<S2SV_blank>Got<S2SV_blank>user<S2SV_blank>d<S2SV_blank>cntrl<S2SV_blank>msg<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>:%lx"" , VAR_2529 ) ; VAR_2530 -> VAR_2531 = VAR_2532 ; } break ; case VAR_2533 : { struct STRUCT_OR_UNION_85 VAR_2534 ; METHOD_416 ( VAR_2535 , VAR_2536 , VAR_2537 , VAR_2538 , ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; <S2SV_StartBug> VAR_2539 . VAR_2540 = VAR_2541 ; <S2SV_EndBug> VAR_2542 . VAR_2543 = VAR_2544 ; VAR_2545 . VAR_2546 = 0 ; VAR_2547 . VAR_2548 = VAR_2549 -> VAR_2550 ; VAR_2551 . VAR_2552 = VAR_2553 ; if ( METHOD_417 ( & VAR_2554 , VAR_2555 , sizeof ( struct STRUCT_OR_UNION_86 ) ) ) return - VAR_2556 ; if ( VAR_2557 . VAR_2558 < sizeof ( VAR_2559 ) ) return - VAR_2560 ; if ( METHOD_418 ( VAR_2561 . VAR_2562 , & VAR_2563 , sizeof ( VAR_2564 ) ) ) return - VAR_2565 ; } break ; case VAR_2566 : { struct STRUCT_OR_UNION_87 VAR_2567 = { 0 } ; METHOD_419 ( VAR_2568 , VAR_2569 , VAR_2570 , VAR_2571 , ""IOCTL_BCM_TIME_SINCE_NET_ENTRY<S2SV_blank>called"" ) ; if ( METHOD_420 ( & VAR_2572 , VAR_2573 , sizeof ( struct STRUCT_OR_UNION_88 ) ) ) return - VAR_2574 ; if ( VAR_2575 . VAR_2576 < sizeof ( struct STRUCT_OR_UNION_89 ) ) return - VAR_2577 ; VAR_2578 . VAR_2579 = METHOD_421 ( ) - VAR_2580 -> VAR_2581 ; if ( METHOD_422 ( VAR_2582 . VAR_2583 , & VAR_2584 , sizeof ( struct STRUCT_OR_UNION_90 ) ) ) return - VAR_2585 ; } break ; case VAR_2586 : METHOD_423 ( VAR_2587 , VAR_2588 , VAR_2589 , VAR_2590 , ""IOCTL_CLOSE_NOTIFICATION"" ) ; break ; default : pr_info ( DRV_NAME "":<S2SV_blank>unknown<S2SV_blank>ioctl<S2SV_blank>cmd=%x\\n"" , VAR_2591 ) ; VAR_2592 = VAR_2593 ; break ; } return VAR_2594 ; }","<S2SV_ModStart> ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; METHOD_229 ( & VAR_2564 , 0 , sizeof ( VAR_2564 ) ) ;","CWE-200 static long bcm_char_ioctl ( struct file * filp , UINT cmd , ULONG arg ) { struct bcm_tarang_data * pTarang = filp -> private_data ; void __user * argp = ( void __user * ) arg ; struct bcm_mini_adapter * Adapter = pTarang -> Adapter ; INT Status = STATUS_FAILURE ; int timeout = 0 ; struct bcm_ioctl_buffer IoBuffer ; int bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Parameters<S2SV_blank>Passed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>IOCTL<S2SV_blank>cmd=0x%X<S2SV_blank>arg=0x%lX"" , cmd , arg ) ; if ( _IOC_TYPE ( cmd ) != BCM_IOCTL ) return - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_READ ) Status = ! access_ok ( VERIFY_WRITE , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) Status = ! access_ok ( VERIFY_READ , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_NONE == ( _IOC_DIR ( cmd ) & _IOC_NONE ) ) Status = STATUS_SUCCESS ; if ( Status ) return - EFAULT ; if ( Adapter -> device_removed ) return - EFAULT ; if ( FALSE == Adapter -> fw_download_done ) { switch ( cmd ) { case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : case IOCTL_BCM_GPIO_SET_REQUEST : case IOCTL_BCM_GPIO_STATUS_REQUEST : return - EACCES ; default : break ; } } Status = vendorextnIoctl ( Adapter , cmd , arg ) ; if ( Status != CONTINUE_COMMON_PATH ) return Status ; switch ( cmd ) { case IOCTL_BCM_REGISTER_READ_PRIVATE : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff ; UINT Bufflen ; u16 temp_value ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } Bufflen = IoBuffer . OutputLength ; temp_value = 4 - ( Bufflen % 4 ) ; Bufflen += temp_value % 4 ; temp_buff = kmalloc ( Bufflen , GFP_KERNEL ) ; if ( ! temp_buff ) return - ENOMEM ; bytes = rdmalt ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , Bufflen ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE_PRIVATE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - EFAULT ; } Status = wrmalt ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Done\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Failed\\n"" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_REGISTER_READ : case IOCTL_BCM_EEPROM_REGISTER_READ : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff = NULL ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Rdms\\n"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } temp_buff = kmalloc ( IoBuffer . OutputLength , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; if ( ( ( ( ULONG ) sRdmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sRdmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) sRdmBuffer . Register ) ; kfree ( temp_buff ) ; return - EINVAL ; } uiTempVar = sRdmBuffer . Register & EEPROM_REJECT_MASK ; bytes = rdmaltWithLock ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , IoBuffer . OutputLength ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE : case IOCTL_BCM_EEPROM_REGISTER_WRITE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( ( ( ( ULONG ) sWrmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sWrmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) sWrmBuffer . Register ) ; return - EINVAL ; } uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - EFAULT ; } Status = wrmaltWithLock ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sWrmBuffer . Length ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Done\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Failed\\n"" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_GPIO_SET_REQUEST : { UCHAR ucResetValue [ 4 ] ; UINT value = 0 ; UINT uiBit = 0 ; UINT uiOperation = 0 ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; uiOperation = gpio_info . uiGpioValue ; value = ( 1 << uiBit ) ; if ( IsReqGpioIsLedInNVM ( Adapter , value ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>LED<S2SV_blank>!!!"" , value ) ; Status = - EINVAL ; break ; } if ( uiOperation ) { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , uiBit ) ; break ; } } else { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , uiBit ) ; break ; } } bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO_MODE_REGISTER<S2SV_blank>read<S2SV_blank>failed"" ) ; break ; } else { Status = STATUS_SUCCESS ; } * ( UINT * ) ucResetValue |= ( 1 << uiBit ) ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>to<S2SV_blank>output<S2SV_blank>Mode\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>GPIO<S2SV_blank>in<S2SV_blank>Output<S2SV_blank>Mode\\n"" ) ; break ; } } break ; case BCM_LED_THREAD_STATE_CHANGE_REQ : { struct bcm_user_thread_req threadReq = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""User<S2SV_blank>made<S2SV_blank>LED<S2SV_blank>thread<S2SV_blank>InActive"" ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( threadReq ) ) return - EINVAL ; if ( copy_from_user ( & threadReq , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( Adapter -> LEDInfo . led_thread_running ) { if ( threadReq . ThreadState == LED_THREAD_ACTIVATION_REQ ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Activating<S2SV_blank>thread<S2SV_blank>req"" ) ; Adapter -> DriverState = LED_THREAD_ACTIVE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DeActivating<S2SV_blank>Thread<S2SV_blank>req....."" ) ; Adapter -> DriverState = LED_THREAD_INACTIVE ; } wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } break ; case IOCTL_BCM_GPIO_STATUS_REQUEST : { ULONG uiBit = 0 ; UCHAR ucRead [ 4 ] ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EACCES ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucRead , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>Failed\\n"" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } } break ; case IOCTL_BCM_GPIO_MULTI_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_info gpio_multi_info [ MAX_IDX ] ; struct bcm_gpio_multi_info * pgpio_multi_info = ( struct bcm_gpio_multi_info * ) gpio_multi_info ; memset ( pgpio_multi_info , 0 , MAX_IDX * sizeof ( struct bcm_gpio_multi_info ) ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) & ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand ) ) { * ( UINT * ) ucResetValue = pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_SET_REG<S2SV_blank>Failed."" ) ; return Status ; } * ( UINT * ) ucResetValue = ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & ( ~ ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ) ) ) ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_CLR_REG<S2SV_blank>Failed."" ) ; return Status ; } } if ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) { bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>to<S2SV_blank>GPIO_PIN_STATE_REGISTER<S2SV_blank>Failed."" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue = ( * ( UINT * ) ucResetValue & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_info , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , Status ) ; return - EFAULT ; } } break ; case IOCTL_BCM_GPIO_MODE_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_mode gpio_multi_mode [ MAX_IDX ] ; struct bcm_gpio_multi_mode * pgpio_multi_mode = ( struct bcm_gpio_multi_mode * ) gpio_multi_mode ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_mode ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_mode , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Read<S2SV_blank>of<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>failed"" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) { * ( UINT * ) ucResetValue |= ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; * ( UINT * ) ucResetValue &= ~ ( ( ~ pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode ) & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Done"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Failed"" ) ; Status = - EFAULT ; break ; } } else { pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_mode , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , Status ) ; return - EFAULT ; } } break ; case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : { PVOID pvBuffer = NULL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( struct bcm_link_request ) ) return - EINVAL ; if ( IoBuffer . InputLength > MAX_CNTL_PKT_SIZE ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; down ( & Adapter -> LowPowerModeSync ) ; Status = wait_event_interruptible_timeout ( Adapter -> lowpower_mode_wait_queue , ! Adapter -> bPreparingForLowPowerMode , ( 1 * HZ ) ) ; if ( Status == - ERESTARTSYS ) goto cntrlEnd ; if ( Adapter -> bPreparingForLowPowerMode ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Preparing<S2SV_blank>Idle<S2SV_blank>Mode<S2SV_blank>is<S2SV_blank>still<S2SV_blank>True<S2SV_blank>-<S2SV_blank>Hence<S2SV_blank>Rejecting<S2SV_blank>control<S2SV_blank>message\\n"" ) ; Status = STATUS_FAILURE ; goto cntrlEnd ; } Status = CopyBufferToControlPacket ( Adapter , ( PVOID ) pvBuffer ) ; cntrlEnd : up ( & Adapter -> LowPowerModeSync ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_BUFFER_DOWNLOAD_START : { if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - EACCES ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , current -> pid ) ; if ( down_trylock ( & Adapter -> fw_download_sema ) ) return - EBUSY ; Adapter -> bBinDownloaded = FALSE ; Adapter -> fw_download_process_pid = current -> pid ; Adapter -> bCfgDownloaded = FALSE ; Adapter -> fw_download_done = FALSE ; netif_carrier_off ( Adapter -> dev ) ; netif_stop_queue ( Adapter -> dev ) ; Status = reset_card_proc ( Adapter ) ; if ( Status ) { pr_err ( PFX ""%s:<S2SV_blank>reset_card_proc<S2SV_blank>Failed!\\n"" , Adapter -> dev -> name ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } mdelay ( 10 ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD : { struct bcm_firmware_info * psFwInfo = NULL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , current -> pid ) ; if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Invalid<S2SV_blank>way<S2SV_blank>to<S2SV_blank>download<S2SV_blank>buffer.<S2SV_blank>Use<S2SV_blank>Start<S2SV_blank>and<S2SV_blank>then<S2SV_blank>call<S2SV_blank>this!!!\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; Status = - EINVAL ; return Status ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { up ( & Adapter -> fw_download_sema ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Length<S2SV_blank>for<S2SV_blank>FW<S2SV_blank>DLD<S2SV_blank>is<S2SV_blank>:<S2SV_blank>%lx\\n"" , IoBuffer . InputLength ) ; if ( IoBuffer . InputLength > sizeof ( struct bcm_firmware_info ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } psFwInfo = kmalloc ( sizeof ( * psFwInfo ) , GFP_KERNEL ) ; if ( ! psFwInfo ) { up ( & Adapter -> fw_download_sema ) ; return - ENOMEM ; } if ( copy_from_user ( psFwInfo , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) { up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; return - EFAULT ; } if ( ! psFwInfo -> pvMappedFirmwareAddress || ( psFwInfo -> u32FirmwareLength == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Something<S2SV_blank>else<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>%lu\\n"" , psFwInfo -> u32FirmwareLength ) ; up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; Status = - EINVAL ; return Status ; } Status = bcm_ioctl_fw_download ( Adapter , psFwInfo ) ; if ( Status != STATUS_SUCCESS ) { if ( psFwInfo -> u32StartingAddress == CONFIG_BEGIN_ADDR ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; else BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = DRIVER_INIT ; Adapter -> LEDInfo . bLedInitDone = FALSE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } if ( Status != STATUS_SUCCESS ) up ( & Adapter -> fw_download_sema ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Uploaded\\n"" ) ; kfree ( psFwInfo ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD_STOP : { if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""FW<S2SV_blank>download<S2SV_blank>blocked<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; return - EACCES ; } Adapter -> bBinDownloaded = TRUE ; Adapter -> bCfgDownloaded = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> downloadDDR = 0 ; Status = run_card_proc ( Adapter ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Firm<S2SV_blank>Download<S2SV_blank>Failed\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Firm<S2SV_blank>Download<S2SV_blank>Over...\\n"" ) ; } mdelay ( 10 ) ; if ( StartInterruptUrb ( ( struct bcm_interface_adapter * ) Adapter -> pvInterfaceAdapter ) ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>interrupt...\\n"" ) ; timeout = 5 * HZ ; Adapter -> waiting_to_fw_download_done = FALSE ; wait_event_timeout ( Adapter -> ioctl_fw_dnld_wait_queue , Adapter -> waiting_to_fw_download_done , timeout ) ; Adapter -> fw_download_process_pid = INVALID_PID ; Adapter -> fw_download_done = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> PrevNumRecvDescs = 0 ; atomic_set ( & Adapter -> cntrlpktCnt , 0 ) ; Adapter -> LinkUpStatus = 0 ; Adapter -> LinkStatus = 0 ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = FW_DOWNLOAD_DONE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } if ( ! timeout ) Status = - ENODEV ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BE_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> BEBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_RTPS_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> rtPSBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_CHIP_RESET : { INT NVMAccess = down_trylock ( & Adapter -> NVMRdmWrmLock ) ; if ( NVMAccess ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""<S2SV_blank>IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - EACCES ; } down ( & Adapter -> RxAppControlQueuelock ) ; Status = reset_card_proc ( Adapter ) ; flushAllAppQ ( ) ; up ( & Adapter -> RxAppControlQueuelock ) ; up ( & Adapter -> NVMRdmWrmLock ) ; ResetCounters ( Adapter ) ; break ; } case IOCTL_QOS_THRESHOLD : { USHORT uiLoopIndex ; Status = 0 ; for ( uiLoopIndex = 0 ; uiLoopIndex < NO_OF_QUEUES ; uiLoopIndex ++ ) { if ( get_user ( Adapter -> PackInfo [ uiLoopIndex ] . uiThreshold , ( unsigned long __user * ) arg ) ) { Status = - EFAULT ; break ; } } break ; } case IOCTL_DUMP_PACKET_INFO : DumpPackInfo ( Adapter ) ; DumpPhsRules ( & Adapter -> stBCMPhsContext ) ; Status = STATUS_SUCCESS ; break ; case IOCTL_GET_PACK_INFO : if ( copy_to_user ( argp , & Adapter -> PackInfo , sizeof ( struct bcm_packet_info ) * NO_OF_QUEUES ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_SWITCH_TRANSFER_MODE : { UINT uiData = 0 ; if ( copy_from_user ( & uiData , argp , sizeof ( UINT ) ) ) return - EFAULT ; if ( uiData ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>ETH_PACKET_TUNNELING_MODE\\n"" ) ; Adapter -> TransferMode = ETH_PACKET_TUNNELING_MODE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>IP_PACKET_ONLY_MODE\\n"" ) ; Adapter -> TransferMode = IP_PACKET_ONLY_MODE ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_DRIVER_VERSION : { ulong len ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; len = min_t ( ulong , IoBuffer . OutputLength , strlen ( DRV_VERSION ) + 1 ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , DRV_VERSION , len ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_CURRENT_STATUS : { struct bcm_link_state link_state ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""copy_from_user<S2SV_blank>failed..\\n"" ) ; return - EFAULT ; } if ( IoBuffer . OutputLength != sizeof ( link_state ) ) { Status = - EINVAL ; break ; } memset ( & link_state , 0 , sizeof ( link_state ) ) ; link_state . bIdleMode = Adapter -> IdleMode ; link_state . bShutdownMode = Adapter -> bShutStatus ; link_state . ucLinkStatus = Adapter -> LinkStatus ; if ( copy_to_user ( IoBuffer . OutputBuffer , & link_state , min_t ( size_t , sizeof ( link_state ) , IoBuffer . OutputLength ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy_to_user<S2SV_blank>Failed..\\n"" ) ; return - EFAULT ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_SET_MAC_TRACING : { UINT tracing_flag ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & tracing_flag , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( tracing_flag ) Adapter -> pTarangs -> MacTracingEnabled = TRUE ; else Adapter -> pTarangs -> MacTracingEnabled = FALSE ; break ; } case IOCTL_BCM_GET_DSX_INDICATION : { ULONG ulSFId = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_add_indication_alt ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Mismatch<S2SV_blank>req:<S2SV_blank>%lx<S2SV_blank>needed<S2SV_blank>is<S2SV_blank>=0x%zx!!!"" , IoBuffer . OutputLength , sizeof ( struct bcm_add_indication_alt ) ) ; return - EINVAL ; } if ( copy_from_user ( & ulSFId , IoBuffer . InputBuffer , sizeof ( ulSFId ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Get<S2SV_blank>DSX<S2SV_blank>Data<S2SV_blank>SF<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>=%lx\\n"" , ulSFId ) ; get_dsx_sf_data_to_application ( Adapter , ulSFId , IoBuffer . OutputBuffer ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_GET_HOST_MIBS : { PVOID temp_buff ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_host_stats_mibs ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Length<S2SV_blank>Check<S2SV_blank>failed<S2SV_blank>%lu<S2SV_blank>%zd\\n"" , IoBuffer . OutputLength , sizeof ( struct bcm_host_stats_mibs ) ) ; return - EINVAL ; } temp_buff = kzalloc ( sizeof ( struct bcm_host_stats_mibs ) , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; Status = ProcessGetHostMibs ( Adapter , temp_buff ) ; GetDroppedAppCntrlPktMibs ( temp_buff , pTarang ) ; if ( Status != STATUS_FAILURE ) if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , sizeof ( struct bcm_host_stats_mibs ) ) ) { kfree ( temp_buff ) ; return - EFAULT ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE : if ( ( FALSE == Adapter -> bTriedToWakeUpFromlowPowerMode ) && ( TRUE == Adapter -> IdleMode ) ) { Adapter -> usIdleModePattern = ABORT_IDLE_MODE ; Adapter -> bWakeUpDevice = TRUE ; wake_up ( & Adapter -> process_rx_cntrlpkt ) ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_BULK_WRM : { struct bcm_bulk_wrm_buffer * pBulkBuffer ; UINT uiTempVar = 0 ; PCHAR pvBuffer = NULL ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( ULONG ) * 2 ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; pBulkBuffer = ( struct bcm_bulk_wrm_buffer * ) pvBuffer ; if ( ( ( ULONG ) pBulkBuffer -> Register & 0x0F000000 ) != 0x0F000000 || ( ( ULONG ) pBulkBuffer -> Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) pBulkBuffer -> Register ) ; kfree ( pvBuffer ) ; Status = - EINVAL ; break ; } uiTempVar = pBulkBuffer -> Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { kfree ( pvBuffer ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; Status = - EFAULT ; break ; } if ( pBulkBuffer -> SwapEndian == FALSE ) Status = wrmWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PCHAR ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; else Status = wrmaltWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PUINT ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Failed\\n"" ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_GET_NVM_SIZE : if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( Adapter -> eNVMType == NVM_EEPROM || Adapter -> eNVMType == NVM_FLASH ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiNVMDSDSize , sizeof ( UINT ) ) ) return - EFAULT ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_CAL_INIT : { UINT uiSectorSize = 0 ; if ( Adapter -> eNVMType == NVM_FLASH ) { if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & uiSectorSize , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( ( uiSectorSize < MIN_SECTOR_SIZE ) || ( uiSectorSize > MAX_SECTOR_SIZE ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( IsFlash2x ( Adapter ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( ( TRUE == Adapter -> bShutStatus ) || ( TRUE == Adapter -> IdleMode ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; return - EACCES ; } Adapter -> uiSectorSize = uiSectorSize ; BcmUpdateSectorSize ( Adapter , Adapter -> uiSectorSize ) ; } } Status = STATUS_SUCCESS ; } else { Status = STATUS_FAILURE ; } } break ; case IOCTL_BCM_SET_DEBUG :  ifdef DEBUG { struct bcm_user_debug_state sUserDebugState ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""In<S2SV_blank>SET_DEBUG<S2SV_blank>ioctl\\n"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sUserDebugState , IoBuffer . InputBuffer , sizeof ( struct bcm_user_debug_state ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL_BCM_SET_DEBUG:<S2SV_blank>OnOff=%d<S2SV_blank>Type<S2SV_blank>=<S2SV_blank>0x%x<S2SV_blank>"" , sUserDebugState . OnOff , sUserDebugState . Type ) ; sUserDebugState . Subtype = 1 << sUserDebugState . Subtype ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""actual<S2SV_blank>Subtype=0x%x\\n"" , sUserDebugState . Subtype ) ; Adapter -> stDebugState . type |= sUserDebugState . Type ; if ( sUserDebugState . OnOff ) Adapter -> stDebugState . subtype [ sUserDebugState . Type ] |= sUserDebugState . Subtype ; else Adapter -> stDebugState . subtype [ sUserDebugState . Type ] &= ~ sUserDebugState . Subtype ; BCM_SHOW_DEBUG_BITMAP ( Adapter ) ; }   break ; case IOCTL_BCM_NVM_READ : case IOCTL_BCM_NVM_WRITE : { struct bcm_nvm_readwrite stNVMReadWrite ; PUCHAR pReadData = NULL ; ULONG ulDSDMagicNumInUsrBuff = 0 ; struct timeval tv0 , tv1 ; memset ( & tv0 , 0 , sizeof ( struct timeval ) ) ; memset ( & tv1 , 0 , sizeof ( struct timeval ) ) ; if ( ( Adapter -> eNVMType == NVM_FLASH ) && ( Adapter -> uiFlashLayoutMajorVersion == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""The<S2SV_blank>Flash<S2SV_blank>Control<S2SV_blank>Section<S2SV_blank>is<S2SV_blank>Corrupted.<S2SV_blank>Hence<S2SV_blank>Rejection<S2SV_blank>on<S2SV_blank>NVM<S2SV_blank>Read/Write\\n"" ) ; return - EFAULT ; } if ( IsFlash2x ( Adapter ) ) { if ( ( Adapter -> eActiveDSD != DSD0 ) && ( Adapter -> eActiveDSD != DSD1 ) && ( Adapter -> eActiveDSD != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""No<S2SV_blank>DSD<S2SV_blank>is<S2SV_blank>active..hence<S2SV_blank>NVM<S2SV_blank>Command<S2SV_blank>is<S2SV_blank>blocked"" ) ; return STATUS_FAILURE ; } } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & stNVMReadWrite , ( IOCTL_BCM_NVM_READ == cmd ) ? IoBuffer . OutputBuffer : IoBuffer . InputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; if ( stNVMReadWrite . uiNumBytes > Adapter -> uiNVMDSDSize ) return STATUS_FAILURE ; if ( stNVMReadWrite . uiOffset > Adapter -> uiNVMDSDSize - stNVMReadWrite . uiNumBytes ) { return STATUS_FAILURE ; } pReadData = memdup_user ( stNVMReadWrite . pBuffer , stNVMReadWrite . uiNumBytes ) ; if ( IS_ERR ( pReadData ) ) return PTR_ERR ( pReadData ) ; do_gettimeofday ( & tv0 ) ; if ( IOCTL_BCM_NVM_READ == cmd ) { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } if ( copy_to_user ( stNVMReadWrite . pBuffer , pReadData , stNVMReadWrite . uiNumBytes ) ) { kfree ( pReadData ) ; return - EFAULT ; } } else { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Adapter -> bHeaderChangeAllowed = TRUE ; if ( IsFlash2x ( Adapter ) ) { Status = BcmFlash2xCorruptSig ( Adapter , Adapter -> eActiveDSD ) ; if ( Status != STATUS_SUCCESS ) { if ( ( ( stNVMReadWrite . uiOffset + stNVMReadWrite . uiNumBytes ) != Adapter -> uiNVMDSDSize ) || ( stNVMReadWrite . uiNumBytes < SIGNATURE_SIZE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } ulDSDMagicNumInUsrBuff = ntohl ( * ( PUINT ) ( pReadData + stNVMReadWrite . uiNumBytes - SIGNATURE_SIZE ) ) ; if ( ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } } } Status = BeceemNVMWrite ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes , stNVMReadWrite . bVerify ) ; if ( IsFlash2x ( Adapter ) ) BcmFlash2xWriteSig ( Adapter , Adapter -> eActiveDSD ) ; Adapter -> bHeaderChangeAllowed = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } } do_gettimeofday ( & tv1 ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""<S2SV_blank>timetaken<S2SV_blank>by<S2SV_blank>Write/read<S2SV_blank>:%ld<S2SV_blank>msec\\n"" , ( tv1 . tv_sec - tv0 . tv_sec ) * 1000 + ( tv1 . tv_usec - tv0 . tv_usec ) / 1000 ) ; kfree ( pReadData ) ; return STATUS_SUCCESS ; } case IOCTL_BCM_FLASH2X_SECTION_READ : { struct bcm_flash2x_readwrite sFlash2xRead = { 0 } ; PUCHAR pReadBuff = NULL ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT ReadBytes = 0 ; UINT ReadOffset = 0 ; void __user * OutPutBuff ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_FLASH2X_SECTION_READ<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xRead , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , sFlash2xRead . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.offset<S2SV_blank>:%x"" , sFlash2xRead . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , sFlash2xRead . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , sFlash2xRead . bVerify ) ; if ( validateFlash2xReadWrite ( Adapter , & sFlash2xRead ) == FALSE ) return STATUS_FAILURE ; NOB = sFlash2xRead . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; ReadOffset = sFlash2xRead . offset ; OutPutBuff = IoBuffer . OutputBuffer ; pReadBuff = ( PCHAR ) kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EACCES ; } while ( NOB ) { if ( NOB > Adapter -> uiSectorSize ) ReadBytes = Adapter -> uiSectorSize ; else ReadBytes = NOB ; Status = BcmFlash2xBulkRead ( Adapter , ( PUINT ) pReadBuff , sFlash2xRead . Section , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; } break ; case IOCTL_BCM_FLASH2X_SECTION_WRITE : { struct bcm_flash2x_readwrite sFlash2xWrite = { 0 } ; PUCHAR pWriteBuff ; void __user * InputAddr ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT WriteOffset = 0 ; UINT WriteBytes = 0 ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_FLASH2X_SECTION_WRITE<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xWrite , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , sFlash2xWrite . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.offset<S2SV_blank>:%d"" , sFlash2xWrite . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , sFlash2xWrite . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , sFlash2xWrite . bVerify ) ; if ( ( sFlash2xWrite . Section != VSA0 ) && ( sFlash2xWrite . Section != VSA1 ) && ( sFlash2xWrite . Section != VSA2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Only<S2SV_blank>VSA<S2SV_blank>write<S2SV_blank>is<S2SV_blank>allowed"" ) ; return - EINVAL ; } if ( validateFlash2xReadWrite ( Adapter , & sFlash2xWrite ) == FALSE ) return STATUS_FAILURE ; InputAddr = sFlash2xWrite . pDataBuff ; WriteOffset = sFlash2xWrite . offset ; NOB = sFlash2xWrite . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; pWriteBuff = kmalloc ( BuffSize , GFP_KERNEL ) ; if ( pWriteBuff == NULL ) return - ENOMEM ; WriteBytes = Adapter -> uiSectorSize ; if ( WriteOffset % Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize - ( WriteOffset % Adapter -> uiSectorSize ) ; if ( NOB < WriteBytes ) WriteBytes = NOB ; down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EACCES ; } BcmFlash2xCorruptSig ( Adapter , sFlash2xWrite . Section ) ; do { Status = copy_from_user ( pWriteBuff , InputAddr , WriteBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>user<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EFAULT ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pWriteBuff , WriteBytes ) ; Status = BcmFlash2xBulkWrite ( Adapter , ( PUINT ) pWriteBuff , sFlash2xWrite . Section , WriteOffset , WriteBytes , sFlash2xWrite . bVerify ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } NOB = NOB - WriteBytes ; if ( NOB ) { WriteOffset = WriteOffset + WriteBytes ; InputAddr = InputAddr + WriteBytes ; if ( NOB > Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize ; else WriteBytes = NOB ; } } while ( NOB > 0 ) ; BcmFlash2xWriteSig ( Adapter , sFlash2xWrite . Section ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; } break ; case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP : { struct bcm_flash2x_bitmap * psFlash2xBitMap ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_flash2x_bitmap ) ) return - EINVAL ; psFlash2xBitMap = kzalloc ( sizeof ( struct bcm_flash2x_bitmap ) , GFP_KERNEL ) ; if ( psFlash2xBitMap == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( psFlash2xBitMap ) ; return - EACCES ; } BcmGetFlash2xSectionalBitMap ( Adapter , psFlash2xBitMap ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , psFlash2xBitMap , sizeof ( struct bcm_flash2x_bitmap ) ) ) { kfree ( psFlash2xBitMap ) ; return - EFAULT ; } kfree ( psFlash2xBitMap ) ; } break ; case IOCTL_BCM_SET_ACTIVE_SECTION : { enum bcm_flash2x_section_val eFlash2xSectionVal = 0 ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SET_ACTIVE_SECTION<S2SV_blank>Called"" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - EFAULT ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Status = BcmSetActiveSection ( Adapter , eFlash2xSectionVal ) ; if ( Status ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>it\'s<S2SV_blank>priority<S2SV_blank>Highest.<S2SV_blank>Status<S2SV_blank>%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION : { Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION<S2SV_blank>called"" ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_COPY_SECTION : { struct bcm_flash2x_copy_section sCopySectStrut = { 0 } ; Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_COPY_SECTION<S2SV_blank><S2SV_blank>Called"" ) ; Adapter -> bAllDSDWriteAllow = FALSE ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; return - EFAULT ; } Status = copy_from_user ( & sCopySectStrut , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_copy_section ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>Copy_Section_Struct<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Source<S2SV_blank>SEction<S2SV_blank>:%x"" , sCopySectStrut . SrcSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Destination<S2SV_blank>SEction<S2SV_blank>:%x"" , sCopySectStrut . DstSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""offset<S2SV_blank>:%x"" , sCopySectStrut . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""NOB<S2SV_blank>:%x"" , sCopySectStrut . numOfBytes ) ; if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . SrcSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Source<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , sCopySectStrut . SrcSection ) ; return - EINVAL ; } if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . DstSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Destinatio<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , sCopySectStrut . DstSection ) ; return - EINVAL ; } if ( sCopySectStrut . SrcSection == sCopySectStrut . DstSection ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Source<S2SV_blank>and<S2SV_blank>Destination<S2SV_blank>section<S2SV_blank>should<S2SV_blank>be<S2SV_blank>different"" ) ; return - EINVAL ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } if ( sCopySectStrut . SrcSection == ISO_IMAGE1 || sCopySectStrut . SrcSection == ISO_IMAGE2 ) { if ( IsNonCDLessDevice ( Adapter ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>Non-CDLess<S2SV_blank>hence<S2SV_blank>won\'t<S2SV_blank>have<S2SV_blank>ISO<S2SV_blank>!!"" ) ; Status = - EINVAL ; } else if ( sCopySectStrut . numOfBytes == 0 ) { Status = BcmCopyISO ( Adapter , sCopySectStrut ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Partial<S2SV_blank>Copy<S2SV_blank>of<S2SV_blank>ISO<S2SV_blank>section<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Allowed.."" ) ; Status = STATUS_FAILURE ; } up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } Status = BcmCopySection ( Adapter , sCopySectStrut . SrcSection , sCopySectStrut . DstSection , sCopySectStrut . offset , sCopySectStrut . numOfBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_GET_FLASH_CS_INFO : { Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""<S2SV_blank>IOCTL_BCM_GET_FLASH_CS_INFO<S2SV_blank>Called"" ) ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Connected<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>flash"" ) ; Status = - EINVAL ; break ; } if ( IsFlash2x ( Adapter ) == TRUE ) { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash2x_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlash2xCSInfo , sizeof ( struct bcm_flash2x_cs_info ) ) ) return - EFAULT ; } else { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlashCSInfo , sizeof ( struct bcm_flash_cs_info ) ) ) return - EFAULT ; } } break ; case IOCTL_BCM_SELECT_DSD : { UINT SectOfset = 0 ; enum bcm_flash2x_section_val eFlash2xSectionVal ; eFlash2xSectionVal = NO_SECTION_VAL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SELECT_DSD<S2SV_blank>Called"" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Read<S2SV_blank>Section<S2SV_blank>:%d"" , eFlash2xSectionVal ) ; if ( ( eFlash2xSectionVal != DSD0 ) && ( eFlash2xSectionVal != DSD1 ) && ( eFlash2xSectionVal != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Passed<S2SV_blank>section<%x><S2SV_blank>is<S2SV_blank>not<S2SV_blank>DSD<S2SV_blank>section"" , eFlash2xSectionVal ) ; return STATUS_FAILURE ; } SectOfset = BcmGetSectionValStartOffset ( Adapter , eFlash2xSectionVal ) ; if ( SectOfset == INVALID_OFFSET ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Provided<S2SV_blank>Section<S2SV_blank>val<S2SV_blank><%d><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>2.x"" , eFlash2xSectionVal ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = TRUE ; Adapter -> ulFlashCalStart = SectOfset ; Adapter -> eActiveDSD = eFlash2xSectionVal ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_NVM_RAW_READ : { struct bcm_nvm_readwrite stNVMRead ; INT NOB ; INT BuffSize ; INT ReadOffset = 0 ; UINT ReadBytes = 0 ; PUCHAR pReadBuff ; void __user * OutPutBuff ; if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""NVM<S2SV_blank>TYPE<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Flash"" ) ; return - EINVAL ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""copy_from_user<S2SV_blank>1<S2SV_blank>failed\\n"" ) ; return - EFAULT ; } if ( copy_from_user ( & stNVMRead , IoBuffer . OutputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; NOB = stNVMRead . uiNumBytes ; if ( NOB > DEFAULT_BUFF_SIZE ) BuffSize = DEFAULT_BUFF_SIZE ; else BuffSize = NOB ; ReadOffset = stNVMRead . uiOffset ; OutPutBuff = stNVMRead . pBuffer ; pReadBuff = kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; Status = - ENOMEM ; break ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; kfree ( pReadBuff ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Adapter -> bFlashRawRead = TRUE ; while ( NOB ) { if ( NOB > DEFAULT_BUFF_SIZE ) ReadBytes = DEFAULT_BUFF_SIZE ; else ReadBytes = NOB ; Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadBuff , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } Adapter -> bFlashRawRead = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; break ; } case IOCTL_BCM_CNTRLMSG_MASK : { ULONG RxCntrlMsgBitMask = 0 ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""copy<S2SV_blank>of<S2SV_blank>Ioctl<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - EFAULT ; } if ( IoBuffer . InputLength != sizeof ( unsigned long ) ) { Status = - EINVAL ; break ; } Status = copy_from_user ( & RxCntrlMsgBitMask , IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""copy<S2SV_blank>of<S2SV_blank>control<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\n<S2SV_blank>Got<S2SV_blank>user<S2SV_blank>d<S2SV_blank>cntrl<S2SV_blank>msg<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>:%lx"" , RxCntrlMsgBitMask ) ; pTarang -> RxCntrlMsgBitMask = RxCntrlMsgBitMask ; } break ; case IOCTL_BCM_GET_DEVICE_DRIVER_INFO : { struct bcm_driver_info DevInfo ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; <S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ; DevInfo . u32RxAlignmentCorrection = 0 ; DevInfo . u32NVMType = Adapter -> eNVMType ; DevInfo . u32InterfaceType = BCM_USB ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( DevInfo ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , & DevInfo , sizeof ( DevInfo ) ) ) return - EFAULT ; } break ; case IOCTL_BCM_TIME_SINCE_NET_ENTRY : { struct bcm_time_elapsed stTimeElapsedSinceNetEntry = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_TIME_SINCE_NET_ENTRY<S2SV_blank>called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_time_elapsed ) ) return - EINVAL ; stTimeElapsedSinceNetEntry . ul64TimeElapsedSinceNetEntry = get_seconds ( ) - Adapter -> liTimeSinceLastNetEntry ; if ( copy_to_user ( IoBuffer . OutputBuffer , & stTimeElapsedSinceNetEntry , sizeof ( struct bcm_time_elapsed ) ) ) return - EFAULT ; } break ; case IOCTL_CLOSE_NOTIFICATION : BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_CLOSE_NOTIFICATION"" ) ; break ; default : pr_info ( DRV_NAME "":<S2SV_blank>unknown<S2SV_blank>ioctl<S2SV_blank>cmd=%x\\n"" , cmd ) ; Status = STATUS_FAILURE ; break ; } return Status ; }","<S2SV_ModStart> ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;"
482,"CWE-000 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; TYPE_12 VAR_11 ; VAR_12 * VAR_13 [ 3 ] ; VAR_14 = 0 ; <S2SV_StartBug> for ( VAR_15 = 0 ; VAR_16 < METHOD_1 ( VAR_17 ) ; ++ VAR_18 ) { <S2SV_EndBug> <S2SV_StartBug> VAR_19 [ VAR_20 ] = METHOD_2 ( 1 , METHOD_3 ( VAR_21 ) ) ; <S2SV_EndBug> METHOD_4 ( VAR_22 [ VAR_23 ] ) ; } VAR_24 = METHOD_5 ( VAR_25 ) - ( VAR_26 -> VAR_27 * VAR_28 -> VAR_29 + 7 ) / 8 ; for ( VAR_30 = 0 ; VAR_31 < VAR_32 -> VAR_33 ; VAR_34 ++ ) { VAR_35 = 0 ; VAR_36 = 0 ; for ( VAR_37 = 0 ; VAR_38 < VAR_39 -> VAR_40 ; VAR_41 ++ ) { while ( VAR_42 < VAR_43 -> VAR_44 ) { if ( ( VAR_45 = METHOD_6 ( VAR_46 ) ) == VAR_47 ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> VAR_48 = ( VAR_49 << 8 ) | VAR_50 ; <S2SV_EndBug> VAR_51 += 8 ; } VAR_52 = ( VAR_53 >> ( VAR_54 - VAR_55 -> VAR_56 ) ) & METHOD_7 ( VAR_57 -> VAR_58 ) ; VAR_59 &= METHOD_8 ( VAR_60 - VAR_61 -> VAR_62 ) ; VAR_63 -= VAR_64 -> VAR_65 ; if ( METHOD_9 ( VAR_66 ) == 3 ) { METHOD_10 ( VAR_67 [ 0 ] , VAR_68 , ( METHOD_11 ( VAR_69 ) ) ) ; METHOD_12 ( VAR_70 [ 1 ] , VAR_71 , ( METHOD_13 ( VAR_72 ) ) ) ; METHOD_14 ( VAR_73 [ 2 ] , VAR_74 , ( METHOD_15 ( VAR_75 ) ) ) ; } else { METHOD_16 ( VAR_76 [ 0 ] , VAR_77 , ( VAR_78 ) ) ; } } if ( VAR_79 ) { if ( ( VAR_80 = METHOD_17 ( VAR_81 ) ) == VAR_82 ) { return - 1 ; } } for ( VAR_83 = 0 ; VAR_84 < METHOD_18 ( VAR_85 ) ; ++ VAR_86 ) { if ( METHOD_19 ( VAR_87 , VAR_88 , 0 , VAR_89 , VAR_90 -> VAR_91 , 1 , VAR_92 [ VAR_93 ] ) ) { return - 1 ; } } } for ( VAR_94 = 0 ; VAR_95 < METHOD_20 ( VAR_96 ) ; ++ VAR_97 ) { METHOD_21 ( VAR_98 [ VAR_99 ] ) ; } return 0 ; }","<S2SV_ModStart> = 0 ; METHOD_4 ( <S2SV_ModEnd> METHOD_20 ( VAR_96 <S2SV_ModStart> ( VAR_96 ) <= 3 ) ; for ( VAR_99 = 0 ; VAR_99 < 3 ; ++ VAR_99 ) { VAR_98 [ VAR_99 ] = 0 ; } for ( VAR_99 = 0 ; VAR_99 < METHOD_20 ( VAR_96 ) ; ++ VAR_99 ) { if ( ! ( <S2SV_ModEnd> VAR_98 [ VAR_99 <S2SV_ModStart> VAR_96 ) ) ) ) { goto VAR_100 ; } <S2SV_ModEnd> } VAR_79 = <S2SV_ModStart> VAR_82 ) { goto VAR_100 ; } VAR_59 = ( VAR_59 << 8 ) | VAR_80 ; VAR_63 += 8 ; } VAR_78 = ( VAR_59 >> ( VAR_63 - VAR_90 -> VAR_65 ) ) & METHOD_8 ( VAR_90 -> VAR_65 ) ; VAR_59 &= METHOD_8 ( VAR_63 - VAR_90 -> VAR_65 ) ; VAR_63 -= VAR_90 -> VAR_65 ; if ( METHOD_20 ( VAR_96 ) == 3 ) { METHOD_16 ( VAR_98 [ 0 ] , VAR_77 , ( METHOD_11 ( VAR_78 ) ) ) ; METHOD_16 ( VAR_98 [ 1 ] , VAR_77 , ( METHOD_13 ( VAR_78 ) ) ) ; METHOD_16 ( VAR_98 [ 2 ] , VAR_77 , ( METHOD_15 ( VAR_78 ) ) ) ; } else { METHOD_16 ( VAR_98 [ 0 ] , VAR_77 , ( VAR_78 ) ) ; } } if ( VAR_79 ) { if ( ( VAR_80 = METHOD_17 ( VAR_81 ) ) == VAR_82 ) { goto VAR_100 ; } } for ( VAR_99 = 0 ; VAR_99 < METHOD_20 ( VAR_96 ) ; ++ VAR_99 ) { if ( METHOD_19 ( VAR_96 , VAR_99 , 0 , VAR_89 , VAR_90 -> VAR_91 , 1 , VAR_98 [ VAR_99 ] ) ) { goto VAR_100 ; } } } for ( VAR_99 = 0 ; VAR_99 < METHOD_20 ( VAR_96 ) ; ++ VAR_99 ) { METHOD_21 ( VAR_98 [ VAR_99 ] ) ; VAR_98 [ VAR_99 ] = 0 ; } return 0 ; VAR_100 : for ( VAR_99 = 0 ; VAR_99 < 3 ; ++ VAR_99 ) { if ( VAR_98 [ VAR_99 ] ) { METHOD_21 ( VAR_98 [ VAR_99 ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>","CWE-000 static int ras_getdatastd ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap , jas_image_t * image ) { int pad ; int nz ; int z ; int c ; int y ; int x ; int v ; int i ; jas_matrix_t * data [ 3 ] ; cmap = 0 ; <S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } pad = RAS_ROWSIZE ( hdr ) - ( hdr -> width * hdr -> depth + 7 ) / 8 ; for ( y = 0 ; y < hdr -> height ; y ++ ) { nz = 0 ; z = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { while ( nz < hdr -> depth ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { return - 1 ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }","<S2SV_ModStart> = 0 ; assert ( <S2SV_ModEnd> jas_image_numcmpts ( image <S2SV_ModStart> ( image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad = <S2SV_ModStart> EOF ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
483,"CWE-119 static TYPE_0 METHOD_0 ( const TYPE_1 * TYPE_2 , TYPE_3 VAR_0 , TYPE_4 * VAR_1 , struct STRUCT_OR_UNION_0 * VAR_2 ) { <S2SV_StartBug> TYPE_5 TYPE_6 <S2SV_EndBug> <S2SV_StartBug> TYPE_7 TYPE_8 [ TYPE_9 ( TYPE_10 ) + 1 ] ; <S2SV_EndBug> else TYPE_11 * TYPE_12 = METHOD_1 ( TYPE_13 ( TYPE_14 ) + 1 ) ; <S2SV_StartBug> <S2SV_EndBug> TYPE_15 * VAR_3 = TYPE_16 ; TYPE_17 * VAR_4 ; enum VAR_5 VAR_6 = VAR_7 ; TYPE_18 VAR_8 = VAR_9 ; TYPE_19 VAR_10 = VAR_11 ; VAR_12 -> VAR_13 = VAR_14 ; METHOD_2 ( TYPE_20 , TYPE_21 , TYPE_22 ( TYPE_23 ) + 1 ) ; while ( * VAR_15 == '/' ) VAR_16 ++ ; if ( ! * VAR_17 ) { <S2SV_StartBug> * VAR_18 = VAR_19 ; <S2SV_EndBug> return 0 ; } for ( ; ; ) { TYPE_24 VAR_20 ; struct STRUCT_OR_UNION_1 VAR_21 ; VAR_22 = METHOD_3 ( VAR_23 , '/' ) ; if ( VAR_24 ) { while ( * VAR_25 == '/' ) * ( VAR_26 ++ ) = '\\0' ; } if ( VAR_27 != VAR_28 ) { METHOD_4 ( VAR_29 , VAR_30 ) ; <S2SV_StartBug> return METHOD_5 ( VAR_31 , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ; <S2SV_EndBug> } VAR_32 . VAR_33 = VAR_34 ; VAR_35 . VAR_36 = & VAR_37 ; VAR_38 . VAR_39 = & VAR_40 ; VAR_41 . VAR_42 = & VAR_43 ; VAR_44 = VAR_45 -> METHOD_6 ( VAR_46 , VAR_47 , & VAR_48 ) ; if ( ! VAR_49 ) { <S2SV_StartBug> if ( VAR_50 ) <S2SV_EndBug> <S2SV_StartBug> return VAR_51 ; <S2SV_EndBug> break ; } if ( VAR_52 == VAR_53 ) { TYPE_25 * VAR_54 ; if ( ++ ( VAR_55 -> VAR_56 ) == 8 ) { METHOD_7 ( VAR_57 , VAR_58 ) ; METHOD_8 ( VAR_59 , VAR_60 ) ; <S2SV_StartBug> return METHOD_9 ( VAR_61 , <S2SV_EndBug> ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ; } VAR_62 = VAR_63 -> METHOD_10 ( VAR_64 ) ; METHOD_11 ( VAR_65 , VAR_66 ) ; if ( ! VAR_67 ) { <S2SV_StartBug> METHOD_12 ( VAR_68 , VAR_69 ) ; <S2SV_EndBug> return VAR_70 ; } if ( VAR_71 [ 0 ] == '/' ) { METHOD_13 ( VAR_72 , VAR_73 ) ; VAR_74 = VAR_75 -> VAR_76 ; } METHOD_14 ( VAR_77 , VAR_78 , & VAR_79 , VAR_80 ) ; VAR_81 = VAR_82 -> VAR_83 ; METHOD_15 ( VAR_84 ) ; if ( VAR_85 ) { METHOD_16 ( VAR_86 , VAR_87 ) ; <S2SV_StartBug> return VAR_88 ; <S2SV_EndBug> } } METHOD_17 ( VAR_89 , VAR_90 ) ; if ( ! VAR_91 || * VAR_92 == '\\0' ) { * VAR_93 = VAR_94 ; VAR_95 -> VAR_96 = VAR_97 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } VAR_98 = VAR_99 ; } <S2SV_StartBug> return METHOD_18 ( VAR_100 , ""file<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> }","<S2SV_ModStart> VAR_95 ) { TYPE_25 * TYPE_20 = METHOD_1 ( <S2SV_ModEnd> TYPE_22 ( TYPE_23 <S2SV_ModStart> ) + 1 ) ; TYPE_25 * VAR_98 = TYPE_20 ; TYPE_25 * VAR_99 ; enum VAR_5 VAR_97 = VAR_28 ; TYPE_19 VAR_94 = VAR_14 ; TYPE_19 VAR_89 = VAR_14 ; VAR_95 -> VAR_14 = VAR_14 ; METHOD_2 ( TYPE_20 , TYPE_23 , <S2SV_ModEnd> TYPE_22 ( TYPE_23 <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> while ( * <S2SV_ModStart> VAR_93 = VAR_94 ; METHOD_19 ( TYPE_20 ) <S2SV_ModStart> VAR_95 ) ; METHOD_19 ( TYPE_20 ) ; <S2SV_ModStart> ( VAR_88 ) { METHOD_19 ( TYPE_20 ) ; <S2SV_ModStart> return VAR_88 ; } <S2SV_ModStart> VAR_95 ) ; METHOD_19 ( TYPE_20 ) ; <S2SV_ModStart> VAR_89 , VAR_95 ) ; METHOD_19 ( TYPE_20 <S2SV_ModStart> VAR_95 ) ; METHOD_19 ( TYPE_20 ) ; <S2SV_ModStart> = VAR_97 ; METHOD_19 ( TYPE_20 ) ; <S2SV_ModStart> VAR_99 ; } METHOD_19 ( TYPE_20 ) ;","CWE-119 static grub_err_t find_file ( const char * currpath , grub_fshelp_node_t currroot , grub_fshelp_node_t * currfound , struct grub_fshelp_find_file_closure * c ) { <S2SV_StartBug>  ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char fpath [ grub_strlen ( currpath ) + 1 ] ; <S2SV_EndBug>  else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ; <S2SV_StartBug>   <S2SV_EndBug> char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , grub_strlen ( currpath ) + 1 ) ; while ( * name == '/' ) name ++ ; if ( ! * name ) { <S2SV_StartBug> * currfound = currnode ; <S2SV_EndBug> return 0 ; } for ( ; ; ) { int found ; struct find_file_closure cc ; next = grub_strchr ( name , '/' ) ; if ( next ) { while ( * next == '/' ) * ( next ++ ) = '\\0' ; } if ( type != GRUB_FSHELP_DIR ) { free_node ( currnode , c ) ; <S2SV_StartBug> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ; <S2SV_EndBug> } cc . name = name ; cc . type = & type ; cc . oldnode = & oldnode ; cc . currnode = & currnode ; found = c -> iterate_dir ( currnode , iterate , & cc ) ; if ( ! found ) { <S2SV_StartBug> if ( grub_errno ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> break ; } if ( type == GRUB_FSHELP_SYMLINK ) { char * symlink ; if ( ++ ( c -> symlinknest ) == 8 ) { free_node ( currnode , c ) ; free_node ( oldnode , c ) ; <S2SV_StartBug> return grub_error ( GRUB_ERR_SYMLINK_LOOP , <S2SV_EndBug> ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ; } symlink = c -> read_symlink ( currnode ) ; free_node ( currnode , c ) ; if ( ! symlink ) { <S2SV_StartBug> free_node ( oldnode , c ) ; <S2SV_EndBug> return grub_errno ; } if ( symlink [ 0 ] == '/' ) { free_node ( oldnode , c ) ; oldnode = c -> rootnode ; } find_file ( symlink , oldnode , & currnode , c ) ; type = c -> foundtype ; grub_free ( symlink ) ; if ( grub_errno ) { free_node ( oldnode , c ) ; <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> } } free_node ( oldnode , c ) ; if ( ! next || * next == '\\0' ) { * currfound = currnode ; c -> foundtype = type ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } name = next ; } <S2SV_StartBug> return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> }","<S2SV_ModStart> c ) { char * fpath = grub_malloc ( <S2SV_ModEnd> grub_strlen ( currpath <S2SV_ModStart> ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> grub_strlen ( currpath <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> while ( * <S2SV_ModStart> currfound = currnode ; free ( fpath ) <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> ( grub_errno ) { free ( fpath ) ; <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> oldnode , c ) ; free ( fpath <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> = type ; free ( fpath ) ; <S2SV_ModStart> next ; } free ( fpath ) ;"
484,"CWE-190 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { struct STRUCT_OR_UNION_2 TYPE_2 * VAR_3 ; struct STRUCT_OR_UNION_3 * VAR_4 = VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 = VAR_7 ; struct STRUCT_OR_UNION_5 * VAR_8 ; struct STRUCT_OR_UNION_6 * VAR_9 ; unsigned VAR_10 ; TYPE_3 VAR_11 ; TYPE_4 VAR_12 = 0 ; if ( ! METHOD_1 ( VAR_13 , VAR_14 ) ) return - VAR_15 ; METHOD_2 ( & VAR_16 -> VAR_17 . VAR_18 ) ; VAR_19 = METHOD_3 ( VAR_20 , VAR_21 -> VAR_22 , VAR_23 ) ; if ( ! VAR_24 ) { METHOD_4 ( ""invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n"" ) ; VAR_25 = - VAR_26 ; goto VAR_27 ; } VAR_28 = METHOD_5 ( VAR_29 ) ; VAR_30 = VAR_31 -> VAR_32 ; VAR_33 = ( struct STRUCT_OR_UNION_7 * ) ( unsigned TYPE_5 ) VAR_34 -> VAR_35 ; if ( ! VAR_36 != ! VAR_37 ) { VAR_38 = - VAR_39 ; goto VAR_40 ; } VAR_41 = VAR_42 & VAR_43 -> VAR_44 ; if ( VAR_45 & VAR_46 && ( VAR_47 % 2 ) ) { VAR_48 = - VAR_49 ; goto VAR_50 ; } if ( VAR_51 && VAR_52 ) { <S2SV_StartBug> VAR_53 = METHOD_6 ( VAR_54 * sizeof ( * VAR_55 ) , VAR_56 ) ; <S2SV_EndBug> if ( ! VAR_57 ) { VAR_58 = - VAR_59 ; goto VAR_60 ; } VAR_61 = METHOD_7 ( VAR_62 , VAR_63 , VAR_64 * sizeof ( * VAR_65 ) ) ; if ( VAR_66 ) { VAR_67 = - VAR_68 ; goto VAR_69 ; } } if ( VAR_70 -> VAR_71 -> METHOD_8 ) { VAR_72 = VAR_73 -> VAR_74 -> METHOD_9 ( VAR_75 , VAR_76 , VAR_77 , VAR_78 -> VAR_79 , VAR_80 , VAR_81 ) ; } else { VAR_82 = - VAR_83 ; goto VAR_84 ; } VAR_85 : METHOD_10 ( VAR_86 ) ; VAR_87 : METHOD_11 ( & VAR_88 -> VAR_89 . VAR_90 ) ; return VAR_91 ; }",<S2SV_ModStart> VAR_63 ) { if ( VAR_81 < 0 || VAR_81 > VAR_92 ) { VAR_91 = - VAR_49 ; goto VAR_87 ; },"CWE-190 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( ""invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n"" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }",<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
485,CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { VAR_1 -> VAR_2 = VAR_3 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> },<S2SV_ModStart> = VAR_3 ; VAR_1 -> VAR_4 = VAR_5 ;,CWE-476 static int asymmetric_key_match_preparse ( struct key_match_data * match_data ) { match_data -> lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> },<S2SV_ModStart> = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
486,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = STRUCT_OR_UNION_4 -> VAR_1 ; TYPE_2 VAR_2 = 0 ; switch ( STRUCT_OR_UNION_5 -> VAR_3 ) { case VAR_4 : VAR_5 = - VAR_6 ; if ( METHOD_1 ( ! ( STRUCT_OR_UNION_6 -> VAR_7 & VAR_8 ) ) ) break ; VAR_9 = - VAR_10 ; if ( METHOD_2 ( ! METHOD_3 ( VAR_11 , STRUCT_OR_UNION_7 -> VAR_12 , STRUCT_OR_UNION_8 -> VAR_13 ) ) ) break ; <S2SV_StartBug> VAR_14 = METHOD_4 ( STRUCT_OR_UNION_9 , VAR_15 ) ; <S2SV_EndBug> if ( METHOD_5 ( VAR_16 ) ) break ; VAR_17 = METHOD_6 ( STRUCT_OR_UNION_10 ) ; if ( VAR_18 ) break ; VAR_19 = - VAR_20 ; if ( STRUCT_OR_UNION_11 -> VAR_21 -> VAR_22 ) STRUCT_OR_UNION_12 -> VAR_23 = VAR_24 ; break ; case VAR_25 : VAR_26 = - VAR_27 ; if ( METHOD_7 ( ! ( STRUCT_OR_UNION_13 -> VAR_28 & VAR_29 ) ) ) break ; VAR_30 = - VAR_31 ; if ( METHOD_8 ( ! METHOD_9 ( VAR_32 , STRUCT_OR_UNION_14 -> VAR_33 , STRUCT_OR_UNION_15 -> VAR_34 ) ) ) break ; <S2SV_StartBug> VAR_35 = METHOD_10 ( STRUCT_OR_UNION_16 , VAR_36 ) ; <S2SV_EndBug> if ( METHOD_11 ( VAR_37 ) ) break ; VAR_38 = METHOD_12 ( STRUCT_OR_UNION_17 ) ; if ( VAR_39 ) break ; VAR_40 = - VAR_41 ; if ( STRUCT_OR_UNION_18 -> VAR_42 -> VAR_43 ) STRUCT_OR_UNION_19 -> VAR_44 = VAR_45 ; break ; case VAR_46 : VAR_47 = - VAR_48 ; if ( METHOD_13 ( ! ( STRUCT_OR_UNION_20 -> VAR_49 & VAR_50 ) ) ) break ; <S2SV_StartBug> VAR_51 = METHOD_14 ( STRUCT_OR_UNION_21 , VAR_52 ) ; <S2SV_EndBug> if ( METHOD_15 ( VAR_53 ) ) break ; VAR_54 = METHOD_16 ( VAR_55 , STRUCT_OR_UNION_22 , VAR_56 ) ; if ( VAR_57 ) break ; VAR_58 = - VAR_59 ; if ( STRUCT_OR_UNION_23 -> VAR_60 -> VAR_61 ) STRUCT_OR_UNION_24 -> VAR_62 = VAR_63 ; break ; case VAR_64 : VAR_65 = - VAR_66 ; if ( METHOD_17 ( ! ( STRUCT_OR_UNION_25 -> VAR_67 & VAR_68 ) ) ) break ; <S2SV_StartBug> VAR_69 = METHOD_18 ( STRUCT_OR_UNION_26 , VAR_70 ) ; <S2SV_EndBug> if ( METHOD_19 ( VAR_71 ) ) break ; VAR_72 = METHOD_20 ( VAR_73 , STRUCT_OR_UNION_27 , VAR_74 ) ; if ( VAR_75 ) break ; VAR_76 = - VAR_77 ; if ( STRUCT_OR_UNION_28 -> VAR_78 -> VAR_79 ) STRUCT_OR_UNION_29 -> VAR_80 = VAR_81 ; break ; case VAR_82 : VAR_83 = - VAR_84 ; if ( STRUCT_OR_UNION_30 -> VAR_85 -> VAR_86 ) STRUCT_OR_UNION_31 -> VAR_87 = VAR_88 ; break ; case VAR_89 : VAR_90 = - VAR_91 ; if ( STRUCT_OR_UNION_32 -> VAR_92 -> VAR_93 ) STRUCT_OR_UNION_33 -> VAR_94 = VAR_95 ; break ; default : METHOD_21 ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n"" ) ; VAR_96 = - VAR_97 ; } if ( ! STRUCT_OR_UNION_34 -> VAR_98 ) return VAR_99 ; return 0 ; }","<S2SV_ModStart> ; VAR_99 = METHOD_12 ( VAR_55 , STRUCT_OR_UNION_32 , <S2SV_ModEnd> STRUCT_OR_UNION_34 ) ; <S2SV_ModStart> ; VAR_99 = METHOD_12 ( VAR_73 , STRUCT_OR_UNION_32 , <S2SV_ModEnd> STRUCT_OR_UNION_34 ) ; <S2SV_ModStart> ; VAR_99 = <S2SV_ModEnd> METHOD_20 ( VAR_55 <S2SV_ModStart> ; VAR_99 = <S2SV_ModEnd> METHOD_20 ( VAR_73","CWE-000 static ssize_t aio_setup_iocb ( struct kiocb * kiocb , bool compat ) { struct file * file = kiocb -> ki_filp ; ssize_t ret = 0 ; switch ( kiocb -> ki_opcode ) { case IOCB_CMD_PREAD : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITE : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PREADV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( READ , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITEV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( WRITE , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_FDSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fdsync ; break ; case IOCB_CMD_FSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fsync ; break ; default : dprintk ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n"" ) ; ret = - EINVAL ; } if ( ! kiocb -> ki_retry ) return ret ; return 0 ; }","<S2SV_ModStart> ; ret = aio_setup_single_vector ( READ , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( READ <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( WRITE"
487,"CWE-787 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_StartBug> TYPE_2 VAR_1 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_3 * VAR_2 ; <S2SV_EndBug> VAR_3 = METHOD_1 ( 1 , 1024 ) ; <S2SV_StartBug> VAR_4 = METHOD_2 ( VAR_5 ) ; <S2SV_EndBug> METHOD_3 ( VAR_6 , 0 , VAR_7 ) ; METHOD_4 ( METHOD_5 ( VAR_8 , 1 , 1023 , VAR_9 ) , 1023 , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>PDF<S2SV_blank>header.\\n"" ) ; METHOD_6 ( VAR_10 , VAR_11 , VAR_12 ) ; return VAR_13 ; }",<S2SV_ModStart> VAR_10 ) { <S2SV_ModEnd> TYPE_3 * VAR_13 <S2SV_ModStart> TYPE_3 * VAR_13 = safe_calloc ( <S2SV_ModEnd> 1024 ) ; <S2SV_ModStart> 1024 ) ; TYPE_2,"CWE-787 static char * get_header ( FILE * fp ) { <S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> header = calloc ( 1 , 1024 ) ; <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>PDF<S2SV_blank>header.\\n"" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }",<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> char * header = safe_calloc ( <S2SV_ModEnd> 1024 ) ; <S2SV_ModStart> 1024 ) ; long
488,"CWE-264 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { METHOD_1 ( VAR_1 -> VAR_2 , 0xff , VAR_3 ) ; VAR_4 -> VAR_5 = VAR_6 ; METHOD_2 ( VAR_7 ) ; <S2SV_StartBug> VAR_8 -> VAR_9 = & VAR_10 ; <S2SV_EndBug> VAR_11 -> VAR_12 = VAR_13 * 2 ; }",<S2SV_ModStart> ; VAR_11 -> VAR_14 &= ~ VAR_15 ; VAR_11 ->,"CWE-264 void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , ETH_ALEN ) ; dev -> addr_len = ETH_ALEN ; ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> dev -> watchdog_timeo = HZ * 2 ; }",<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
489,CWE-404 static TYPE_0 METHOD_0 ( TYPE_1 ) { struct STRUCT_OR_UNION_0 * VAR_0 ; TYPE_2 VAR_1 ; VAR_2 = METHOD_1 ( ) ; if ( ! VAR_3 ) return - VAR_4 ; VAR_5 = METHOD_2 ( VAR_6 ) ; if ( VAR_7 < 0 ) { METHOD_3 ( VAR_8 ) ; <S2SV_StartBug> return VAR_9 != - VAR_10 ? VAR_11 : 0 ; <S2SV_EndBug> } return METHOD_4 ( VAR_12 ) ; },<S2SV_ModStart> ; return VAR_11 <S2SV_ModEnd> ; } return,CWE-404 static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; },<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
490,"CWE-17 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 ; TYPE_1 VAR_3 , VAR_4 = 0 ; struct STRUCT_OR_UNION_2 VAR_5 = { } ; TYPE_2 * VAR_6 = VAR_7 ; TYPE_3 * VAR_8 ; TYPE_4 VAR_9 ; TYPE_5 VAR_10 ; if ( ! VAR_11 ) return ; if ( ! VAR_12 || ! VAR_13 -> VAR_14 ) return ; VAR_15 = METHOD_1 ( VAR_16 -> VAR_17 * sizeof ( * VAR_18 ) , VAR_19 ) ; if ( ! VAR_20 ) return ; for ( VAR_21 = 0 , VAR_22 = 0 ; VAR_23 < VAR_24 -> VAR_25 ; VAR_26 ++ ) { VAR_27 += 64 ; VAR_28 [ VAR_29 ] = VAR_30 ; } VAR_31 . VAR_32 = VAR_33 ; <S2SV_StartBug> for ( VAR_34 = 0 ; VAR_35 < 10 ; VAR_36 ++ ) { <S2SV_EndBug> VAR_37 = METHOD_2 ( VAR_38 , VAR_39 , VAR_40 , VAR_41 , & VAR_42 ) ; if ( VAR_43 <= 0 ) { VAR_44 = VAR_45 ; if ( VAR_46 ) METHOD_3 ( VAR_47 ) ; goto VAR_48 ; } if ( VAR_49 ) { if ( VAR_50 != VAR_51 ) { METHOD_4 ( ""bpf_jit:<S2SV_blank>proglen=%d<S2SV_blank>!=<S2SV_blank>oldproglen=%d\\n"" , VAR_52 , VAR_53 ) ; goto VAR_54 ; } break ; } if ( VAR_55 == VAR_56 ) { VAR_57 = METHOD_5 ( VAR_58 , & VAR_59 , 1 , VAR_60 ) ; if ( ! VAR_61 ) goto VAR_62 ; } VAR_63 = VAR_64 ; } if ( VAR_65 > 1 ) METHOD_6 ( VAR_66 -> VAR_67 , VAR_68 , 0 , VAR_69 ) ; if ( VAR_70 ) { METHOD_7 ( VAR_71 , VAR_72 + VAR_73 ) ; METHOD_8 ( ( unsigned TYPE_6 ) VAR_74 , VAR_75 -> VAR_76 ) ; VAR_77 -> VAR_78 = ( TYPE_7 * ) VAR_79 ; VAR_80 -> VAR_81 = VAR_82 ; } VAR_83 : METHOD_9 ( VAR_84 ) ; }",<S2SV_ModStart> VAR_36 < 10 || VAR_79,"CWE-17 void bpf_int_jit_compile ( struct bpf_prog * prog ) { struct bpf_binary_header * header = NULL ; int proglen , oldproglen = 0 ; struct jit_context ctx = { } ; u8 * image = NULL ; int * addrs ; int pass ; int i ; if ( ! bpf_jit_enable ) return ; if ( ! prog || ! prog -> len ) return ; addrs = kmalloc ( prog -> len * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( ! addrs ) return ; for ( proglen = 0 , i = 0 ; i < prog -> len ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } ctx . cleanup_addr = proglen ; <S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; if ( proglen <= 0 ) { image = NULL ; if ( header ) bpf_jit_binary_free ( header ) ; goto out ; } if ( image ) { if ( proglen != oldproglen ) { pr_err ( ""bpf_jit:<S2SV_blank>proglen=%d<S2SV_blank>!=<S2SV_blank>oldproglen=%d\\n"" , proglen , oldproglen ) ; goto out ; } break ; } if ( proglen == oldproglen ) { header = bpf_jit_binary_alloc ( proglen , & image , 1 , jit_fill_hole ) ; if ( ! header ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) bpf_jit_dump ( prog -> len , proglen , 0 , image ) ; if ( image ) { bpf_flush_icache ( header , image + proglen ) ; set_memory_ro ( ( unsigned long ) header , header -> pages ) ; prog -> bpf_func = ( void * ) image ; prog -> jited = true ; } out : kfree ( addrs ) ; }",<S2SV_ModStart> pass < 10 || image
491,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 * VAR_4 = VAR_5 -> VAR_6 ; TYPE_6 * VAR_7 = VAR_8 -> VAR_9 ; <S2SV_StartBug> TYPE_7 VAR_10 = VAR_11 -> VAR_12 ; <S2SV_EndBug> TYPE_8 VAR_13 [ VAR_14 ] ; TYPE_9 VAR_15 , VAR_16 ; TYPE_10 * VAR_17 = VAR_18 ; if ( VAR_19 == VAR_20 ) return VAR_21 -> VAR_22 ; else if ( ! VAR_23 && ( ( VAR_24 == VAR_25 && VAR_26 == 0 ) || ( VAR_27 == VAR_28 && VAR_29 == VAR_30 -> VAR_31 ) ) ) return VAR_32 -> VAR_33 ; <S2SV_StartBug> else if ( ( VAR_34 -> VAR_35 == - 1 && VAR_36 == VAR_37 ) ) <S2SV_EndBug> return METHOD_1 ( VAR_38 ) ; if ( VAR_39 == VAR_40 ) VAR_41 += VAR_42 -> VAR_43 ; else if ( VAR_44 == VAR_45 ) VAR_46 += VAR_47 -> VAR_48 ; else if ( VAR_49 != VAR_50 ) return METHOD_2 ( VAR_51 ) ; if ( VAR_52 < 0 ) return METHOD_3 ( VAR_53 ) ; VAR_54 -> VAR_55 = VAR_56 ; if ( VAR_57 -> VAR_58 && VAR_59 -> VAR_60 ) return METHOD_4 ( VAR_61 ) ; VAR_62 = VAR_63 -> VAR_64 - VAR_65 -> VAR_66 ; METHOD_5 ( VAR_67 , VAR_68 -> VAR_69 , VAR_70 ) ; VAR_71 -> VAR_72 = VAR_73 ; if ( ( VAR_74 = METHOD_6 ( VAR_75 , & VAR_76 ) ) < 0 ) { METHOD_7 ( & VAR_77 ) ; METHOD_8 ( VAR_78 -> VAR_79 , VAR_80 , VAR_81 ) ; VAR_82 -> VAR_83 = VAR_84 -> VAR_85 ; VAR_86 -> VAR_87 = VAR_88 -> VAR_89 + VAR_90 ; VAR_91 -> VAR_92 = VAR_93 ; VAR_94 -> VAR_95 = VAR_96 ; return VAR_97 ; } METHOD_9 ( & VAR_98 ) ; METHOD_10 ( VAR_99 ) ; return VAR_100 ; }",<S2SV_ModStart> -> VAR_92 ; TYPE_11 <S2SV_ModEnd> VAR_96 = VAR_94 <S2SV_ModStart> -> VAR_48 == VAR_101 <S2SV_ModEnd> && VAR_49 ==,"CWE-119 static int64_t http_seek_internal ( URLContext * h , int64_t off , int whence , int force_reconnect ) { HTTPContext * s = h -> priv_data ; URLContext * old_hd = s -> hd ; <S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> uint8_t old_buf [ BUFFER_SIZE ] ; int old_buf_size , ret ; AVDictionary * options = NULL ; if ( whence == AVSEEK_SIZE ) return s -> filesize ; else if ( ! force_reconnect && ( ( whence == SEEK_CUR && off == 0 ) || ( whence == SEEK_SET && off == s -> off ) ) ) return s -> off ; <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> return AVERROR ( ENOSYS ) ; if ( whence == SEEK_CUR ) off += s -> off ; else if ( whence == SEEK_END ) off += s -> filesize ; else if ( whence != SEEK_SET ) return AVERROR ( EINVAL ) ; if ( off < 0 ) return AVERROR ( EINVAL ) ; s -> off = off ; if ( s -> off && h -> is_streamed ) return AVERROR ( ENOSYS ) ; old_buf_size = s -> buf_end - s -> buf_ptr ; memcpy ( old_buf , s -> buf_ptr , old_buf_size ) ; s -> hd = NULL ; if ( ( ret = http_open_cnx ( h , & options ) ) < 0 ) { av_dict_free ( & options ) ; memcpy ( s -> buffer , old_buf , old_buf_size ) ; s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer + old_buf_size ; s -> hd = old_hd ; s -> off = old_off ; return ret ; } av_dict_free ( & options ) ; ffurl_close ( old_hd ) ; return off ; }",<S2SV_ModStart> -> hd ; uint64_t <S2SV_ModEnd> old_off = s <S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> && whence ==
492,CWE-119 TYPE_0 METHOD_0 ( ) { <S2SV_StartBug> METHOD_1 ( ) ; <S2SV_EndBug> METHOD_2 ( VAR_0 ) ; },<S2SV_ModStart> ( ) { <S2SV_ModEnd> METHOD_2 ( VAR_0,CWE-119 void vp8_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; },<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal
493,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 [ 128 ] ; <S2SV_StartBug> TYPE_4 VAR_3 = METHOD_1 ( VAR_4 , sizeof ( VAR_5 ) , VAR_6 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_2 ( VAR_7 , VAR_8 , VAR_9 ) ; <S2SV_EndBug> METHOD_3 ( VAR_10 , ""\\n"" , 1 ) ; return 1 ; }","<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> METHOD_1 ( VAR_8 <S2SV_ModStart> 0 ) ; METHOD_4 <S2SV_ModEnd> ( VAR_10 , <S2SV_ModStart> ( VAR_10 , ""%s\\n"" , VAR_8 <S2SV_ModEnd> ) ; return","CWE-125 int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , ""\\n"" , 1 ) ; return 1 ; }","<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , ""%s\\n"" , obj_txt <S2SV_ModEnd> ) ; return"
494,CWE-119 TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 ) { TYPE_2 * VAR_1 ; TYPE_3 VAR_2 = 0 ; if ( ! VAR_3 ) { <S2SV_StartBug> return VAR_4 ; <S2SV_EndBug> } while ( VAR_5 [ VAR_6 ] != 0 || VAR_7 [ VAR_8 + 1 ] != 0 ) { VAR_9 ++ ; } VAR_10 = METHOD_1 ( VAR_11 + 2 ) ; VAR_12 = 0 ; while ( VAR_13 [ VAR_14 ] != 0 || VAR_15 [ VAR_16 + 1 ] != 0 ) { VAR_17 [ VAR_18 ] = 0xFF & VAR_19 [ VAR_20 ] ; VAR_21 ++ ; } VAR_22 [ VAR_23 ++ ] = '\\0' ; VAR_24 [ VAR_25 ++ ] = '\\0' ; return VAR_26 ; },<S2SV_ModStart> ) { return VAR_27 <S2SV_ModEnd> ; } while,CWE-119 char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; },<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
495,"CWE-119 static TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 ) { const struct STRUCT_OR_UNION_1 * VAR_1 ; unsigned TYPE_1 VAR_2 ; <S2SV_StartBug> if ( ! METHOD_1 ( & VAR_3 -> VAR_4 ) ) <S2SV_EndBug> return VAR_5 ; VAR_6 = METHOD_2 ( VAR_7 ) ; if ( METHOD_3 ( VAR_8 -> VAR_9 . VAR_10 . VAR_11 , VAR_12 ) != 0 ) return VAR_13 ; VAR_14 = ( ( struct STRUCT_OR_UNION_2 * ) VAR_15 ) -> VAR_16 ; VAR_17 = - VAR_18 - 1 ; return VAR_19 == VAR_20 || VAR_21 == VAR_22 ; }",<S2SV_ModStart> ! METHOD_1 ( VAR_7 <S2SV_ModEnd> ) ) return,"CWE-119 static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }",<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
496,"CWE-617 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * * VAR_5 , const TYPE_7 * * VAR_6 ) { TYPE_8 VAR_7 ; TYPE_9 VAR_8 ; VAR_9 . VAR_10 = VAR_11 -> VAR_12 ; VAR_13 . VAR_14 = ( TYPE_10 * ) VAR_15 -> VAR_16 ; VAR_17 = METHOD_1 ( & VAR_18 , VAR_19 ) ; if ( VAR_20 ) <S2SV_StartBug> return VAR_21 ; <S2SV_EndBug> VAR_22 = METHOD_2 ( VAR_23 , VAR_24 ? VAR_25 : VAR_26 , & VAR_27 , VAR_28 -> VAR_29 , * VAR_30 ) ; if ( VAR_31 ) { * VAR_32 = ""INVALID_S4U2SELF_CHECKSUM"" ; METHOD_3 ( VAR_33 , * VAR_34 ) ; * VAR_35 = VAR_36 ; return VAR_37 ; } if ( METHOD_4 ( VAR_38 , ( * VAR_39 ) -> VAR_40 . VAR_41 ) == 0 || ( * VAR_42 ) -> VAR_43 . VAR_44 . VAR_45 != 0 ) { * VAR_46 = ""INVALID_S4U2SELF_REQUEST"" ; METHOD_5 ( VAR_47 , * VAR_48 ) ; * VAR_49 = VAR_50 ; return VAR_51 ; } return 0 ; }","<S2SV_ModStart> ( VAR_37 ) { * VAR_46 = ""DECODE_PA_S4U_X509_USER"" ; return VAR_37 ; } <S2SV_ModEnd> VAR_37 = METHOD_2","CWE-617 static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }","<S2SV_ModStart> ( code ) { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum"
497,"CWE-125 TYPE_0 <S2SV_StartBug> METHOD_0 ( TYPE_1 METHOD_1 , TYPE_2 VAR_0 , TYPE_3 VAR_1 , TYPE_4 VAR_2 , TYPE_5 <S2SV_EndBug> VAR_3 , TYPE_6 VAR_4 , TYPE_7 * VAR_5 ) { TYPE_8 VAR_6 ; if ( ! METHOD_2 ) { METHOD_3 ( VAR_7 , ""field<S2SV_blank>arg<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>arg"" ) ; return VAR_8 ; } VAR_9 = ( TYPE_9 ) METHOD_4 ( VAR_10 , sizeof ( * VAR_11 ) ) ; if ( ! VAR_12 ) return VAR_13 ; VAR_14 -> METHOD_5 = METHOD_6 ; VAR_15 -> VAR_16 = VAR_17 ; <S2SV_StartBug> VAR_18 -> VAR_19 = VAR_20 ; <S2SV_EndBug> VAR_21 -> VAR_22 = VAR_23 ; VAR_24 -> VAR_25 = VAR_26 ; VAR_27 -> VAR_28 = VAR_29 ; return VAR_30 ; }","<S2SV_ModStart> TYPE_2 VAR_17 , TYPE_10 VAR_31 , <S2SV_ModStart> ; VAR_30 -> VAR_31 = VAR_31 ; VAR_30 ->","CWE-125 arg_ty <S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { arg_ty p ; if ( ! arg ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>arg<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>arg"" ) ; return NULL ; } p = ( arg_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> arg = arg ; p -> annotation = annotation ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> expr_ty annotation , string type_comment , <S2SV_ModStart> ; p -> type_comment = type_comment ; p ->"
498,"CWE-125 static TYPE_0 <S2SV_StartBug> METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 ) <S2SV_EndBug> { <S2SV_StartBug> const TYPE_3 * VAR_2 = ( const TYPE_4 * ) VAR_3 ; <S2SV_EndBug> if ( METHOD_1 ( VAR_4 ) & VAR_5 ) { METHOD_2 ( ( VAR_6 , ""A"" ) ) ; } if ( METHOD_3 ( VAR_7 ) & VAR_8 ) { METHOD_4 ( ( VAR_9 , ""S"" ) ) ; } }","<S2SV_ModStart> TYPE_2 * VAR_3 , TYPE_5 VAR_10 <S2SV_ModStart> ) VAR_3 ; if ( VAR_10 < 4 ) { METHOD_4 ( ( VAR_9 , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }","CWE-125 static void <S2SV_StartBug> l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_SYNC_MASK ) { ND_PRINT ( ( ndo , ""S"" ) ) ; } }","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }"
499,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = & VAR_3 -> VAR_4 ; TYPE_4 VAR_5 = 0 ; TYPE_5 VAR_6 = 0 ; TYPE_6 VAR_7 = METHOD_1 ( VAR_8 , VAR_9 -> VAR_10 ) ; TYPE_7 VAR_11 = METHOD_2 ( VAR_12 , VAR_13 -> VAR_14 ) ; TYPE_8 VAR_15 ; TYPE_9 VAR_16 = 0 ; <S2SV_StartBug> TYPE_10 VAR_17 = VAR_18 -> VAR_19 ; <S2SV_EndBug> TYPE_11 VAR_20 = 0 ; TYPE_12 VAR_21 ; TYPE_13 VAR_22 = 0 ; TYPE_14 VAR_23 = 0 ; TYPE_15 VAR_24 [ VAR_25 + 1 ] ; TYPE_16 * VAR_26 = VAR_27 -> VAR_28 ; <S2SV_StartBug> METHOD_3 ( VAR_29 , 0 , sizeof ( VAR_30 ) ) ; <S2SV_EndBug> VAR_31 -> VAR_32 = & VAR_33 -> VAR_34 ; if ( VAR_35 -> VAR_36 == VAR_37 ) VAR_38 -> VAR_39 = 0 ; else VAR_40 -> VAR_41 = VAR_42 -> VAR_43 . VAR_44 ; VAR_45 = VAR_46 -> VAR_47 ; if ( VAR_48 < VAR_49 ) VAR_50 = VAR_51 ; else if ( VAR_52 > VAR_53 ) VAR_54 = VAR_55 ; VAR_56 = ( VAR_57 < 16 ) ? 4 : VAR_58 / 4 ; METHOD_4 ( VAR_59 , VAR_60 -> VAR_61 ) ; METHOD_5 ( VAR_62 , VAR_63 ) ; METHOD_6 ( VAR_64 , & VAR_65 -> VAR_66 . VAR_67 , VAR_68 ) ; VAR_69 = METHOD_7 ( VAR_70 , VAR_71 -> VAR_72 ) ; VAR_73 [ VAR_74 ] = VAR_75 ; VAR_76 = VAR_77 ; while ( VAR_78 > 0 ) { VAR_79 = ( VAR_80 >> ( 15 - ( VAR_81 / 8 ) ) ) * VAR_82 ; if ( VAR_83 -> VAR_84 . VAR_85 < 20 ) VAR_86 = VAR_87 * VAR_88 -> VAR_89 . VAR_90 / 20 ; VAR_91 = ( ( VAR_92 + VAR_93 ) > VAR_94 ) ? VAR_95 : ( VAR_96 + VAR_97 ) ; VAR_98 = ( ( VAR_99 - VAR_100 ) < VAR_101 ) ? VAR_102 : ( VAR_103 - VAR_104 ) ; if ( ( VAR_105 <= 0 ) && ( VAR_106 != VAR_107 ) ) { if ( VAR_108 [ VAR_109 ] == 0 ) { METHOD_8 ( VAR_110 , VAR_111 -> VAR_112 ) ; METHOD_9 ( VAR_113 , VAR_114 ) ; METHOD_10 ( VAR_115 , & VAR_116 -> VAR_117 . VAR_118 , VAR_119 ) ; VAR_120 = METHOD_11 ( VAR_121 , VAR_122 -> VAR_123 ) ; VAR_124 [ VAR_125 ] = VAR_126 ; } else VAR_127 = VAR_128 [ VAR_129 ] ; if ( ( VAR_130 - VAR_131 ) < VAR_132 ) { if ( VAR_133 < VAR_134 ) VAR_135 = VAR_136 ; VAR_137 = VAR_138 ; } } if ( ( VAR_139 >= 0 ) && ( VAR_140 != VAR_141 ) ) { if ( VAR_142 [ VAR_143 ] == 0 ) { METHOD_12 ( VAR_144 , VAR_145 -> VAR_146 ) ; METHOD_13 ( VAR_147 , VAR_148 ) ; METHOD_14 ( VAR_149 , & VAR_150 -> VAR_151 . VAR_152 , VAR_153 ) ; VAR_154 = METHOD_15 ( VAR_155 , VAR_156 -> VAR_157 ) ; VAR_158 [ VAR_159 ] = VAR_160 ; } else VAR_161 = VAR_162 [ VAR_163 ] ; if ( VAR_164 < ( VAR_165 - VAR_166 ) ) { VAR_167 = VAR_168 ; VAR_169 = VAR_170 ; } } if ( VAR_171 == VAR_172 ) { VAR_173 = VAR_174 / 2 ; VAR_175 = 0 ; } else { VAR_176 = ( VAR_177 < VAR_178 ) ? - 1 : 1 ; VAR_179 = VAR_180 ; } } VAR_181 -> VAR_182 = VAR_183 ; VAR_184 -> VAR_185 = VAR_186 ; }","<S2SV_ModStart> ; TYPE_15 VAR_179 <S2SV_ModEnd> ; TYPE_15 VAR_138 <S2SV_ModStart> -> VAR_185 ; METHOD_16 <S2SV_ModEnd> ( VAR_162 ,","CWE-119 void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; <S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }","<S2SV_ModStart> ; int filt_mid <S2SV_ModEnd> ; int filt_low <S2SV_ModStart> -> frame_to_show ; memset <S2SV_ModEnd> ( ss_err ,"
500,"CWE-000 static TYPE_0 STRUCT_OR_UNION_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 ) { struct STRUCT_OR_UNION_3 VAR_2 ; <S2SV_StartBug> METHOD_0 ( VAR_3 . VAR_4 , ""cipher"" , sizeof ( VAR_5 . VAR_6 ) ) ; <S2SV_EndBug> VAR_7 . VAR_8 = VAR_9 -> VAR_10 ; VAR_11 . VAR_12 = VAR_13 -> VAR_14 . VAR_15 ; VAR_16 . VAR_17 = VAR_18 -> VAR_19 . VAR_20 ; if ( METHOD_1 ( VAR_21 , VAR_22 , sizeof ( struct STRUCT_OR_UNION_4 ) , & VAR_23 ) ) goto VAR_24 ; return 0 ; VAR_25 : return - VAR_26 ; }",<S2SV_ModStart> STRUCT_OR_UNION_4 VAR_23 ; METHOD_2 <S2SV_ModEnd> ( VAR_23 .,"CWE-000 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }",<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
501,"CWE-119 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 = { 0 } ; <S2SV_EndBug> VAR_3 . VAR_4 = ( VAR_5 -> VAR_6 + 15 ) / 16 ; VAR_7 . VAR_8 = ( VAR_9 -> VAR_10 + 15 ) / 16 ; VAR_11 . VAR_12 = VAR_13 ; if ( METHOD_1 ( VAR_14 , VAR_15 , & VAR_16 ) ) METHOD_2 ( VAR_17 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map"" ) ; }","<S2SV_ModStart> VAR_16 = { 0 , 0 ,","CWE-119 static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = NULL ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map"" ) ; }","<S2SV_ModStart> map = { 0 , 0 ,"
502,"CWE-400 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 ) { VAR_4 * VAR_5 ; TYPE_5 VAR_6 ; VAR_7 * VAR_8 ; TYPE_6 VAR_9 ; TYPE_7 VAR_10 ; TYPE_8 VAR_11 ; VAR_12 * VAR_13 ; VAR_14 = & VAR_15 -> VAR_16 ; if ( ( ! VAR_17 -> VAR_18 && VAR_19 -> VAR_20 != 1 ) || ( VAR_21 -> VAR_22 && VAR_23 -> VAR_24 >= 1 ) ) { return VAR_25 ; } if ( VAR_26 % VAR_27 ) { <S2SV_StartBug> return VAR_28 ; <S2SV_EndBug> } VAR_29 = METHOD_1 ( & VAR_30 , & VAR_31 , VAR_32 , VAR_33 , VAR_34 ) ; if ( VAR_35 != 0 ) { return VAR_36 ; } if ( VAR_37 -> VAR_38 ) { METHOD_2 ( & VAR_39 . VAR_40 , VAR_41 , VAR_42 , VAR_43 , 0 ) ; VAR_44 . VAR_45 . VAR_46 = VAR_47 ; VAR_48 . VAR_49 . VAR_50 = VAR_51 ; VAR_52 = METHOD_3 ( VAR_53 , & VAR_54 , 1 ) ; } else { VAR_55 = METHOD_4 ( VAR_56 , VAR_57 , VAR_58 , VAR_59 ) ; } METHOD_5 ( VAR_60 , VAR_61 ) ; if ( VAR_62 != 0 ) { return VAR_63 ; } METHOD_6 ( & VAR_64 ) ; VAR_65 = METHOD_7 ( VAR_66 , 1 , VAR_67 , & VAR_68 , VAR_69 , VAR_70 -> VAR_71 ? VAR_72 : VAR_73 ) ; if ( VAR_74 == VAR_75 ) { return VAR_76 ; } if ( VAR_77 -> VAR_78 ) { METHOD_8 ( VAR_79 , VAR_80 ) ; VAR_81 -> VAR_82 = 1 ; VAR_83 -> VAR_84 = 1 ; } else { METHOD_9 ( VAR_85 , VAR_86 ) ; VAR_87 -> VAR_88 = 1 ; VAR_89 -> VAR_90 += 2 ; } return 0 ; }",<S2SV_ModStart> { return VAR_28 ; } if ( VAR_41 / VAR_27 > VAR_89 -> VAR_91 ) { return VAR_92,"CWE-400 static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return NGHTTP2_ERR_PROTO ; } if ( settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) { <S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , NGHTTP2_SETTINGS , NGHTTP2_FLAG_NONE , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , NGHTTP2_FLAG_NONE , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , NGHTTP2_STREAM_FLAG_NONE , & pri_spec , NGHTTP2_STREAM_OPENING , session -> server ? NULL : stream_user_data ) ; if ( stream == NULL ) { return NGHTTP2_ERR_NOMEM ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_RD ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_WR ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }",<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS
503,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , const TYPE_2 * VAR_2 ) { TYPE_3 VAR_3 ; TYPE_4 VAR_4 = 0 ; TYPE_5 VAR_5 = 0 ; TYPE_6 VAR_6 = 0 ; const TYPE_7 VAR_7 = VAR_8 -> VAR_9 . VAR_10 . VAR_11 * 1000 * ( TYPE_8 ) VAR_12 -> VAR_13 . VAR_14 / ( TYPE_9 ) VAR_15 -> VAR_16 . VAR_17 ; TYPE_10 VAR_18 = VAR_19 -> VAR_20 ++ % VAR_21 -> VAR_22 ; VAR_23 -> VAR_24 [ VAR_25 ] = VAR_26 ; VAR_27 -> VAR_28 [ VAR_29 ] = ( TYPE_11 ) VAR_30 -> VAR_31 . VAR_32 . VAR_33 ; if ( VAR_34 < VAR_35 -> VAR_36 ) return ; <S2SV_StartBug> VAR_37 = VAR_38 ; <S2SV_EndBug> for ( VAR_39 = VAR_40 -> VAR_41 ; VAR_42 > 0 && VAR_43 -> VAR_44 - VAR_45 < VAR_46 -> VAR_47 ; VAR_48 -- ) { const TYPE_12 VAR_49 = ( VAR_50 - 1 ) % VAR_51 -> VAR_52 ; VAR_53 = VAR_54 -> VAR_55 [ VAR_56 ] ; if ( VAR_57 - VAR_58 > VAR_59 -> VAR_60 ) break ; VAR_61 += VAR_62 -> VAR_63 [ VAR_64 ] ; } if ( VAR_65 == VAR_66 ) return ; VAR_67 = VAR_68 * 8 * 1000 / ( VAR_69 - VAR_70 ) ; VAR_71 = ( TYPE_13 ) ( VAR_72 * ( VAR_73 / 2 ) / ( VAR_74 -> VAR_75 * 1000 ) ) ; if ( VAR_76 < 0 ) VAR_77 = 0 ; if ( VAR_78 > VAR_79 - 1 ) VAR_80 = VAR_81 - 1 ; if ( VAR_82 -> VAR_83 [ VAR_84 ] . VAR_85 > VAR_86 ) VAR_87 -> VAR_88 [ VAR_89 ] . VAR_90 = ( TYPE_14 ) VAR_91 ; if ( VAR_92 -> VAR_93 [ VAR_94 ] . VAR_95 < VAR_96 ) VAR_97 -> VAR_98 [ VAR_99 ] . VAR_100 = ( TYPE_15 ) VAR_101 ; VAR_102 -> VAR_103 [ VAR_104 ] . VAR_105 ++ ; VAR_106 -> VAR_107 ++ ; }",<S2SV_ModStart> ) return ; if ( ! VAR_74 -> VAR_75 ) return ;,"CWE-119 void update_rate_histogram ( struct rate_hist * hist , const vpx_codec_enc_cfg_t * cfg , const vpx_codec_cx_pkt_t * pkt ) { int i ; int64_t then = 0 ; int64_t avg_bitrate = 0 ; int64_t sum_sz = 0 ; const int64_t now = pkt -> data . frame . pts * 1000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; int idx = hist -> frames ++ % hist -> samples ; hist -> pts [ idx ] = now ; hist -> sz [ idx ] = ( int ) pkt -> data . frame . sz ; if ( now < cfg -> rc_buf_initial_sz ) return ; <S2SV_StartBug> then = now ; <S2SV_EndBug> for ( i = hist -> frames ; i > 0 && hist -> frames - i < hist -> samples ; i -- ) { const int i_idx = ( i - 1 ) % hist -> samples ; then = hist -> pts [ i_idx ] ; if ( now - then > cfg -> rc_buf_sz ) break ; sum_sz += hist -> sz [ i_idx ] ; } if ( now == then ) return ; avg_bitrate = sum_sz * 8 * 1000 / ( now - then ) ; idx = ( int ) ( avg_bitrate * ( RATE_BINS / 2 ) / ( cfg -> rc_target_bitrate * 1000 ) ) ; if ( idx < 0 ) idx = 0 ; if ( idx > RATE_BINS - 1 ) idx = RATE_BINS - 1 ; if ( hist -> bucket [ idx ] . low > avg_bitrate ) hist -> bucket [ idx ] . low = ( int ) avg_bitrate ; if ( hist -> bucket [ idx ] . high < avg_bitrate ) hist -> bucket [ idx ] . high = ( int ) avg_bitrate ; hist -> bucket [ idx ] . count ++ ; hist -> total ++ ; }",<S2SV_ModStart> ) return ; if ( ! cfg -> rc_target_bitrate ) return ;
504,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 * VAR_3 ) { struct STRUCT_OR_UNION_1 * VAR_4 = & METHOD_1 ( VAR_5 ) -> VAR_6 [ VAR_7 ] . VAR_8 ; TYPE_4 VAR_9 , VAR_10 = 0 ; TYPE_5 VAR_11 = - 1 ; METHOD_2 ( & VAR_12 -> VAR_13 ) ; for ( VAR_14 = VAR_15 ; VAR_16 < VAR_17 ; VAR_18 ++ ) { if ( VAR_19 < 0 && ( VAR_20 -> VAR_21 [ VAR_22 ] == 0 ) ) { VAR_23 = VAR_24 ; continue ; } if ( VAR_25 -> VAR_26 [ VAR_27 ] && ( VAR_28 == ( VAR_29 & METHOD_3 ( VAR_30 -> VAR_31 [ VAR_32 ] ) ) ) ) { * VAR_33 = VAR_34 ; ++ VAR_35 -> VAR_36 [ VAR_37 ] ; goto VAR_38 ; <S2SV_StartBug> } <S2SV_EndBug> } if ( VAR_39 -> VAR_40 == VAR_41 -> VAR_42 ) { VAR_43 = - VAR_44 ; goto VAR_45 ; } VAR_46 -> VAR_47 [ VAR_48 ] = 1 ; VAR_49 -> VAR_50 [ VAR_51 ] = METHOD_4 ( VAR_52 | VAR_53 ) ; VAR_54 = METHOD_5 ( VAR_55 , VAR_56 , VAR_57 -> VAR_58 ) ; if ( METHOD_6 ( VAR_59 ) ) { METHOD_7 ( VAR_60 , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , VAR_61 ) ; VAR_62 -> VAR_63 [ VAR_64 ] = 0 ; VAR_65 -> VAR_66 [ VAR_67 ] = 0 ; goto VAR_68 ; } * VAR_69 = VAR_70 ; ++ VAR_71 -> VAR_72 ; VAR_73 : METHOD_8 ( & VAR_74 -> VAR_75 ) ; return VAR_76 ; }",<S2SV_ModStart> VAR_73 ; } } if ( VAR_70 < 0 ) { VAR_76 = - VAR_77 ; goto VAR_73 ;,"CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }",<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
505,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , const unsigned TYPE_1 * VAR_2 , const unsigned TYPE_2 * VAR_3 , const unsigned TYPE_3 * VAR_4 , const unsigned TYPE_4 * VAR_5 , unsigned TYPE_5 VAR_6 ) { unsigned TYPE_6 VAR_7 ; TYPE_7 VAR_8 ; if ( ( unsigned TYPE_8 ) VAR_9 % VAR_10 ( struct STRUCT_OR_UNION_2 ) != 0 || <S2SV_StartBug> ( unsigned TYPE_9 * ) VAR_11 + sizeof ( struct STRUCT_OR_UNION_3 ) >= VAR_12 ) { <S2SV_EndBug> METHOD_1 ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , VAR_13 ) ; return - VAR_14 ; } if ( VAR_15 -> VAR_16 < sizeof ( struct STRUCT_OR_UNION_4 ) + sizeof ( struct STRUCT_OR_UNION_5 ) ) { METHOD_2 ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , VAR_17 , VAR_18 -> VAR_19 ) ; return - VAR_20 ; } VAR_21 = METHOD_3 ( VAR_22 ) ; if ( VAR_23 ) return VAR_24 ; for ( VAR_25 = 0 ; VAR_26 < VAR_27 ; VAR_28 ++ ) { if ( ! ( VAR_29 & ( 1 << VAR_30 ) ) ) continue ; if ( ( unsigned TYPE_10 * ) VAR_31 - VAR_32 == VAR_33 [ VAR_34 ] ) VAR_35 -> VAR_36 [ VAR_37 ] = VAR_38 [ VAR_39 ] ; if ( ( unsigned TYPE_11 * ) VAR_40 - VAR_41 == VAR_42 [ VAR_43 ] ) { if ( ! METHOD_4 ( VAR_44 ) ) { METHOD_5 ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - VAR_45 ; } VAR_46 -> VAR_47 [ VAR_48 ] = VAR_49 [ VAR_50 ] ; } } VAR_51 -> VAR_52 = ( ( struct STRUCT_OR_UNION_6 ) { 0 , 0 } ) ; VAR_53 -> VAR_54 = 0 ; return 0 ; }",<S2SV_ModStart> STRUCT_OR_UNION_4 ) >= VAR_12 || ( unsigned TYPE_11 * ) VAR_53 + VAR_53 -> VAR_19 >,"CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
506,"CWE-264 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 ; VAR_4 -> VAR_5 = - 1 ; VAR_6 -> VAR_7 = - 1 ; <S2SV_StartBug> VAR_8 -> VAR_9 = 0666 ; <S2SV_EndBug> if ( ! VAR_10 ) { return 0 ; } if ( VAR_11 -> VAR_12 && * VAR_13 -> VAR_14 ) { struct STRUCT_OR_UNION_2 * VAR_15 ; VAR_16 = METHOD_1 ( VAR_17 -> VAR_18 ) ; if ( ! VAR_19 ) { METHOD_2 ( VAR_20 , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\'%s\'"" , VAR_21 -> VAR_22 -> VAR_23 , VAR_24 -> VAR_25 ) ; return - 1 ; } VAR_26 -> VAR_27 = VAR_28 -> VAR_29 ; VAR_30 -> VAR_31 = VAR_32 -> VAR_33 ; } if ( VAR_34 -> VAR_35 && * VAR_36 -> VAR_37 ) { struct STRUCT_OR_UNION_3 * VAR_38 ; VAR_39 = METHOD_3 ( VAR_40 -> VAR_41 ) ; if ( ! VAR_42 ) { METHOD_4 ( VAR_43 , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>\'%s\'"" , VAR_44 -> VAR_45 -> VAR_46 , VAR_47 -> VAR_48 ) ; return - 1 ; } VAR_49 -> VAR_50 = VAR_51 -> VAR_52 ; } if ( VAR_53 -> VAR_54 && * VAR_55 -> VAR_56 ) { VAR_57 -> VAR_58 = METHOD_5 ( VAR_59 -> VAR_60 , 0 , 8 ) ; } return 0 ; }",<S2SV_ModStart> -> VAR_58 = 0660 <S2SV_ModEnd> ; if (,"CWE-264 int fpm_unix_resolve_socket_premissions ( struct fpm_worker_pool_s * wp ) { struct fpm_worker_pool_config_s * c = wp -> config ; wp -> socket_uid = - 1 ; wp -> socket_gid = - 1 ; <S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> if ( ! c ) { return 0 ; } if ( c -> listen_owner && * c -> listen_owner ) { struct passwd * pwd ; pwd = getpwnam ( c -> listen_owner ) ; if ( ! pwd ) { zlog ( ZLOG_SYSERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\'%s\'"" , wp -> config -> name , c -> listen_owner ) ; return - 1 ; } wp -> socket_uid = pwd -> pw_uid ; wp -> socket_gid = pwd -> pw_gid ; } if ( c -> listen_group && * c -> listen_group ) { struct group * grp ; grp = getgrnam ( c -> listen_group ) ; if ( ! grp ) { zlog ( ZLOG_SYSERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>\'%s\'"" , wp -> config -> name , c -> listen_group ) ; return - 1 ; } wp -> socket_gid = grp -> gr_gid ; } if ( c -> listen_mode && * c -> listen_mode ) { wp -> socket_mode = strtoul ( c -> listen_mode , 0 , 8 ) ; } return 0 ; }",<S2SV_ModStart> -> socket_mode = 0660 <S2SV_ModEnd> ; if (
507,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_3 > 32 && VAR_4 < 128 ) { METHOD_1 ( VAR_5 >= 4 ) ; VAR_6 [ 0 ] = '\\'' ; VAR_7 [ 1 ] = ( TYPE_4 ) VAR_8 ; VAR_9 [ 2 ] = '\\'' ; VAR_10 [ 3 ] = 0 ; return ; } switch ( VAR_11 ) { case VAR_12 : METHOD_2 ( VAR_13 , ""EOF"" , VAR_14 ) ; return ; case VAR_15 : METHOD_3 ( VAR_16 , ""ID"" , VAR_17 ) ; return ; case VAR_18 : METHOD_4 ( VAR_19 , ""INT"" , VAR_20 ) ; return ; case VAR_21 : METHOD_5 ( VAR_22 , ""FLOAT"" , VAR_23 ) ; return ; case VAR_24 : METHOD_6 ( VAR_25 , ""STRING"" , VAR_26 ) ; return ; case VAR_27 : METHOD_7 ( VAR_28 , ""UNFINISHED<S2SV_blank>STRING"" , VAR_29 ) ; return ; case VAR_30 : METHOD_8 ( VAR_31 , ""TEMPLATE<S2SV_blank>LITERAL"" , VAR_32 ) ; return ; case VAR_33 : METHOD_9 ( VAR_34 , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , VAR_35 ) ; return ; case VAR_36 : METHOD_10 ( VAR_37 , ""REGEX"" , VAR_38 ) ; return ; case VAR_39 : METHOD_11 ( VAR_40 , ""UNFINISHED<S2SV_blank>REGEX"" , VAR_41 ) ; return ; case VAR_42 : METHOD_12 ( VAR_43 , ""UNFINISHED<S2SV_blank>COMMENT"" , VAR_44 ) ; return ; } if ( VAR_45 >= VAR_46 && VAR_47 < VAR_48 ) { const TYPE_5 VAR_49 [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned TYPE_6 VAR_50 = 0 ; TYPE_7 VAR_51 = VAR_52 - VAR_53 ; while ( VAR_54 > 0 && VAR_55 < sizeof ( VAR_56 ) ) { while ( VAR_57 [ VAR_58 ] && VAR_59 < sizeof ( VAR_60 ) ) VAR_61 ++ ; VAR_62 ++ ; VAR_63 -- ; } METHOD_13 ( VAR_64 == 0 ) ; METHOD_14 ( VAR_65 , & VAR_66 [ VAR_67 ] , VAR_68 ) ; return ; } METHOD_15 ( VAR_69 >= 10 ) ; <S2SV_StartBug> METHOD_16 ( VAR_70 , ""?["" , VAR_71 ) ; <S2SV_EndBug> METHOD_17 ( VAR_72 , & VAR_73 [ 2 ] , 10 ) ; METHOD_18 ( VAR_74 , ""]"" , VAR_75 ) ; }","<S2SV_ModStart> 10 ) ; METHOD_19 ( VAR_74 , VAR_75 , ""?[%d]"" , VAR_72 <S2SV_ModEnd> ) ; }","CWE-119 void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; <S2SV_StartBug> strncpy ( str , ""?["" , len ) ; <S2SV_EndBug> itostr ( token , & str [ 2 ] , 10 ) ; strncat ( str , ""]"" , len ) ; }","<S2SV_ModStart> 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token <S2SV_ModEnd> ) ; }"
508,"CWE-200 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { struct STRUCT_OR_UNION_2 VAR_5 ; VAR_6 . VAR_7 = METHOD_1 ( VAR_8 -> VAR_9 . VAR_10 ) ; VAR_11 . VAR_12 = METHOD_2 ( VAR_13 -> VAR_14 . VAR_15 ) ; if ( VAR_16 ) { VAR_17 . VAR_18 = VAR_19 ; VAR_20 . VAR_21 = VAR_22 ; VAR_23 . VAR_24 = VAR_25 -> VAR_26 . VAR_27 ; VAR_28 . VAR_29 = VAR_30 -> VAR_31 . VAR_32 ; } else { VAR_33 . VAR_34 = VAR_35 ; VAR_36 . VAR_37 = VAR_38 ; VAR_39 . VAR_40 = VAR_41 -> VAR_42 . VAR_43 ; VAR_44 . VAR_45 = VAR_46 -> VAR_47 . VAR_48 ; } <S2SV_StartBug> METHOD_3 ( VAR_49 , & VAR_50 , sizeof ( VAR_51 ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> VAR_48 ; } VAR_51 . VAR_52 = 0 ;,"CWE-200 void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> }",<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
509,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_7 * VAR_8 = ( struct STRUCT_OR_UNION_8 * ) VAR_9 -> VAR_10 ; TYPE_3 VAR_11 ; unsigned TYPE_4 * asmptr ; struct sk_buff * TYPE_5 ; TYPE_6 VAR_12 , er , qbit ; if ( VAR_13 -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( TYPE_7 = skb_recv_datagram ( VAR_14 , VAR_15 & ~ MSG_DONTWAIT , VAR_16 & MSG_DONTWAIT , & er ) ) == VAR_17 ) return er ; qbit = ( TYPE_8 -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( TYPE_9 , ROSE_MIN_LEN ) ; if ( VAR_18 -> qbitincl ) { asmptr = skb_push ( TYPE_10 , 1 ) ; * asmptr = qbit ; } VAR_19 ( TYPE_11 ) ; VAR_20 = TYPE_12 -> VAR_21 ; if ( VAR_22 > VAR_23 ) { VAR_24 = VAR_25 ; VAR_26 -> VAR_27 |= VAR_28 ; } METHOD_2 ( TYPE_13 , 0 , VAR_29 -> VAR_30 , VAR_31 ) ; if ( VAR_32 != VAR_33 ) { <S2SV_StartBug> VAR_34 -> VAR_35 = VAR_36 ; <S2SV_EndBug> VAR_37 -> VAR_38 = VAR_39 -> VAR_40 ; VAR_41 -> VAR_42 = VAR_43 -> VAR_44 ; VAR_45 -> VAR_46 = VAR_47 -> VAR_48 ; if ( VAR_49 -> VAR_50 >= sizeof ( struct STRUCT_OR_UNION_9 ) ) { struct STRUCT_OR_UNION_10 * VAR_51 = ( struct STRUCT_OR_UNION_11 * ) VAR_52 -> VAR_53 ; for ( VAR_54 = 0 ; VAR_55 < VAR_56 -> VAR_57 ; VAR_58 ++ ) VAR_59 -> VAR_60 [ VAR_61 ] = VAR_62 -> VAR_63 [ VAR_64 ] ; VAR_65 -> VAR_66 = sizeof ( struct STRUCT_OR_UNION_12 ) ; } else { if ( VAR_67 -> VAR_68 >= 1 ) { VAR_69 -> VAR_70 = 1 ; VAR_71 -> VAR_72 = VAR_73 -> VAR_74 [ 0 ] ; } VAR_75 -> VAR_76 = sizeof ( struct STRUCT_OR_UNION_13 ) ; } } METHOD_3 ( VAR_77 , TYPE_14 ) ; return VAR_78 ; }","<S2SV_ModStart> VAR_33 ) { METHOD_4 ( VAR_71 , 0 , VAR_75 -> VAR_76 ) ;","CWE-200 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) { <S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }","<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;"
510,"CWE-20 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 ; const TYPE_4 * VAR_4 ; const struct STRUCT_OR_UNION_1 * VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 ; METHOD_1 ( ( VAR_8 , ""<S2SV_blank>wb-id:"" ) ) ; if ( VAR_9 < sizeof ( * VAR_10 ) || ! METHOD_2 ( * VAR_11 ) ) return ( - 1 ) ; VAR_12 -= sizeof ( * VAR_13 ) ; METHOD_3 ( ( VAR_14 , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , METHOD_4 ( & VAR_15 -> VAR_16 . VAR_17 ) , METHOD_5 ( VAR_18 , & VAR_19 -> VAR_20 . VAR_21 . VAR_22 ) , METHOD_6 ( & VAR_23 -> VAR_24 . VAR_25 . VAR_26 ) , METHOD_7 ( & VAR_27 -> VAR_28 ) , METHOD_8 ( VAR_29 , & VAR_30 -> VAR_31 . VAR_32 ) , METHOD_9 ( & VAR_33 -> VAR_34 . VAR_35 ) ) ) ; VAR_36 = METHOD_10 ( & VAR_37 -> VAR_38 . VAR_39 ) ; VAR_40 -= sizeof ( * VAR_41 ) * VAR_42 ; VAR_43 = ( struct STRUCT_OR_UNION_2 * ) ( VAR_44 + 1 ) ; VAR_45 = ( TYPE_7 * ) ( VAR_46 + VAR_47 ) ; <S2SV_StartBug> if ( ! METHOD_11 ( VAR_48 , VAR_49 ) ) { <S2SV_EndBug> METHOD_12 ( ( VAR_50 , ""\\"""" ) ) ; fn_print ( VAR_51 , ( u_char * ) VAR_52 , ( u_char * ) VAR_53 + VAR_54 ) ; METHOD_13 ( ( VAR_55 , ""\\"""" ) ) ; } VAR_56 = '<' ; for ( VAR_57 = 0 ; VAR_58 < VAR_59 && METHOD_14 ( * VAR_60 ) ; ++ VAR_61 , ++ VAR_62 ) { METHOD_15 ( ( VAR_63 , ""%c%s:%u"" , VAR_64 , METHOD_16 ( VAR_65 , & VAR_66 -> VAR_67 ) , METHOD_17 ( & VAR_68 -> VAR_69 ) ) ) ; VAR_70 = ',' ; } if ( VAR_71 >= VAR_72 ) { METHOD_18 ( ( VAR_73 , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> METHOD_11 ( VAR_53,"CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-id:"" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\"""" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
511,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { TYPE_3 VAR_4 = VAR_5 & VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 = STRUCT_OR_UNION_5 -> VAR_8 ; unsigned TYPE_4 VAR_9 , VAR_10 ; struct STRUCT_OR_UNION_6 * VAR_11 , * VAR_12 ; TYPE_5 VAR_13 = 0 ; METHOD_1 ( ""%p<S2SV_blank>%zu\\n"" , VAR_14 , VAR_15 ) ; <S2SV_StartBug> VAR_16 -> VAR_17 = 0 ; <S2SV_EndBug> METHOD_2 ( VAR_18 ) ; if ( VAR_19 -> VAR_20 == VAR_21 && METHOD_3 ( & VAR_22 -> VAR_23 ) ) { METHOD_4 ( VAR_24 ) ; return 0 ; } METHOD_5 ( VAR_25 ) ; if ( VAR_26 & ( VAR_27 ) ) return - VAR_28 ; VAR_29 = METHOD_6 ( VAR_30 , VAR_31 , VAR_32 , & VAR_33 ) ; if ( ! VAR_34 ) { METHOD_7 ( ""Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d"" , VAR_35 -> VAR_36 , VAR_37 , METHOD_8 ( VAR_38 ) ) ; if ( VAR_39 -> VAR_40 & VAR_41 ) return 0 ; return VAR_42 ; } VAR_43 = VAR_44 -> VAR_45 ; VAR_46 = min_t ( unsigned TYPE_6 , VAR_47 , VAR_48 ) ; VAR_49 = VAR_50 ; if ( METHOD_9 ( VAR_51 , 0 , VAR_52 -> VAR_53 , VAR_54 ) ) { if ( ! ( VAR_55 & VAR_56 ) ) METHOD_10 ( & VAR_57 -> VAR_58 , VAR_59 ) ; return - VAR_60 ; } METHOD_11 ( VAR_61 , VAR_62 , VAR_63 ) ; if ( VAR_64 -> VAR_65 == VAR_66 && VAR_67 -> VAR_68 ) { struct STRUCT_OR_UNION_7 * VAR_69 = METHOD_12 ( VAR_70 ) ; struct STRUCT_OR_UNION_8 * VAR_71 = ( struct STRUCT_OR_UNION_9 * ) VAR_72 -> VAR_73 ; VAR_74 -> VAR_75 = sizeof ( struct STRUCT_OR_UNION_10 ) ; METHOD_13 ( ""Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n"" , VAR_76 -> VAR_77 , VAR_78 -> VAR_79 ) ; METHOD_14 ( VAR_80 , 0 , sizeof ( * VAR_81 ) ) ; VAR_82 -> VAR_83 = VAR_84 ; VAR_85 -> VAR_86 = VAR_87 ; VAR_88 -> VAR_89 = VAR_90 -> VAR_91 ; VAR_92 -> VAR_93 = VAR_94 -> VAR_95 ; } if ( ! ( VAR_96 & VAR_97 ) ) { if ( VAR_98 -> VAR_99 == VAR_100 || VAR_101 -> VAR_102 == VAR_103 || VAR_104 -> VAR_105 == VAR_106 ) { METHOD_15 ( VAR_107 , VAR_108 ) ; if ( VAR_109 -> VAR_110 ) { METHOD_16 ( & VAR_111 -> VAR_112 , VAR_113 ) ; goto VAR_114 ; } } METHOD_17 ( VAR_115 ) ; } VAR_116 : if ( VAR_117 -> VAR_118 == VAR_119 && ( VAR_120 & VAR_121 ) ) VAR_122 = VAR_123 ; return VAR_124 ; }",<S2SV_ModStart> VAR_110 ) ; <S2SV_ModEnd> METHOD_2 ( VAR_117,"CWE-20 static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; sockaddr -> sa_family = AF_NFC ; sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }",<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
512,"CWE-362 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 , struct STRUCT_OR_UNION_4 * VAR_3 ) { struct STRUCT_OR_UNION_5 * VAR_4 = METHOD_1 ( VAR_5 ) ; struct STRUCT_OR_UNION_6 * VAR_6 , * VAR_7 = METHOD_2 ( VAR_8 ) ; struct STRUCT_OR_UNION_7 * VAR_9 ; struct STRUCT_OR_UNION_8 * VAR_10 ; struct STRUCT_OR_UNION_9 * VAR_11 ; struct STRUCT_OR_UNION_10 * VAR_12 ; if ( VAR_13 -> VAR_14 == METHOD_3 ( VAR_15 ) ) { VAR_16 = METHOD_4 ( VAR_17 , VAR_18 , VAR_19 , VAR_20 ) ; if ( VAR_21 == VAR_22 ) return VAR_23 ; VAR_24 = ( struct STRUCT_OR_UNION_11 * ) VAR_25 ; VAR_26 = METHOD_5 ( VAR_27 ) ; VAR_28 -> VAR_29 = & VAR_30 -> VAR_31 ; VAR_32 = METHOD_6 ( VAR_33 ) ; METHOD_7 ( VAR_34 , VAR_35 , sizeof ( struct STRUCT_OR_UNION_12 ) ) ; METHOD_8 ( VAR_36 -> VAR_37 , & VAR_38 -> VAR_39 ) ; METHOD_9 ( VAR_40 -> VAR_41 , & VAR_42 -> VAR_43 ) ; METHOD_10 ( & VAR_44 -> VAR_45 , & VAR_46 -> VAR_47 ) ; METHOD_11 ( VAR_48 ) -> VAR_49 = & VAR_50 ; VAR_51 -> VAR_52 = VAR_53 ; VAR_54 -> VAR_55 = VAR_56 ; VAR_57 -> VAR_58 = VAR_59 ; VAR_60 -> VAR_61 = METHOD_12 ( VAR_62 ) ; VAR_63 -> VAR_64 = METHOD_13 ( VAR_65 ) -> VAR_66 ; METHOD_14 ( VAR_67 , METHOD_15 ( VAR_68 ) -> VAR_69 ) ; return VAR_70 ; } VAR_71 = VAR_72 -> VAR_73 ; if ( METHOD_16 ( VAR_74 ) ) goto VAR_75 ; if ( VAR_76 == VAR_77 ) { struct STRUCT_OR_UNION_13 * VAR_78 , VAR_79 ; struct STRUCT_OR_UNION_14 VAR_80 ; METHOD_17 ( & VAR_81 , 0 , sizeof ( VAR_82 ) ) ; VAR_83 . VAR_84 = VAR_85 ; METHOD_18 ( & VAR_86 . VAR_87 , & VAR_88 -> VAR_89 ) ; VAR_90 = METHOD_19 ( & VAR_91 , VAR_92 , & VAR_93 ) ; METHOD_20 ( & VAR_94 . VAR_95 , & VAR_96 -> VAR_97 ) ; VAR_98 . VAR_99 = VAR_100 -> VAR_101 ; VAR_102 . VAR_103 = METHOD_21 ( VAR_104 ) -> VAR_105 ; VAR_106 . VAR_107 = METHOD_22 ( VAR_108 ) -> VAR_109 ; METHOD_23 ( VAR_110 , METHOD_24 ( & VAR_111 ) ) ; VAR_112 = METHOD_25 ( VAR_113 , & VAR_114 , VAR_115 , VAR_116 ) ; if ( METHOD_26 ( VAR_117 ) ) goto VAR_118 ; } VAR_119 = METHOD_27 ( VAR_120 , VAR_121 , VAR_122 ) ; if ( VAR_123 == VAR_124 ) goto VAR_125 ; METHOD_28 ( VAR_126 , VAR_127 , VAR_128 , VAR_129 ) ; VAR_130 -> VAR_131 = VAR_132 -> VAR_133 -> VAR_134 & ~ ( VAR_135 | VAR_136 ) ; VAR_137 = ( struct STRUCT_OR_UNION_15 * ) VAR_138 ; VAR_139 = METHOD_29 ( VAR_140 ) ; VAR_141 -> VAR_142 = & VAR_143 -> VAR_144 ; VAR_145 = METHOD_30 ( VAR_146 ) ; METHOD_31 ( VAR_147 , VAR_148 , sizeof ( struct STRUCT_OR_UNION_16 ) ) ; METHOD_32 ( & VAR_149 -> VAR_150 , & VAR_151 -> VAR_152 ) ; METHOD_33 ( & VAR_153 -> VAR_154 , & VAR_155 -> VAR_156 ) ; METHOD_34 ( & VAR_157 -> VAR_158 , & VAR_159 -> VAR_160 ) ; VAR_161 -> VAR_162 = VAR_163 -> VAR_164 ; <S2SV_StartBug> VAR_165 -> VAR_166 = VAR_167 ; <S2SV_EndBug> VAR_168 -> VAR_169 . VAR_170 = VAR_171 -> VAR_172 . VAR_173 ; VAR_174 -> VAR_175 = VAR_176 ; if ( VAR_177 -> VAR_178 != VAR_179 ) { VAR_180 -> VAR_181 = METHOD_35 ( VAR_182 -> VAR_183 , VAR_184 ) ; METHOD_36 ( VAR_185 -> VAR_186 ) ; VAR_187 -> VAR_188 = VAR_189 ; if ( VAR_190 -> VAR_191 ) METHOD_37 ( VAR_192 -> VAR_193 , VAR_194 ) ; } VAR_195 -> VAR_196 = VAR_197 ; VAR_198 -> VAR_199 = METHOD_38 ( VAR_200 ) ; VAR_201 -> VAR_202 = METHOD_39 ( VAR_203 ) -> VAR_204 ; if ( VAR_205 != VAR_206 ) { VAR_207 -> VAR_208 = METHOD_40 ( VAR_209 , VAR_210 ) ; if ( VAR_211 != VAR_212 -> VAR_213 ) METHOD_41 ( VAR_214 , VAR_215 , VAR_216 -> VAR_217 ) ; } METHOD_42 ( VAR_218 ) -> VAR_219 = 0 ; if ( VAR_220 -> VAR_221 != VAR_222 ) METHOD_43 ( VAR_223 ) -> VAR_224 = ( VAR_225 -> VAR_226 -> VAR_227 + VAR_228 -> VAR_229 -> VAR_230 ) ; METHOD_44 ( VAR_231 , METHOD_45 ( VAR_232 ) ) ; VAR_233 -> VAR_234 = VAR_235 -> VAR_236 = VAR_237 ; VAR_238 -> VAR_239 = VAR_240 ; if ( METHOD_46 ( VAR_241 , VAR_242 ) < 0 ) { METHOD_47 ( VAR_243 ) ; goto VAR_244 ; } METHOD_48 ( VAR_245 , VAR_246 ) ; return VAR_247 ; VAR_248 : METHOD_49 ( METHOD_50 ( VAR_249 ) , VAR_250 ) ; VAR_251 : METHOD_51 ( VAR_252 ) ; VAR_253 : METHOD_52 ( METHOD_53 ( VAR_254 ) , VAR_255 ) ; if ( VAR_256 != VAR_257 && VAR_258 != VAR_259 -> VAR_260 ) METHOD_54 ( VAR_261 , VAR_262 , VAR_263 -> VAR_264 ) ; return VAR_265 ; }",<S2SV_ModStart> ; VAR_238 -> VAR_266 <S2SV_ModEnd> = VAR_265 ;,"CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }",<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
513,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , <S2SV_EndBug> const TYPE_2 * VAR_1 ) { <S2SV_StartBug> const TYPE_3 VAR_2 = ( VAR_3 -> VAR_4 - <S2SV_EndBug> VAR_5 -> VAR_6 ) / VAR_7 -> VAR_8 ; <S2SV_StartBug> const TYPE_4 VAR_9 = VAR_10 <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? METHOD_1 ( METHOD_2 ( 1.0 - ( VAR_11 / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> : 0.85 ; return METHOD_3 ( VAR_12 , VAR_13 -> VAR_14 ) ; }","<S2SV_ModStart> METHOD_0 ( const TYPE_5 * VAR_15 <S2SV_ModEnd> , const TYPE_2 <S2SV_ModStart> { const TYPE_4 VAR_16 = METHOD_4 ( VAR_15 , VAR_13 ) <S2SV_ModEnd> ; const TYPE_4 <S2SV_ModStart> ; const TYPE_4 VAR_17 = ( 0.95 * METHOD_2 ( ( VAR_13 -> VAR_14 - VAR_13 -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( VAR_17 , ( VAR_16 + ( <S2SV_ModEnd> ( 1.0 - <S2SV_ModStart> ( 1.0 - VAR_16 ) * VAR_17 ) ) <S2SV_ModEnd> ) ; }","CWE-119 <S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> const FIRSTPASS_STATS * next_frame ) { <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> next_frame -> coded_error ) / cm -> MBs ; <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> : 0.85 ; return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ; }","<S2SV_ModStart> get_prediction_decay_rate ( const VP9_COMP * cpi <S2SV_ModEnd> , const FIRSTPASS_STATS <S2SV_ModStart> { const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) <S2SV_ModEnd> ; const double <S2SV_ModStart> ; const double zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( <S2SV_ModEnd> ( 1.0 - <S2SV_ModStart> ( 1.0 - sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> ) ; }"
514,"CWE-264 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 , unsigned TYPE_3 VAR_3 ) { TYPE_4 VAR_4 ; unsigned TYPE_5 TYPE_6 * VAR_5 = ( unsigned TYPE_7 TYPE_8 * ) VAR_6 ; switch ( VAR_7 ) { case VAR_8 : VAR_9 = METHOD_1 ( VAR_10 , VAR_11 , VAR_12 ) ; break ; case VAR_13 : VAR_14 = METHOD_2 ( VAR_15 , VAR_16 , VAR_17 ) ; break ; case VAR_18 : VAR_19 = METHOD_3 ( VAR_20 , & VAR_21 , VAR_22 , 0 , sizeof ( struct STRUCT_OR_UNION_1 ) , VAR_23 ) ; break ; case VAR_24 : VAR_25 = METHOD_4 ( VAR_26 , & VAR_27 , VAR_28 , 0 , sizeof ( struct STRUCT_OR_UNION_2 ) , VAR_29 ) ; break ; case VAR_30 : VAR_31 = METHOD_5 ( VAR_32 , & VAR_33 , VAR_34 , 0 , sizeof ( union STRUCT_OR_UNION_3 ) , VAR_35 ) ; break ; case VAR_36 : VAR_37 = METHOD_6 ( VAR_38 , & VAR_39 , VAR_40 , 0 , sizeof ( union STRUCT_OR_UNION_4 ) , VAR_41 ) ; break ; TYPE_9 TYPE_10 case VAR_42 : VAR_43 = METHOD_7 ( VAR_44 , VAR_45 ) ; break ; case VAR_46 : VAR_47 = METHOD_8 ( VAR_48 , VAR_49 ) ; break ; case VAR_50 : <S2SV_StartBug> VAR_51 = METHOD_9 ( METHOD_10 ( VAR_52 ) -> VAR_53 , <S2SV_EndBug> VAR_54 ) ; break ; case VAR_55 : METHOD_11 ( VAR_56 ) -> VAR_57 = VAR_58 ; VAR_59 = 0 ; break ; TYPE_11 TYPE_12 case VAR_60 : VAR_61 = METHOD_12 ( VAR_62 , VAR_63 ) ; break ; case VAR_64 : VAR_65 = METHOD_13 ( VAR_66 , VAR_67 ) ; break ; TYPE_13 TYPE_14 case VAR_68 : VAR_69 = METHOD_14 ( VAR_70 , & VAR_71 , VAR_72 , 0 , VAR_73 , VAR_74 ) ; break ; case VAR_75 : VAR_76 = METHOD_15 ( VAR_77 , & VAR_78 , VAR_79 , 0 , VAR_80 , VAR_81 ) ; break ; TYPE_15 TYPE_16 case VAR_82 : if ( METHOD_16 ( VAR_83 ) < 0 ) return - VAR_84 ; VAR_85 = METHOD_17 ( VAR_86 , VAR_87 , ( unsigned TYPE_17 TYPE_18 * ) VAR_88 ) ; METHOD_18 ( VAR_89 ) ; break ; case VAR_90 : if ( METHOD_19 ( VAR_91 ) < 0 ) return - VAR_92 ; VAR_93 = METHOD_20 ( VAR_94 , VAR_95 , ( unsigned TYPE_19 TYPE_20 * ) VAR_96 ) ; METHOD_21 ( VAR_97 ) ; break ; default : VAR_98 = METHOD_22 ( VAR_99 , VAR_100 , VAR_101 , VAR_102 ) ; break ; } return VAR_103 ; }",<S2SV_ModStart> ) -> VAR_53 [ 0 ],"CWE-264 long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ;  ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ;   case PTRACE_GET_THREAD_AREA : <S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ;  ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ;    ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ;    ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ;   default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }",<S2SV_ModStart> ) -> tp_value [ 0 ]
515,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , TYPE_2 VAR_2 , const TYPE_3 * VAR_3 , ... ) { TYPE_4 VAR_4 ; <S2SV_StartBug> struct STRUCT_OR_UNION_1 VAR_5 ; <S2SV_EndBug> TYPE_5 VAR_6 [ 32 ] ; METHOD_1 ( VAR_7 , 0 , sizeof ( VAR_8 ) ) ; METHOD_2 ( VAR_9 , VAR_10 , sizeof ( VAR_11 ) - 1 ) ; METHOD_3 ( VAR_12 , VAR_13 ) ; VAR_14 . VAR_15 = VAR_16 ; VAR_17 . VAR_18 = & VAR_19 ; if ( ! ( VAR_20 & VAR_21 ) ) goto VAR_22 ; if ( METHOD_4 ( VAR_23 ) && METHOD_5 ( VAR_24 -> VAR_25 ) ) METHOD_6 ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> METHOD_7 ( & VAR_26 -> VAR_27 -> VAR_28 ) , VAR_29 , VAR_30 , <S2SV_EndBug> VAR_31 -> VAR_32 , & VAR_33 ) ; else <S2SV_StartBug> METHOD_8 ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , VAR_34 , VAR_35 , & VAR_36 ) ; <S2SV_EndBug> VAR_37 : METHOD_9 ( VAR_38 ) ; }","<S2SV_ModStart> struct STRUCT_OR_UNION_1 VAR_36 <S2SV_ModEnd> ; METHOD_3 ( <S2SV_ModStart> VAR_28 ) , VAR_10 <S2SV_ModEnd> , VAR_35 , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , VAR_10 <S2SV_ModEnd> , VAR_35 ,","CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,"
516,"CWE-416 <S2SV_StartBug> static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , <S2SV_EndBug> TYPE_0 VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; METHOD_1 ( & VAR_3 -> VAR_4 ) ; <S2SV_StartBug> VAR_5 = METHOD_2 ( & VAR_6 -> VAR_7 , VAR_8 ) ; <S2SV_EndBug> if ( VAR_9 ) METHOD_3 ( VAR_10 ) ; METHOD_4 ( & VAR_11 -> VAR_12 ) ; <S2SV_StartBug> return VAR_13 ? VAR_14 : METHOD_5 ( - VAR_15 ) ; <S2SV_EndBug> }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct STRUCT_OR_UNION_2 * <S2SV_ModStart> ; VAR_14 = METHOD_6 ( VAR_11 , VAR_8 <S2SV_ModEnd> ) ; METHOD_4 <S2SV_ModStart> ; return VAR_14 <S2SV_ModEnd> ; } <S2SV_null>","CWE-416 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>"
517,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { <S2SV_EndBug> VAR_4 = * VAR_5 ; <S2SV_StartBug> METHOD_1 ( VAR_6 -> VAR_7 [ VAR_8 ] , VAR_9 , VAR_10 ) ; <S2SV_EndBug> * VAR_11 = VAR_12 ; }","<S2SV_ModStart> TYPE_4 * VAR_11 , TYPE_4 VAR_13 <S2SV_ModStart> VAR_9 , VAR_10 , VAR_13","CWE-119 <S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> * offset = bloc ; }","<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> NULL , fout , maxoffset"
518,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 ; <S2SV_StartBug> TYPE_2 VAR_4 , VAR_5 , VAR_6 ; <S2SV_EndBug> TYPE_3 VAR_7 ; struct STRUCT_OR_UNION_3 * VAR_8 = METHOD_1 ( VAR_9 ) ; struct STRUCT_OR_UNION_4 * VAR_10 ; TYPE_4 VAR_11 ; struct STRUCT_OR_UNION_5 * VAR_12 ; unsigned TYPE_5 VAR_13 ; TYPE_6 VAR_14 = 0 ; VAR_15 = METHOD_2 ( VAR_16 , VAR_17 , VAR_18 , & VAR_19 ) ; if ( ! VAR_20 ) return 1 ; METHOD_3 ( VAR_21 != VAR_22 ) ; VAR_23 = ( struct STRUCT_OR_UNION_6 * ) VAR_24 -> VAR_25 ; VAR_26 = METHOD_4 ( VAR_27 -> VAR_28 ) ; if ( sizeof ( * VAR_29 ) + VAR_30 > VAR_31 -> VAR_32 ) { METHOD_5 ( VAR_33 , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , VAR_34 , VAR_35 -> VAR_36 - sizeof ( * VAR_37 ) ) ; goto VAR_38 ; } VAR_39 = METHOD_6 ( VAR_40 , METHOD_7 ( VAR_41 -> VAR_42 ) ) ; if ( VAR_43 ) goto VAR_44 ; for ( VAR_45 = 0 , VAR_46 = 0 ; VAR_47 < VAR_48 -> VAR_49 && VAR_50 < VAR_51 ; VAR_52 ++ , VAR_53 += VAR_54 -> VAR_55 ) { struct STRUCT_OR_UNION_7 * VAR_56 = & VAR_57 -> VAR_58 [ VAR_59 ] ; VAR_60 = ( struct STRUCT_OR_UNION_8 * ) & ( VAR_61 -> VAR_62 [ VAR_63 ] ) ; VAR_64 = VAR_65 -> VAR_66 ; if ( VAR_67 == 1 ) { struct STRUCT_OR_UNION_9 * VAR_68 = ( struct STRUCT_OR_UNION_10 * ) VAR_69 ; VAR_70 -> VAR_71 = VAR_72 ; VAR_73 -> VAR_74 = METHOD_8 ( VAR_75 -> VAR_76 ) ; VAR_77 -> VAR_78 = METHOD_9 ( VAR_79 -> VAR_80 ) ; VAR_81 -> VAR_82 = VAR_83 ; } else if ( VAR_84 == 2 ) { struct STRUCT_OR_UNION_11 * VAR_85 = ( struct STRUCT_OR_UNION_12 * ) VAR_86 ; if ( ! METHOD_10 ( VAR_87 -> VAR_88 . VAR_89 , VAR_90 , METHOD_11 ( VAR_91 ) ) ) { TYPE_7 VAR_92 = METHOD_12 ( ( ( TYPE_8 * ) VAR_93 -> VAR_94 . VAR_95 ) [ 0 ] ) ; if ( VAR_96 < 0x0200 ) { VAR_97 -> VAR_98 = VAR_99 ; VAR_100 -> VAR_101 = VAR_102 ; } else { VAR_103 -> VAR_104 = VAR_105 ; VAR_106 -> VAR_107 = VAR_108 ; } } else if ( ! METHOD_13 ( VAR_109 -> VAR_110 . VAR_111 , VAR_112 , METHOD_14 ( VAR_113 ) ) ) { <S2SV_StartBug> TYPE_9 VAR_114 ; <S2SV_EndBug> struct STRUCT_OR_UNION_13 * VAR_115 ; <S2SV_StartBug> struct STRUCT_OR_UNION_14 * VAR_116 = <S2SV_EndBug> ( struct STRUCT_OR_UNION_15 * ) VAR_117 ; VAR_118 -> VAR_119 = VAR_120 ; VAR_121 -> VAR_122 . VAR_123 . VAR_124 = METHOD_15 ( VAR_125 -> VAR_126 ) ; for ( VAR_127 = 0 ; VAR_128 < VAR_129 -> VAR_130 ; VAR_131 ++ ) { struct STRUCT_OR_UNION_16 * VAR_132 ; VAR_133 = METHOD_16 ( VAR_134 -> VAR_135 [ VAR_136 ] ) ; VAR_137 = METHOD_17 ( VAR_138 , VAR_139 , VAR_140 , & VAR_141 ) ; VAR_142 -> VAR_143 . VAR_144 . VAR_145 [ VAR_146 ] = VAR_147 ; if ( VAR_148 == VAR_149 ) continue ; VAR_150 = ( struct STRUCT_OR_UNION_17 * ) VAR_151 -> VAR_152 ; if ( VAR_153 != 0 || METHOD_18 ( VAR_154 -> VAR_155 . VAR_156 , VAR_157 , METHOD_19 ( VAR_158 ) ) ) { METHOD_20 ( VAR_159 ) ; VAR_160 -> VAR_161 . VAR_162 . VAR_163 [ VAR_164 ] = VAR_165 ; } } VAR_166 -> VAR_167 = VAR_168 ; } else if ( ! METHOD_21 ( VAR_169 -> VAR_170 . VAR_171 , VAR_172 , METHOD_22 ( VAR_173 ) ) ) { struct STRUCT_OR_UNION_18 * VAR_174 = & VAR_175 -> VAR_176 . VAR_177 ; struct STRUCT_OR_UNION_19 * VAR_178 = ( struct STRUCT_OR_UNION_20 * ) & ( VAR_179 -> VAR_180 [ VAR_181 ] ) ; METHOD_23 ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , VAR_182 , VAR_183 , VAR_184 ) ; VAR_185 -> VAR_186 = VAR_187 ; VAR_188 -> VAR_189 = VAR_190 ; VAR_191 -> VAR_192 = METHOD_24 ( VAR_193 -> VAR_194 ) ; VAR_195 -> VAR_196 = METHOD_25 ( VAR_197 -> VAR_198 ) ; VAR_199 -> VAR_200 = METHOD_26 ( VAR_201 -> VAR_202 ) ; VAR_203 -> VAR_204 = METHOD_27 ( VAR_205 -> VAR_206 ) ; VAR_207 -> VAR_208 = METHOD_28 ( VAR_209 -> VAR_210 ) ; if ( VAR_211 -> VAR_212 & 0x01 ) VAR_213 -> VAR_214 |= VAR_215 ; METHOD_29 ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , METHOD_30 ( * ( TYPE_10 * ) VAR_216 -> VAR_217 . VAR_218 ) ) ; METHOD_31 ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , METHOD_32 ( VAR_219 -> VAR_220 ) ) ; METHOD_33 ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , METHOD_34 ( VAR_221 -> VAR_222 ) ) ; METHOD_35 ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , METHOD_36 ( VAR_223 -> VAR_224 ) ) ; METHOD_37 ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , METHOD_38 ( VAR_225 -> VAR_226 ) ) ; METHOD_39 ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , METHOD_40 ( VAR_227 -> VAR_228 ) ) ; METHOD_41 ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , VAR_229 -> VAR_230 , VAR_231 -> VAR_232 ) ; } else { METHOD_42 ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , VAR_233 -> VAR_234 . VAR_235 ) ; continue ; } VAR_236 -> VAR_237 = METHOD_43 ( VAR_238 -> VAR_239 ) ; VAR_240 -> VAR_241 = METHOD_44 ( VAR_242 -> VAR_243 ) ; } METHOD_45 ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , VAR_244 , VAR_245 -> VAR_246 , VAR_247 , VAR_248 -> VAR_249 ) ; } if ( VAR_250 ) { struct STRUCT_OR_UNION_21 * VAR_251 = ( struct STRUCT_OR_UNION_22 * ) & ( VAR_252 -> VAR_253 [ 0 ] ) ; * VAR_254 = METHOD_46 ( VAR_255 -> VAR_256 ) ; METHOD_47 ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , VAR_257 -> VAR_258 , VAR_259 -> VAR_260 ) ; } if ( VAR_261 -> VAR_262 . VAR_263 ) METHOD_48 ( VAR_264 , METHOD_49 ( VAR_265 -> VAR_266 ) ) ; VAR_267 : METHOD_50 ( VAR_268 ) ; return VAR_269 ; }","<S2SV_ModStart> ; TYPE_6 VAR_244 <S2SV_ModEnd> , VAR_181 ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( VAR_264 , VAR_248 , ( <S2SV_ModEnd> struct STRUCT_OR_UNION_15 * <S2SV_ModStart> struct STRUCT_OR_UNION_15 * ) VAR_117 ) < 0 ) goto VAR_267 <S2SV_ModEnd> ; } else","CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }","<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else"
519,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , unsigned TYPE_2 * VAR_1 , unsigned TYPE_3 * VAR_2 ) { <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> VAR_2 ) { ( TYPE_0 ) VAR_0 ; ( TYPE_0 ) VAR_1 ; ( TYPE_0 ) VAR_2 ;,"CWE-119 static void y4m_convert_null ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> _aux ) { ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ;
520,"CWE-19 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { struct STRUCT_OR_UNION_2 * VAR_0 = VAR_1 ; <S2SV_StartBug> struct STRUCT_OR_UNION_3 * VAR_2 ; <S2SV_EndBug> METHOD_1 ( & METHOD_2 ( STRUCT_OR_UNION_4 ) -> VAR_3 ) ; if ( ! METHOD_3 ( STRUCT_OR_UNION_5 ) -> VAR_4 ) goto VAR_5 ; VAR_6 = METHOD_4 ( STRUCT_OR_UNION_6 -> VAR_7 , METHOD_5 ( STRUCT_OR_UNION_7 ) -> VAR_8 ) ; if ( ! VAR_9 ) { METHOD_6 ( STRUCT_OR_UNION_8 -> VAR_10 , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>read<S2SV_blank>error"" , STRUCT_OR_UNION_9 -> VAR_11 , METHOD_7 ( STRUCT_OR_UNION_10 ) -> VAR_12 ) ; goto VAR_13 ; } METHOD_8 ( VAR_14 , ""b_count=%d"" , METHOD_9 ( & ( VAR_15 -> VAR_16 ) ) ) ; if ( METHOD_10 ( VAR_17 ) -> VAR_18 != METHOD_11 ( VAR_19 ) || METHOD_12 ( VAR_20 ) -> VAR_21 != METHOD_13 ( 1 ) ) { METHOD_14 ( STRUCT_OR_UNION_11 -> VAR_22 , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , STRUCT_OR_UNION_12 -> VAR_23 , METHOD_15 ( STRUCT_OR_UNION_13 ) -> VAR_24 ) ; goto VAR_25 ; } <S2SV_StartBug> VAR_26 = METHOD_16 ( VAR_27 , VAR_28 -> VAR_29 , VAR_30 -> VAR_31 ) ; <S2SV_EndBug> METHOD_17 ( VAR_32 ) ; if ( METHOD_18 ( VAR_33 ) -> VAR_34 == METHOD_19 ( 1 ) ) { <S2SV_StartBug> if ( VAR_35 ) <S2SV_EndBug> METHOD_20 ( VAR_36 ) ; METHOD_21 ( STRUCT_OR_UNION_14 , METHOD_22 ( STRUCT_OR_UNION_15 ) -> VAR_37 , 1 ) ; METHOD_23 ( VAR_38 ) ; METHOD_24 ( VAR_39 ) ; METHOD_25 ( VAR_40 ) ; } else { <S2SV_StartBug> METHOD_26 ( & METHOD_27 ( VAR_41 ) -> VAR_42 , - 1 ) ; <S2SV_EndBug> if ( VAR_43 ) METHOD_28 ( VAR_44 ) ; METHOD_29 ( VAR_45 , ""refcount<S2SV_blank>now=%d"" , METHOD_30 ( METHOD_31 ( VAR_46 ) -> VAR_47 ) ) ; METHOD_32 ( VAR_48 ) ; METHOD_33 ( VAR_49 ) ; if ( METHOD_34 ( STRUCT_OR_UNION_16 ) ) METHOD_35 ( VAR_50 ) ; METHOD_36 ( STRUCT_OR_UNION_17 , 1 ) ; } METHOD_37 ( STRUCT_OR_UNION_18 ) -> VAR_51 = 0 ; VAR_52 : METHOD_38 ( VAR_53 ) ; METHOD_39 ( & METHOD_40 ( STRUCT_OR_UNION_19 ) -> VAR_54 ) ; }","<S2SV_ModStart> = VAR_1 ; <S2SV_ModEnd> METHOD_1 ( & <S2SV_ModStart> VAR_52 ; } <S2SV_ModEnd> METHOD_17 ( VAR_53 <S2SV_ModStart> ) ) { __u32 hash = METHOD_30 ( METHOD_31 ( VAR_53 ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( STRUCT_OR_UNION_19 -> VAR_22 ) -> s_mb_cache , hash , VAR_53 -> VAR_31 <S2SV_ModEnd> ) ; METHOD_21 <S2SV_ModStart> , - 1 <S2SV_ModEnd> ) ; METHOD_29","CWE-19 void ext2_xattr_delete_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> down_write ( & EXT2_I ( inode ) -> xattr_sem ) ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } ea_bdebug ( bh , ""b_count=%d"" , atomic_read ( & ( bh -> b_count ) ) ) ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> lock_buffer ( bh ) ; if ( HDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ext2_free_blocks ( inode , EXT2_I ( inode ) -> i_file_acl , 1 ) ; get_bh ( bh ) ; bforget ( bh ) ; unlock_buffer ( bh ) ; } else { <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> if ( ce ) mb_cache_entry_release ( ce ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; unlock_buffer ( bh ) ; mark_buffer_dirty ( bh ) ; if ( IS_SYNC ( inode ) ) sync_dirty_buffer ( bh ) ; dquot_free_block_nodirty ( inode , 1 ) ; } EXT2_I ( inode ) -> i_file_acl = 0 ; cleanup : brelse ( bh ) ; up_write ( & EXT2_I ( inode ) -> xattr_sem ) ; }","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> down_write ( & <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; ext2_free_blocks <S2SV_ModStart> , - 1 <S2SV_ModEnd> ) ; ea_bdebug"
521,"CWE-369 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = VAR_2 ; TYPE_3 * VAR_3 = VAR_4 ; TYPE_4 VAR_5 = 0 ; if ( ! VAR_6 -> VAR_7 ) { VAR_8 = & VAR_9 -> VAR_10 [ VAR_11 -> VAR_12 ] ; goto VAR_13 ; } else { TYPE_5 VAR_14 , VAR_15 ; VAR_16 -> VAR_17 = 0 ; VAR_18 -> VAR_19 = 0 ; VAR_20 -> VAR_21 = 0 ; for ( VAR_22 = 0 ; VAR_23 < VAR_24 -> VAR_25 ; VAR_26 ++ ) { VAR_27 = & VAR_28 -> VAR_29 [ VAR_30 ] ; for ( VAR_31 = 0 ; VAR_32 < VAR_33 -> VAR_34 ; VAR_35 ++ ) { TYPE_6 VAR_36 , VAR_37 ; VAR_38 = & VAR_39 -> VAR_40 [ VAR_41 ] ; VAR_42 = VAR_43 -> VAR_44 * ( 1u << ( VAR_45 -> VAR_46 + VAR_47 -> VAR_48 - 1 - VAR_49 ) ) ; VAR_50 = VAR_51 -> VAR_52 * ( 1u << ( VAR_53 -> VAR_54 + VAR_55 -> VAR_56 - 1 - VAR_57 ) ) ; VAR_58 -> VAR_59 = ! VAR_60 -> VAR_61 ? VAR_62 : METHOD_1 ( VAR_63 -> VAR_64 , VAR_65 ) ; VAR_66 -> VAR_67 = ! VAR_68 -> VAR_69 ? VAR_70 : METHOD_2 ( VAR_71 -> VAR_72 , VAR_73 ) ; } } } if ( ! VAR_74 -> VAR_75 ) { VAR_76 -> VAR_77 . VAR_78 = VAR_79 -> VAR_80 ; VAR_81 -> VAR_82 . VAR_83 = VAR_84 -> VAR_85 ; VAR_86 -> VAR_87 . VAR_88 = VAR_89 -> VAR_90 ; VAR_91 -> VAR_92 . VAR_93 = VAR_94 -> VAR_95 ; } for ( VAR_96 -> VAR_97 = VAR_98 -> VAR_99 . VAR_100 ; VAR_101 -> VAR_102 < VAR_103 -> VAR_104 . VAR_105 ; VAR_106 -> VAR_107 += ( TYPE_7 ) ( VAR_108 -> VAR_109 - ( TYPE_8 ) ( VAR_110 -> VAR_111 % ( TYPE_9 ) VAR_112 -> VAR_113 ) ) ) { for ( VAR_114 -> VAR_115 = VAR_116 -> VAR_117 . VAR_118 ; VAR_119 -> VAR_120 < VAR_121 -> VAR_122 . VAR_123 ; VAR_124 -> VAR_125 += ( TYPE_10 ) ( VAR_126 -> VAR_127 - ( TYPE_11 ) ( VAR_128 -> VAR_129 % ( TYPE_12 ) VAR_130 -> VAR_131 ) ) ) { for ( VAR_132 -> VAR_133 = VAR_134 -> VAR_135 . VAR_136 ; VAR_137 -> VAR_138 < VAR_139 -> VAR_140 . VAR_141 ; VAR_142 -> VAR_143 ++ ) { VAR_144 = & VAR_145 -> VAR_146 [ VAR_147 -> VAR_148 ] ; for ( VAR_149 -> VAR_150 = VAR_151 -> VAR_152 . VAR_153 ; VAR_154 -> VAR_155 < METHOD_3 ( VAR_156 -> VAR_157 . VAR_158 , VAR_159 -> VAR_160 ) ; VAR_161 -> VAR_162 ++ ) { TYPE_13 VAR_163 ; TYPE_14 VAR_164 , VAR_165 ; TYPE_15 VAR_166 , VAR_167 ; TYPE_16 VAR_168 , VAR_169 ; TYPE_17 VAR_170 , VAR_171 ; VAR_172 = & VAR_173 -> VAR_174 [ VAR_175 -> VAR_176 ] ; VAR_177 = VAR_178 -> VAR_179 - 1 - VAR_180 -> VAR_181 ; VAR_182 = METHOD_4 ( VAR_183 -> VAR_184 , ( TYPE_18 ) ( VAR_185 -> VAR_186 << VAR_187 ) ) ; VAR_188 = METHOD_5 ( VAR_189 -> VAR_190 , ( TYPE_19 ) ( VAR_191 -> VAR_192 << VAR_193 ) ) ; VAR_194 = METHOD_6 ( VAR_195 -> VAR_196 , ( TYPE_20 ) ( VAR_197 -> VAR_198 << VAR_199 ) ) ; VAR_200 = METHOD_7 ( VAR_201 -> VAR_202 , ( TYPE_21 ) ( VAR_203 -> VAR_204 << VAR_205 ) ) ; VAR_206 = VAR_207 -> VAR_208 + VAR_209 ; VAR_210 = VAR_211 -> VAR_212 + VAR_213 ; <S2SV_StartBug> if ( ! ( ( VAR_214 -> VAR_215 % ( TYPE_22 ) ( VAR_216 -> VAR_217 << VAR_218 ) == 0 ) || ( ( VAR_219 -> VAR_220 == VAR_221 -> VAR_222 ) && <S2SV_EndBug> ( ( VAR_223 << VAR_224 ) % ( 1 << VAR_225 ) ) ) ) ) { continue ; } if ( ! ( ( VAR_226 -> VAR_227 % ( TYPE_23 ) ( VAR_228 -> VAR_229 << VAR_230 ) == 0 ) || ( ( VAR_231 -> VAR_232 == VAR_233 -> VAR_234 ) && ( ( VAR_235 << VAR_236 ) % ( 1 << VAR_237 ) ) ) ) ) { continue ; } if ( ( VAR_238 -> VAR_239 == 0 ) || ( VAR_240 -> VAR_241 == 0 ) ) { continue ; } if ( ( VAR_242 == VAR_243 ) || ( VAR_244 == VAR_245 ) ) { continue ; } VAR_246 = METHOD_8 ( METHOD_9 ( VAR_247 -> VAR_248 , ( TYPE_24 ) ( VAR_249 -> VAR_250 << VAR_251 ) ) , ( TYPE_25 ) VAR_252 -> VAR_253 ) - METHOD_10 ( VAR_254 , ( TYPE_26 ) VAR_255 -> VAR_256 ) ; VAR_257 = METHOD_11 ( METHOD_12 ( VAR_258 -> VAR_259 , ( TYPE_27 ) ( VAR_260 -> VAR_261 << VAR_262 ) ) , ( TYPE_28 ) VAR_263 -> VAR_264 ) - METHOD_13 ( VAR_265 , ( TYPE_29 ) VAR_266 -> VAR_267 ) ; VAR_268 -> VAR_269 = ( TYPE_30 ) ( VAR_270 + VAR_271 * ( TYPE_31 ) VAR_272 -> VAR_273 ) ; for ( VAR_274 -> VAR_275 = VAR_276 -> VAR_277 . VAR_278 ; VAR_279 -> VAR_280 < VAR_281 -> VAR_282 . VAR_283 ; VAR_284 -> VAR_285 ++ ) { VAR_286 = VAR_287 -> VAR_288 * VAR_289 -> VAR_290 + VAR_291 -> VAR_292 * VAR_293 -> VAR_294 + VAR_295 -> VAR_296 * VAR_297 -> VAR_298 + VAR_299 -> VAR_300 * VAR_301 -> VAR_302 ; if ( ! VAR_303 -> VAR_304 [ VAR_305 ] ) { VAR_306 -> VAR_307 [ VAR_308 ] = 1 ; return VAR_309 ; } VAR_310 : ; } } } } } return VAR_311 ; }",<S2SV_ModStart> ; if ( VAR_237 >= 31 || ( ( VAR_260 -> VAR_250 << VAR_237 ) >> VAR_237 ) != VAR_260 -> VAR_250 || VAR_225 >= 31 || ( ( VAR_260 -> VAR_261 << VAR_225 ) >> VAR_225 ) != VAR_260 -> VAR_261 ) { continue ; } if (,"CWE-369 static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { comp = & pi -> comps [ pi -> compno ] ; for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }",<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
522,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> VAR_3 = VAR_4 ; for ( VAR_5 = VAR_6 ; VAR_7 > 0 ; -- VAR_8 ) { if ( METHOD_1 ( VAR_9 ) == VAR_10 ) { return VAR_11 - VAR_12 ; } } return VAR_13 ; }","<S2SV_ModStart> TYPE_3 VAR_12 ; if ( VAR_13 < 0 ) { METHOD_2 ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; }","CWE-190 int jas_stream_gobble ( jas_stream_t * stream , int n ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }","<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; }"
523,"CWE-772 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; VAR_2 * VAR_3 ; VAR_4 * VAR_5 ; struct STRUCT_OR_UNION_1 * VAR_6 = METHOD_1 ( VAR_7 -> VAR_8 . VAR_9 ) ; struct STRUCT_OR_UNION_2 * VAR_10 = METHOD_2 ( VAR_11 ) ; VAR_12 = METHOD_3 ( VAR_13 ) ; if ( ! VAR_14 ) return - VAR_15 ; VAR_16 = METHOD_4 ( VAR_17 ) ; if ( ! VAR_18 ) { METHOD_5 ( VAR_19 ) ; return - VAR_20 ; } VAR_21 [ 1 ] = VAR_22 ; VAR_23 [ 9 ] = VAR_24 -> VAR_25 ; VAR_26 = METHOD_6 ( VAR_27 , VAR_28 , VAR_29 , VAR_30 , VAR_31 ) ; if ( ! VAR_32 ) goto VAR_33 ; VAR_34 -> VAR_35 = METHOD_7 ( & VAR_36 [ 12 ] ) ; VAR_37 -> VAR_38 = METHOD_8 ( & VAR_39 [ 16 ] ) ; VAR_40 -> VAR_41 = METHOD_9 ( & VAR_42 [ 20 ] ) ; VAR_43 -> VAR_44 = METHOD_10 ( & VAR_45 [ 24 ] ) ; VAR_46 : <S2SV_StartBug> METHOD_11 ( VAR_47 ) ; <S2SV_EndBug> return VAR_48 ; }",<S2SV_ModStart> : METHOD_11 ( VAR_28 ) ; METHOD_11 (,"CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }",<S2SV_ModStart> : kfree ( req ) ; kfree (
524,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 ) { TYPE_2 VAR_1 ; struct STRUCT_OR_UNION_0 VAR_2 ; TYPE_3 VAR_3 ; <S2SV_StartBug> TYPE_4 VAR_4 [ VAR_5 ] ; <S2SV_EndBug> METHOD_1 ( VAR_6 , 0 , sizeof ( VAR_7 ) ) ; <S2SV_StartBug> VAR_8 = METHOD_2 ( VAR_9 , VAR_10 , sizeof ( VAR_11 ) , VAR_12 , & VAR_13 , & VAR_14 ) ; <S2SV_EndBug> if ( VAR_15 > 0 ) { <S2SV_StartBug> VAR_16 [ VAR_17 ] = 0 ; <S2SV_EndBug> if ( VAR_18 . VAR_19 != VAR_20 ) return ; if ( METHOD_3 ( VAR_21 , ""M-SEARCH<S2SV_blank>*"" ) ) { TYPE_5 VAR_22 ; TYPE_6 * VAR_23 , * VAR_24 ; struct STRUCT_OR_UNION_1 * VAR_25 ; struct STRUCT_OR_UNION_2 * VAR_26 = ( struct STRUCT_OR_UNION_3 * ) & VAR_27 ; VAR_28 = METHOD_4 ( & VAR_29 ) ; if ( ! VAR_30 ) { METHOD_5 ( VAR_31 , ""No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , METHOD_6 ( VAR_32 -> VAR_33 ) ) ; return ; } METHOD_7 ( VAR_34 , ""Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , METHOD_8 ( VAR_35 -> VAR_36 ) ) ; VAR_37 = METHOD_9 ( VAR_38 , ""\\r\\nST:"" ) ; if ( ! VAR_39 ) { METHOD_10 ( VAR_40 , ""No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>"" VAR_41 ) ; VAR_42 = VAR_43 ; METHOD_11 ( VAR_44 , VAR_45 , & VAR_46 ) ; return ; } VAR_47 = METHOD_12 ( VAR_48 , ':' ) ; if ( ! VAR_49 ) return ; VAR_50 ++ ; while ( METHOD_13 ( * VAR_51 ) ) VAR_52 ++ ; VAR_53 = METHOD_14 ( VAR_54 , ""\\r\\n"" ) ; if ( ! VAR_55 ) return ; * VAR_56 = 0 ; for ( VAR_57 = 0 ; VAR_58 [ VAR_59 ] ; VAR_60 ++ ) { if ( ! METHOD_15 ( VAR_61 [ VAR_62 ] , VAR_63 ) ) { METHOD_16 ( VAR_64 , ""M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , VAR_65 , METHOD_17 ( VAR_66 -> VAR_67 ) , METHOD_18 ( VAR_68 -> VAR_69 ) ) ; METHOD_19 ( VAR_70 , VAR_71 , & VAR_72 ) ; return ; } } METHOD_20 ( VAR_73 , ""M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , VAR_74 , METHOD_21 ( VAR_75 -> VAR_76 ) ) ; } } }",<S2SV_ModStart> VAR_38 [ VAR_5 + 1 <S2SV_ModStart> ( VAR_38 ) - 1 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( VAR_72,"CWE-119 static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , ""M-SEARCH<S2SV_blank>*"" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , ""No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , ""Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , ""\\r\\nST:"" ) ; if ( ! type ) { logit ( LOG_DEBUG , ""No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>"" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , ""\\r\\n"" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , ""M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , ""M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }",<S2SV_ModStart> buf [ MAX_PKT_SIZE + 1 <S2SV_ModStart> ( buf ) - 1 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( sa
525,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * TYPE_2 ) { TYPE_3 * VAR_0 , * VAR_1 , * VAR_2 , * VAR_3 , * VAR_4 , * VAR_5 , * VAR_6 , * VAR_7 , * VAR_8 ; const TYPE_4 * VAR_9 , * VAR_10 , * VAR_11 , * VAR_12 ; <S2SV_StartBug> unsigned TYPE_5 VAR_13 , VAR_14 , VAR_15 ; <S2SV_EndBug> TYPE_6 VAR_16 , VAR_17 ; unsigned TYPE_7 VAR_18 , VAR_19 ; VAR_20 = ( TYPE_8 ) TYPE_9 -> TYPE_10 [ 0 ] . VAR_21 ; VAR_22 = 1 << ( VAR_23 - 1 ) ; VAR_24 = ( 1 << VAR_25 ) - 1 ; <S2SV_StartBug> VAR_26 = ( unsigned TYPE_11 ) TYPE_12 -> TYPE_13 [ 0 ] . TYPE_14 ; VAR_27 = ( unsigned TYPE_15 ) TYPE_16 -> TYPE_17 [ 0 ] . TYPE_18 ; <S2SV_EndBug> VAR_28 = VAR_29 * VAR_30 ; VAR_31 = TYPE_19 -> TYPE_20 [ 0 ] . VAR_32 ; VAR_33 = TYPE_21 -> TYPE_22 [ 1 ] . VAR_34 ; VAR_35 = TYPE_23 -> TYPE_24 [ 2 ] . VAR_36 ; <S2SV_StartBug> VAR_37 = VAR_38 = ( TYPE_25 * ) METHOD_1 ( sizeof ( TYPE_26 ) * ( TYPE_27 ) VAR_39 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_40 = VAR_41 = ( TYPE_28 * ) METHOD_2 ( sizeof ( TYPE_29 ) * ( TYPE_30 ) VAR_42 ) ; <S2SV_EndBug> VAR_43 = VAR_44 = ( TYPE_31 * ) METHOD_3 ( sizeof ( TYPE_32 ) * ( TYPE_33 ) VAR_45 ) ; if ( VAR_46 == VAR_47 || VAR_48 == VAR_49 || VAR_50 == VAR_51 ) goto VAR_52 ; <S2SV_StartBug> for ( VAR_53 = 0U ; VAR_54 < ( VAR_55 & ~ ( unsigned TYPE_34 ) 1U ) ; VAR_56 += 2U ) <S2SV_EndBug> { <S2SV_StartBug> VAR_57 = VAR_58 + VAR_59 ; <S2SV_EndBug> VAR_60 = VAR_61 + VAR_62 ; VAR_63 = VAR_64 + VAR_65 ; VAR_66 = VAR_67 + VAR_68 ; <S2SV_StartBug> for ( VAR_69 = 0 ; VAR_70 < ( VAR_71 & ~ ( unsigned TYPE_35 ) 1U ) ; VAR_72 += 2U ) <S2SV_EndBug> { METHOD_4 ( VAR_73 , VAR_74 , * VAR_75 , * VAR_76 , * VAR_77 , VAR_78 , VAR_79 , VAR_80 ) ; ++ VAR_81 ; ++ VAR_82 ; ++ VAR_83 ; ++ VAR_84 ; METHOD_5 ( VAR_85 , VAR_86 , * VAR_87 , * VAR_88 , * VAR_89 , VAR_90 , VAR_91 , VAR_92 ) ; ++ VAR_93 ; ++ VAR_94 ; ++ VAR_95 ; ++ VAR_96 ; METHOD_6 ( VAR_97 , VAR_98 , * VAR_99 , * VAR_100 , * VAR_101 , VAR_102 , VAR_103 , VAR_104 ) ; ++ VAR_105 ; ++ VAR_106 ; ++ VAR_107 ; ++ VAR_108 ; METHOD_7 ( VAR_109 , VAR_110 , * VAR_111 , * VAR_112 , * VAR_113 , VAR_114 , VAR_115 , VAR_116 ) ; ++ VAR_117 ; ++ VAR_118 ; ++ VAR_119 ; ++ VAR_120 ; ++ VAR_121 ; ++ VAR_122 ; } <S2SV_StartBug> if ( VAR_123 < VAR_124 ) <S2SV_EndBug> { METHOD_8 ( VAR_125 , VAR_126 , * VAR_127 , * VAR_128 , * VAR_129 , VAR_130 , VAR_131 , VAR_132 ) ; ++ VAR_133 ; ++ VAR_134 ; ++ VAR_135 ; ++ VAR_136 ; METHOD_9 ( VAR_137 , VAR_138 , * VAR_139 , * VAR_140 , * VAR_141 , VAR_142 , VAR_143 , VAR_144 ) ; ++ VAR_145 ; ++ VAR_146 ; ++ VAR_147 ; ++ VAR_148 ; ++ VAR_149 ; ++ VAR_150 ; } VAR_151 += VAR_152 ; VAR_153 += VAR_154 ; VAR_155 += VAR_156 ; VAR_157 += VAR_158 ; } <S2SV_StartBug> if ( VAR_159 < VAR_160 ) <S2SV_EndBug> { <S2SV_StartBug> for ( VAR_161 = 0U ; VAR_162 < ( VAR_163 & ~ ( unsigned TYPE_36 ) 1U ) ; VAR_164 += 2U ) <S2SV_EndBug> { METHOD_10 ( VAR_165 , VAR_166 , * VAR_167 , * VAR_168 , * VAR_169 , VAR_170 , VAR_171 , VAR_172 ) ; ++ VAR_173 ; ++ VAR_174 ; ++ VAR_175 ; ++ VAR_176 ; METHOD_11 ( VAR_177 , VAR_178 , * VAR_179 , * VAR_180 , * VAR_181 , VAR_182 , VAR_183 , VAR_184 ) ; ++ VAR_185 ; ++ VAR_186 ; ++ VAR_187 ; ++ VAR_188 ; ++ VAR_189 ; ++ VAR_190 ; } if ( VAR_191 < VAR_192 ) { METHOD_12 ( VAR_193 , VAR_194 , * VAR_195 , * VAR_196 , * VAR_197 , VAR_198 , VAR_199 , VAR_200 ) ; } } METHOD_13 ( TYPE_37 -> TYPE_38 [ 0 ] . VAR_201 ) ; TYPE_39 -> TYPE_40 [ 0 ] . VAR_202 = VAR_203 ; METHOD_14 ( TYPE_41 -> TYPE_42 [ 1 ] . VAR_204 ) ; TYPE_43 -> TYPE_44 [ 1 ] . VAR_205 = VAR_206 ; METHOD_15 ( TYPE_45 -> TYPE_46 [ 2 ] . VAR_207 ) ; TYPE_47 -> TYPE_48 [ 2 ] . VAR_208 = VAR_209 ; <S2SV_StartBug> if METHOD_16 ( VAR_210 ) || METHOD_17 ( VAR_211 ) <S2SV_EndBug> <S2SV_StartBug> TYPE_49 -> TYPE_50 [ 1 ] . TYPE_51 = VAR_212 ; TYPE_52 -> TYPE_53 [ 1 ] . TYPE_54 = VAR_213 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_55 -> TYPE_56 [ 2 ] . TYPE_57 = VAR_214 ; TYPE_58 -> TYPE_59 [ 2 ] . TYPE_60 = VAR_215 ; <S2SV_EndBug> else <S2SV_StartBug> TYPE_61 -> TYPE_62 [ 1 ] . TYPE_63 = ( TYPE_64 ) VAR_216 ; TYPE_65 -> TYPE_66 [ 1 ] . TYPE_67 = ( TYPE_68 ) VAR_217 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_69 -> TYPE_70 [ 2 ] . TYPE_71 = ( TYPE_72 ) VAR_218 ; TYPE_73 -> TYPE_74 [ 2 ] . TYPE_75 = ( TYPE_76 ) VAR_219 ; <S2SV_EndBug> TYPE_77 -> TYPE_78 [ 1 ] . TYPE_79 = TYPE_80 -> TYPE_81 [ 0 ] . TYPE_82 ; TYPE_83 -> TYPE_84 [ 2 ] . TYPE_85 = TYPE_86 -> TYPE_87 [ 0 ] . TYPE_88 ; TYPE_89 -> TYPE_90 [ 1 ] . TYPE_91 = TYPE_92 -> TYPE_93 [ 0 ] . TYPE_94 ; <S2SV_StartBug> TYPE_95 -> TYPE_96 [ 2 ] . TYPE_97 = TYPE_98 -> TYPE_99 [ 0 ] . TYPE_100 ; <S2SV_EndBug> return ; VAR_220 : <S2SV_StartBug> if ( VAR_221 ) METHOD_18 ( VAR_222 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_223 ) METHOD_19 ( VAR_224 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_225 ) METHOD_20 ( VAR_226 ) ; <S2SV_EndBug> }","<S2SV_ModStart> * VAR_145 ; TYPE_33 VAR_218 , VAR_219 , VAR_45 , VAR_227 , VAR_228 , VAR_229 , VAR_230 ; TYPE_36 VAR_193 , VAR_194 ; TYPE_33 VAR_159 <S2SV_ModEnd> ; VAR_194 = <S2SV_ModStart> VAR_218 = ( TYPE_33 ) TYPE_98 -> TYPE_99 [ 0 ] . TYPE_71 ; VAR_219 = ( TYPE_33 ) TYPE_98 -> TYPE_99 [ 0 ] . TYPE_75 ; VAR_45 = VAR_218 * VAR_219 ; VAR_195 = TYPE_98 -> TYPE_99 [ 0 ] . VAR_208 ; VAR_196 = TYPE_98 -> TYPE_99 [ 1 ] . VAR_208 ; VAR_197 = TYPE_98 -> TYPE_99 [ 2 ] . VAR_208 ; VAR_203 = VAR_222 = ( TYPE_36 * ) METHOD_3 ( sizeof ( TYPE_36 ) * VAR_45 ) ; VAR_206 = VAR_224 <S2SV_ModEnd> = ( TYPE_36 <S2SV_ModStart> TYPE_36 ) * <S2SV_ModEnd> VAR_45 ) ; <S2SV_ModStart> VAR_45 ) ; VAR_209 = VAR_226 <S2SV_ModEnd> = ( TYPE_36 <S2SV_ModStart> TYPE_36 ) * <S2SV_ModEnd> VAR_45 ) ; <S2SV_ModStart> goto VAR_220 ; VAR_227 = TYPE_98 -> VAR_231 & 1U ; VAR_228 = VAR_218 - VAR_227 ; VAR_229 = TYPE_98 -> VAR_232 & 1U ; VAR_230 = VAR_219 - VAR_229 ; if ( VAR_229 > 0U ) { TYPE_33 VAR_191 ; for ( VAR_191 = 0 ; VAR_191 < VAR_218 ; ++ VAR_191 ) { METHOD_12 ( VAR_193 , VAR_194 , * VAR_195 , 0 , 0 , VAR_222 , VAR_224 , VAR_226 ) ; ++ VAR_195 ; ++ VAR_222 ; ++ VAR_224 ; ++ VAR_226 ; } } <S2SV_ModStart> VAR_159 < ( VAR_230 <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( TYPE_33 <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> 2U ) { TYPE_33 VAR_191 ; <S2SV_ModStart> + VAR_218 ; if ( VAR_227 > 0U ) { METHOD_12 ( VAR_193 , VAR_194 , * VAR_195 , 0 , 0 , VAR_222 , VAR_224 , VAR_226 ) ; ++ VAR_195 ; ++ VAR_222 ; ++ VAR_224 ; ++ VAR_226 ; METHOD_12 ( VAR_193 , VAR_194 , * VAR_145 , * VAR_196 , * VAR_197 , VAR_146 , VAR_147 , VAR_148 ) ; ++ VAR_145 ; ++ VAR_146 ; ++ VAR_147 ; ++ VAR_148 ; } <S2SV_ModStart> VAR_191 < ( VAR_228 <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( TYPE_33 <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( VAR_191 < VAR_228 <S2SV_ModEnd> ) { METHOD_12 <S2SV_ModStart> ( VAR_159 < VAR_230 ) { TYPE_33 VAR_191 ; <S2SV_ModEnd> for ( VAR_191 <S2SV_ModStart> & ~ ( TYPE_33 <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> = VAR_209 ; <S2SV_ModEnd> TYPE_98 -> TYPE_99 <S2SV_ModStart> . TYPE_71 = TYPE_98 -> TYPE_99 [ 2 ] . TYPE_71 = TYPE_98 -> TYPE_99 [ 0 ] . TYPE_71 ; <S2SV_ModEnd> TYPE_98 -> TYPE_99 <S2SV_ModStart> . TYPE_75 = <S2SV_ModEnd> TYPE_98 -> TYPE_99 <S2SV_ModStart> 2 ] . TYPE_75 = TYPE_98 -> TYPE_99 [ 0 ] . TYPE_75 ; TYPE_98 -> TYPE_99 [ 1 ] . TYPE_88 = <S2SV_ModEnd> TYPE_98 -> TYPE_99 <S2SV_ModStart> 2 ] . TYPE_88 = TYPE_98 -> TYPE_99 [ 0 ] . TYPE_88 ; <S2SV_ModEnd> TYPE_98 -> TYPE_99 <S2SV_ModStart> 1 ] . TYPE_100 = <S2SV_ModEnd> TYPE_98 -> TYPE_99 <S2SV_ModStart> 2 ] . <S2SV_ModEnd> TYPE_100 = TYPE_98 <S2SV_ModStart> ; TYPE_98 -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; VAR_220 : <S2SV_ModEnd> METHOD_20 ( VAR_222 <S2SV_ModStart> VAR_222 ) ; <S2SV_ModEnd> METHOD_20 ( VAR_224 <S2SV_ModStart> VAR_224 ) ; <S2SV_ModEnd> METHOD_20 ( VAR_226","CWE-125 static void sycc420_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b , * nr , * ng , * nb ; const int * y , * cb , * cr , * ny ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> { <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> nr = r + maxw ; ng = g + maxw ; nb = b + maxw ; <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } y += maxw ; r += maxw ; g += maxw ; b += maxw ; } <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug>  if d ( USE_JPWL ) || d ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug>  else <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug>   img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }","<S2SV_ModStart> * ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> max ) ; d2 = b <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> i < ( loopmaxh <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> 2U ) { size_t j ; <S2SV_ModStart> + maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> ( i < loopmaxh ) { size_t j ; <S2SV_ModEnd> for ( j <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b"
526,"CWE-119 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = 0xFF000000 ; const TYPE_4 * VAR_3 ; TYPE_5 VAR_4 [ 100 ] ; <S2SV_StartBug> if ( * VAR_5 == '' ) { <S2SV_EndBug> VAR_6 ++ ; VAR_7 -- ; if ( VAR_8 == 3 ) { VAR_9 |= ( METHOD_1 ( VAR_10 [ 2 ] ) << 4 ) | ( METHOD_2 ( VAR_11 [ 1 ] ) << 12 ) | ( METHOD_3 ( VAR_12 [ 0 ] ) << 20 ) ; } else if ( VAR_13 == 4 ) { VAR_14 = ( METHOD_4 ( VAR_15 [ 3 ] ) << 4 ) | ( METHOD_5 ( VAR_16 [ 2 ] ) << 12 ) | ( METHOD_6 ( VAR_17 [ 1 ] ) << 20 ) | ( METHOD_7 ( VAR_18 [ 0 ] ) << 28 ) ; } else if ( VAR_19 == 6 ) { VAR_20 |= METHOD_8 ( VAR_21 [ 5 ] ) | ( METHOD_9 ( VAR_22 [ 4 ] ) << 4 ) | ( METHOD_10 ( VAR_23 [ 3 ] ) << 8 ) | ( METHOD_11 ( VAR_24 [ 2 ] ) << 12 ) | ( METHOD_12 ( VAR_25 [ 1 ] ) << 16 ) | ( METHOD_13 ( VAR_26 [ 0 ] ) << 20 ) ; } else if ( VAR_27 == 8 ) { VAR_28 = METHOD_14 ( VAR_29 [ 7 ] ) | ( METHOD_15 ( VAR_30 [ 6 ] ) << 4 ) | ( METHOD_16 ( VAR_31 [ 5 ] ) << 8 ) | ( METHOD_17 ( VAR_32 [ 4 ] ) << 12 ) | ( METHOD_18 ( VAR_33 [ 3 ] ) << 16 ) | ( METHOD_19 ( VAR_34 [ 2 ] ) << 20 ) | ( METHOD_20 ( VAR_35 [ 1 ] ) << 24 ) | ( METHOD_21 ( VAR_36 [ 0 ] ) << 28 ) ; } } else { METHOD_22 ( VAR_37 , VAR_38 , VAR_39 ) ; VAR_40 [ VAR_41 ] = '\\0' ; VAR_42 = METHOD_23 ( VAR_43 , VAR_44 , METHOD_24 ( VAR_45 ) , sizeof ( TYPE_6 ) , VAR_46 ) ; if ( ! VAR_47 ) return VAR_48 ; VAR_49 = VAR_50 -> VAR_51 ; } return VAR_52 ; }","<S2SV_ModStart> 100 ] ; VAR_41 = METHOD_26 ( METHOD_25 ( VAR_41 , 0 ) , sizeof ( VAR_43 ) - 1 ) ;","CWE-119 static uint32_t color_string_to_rgba ( const char * p , int len ) { uint32_t ret = 0xFF000000 ; const ColorEntry * entry ; char color_name [ 100 ] ; <S2SV_StartBug> if ( * p == '' ) { <S2SV_EndBug> p ++ ; len -- ; if ( len == 3 ) { ret |= ( hex_char_to_number ( p [ 2 ] ) << 4 ) | ( hex_char_to_number ( p [ 1 ] ) << 12 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 4 ) { ret = ( hex_char_to_number ( p [ 3 ] ) << 4 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 20 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } else if ( len == 6 ) { ret |= hex_char_to_number ( p [ 5 ] ) | ( hex_char_to_number ( p [ 4 ] ) << 4 ) | ( hex_char_to_number ( p [ 3 ] ) << 8 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 16 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 8 ) { ret = hex_char_to_number ( p [ 7 ] ) | ( hex_char_to_number ( p [ 6 ] ) << 4 ) | ( hex_char_to_number ( p [ 5 ] ) << 8 ) | ( hex_char_to_number ( p [ 4 ] ) << 12 ) | ( hex_char_to_number ( p [ 3 ] ) << 16 ) | ( hex_char_to_number ( p [ 2 ] ) << 20 ) | ( hex_char_to_number ( p [ 1 ] ) << 24 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } } else { strncpy ( color_name , p , len ) ; color_name [ len ] = '\\0' ; entry = bsearch ( color_name , color_table , FF_ARRAY_ELEMS ( color_table ) , sizeof ( ColorEntry ) , color_table_compare ) ; if ( ! entry ) return ret ; ret = entry -> rgb_color ; } return ret ; }","<S2SV_ModStart> 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;"
527,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = & VAR_2 -> VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 = VAR_5 -> VAR_6 -> VAR_7 ; struct STRUCT_OR_UNION_3 * VAR_8 = VAR_9 -> VAR_10 ; TYPE_1 VAR_11 = VAR_12 -> VAR_13 -> VAR_14 ; TYPE_2 VAR_15 , VAR_16 = 0 ; TYPE_3 VAR_17 = 0 ; TYPE_4 VAR_18 = VAR_19 ; METHOD_1 ( VAR_20 ) ; VAR_21 = 0 ; VAR_22 -> VAR_23 = VAR_24 ; for ( ; ; ) { struct STRUCT_OR_UNION_4 * VAR_25 ; TYPE_5 VAR_26 ; TYPE_6 VAR_27 ; if ( VAR_28 >= VAR_29 ) { METHOD_2 ( ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , VAR_30 , VAR_31 ) ; return - VAR_32 ; } VAR_33 = & VAR_34 [ VAR_35 ] ; VAR_36 = METHOD_3 ( VAR_37 -> VAR_38 ) ; if ( ++ VAR_39 > VAR_40 ) { METHOD_4 ( ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , VAR_41 ) ; return - VAR_42 ; } VAR_43 = METHOD_5 ( VAR_44 , VAR_45 ) ; if ( VAR_46 < 0 ) return VAR_47 ; if ( VAR_48 == 1 ) { if ( VAR_49 ) { if ( VAR_50 ) METHOD_6 ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , VAR_51 , VAR_52 ) ; else METHOD_7 ( ""%d:<S2SV_blank>safe\\n"" , VAR_53 ) ; } goto VAR_54 ; } if ( VAR_55 && VAR_56 ) { METHOD_8 ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , VAR_57 , VAR_58 ) ; METHOD_9 ( & VAR_59 -> VAR_60 ) ; VAR_61 = VAR_62 ; } if ( VAR_63 ) { METHOD_10 ( ""%d:<S2SV_blank>"" , VAR_64 ) ; <S2SV_StartBug> METHOD_11 ( VAR_65 ) ; <S2SV_EndBug> } VAR_66 = METHOD_12 ( VAR_67 , VAR_68 , VAR_69 ) ; if ( VAR_70 ) return VAR_71 ; if ( VAR_72 == VAR_73 || VAR_74 == VAR_75 ) { VAR_76 = METHOD_13 ( VAR_77 , VAR_78 ) ; if ( VAR_79 ) return VAR_80 ; } else if ( VAR_81 == VAR_82 ) { enum VAR_83 * VAR_84 , VAR_85 ; VAR_86 = METHOD_14 ( VAR_87 , VAR_88 -> VAR_89 , VAR_90 ) ; if ( VAR_91 ) return VAR_92 ; VAR_93 = METHOD_15 ( VAR_94 , VAR_95 -> VAR_96 , VAR_97 ) ; if ( VAR_98 ) return VAR_99 ; VAR_100 = VAR_101 [ VAR_102 -> VAR_103 ] . VAR_104 ; VAR_105 = METHOD_16 ( VAR_106 , VAR_107 -> VAR_108 , VAR_109 -> VAR_110 , METHOD_17 ( VAR_111 -> VAR_112 ) , VAR_113 , VAR_114 -> VAR_115 ) ; if ( VAR_116 ) return VAR_117 ; if ( METHOD_18 ( VAR_118 -> VAR_119 ) != VAR_120 && METHOD_19 ( VAR_121 -> VAR_122 ) != VAR_123 ) { VAR_124 ++ ; continue ; } VAR_125 = & VAR_126 -> VAR_127 [ VAR_128 ] . VAR_129 ; if ( * VAR_130 == VAR_131 ) { * VAR_132 = VAR_133 ; } else if ( VAR_134 != * VAR_135 && ( VAR_136 == VAR_137 || * VAR_138 == VAR_139 ) ) { METHOD_20 ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - VAR_140 ; } } else if ( VAR_141 == VAR_142 ) { enum VAR_143 * VAR_144 , VAR_145 ; if ( METHOD_21 ( VAR_146 -> VAR_147 ) == VAR_148 ) { VAR_149 = METHOD_22 ( VAR_150 , VAR_151 ) ; if ( VAR_152 ) return VAR_153 ; VAR_154 ++ ; continue ; } VAR_155 = METHOD_23 ( VAR_156 , VAR_157 -> VAR_158 , VAR_159 ) ; if ( VAR_160 ) return VAR_161 ; VAR_162 = METHOD_24 ( VAR_163 , VAR_164 -> VAR_165 , VAR_166 ) ; if ( VAR_167 ) return VAR_168 ; VAR_169 = VAR_170 [ VAR_171 -> VAR_172 ] . VAR_173 ; VAR_174 = METHOD_25 ( VAR_175 , VAR_176 -> VAR_177 , VAR_178 -> VAR_179 , METHOD_26 ( VAR_180 -> VAR_181 ) , VAR_182 , VAR_183 -> VAR_184 ) ; if ( VAR_185 ) return VAR_186 ; VAR_187 = & VAR_188 -> VAR_189 [ VAR_190 ] . VAR_191 ; if ( * VAR_192 == VAR_193 ) { * VAR_194 = VAR_195 ; } else if ( VAR_196 != * VAR_197 && ( VAR_198 == VAR_199 || * VAR_200 == VAR_201 ) ) { METHOD_27 ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - VAR_202 ; } } else if ( VAR_203 == VAR_204 ) { if ( METHOD_28 ( VAR_205 -> VAR_206 ) != VAR_207 || VAR_208 -> VAR_209 != VAR_210 ) { METHOD_29 ( ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_211 ; } VAR_212 = METHOD_30 ( VAR_213 , VAR_214 -> VAR_215 , VAR_216 ) ; if ( VAR_217 ) return VAR_218 ; VAR_219 = METHOD_31 ( VAR_220 , VAR_221 -> VAR_222 , VAR_223 -> VAR_224 , METHOD_32 ( VAR_225 -> VAR_226 ) , VAR_227 , - 1 ) ; if ( VAR_228 ) return VAR_229 ; } else if ( VAR_230 == VAR_231 ) { TYPE_7 VAR_232 = METHOD_33 ( VAR_233 -> VAR_234 ) ; if ( VAR_235 == VAR_236 ) { if ( METHOD_34 ( VAR_237 -> VAR_238 ) != VAR_239 || VAR_240 -> VAR_241 != 0 || VAR_242 -> VAR_243 != VAR_244 || VAR_245 -> VAR_246 != VAR_247 ) { METHOD_35 ( ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_248 ; } VAR_249 = METHOD_36 ( VAR_250 , VAR_251 -> VAR_252 , VAR_253 ) ; if ( VAR_254 ) return VAR_255 ; } else if ( VAR_256 == VAR_257 ) { if ( METHOD_37 ( VAR_258 -> VAR_259 ) != VAR_260 || VAR_261 -> VAR_262 != 0 || VAR_263 -> VAR_264 != VAR_265 || VAR_266 -> VAR_267 != VAR_268 ) { METHOD_38 ( ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_269 ; } VAR_270 += VAR_271 -> VAR_272 + 1 ; continue ; } else if ( VAR_273 == VAR_274 ) { if ( METHOD_39 ( VAR_275 -> VAR_276 ) != VAR_277 || VAR_278 -> VAR_279 != 0 || VAR_280 -> VAR_281 != VAR_282 || VAR_283 -> VAR_284 != VAR_285 ) { METHOD_40 ( ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_286 ; } VAR_287 = METHOD_41 ( VAR_288 , VAR_289 , VAR_290 ) ; if ( VAR_291 ) return VAR_292 ; if ( METHOD_42 ( VAR_293 , VAR_294 ) ) { METHOD_43 ( ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - VAR_295 ; } VAR_296 : VAR_297 = METHOD_44 ( VAR_298 , & VAR_299 ) ; if ( VAR_300 < 0 ) { break ; } else { VAR_301 = VAR_302 ; continue ; } } else { VAR_303 = METHOD_45 ( VAR_304 , VAR_305 , & VAR_306 ) ; if ( VAR_307 ) return VAR_308 ; } } else if ( VAR_309 == VAR_310 ) { TYPE_8 VAR_311 = METHOD_46 ( VAR_312 -> VAR_313 ) ; if ( VAR_314 == VAR_315 || VAR_316 == VAR_317 ) { VAR_318 = METHOD_47 ( VAR_319 , VAR_320 ) ; if ( VAR_321 ) return VAR_322 ; } else if ( VAR_323 == VAR_324 ) { VAR_325 = METHOD_48 ( VAR_326 , VAR_327 ) ; if ( VAR_328 ) return VAR_329 ; VAR_330 ++ ; } else { METHOD_49 ( ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - VAR_331 ; } METHOD_50 ( VAR_332 , VAR_333 -> VAR_334 ) ; } else { METHOD_51 ( ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , VAR_335 ) ; return - VAR_336 ; } VAR_337 ++ ; } METHOD_52 ( ""processed<S2SV_blank>%d<S2SV_blank>insns\\n"" , VAR_338 ) ; return 0 ; }","<S2SV_ModStart> ; METHOD_11 ( VAR_326 ,","CWE-200 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state = & env -> cur_state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs = state -> regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; init_reg_state ( regs ) ; insn_idx = 0 ; env -> varlen_map_value_access = false ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( log_level ) { if ( do_print_state ) verbose ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( ""%d:<S2SV_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( log_level && do_print_state ) { verbose ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( & env -> cur_state ) ; do_print_state = false ; } if ( log_level ) { verbose ( ""%d:<S2SV_blank>"" , insn_idx ) ; <S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; if ( BPF_SIZE ( insn -> code ) != BPF_W && BPF_SIZE ( insn -> code ) != BPF_DW ) { insn_idx ++ ; continue ; } prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } process_bpf_exit : insn_idx = pop_stack ( env , & prev_insn_idx ) ; if ( insn_idx < 0 ) { break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; } else { verbose ( ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } reset_reg_range_values ( regs , insn -> dst_reg ) ; } else { verbose ( ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( ""processed<S2SV_blank>%d<S2SV_blank>insns\\n"" , insn_processed ) ; return 0 ; }","<S2SV_ModStart> ; print_bpf_insn ( env ,"
528,"CWE-264 static TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 , TYPE_1 VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 ) { if ( ( VAR_3 -> VAR_4 == 1 ) && ( VAR_5 -> VAR_6 [ 0 ] . VAR_7 == 1 ) ) { TYPE_2 VAR_8 = VAR_9 -> VAR_10 [ 0 ] . VAR_11 ; if ( VAR_12 == VAR_13 ) { TYPE_3 VAR_14 = METHOD_1 ( VAR_15 -> VAR_16 , VAR_17 ) ; <S2SV_StartBug> if ( METHOD_2 ( VAR_18 , METHOD_3 ( ) ) ) <S2SV_EndBug> return VAR_19 ; } else if ( VAR_20 == VAR_21 ) { TYPE_4 VAR_22 = METHOD_4 ( VAR_23 -> VAR_24 , VAR_25 ) ; <S2SV_StartBug> if ( METHOD_5 ( VAR_26 , METHOD_6 ( ) ) ) <S2SV_EndBug> return VAR_27 ; } } if ( ! METHOD_7 ( VAR_28 ) ) return VAR_29 ; if ( METHOD_8 ( VAR_30 -> VAR_31 , VAR_32 ) && METHOD_9 ( STRUCT_OR_UNION_4 , VAR_33 -> VAR_34 , VAR_35 ) ) return VAR_36 ; return VAR_37 ; }","<S2SV_ModStart> ( VAR_18 , STRUCT_OR_UNION_4 -> VAR_38 -> VAR_39 <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( VAR_26 , STRUCT_OR_UNION_4 -> VAR_38 -> VAR_40 <S2SV_ModEnd> ) ) return","CWE-264 static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; <S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ; return false ; }","<S2SV_ModStart> ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return"
529,"CWE-254 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , unsigned TYPE_1 VAR_2 , unsigned TYPE_2 * VAR_3 ) { <S2SV_StartBug> return VAR_4 ; <S2SV_EndBug> }",<S2SV_ModStart> ) { return METHOD_2 ( METHOD_1 ( VAR_0 ) ) <S2SV_ModEnd> ; } <S2SV_null>,"CWE-254 static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <S2SV_StartBug> return true ; <S2SV_EndBug> }",<S2SV_ModStart> ) { return nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> ; } <S2SV_null>
530,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 VAR_3 ; if ( METHOD_1 ( VAR_4 , VAR_5 ) ) { return VAR_6 ; } if ( METHOD_2 ( sizeof ( unsigned TYPE_5 * ) , VAR_7 ) ) { return VAR_8 ; } <S2SV_StartBug> VAR_9 = ( TYPE_6 * ) METHOD_3 ( 1 , sizeof ( TYPE_7 ) ) ; <S2SV_EndBug> VAR_10 -> VAR_11 = ( unsigned TYPE_8 * * ) METHOD_4 ( sizeof ( unsigned TYPE_9 * ) * VAR_12 ) ; VAR_13 -> VAR_14 = ( unsigned TYPE_10 * * ) METHOD_5 ( sizeof ( unsigned TYPE_11 * ) * VAR_15 ) ; VAR_16 -> VAR_17 = 0 ; VAR_18 -> VAR_19 = 0 ; VAR_20 -> VAR_21 = 0 ; VAR_22 -> VAR_23 = 0 ; VAR_24 -> VAR_25 = 0 ; for ( VAR_26 = 0 ; VAR_27 < VAR_28 ; VAR_29 ++ ) { VAR_30 -> VAR_31 [ VAR_32 ] = ( unsigned TYPE_12 * ) METHOD_6 ( VAR_33 , sizeof ( unsigned TYPE_13 ) ) ; VAR_34 -> VAR_35 [ VAR_36 ] = ( unsigned TYPE_14 * ) METHOD_7 ( VAR_37 , sizeof ( unsigned TYPE_15 ) ) ; } VAR_38 -> VAR_39 = VAR_40 ; VAR_41 -> VAR_42 = VAR_43 ; VAR_44 -> VAR_45 = 0 ; VAR_46 -> VAR_47 = ( - 1 ) ; VAR_48 -> VAR_49 = 0 ; VAR_50 -> VAR_51 = 1 ; VAR_52 -> VAR_53 = 0 ; VAR_54 -> VAR_55 = 0 ; for ( VAR_56 = 0 ; VAR_57 < VAR_58 ; VAR_59 ++ ) { VAR_60 -> VAR_61 [ VAR_62 ] = 1 ; VAR_63 -> VAR_64 [ VAR_65 ] = 0 ; VAR_66 -> VAR_67 [ VAR_68 ] = 0 ; VAR_69 -> VAR_70 [ VAR_71 ] = 0 ; } VAR_72 -> VAR_73 = 0 ; VAR_74 -> VAR_75 = 0 ; VAR_76 -> VAR_77 = 0 ; VAR_78 -> VAR_79 = 0 ; VAR_80 -> VAR_81 = VAR_82 -> VAR_83 - 1 ; VAR_84 -> VAR_85 = VAR_86 -> VAR_87 - 1 ; VAR_88 -> VAR_89 = VAR_90 ; VAR_91 -> VAR_92 = VAR_93 ; return VAR_94 ; }","<S2SV_ModStart> VAR_90 ; } if ( METHOD_2 ( sizeof ( unsigned TYPE_15 * ) , VAR_83 ) ) { return VAR_90 ; }","CWE-190 gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++ ) { im -> open [ i ] = 1 ; im -> red [ i ] = 0 ; im -> green [ i ] = 0 ; im -> blue [ i ] = 0 ; } im -> trueColor = 0 ; im -> tpixels = 0 ; im -> cx1 = 0 ; im -> cy1 = 0 ; im -> cx2 = im -> sx - 1 ; im -> cy2 = im -> sy - 1 ; im -> interpolation = NULL ; im -> interpolation_id = GD_BILINEAR_FIXED ; return im ; }","<S2SV_ModStart> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }"
531,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , enum VAR_1 VAR_2 , TYPE_1 * VAR_3 , unsigned TYPE_2 VAR_4 ) { unsigned TYPE_3 * VAR_5 = VAR_6 -> VAR_7 + VAR_8 -> VAR_9 ; unsigned TYPE_4 VAR_10 = VAR_11 + ( VAR_12 == VAR_13 ? 0 : VAR_14 ) ; <S2SV_StartBug> if ( VAR_15 -> VAR_16 + VAR_17 > VAR_18 ) { <S2SV_EndBug> METHOD_1 ( VAR_19 , METHOD_2 ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , VAR_20 ) ; return - 1 ; } if ( VAR_21 == VAR_22 ) { METHOD_3 ( VAR_23 , VAR_24 , VAR_25 ) ; VAR_26 -> VAR_27 += VAR_28 ; return VAR_29 ; } METHOD_4 ( VAR_30 , VAR_31 , sizeof ( VAR_32 ) ) ; VAR_33 [ 4 ] = VAR_34 ; if VAR_35 == VAR_36 { unsigned TYPE_5 VAR_37 ; VAR_38 = METHOD_5 ( VAR_39 ) ; METHOD_6 ( VAR_40 + 5 , & VAR_41 , sizeof ( VAR_42 ) ) ; } else METHOD_7 ( VAR_43 + 5 , & VAR_44 , sizeof ( VAR_45 ) ) ; if ( VAR_46 > 0 ) { METHOD_8 ( VAR_47 + VAR_48 , VAR_49 , VAR_50 ) ; } VAR_51 -> VAR_52 += VAR_53 ; return VAR_54 ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> VAR_54 > VAR_20 <S2SV_ModStart> VAR_54 > VAR_20 - VAR_51 -> VAR_52,"CWE-119 int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ;  if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; }  else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ;   if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> act_size > MT_PACKET_LEN <S2SV_ModStart> act_size > MT_PACKET_LEN - packet -> size
532,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 ) { TYPE_2 VAR_2 [ VAR_3 ] ; TYPE_3 * VAR_4 = VAR_5 ; if ( ! VAR_6 ) return - 1 ; while ( * VAR_7 ) { METHOD_1 ( VAR_8 ) ; if ( METHOD_2 ( ""FLAGS"" , VAR_9 , 5 ) == 0 ) { VAR_10 = METHOD_3 ( VAR_11 , VAR_12 ) ; if ( ! VAR_13 ) return - 1 ; } else if ( METHOD_4 ( ""UID"" , VAR_14 , 3 ) == 0 ) { VAR_15 += 3 ; METHOD_5 ( VAR_16 ) ; if ( METHOD_6 ( VAR_17 , & VAR_18 -> VAR_19 -> VAR_20 ) < 0 ) return - 1 ; VAR_21 = METHOD_7 ( VAR_22 ) ; } else if ( METHOD_8 ( ""INTERNALDATE"" , VAR_23 , 12 ) == 0 ) { VAR_24 += 12 ; METHOD_9 ( VAR_25 ) ; if ( * VAR_26 != \'\\""\' ) { mutt_debug ( 1 , ""bogus<S2SV_blank>INTERNALDATE<S2SV_blank>entry:<S2SV_blank>%s\\n"" , VAR_27 ) ; return - 1 ; } VAR_28 ++ ; VAR_29 = VAR_30 ; <S2SV_StartBug> while ( * VAR_31 && * VAR_32 != \'\\""\' ) <S2SV_EndBug> * VAR_33 ++ = * VAR_34 ++ ; if ( * VAR_35 != \'\\""\' ) return - 1 ; VAR_36 ++ ; * VAR_37 = '\\0' ; VAR_38 -> received = mutt_date_parse_imap ( VAR_39 ) ; } else if ( METHOD_10 ( ""RFC822.SIZE"" , VAR_40 , 11 ) == 0 ) { VAR_41 += 11 ; METHOD_11 ( VAR_42 ) ; VAR_43 = VAR_44 ; <S2SV_StartBug> while ( isdigit ( ( unsigned TYPE_4 ) * VAR_45 ) ) <S2SV_EndBug> * VAR_46 ++ = * VAR_47 ++ ; * VAR_48 = '\\0' ; if ( mutt_str_atol ( VAR_49 , & VAR_50 -> content_length ) < 0 ) return - 1 ; } else if ( ( METHOD_12 ( ""BODY"" , VAR_51 , 4 ) == 0 ) || ( METHOD_13 ( ""RFC822.HEADER"" , VAR_52 , 13 ) == 0 ) ) { return - 2 ; } else if ( * VAR_53 == ')' ) VAR_54 ++ ; else if ( * VAR_55 ) { imap_error ( ""msg_parse_fetch"" , VAR_56 ) ; return - 1 ; } } return 0 ; }","<S2SV_ModStart> * VAR_56 && ( <S2SV_ModStart> VAR_56 != \'\\""\' ) && ( VAR_48 != ( VAR_49 + sizeof ( VAR_49 ) - 1 ) ) <S2SV_ModStart> ) * VAR_56 ) && ( VAR_48 != ( VAR_49 + sizeof ( VAR_49 ) - 1 )","CWE-119 static int msg_parse_fetch ( struct ImapHeader * h , char * s ) { char tmp [ SHORT_STRING ] ; char * ptmp = NULL ; if ( ! s ) return - 1 ; while ( * s ) { SKIPWS ( s ) ; if ( mutt_str_strncasecmp ( ""FLAGS"" , s , 5 ) == 0 ) { s = msg_parse_flags ( h , s ) ; if ( ! s ) return - 1 ; } else if ( mutt_str_strncasecmp ( ""UID"" , s , 3 ) == 0 ) { s += 3 ; SKIPWS ( s ) ; if ( mutt_str_atoui ( s , & h -> data -> uid ) < 0 ) return - 1 ; s = imap_next_word ( s ) ; } else if ( mutt_str_strncasecmp ( ""INTERNALDATE"" , s , 12 ) == 0 ) { s += 12 ; SKIPWS ( s ) ; if ( * s != \'\\""\' ) { mutt_debug ( 1 , ""bogus<S2SV_blank>INTERNALDATE<S2SV_blank>entry:<S2SV_blank>%s\\n"" , s ) ; return - 1 ; } s ++ ; ptmp = tmp ; <S2SV_StartBug> while ( * s && * s != \'\\""\' ) <S2SV_EndBug> * ptmp ++ = * s ++ ; if ( * s != \'\\""\' ) return - 1 ; s ++ ; * ptmp = '\\0' ; h -> received = mutt_date_parse_imap ( tmp ) ; } else if ( mutt_str_strncasecmp ( ""RFC822.SIZE"" , s , 11 ) == 0 ) { s += 11 ; SKIPWS ( s ) ; ptmp = tmp ; <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> * ptmp ++ = * s ++ ; * ptmp = '\\0' ; if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) return - 1 ; } else if ( ( mutt_str_strncasecmp ( ""BODY"" , s , 4 ) == 0 ) || ( mutt_str_strncasecmp ( ""RFC822.HEADER"" , s , 13 ) == 0 ) ) { return - 2 ; } else if ( * s == ')' ) s ++ ; else if ( * s ) { imap_error ( ""msg_parse_fetch"" , s ) ; return - 1 ; } } return 0 ; }","<S2SV_ModStart> * s && ( <S2SV_ModStart> s != \'\\""\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 )"
533,"CWE-190 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> if ( METHOD_1 ( VAR_3 , 4 , & VAR_4 ) ) return - 1 ; * VAR_5 = VAR_6 ; return 0 ; }",<S2SV_ModStart> VAR_5 ) { TYPE_4 <S2SV_ModEnd> VAR_6 ; if,"CWE-190 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }",<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
534,CWE-362 static TYPE_0 METHOD_0 ( TYPE_1 ) { struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 = METHOD_1 ( VAR_0 ) ; <S2SV_StartBug> TYPE_2 VAR_1 = METHOD_2 ( ) ; <S2SV_EndBug> do { STRUCT_OR_UNION_2 -> VAR_2 = 0 ; METHOD_3 ( VAR_3 ) ; METHOD_4 ( ! METHOD_5 ( ) ) ; METHOD_6 ( ) ; } while ( STRUCT_OR_UNION_3 -> VAR_4 ) ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> = METHOD_2 ( ) ; METHOD_7 ( & VAR_5 <S2SV_ModStart> VAR_4 ) ; METHOD_8 ( & VAR_5 ) ;,CWE-362 static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; <S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; xen_evtchn_handle_events ( cpu ) ; BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_ModStart> = smp_processor_id ( ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ;
535,"CWE-89 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 ) { TYPE_2 VAR_2 ; struct STRUCT_OR_UNION_1 * VAR_3 = & VAR_4 -> VAR_5 . VAR_6 ; struct STRUCT_OR_UNION_2 * VAR_7 = VAR_8 -> VAR_9 ; struct STRUCT_OR_UNION_3 * VAR_10 = & VAR_11 -> VAR_12 ; <S2SV_StartBug> const TYPE_3 * VAR_13 = VAR_14 -> VAR_15 -> METHOD_1 . VAR_16 ; <S2SV_EndBug> TYPE_4 VAR_17 ; TYPE_5 VAR_18 [ VAR_19 + 1 ] ; * VAR_20 = VAR_21 ; METHOD_2 ( VAR_22 ) ; VAR_23 = METHOD_3 ( VAR_24 ) ; if ( VAR_25 != VAR_26 ) return VAR_27 ; VAR_28 -> VAR_29 . VAR_30 = VAR_31 ; VAR_32 -> VAR_33 = VAR_34 ; VAR_35 -> VAR_36 = VAR_37 ; VAR_38 -> VAR_39 = VAR_40 ; VAR_41 -> VAR_42 = VAR_43 ; if ( VAR_44 -> VAR_45 . VAR_46 && VAR_47 -> VAR_48 . VAR_49 ) { struct STRUCT_OR_UNION_4 VAR_50 ; struct STRUCT_OR_UNION_5 * VAR_51 ; VAR_52 = VAR_53 -> METHOD_4 . VAR_54 . VAR_55 ; METHOD_5 ( & VAR_56 , 0 , sizeof ( VAR_57 ) ) ; VAR_58 -> METHOD_6 . VAR_59 . VAR_60 = & VAR_61 ; VAR_62 = METHOD_7 ( VAR_63 , VAR_64 , VAR_65 -> VAR_66 . VAR_67 , VAR_68 -> VAR_69 ) ; VAR_70 -> METHOD_8 . VAR_71 . VAR_72 = VAR_73 ; if ( VAR_74 != VAR_75 ) return VAR_76 ; } if ( ( VAR_77 -> VAR_78 -> VAR_79 & VAR_80 ) && VAR_81 -> METHOD_9 . VAR_82 != VAR_83 ) { VAR_84 = METHOD_10 ( VAR_85 , VAR_86 ) ; if ( VAR_87 ) return VAR_88 ; } METHOD_11 ( VAR_89 ) ; VAR_90 -> VAR_91 = VAR_92 ; VAR_93 -> VAR_94 = VAR_95 ; VAR_96 -> VAR_97 = VAR_98 ; VAR_99 -> VAR_100 = VAR_101 ; if ( ! * VAR_102 ) { if ( ! METHOD_12 ( VAR_103 , sizeof VAR_104 ) ) VAR_105 = VAR_106 ; else VAR_107 = ""localhost"" ; } <S2SV_StartBug> VAR_108 -> VAR_109 = METHOD_13 ( VAR_110 -> VAR_111 , VAR_112 , 0 , & VAR_113 ) ; <S2SV_EndBug> if ( ! VAR_114 -> VAR_115 ) return VAR_116 ; METHOD_14 ( VAR_117 , VAR_118 ) ; if ( VAR_119 -> METHOD_15 . VAR_120 == VAR_121 ) VAR_122 = METHOD_16 ( VAR_123 , VAR_124 ) ; else { VAR_125 = METHOD_17 ( VAR_126 ) ; if ( ! VAR_127 ) * VAR_128 = VAR_129 ; } return VAR_130 ; }","<S2SV_ModStart> METHOD_15 . VAR_112 <S2SV_ModEnd> ; TYPE_5 VAR_106 <S2SV_ModStart> ""localhost"" ; } VAR_130 = METHOD_18 ( VAR_126 -> VAR_119 , VAR_112 , 0 , & <S2SV_ModStart> VAR_114 -> VAR_115 , VAR_131 , VAR_129 ) ; if ( VAR_130 ) return VAR_130 <S2SV_ModEnd> ; METHOD_15 (","CWE-89 static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = ""localhost"" ; } <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }","<S2SV_ModStart> state . path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> ""localhost"" ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state ("
536,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 * VAR_1 ) { if ( ! VAR_2 || ! VAR_3 ) return - 1 ; if ( VAR_4 -> VAR_5 ) { if ( ( VAR_6 -> VAR_7 && ( VAR_8 -> VAR_9 == ( VAR_10 -> VAR_11 - 1 ) ) ) || ( ! VAR_12 -> VAR_13 && ( VAR_14 -> VAR_15 == ( VAR_16 -> VAR_17 + 1 ) ) ) ) { VAR_18 -> VAR_19 = 0 ; } } if ( ! VAR_20 -> VAR_21 ) { VAR_22 -> VAR_23 = VAR_24 -> VAR_25 ; if ( VAR_26 -> VAR_27 == VAR_28 -> VAR_29 ) return 1 ; <S2SV_StartBug> while ( ! * ( VAR_30 -> VAR_31 ) ) <S2SV_EndBug> VAR_32 -> VAR_33 ++ ; VAR_34 -> VAR_35 = METHOD_1 ( VAR_36 -> VAR_37 , ',' ) ; if ( ! VAR_38 -> VAR_39 ) VAR_40 -> VAR_41 = VAR_42 -> VAR_43 ; else * ( VAR_44 -> VAR_45 ) = '\\0' ; TYPE_2 * VAR_46 = METHOD_2 ( VAR_47 -> VAR_48 , ':' ) ; if ( VAR_49 ) * VAR_50 ++ = '\\0' ; if ( METHOD_3 ( VAR_51 -> VAR_52 , & VAR_53 -> VAR_54 ) != 0 ) return - 1 ; if ( VAR_55 ) { if ( METHOD_4 ( VAR_56 , & VAR_57 -> VAR_58 ) != 0 ) return - 1 ; } else VAR_59 -> VAR_60 = VAR_61 -> VAR_62 ; VAR_63 -> VAR_64 = ( VAR_65 -> VAR_66 < VAR_67 -> VAR_68 ) ; VAR_69 -> VAR_70 = 1 ; } * VAR_71 = VAR_72 -> VAR_73 ; if ( VAR_74 -> VAR_75 ) VAR_76 -> VAR_77 -- ; else VAR_78 -> VAR_79 ++ ; return 0 ; }","<S2SV_ModStart> return 1 ; VAR_78 -> VAR_45 = METHOD_2 ( VAR_78 -> VAR_52 , ',' ) ; if ( ! VAR_78 -> VAR_45 ) VAR_78 -> VAR_45 = VAR_78 -> VAR_43 ; else * ( VAR_78 -> VAR_45 ++ <S2SV_ModEnd> ) = '\\0'","CWE-125 int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; <S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }","<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'"
537,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 ) { <S2SV_StartBug> const struct STRUCT_OR_UNION_1 * VAR_3 ; <S2SV_EndBug> switch ( VAR_4 -> VAR_5 ) { case VAR_6 : VAR_7 = ( const struct STRUCT_OR_UNION_2 * ) ( const TYPE_3 * ) VAR_8 ; METHOD_1 ( * VAR_9 ) ; if ( VAR_10 < sizeof ( struct STRUCT_OR_UNION_3 ) ) <S2SV_StartBug> goto VAR_11 ; <S2SV_EndBug> METHOD_2 ( ( VAR_12 , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>%ld<S2SV_blank>ms"" , ( unsigned TYPE_4 ) METHOD_3 ( & VAR_13 -> VAR_14 ) ) ) ; break ; default : METHOD_4 ( ( VAR_15 , ""\\n\\text<S2SV_blank>%u<S2SV_blank>%u"" , VAR_16 -> VAR_17 , VAR_18 -> VAR_19 ) ) ; break ; } return ; VAR_20 : METHOD_5 ( ( VAR_21 , ""<S2SV_blank>[|hello]"" ) ) ; }","<S2SV_ModStart> STRUCT_OR_UNION_3 * VAR_13 ; METHOD_1 ( * VAR_18 ) <S2SV_ModStart> goto VAR_20 ; if ( VAR_18 -> VAR_19 < 4 ) { METHOD_5 ( ( VAR_21 , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u"" , VAR_18 -> VAR_19 ) ) ; break ; }","CWE-125 static void aodv_extension ( netdissect_options * ndo , const struct aodv_ext * ep , u_int length ) { <S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> switch ( ep -> type ) { case AODV_EXT_HELLO : ah = ( const struct aodv_hello * ) ( const void * ) ep ; ND_TCHECK ( * ah ) ; if ( length < sizeof ( struct aodv_hello ) ) <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>%ld<S2SV_blank>ms"" , ( unsigned long ) EXTRACT_32BITS ( & ah -> interval ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>%u<S2SV_blank>%u"" , ep -> type , ep -> length ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|hello]"" ) ) ; }","<S2SV_ModStart> aodv_hello * ah ; ND_TCHECK ( * ep ) <S2SV_ModStart> goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u"" , ep -> length ) ) ; break ; }"
538,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 -> VAR_4 ; TYPE_4 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_5 * VAR_8 = VAR_9 -> VAR_10 [ 0 ] ; TYPE_6 VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 ; VAR_16 * VAR_17 ; if ( ! VAR_18 -> VAR_19 || VAR_20 -> VAR_21 == VAR_22 -> VAR_23 ) return METHOD_1 ( VAR_24 , VAR_25 ) ; METHOD_2 ( VAR_26 , ""picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n"" , VAR_27 -> VAR_28 ? ""up"" : ""down"" ) ; VAR_29 = VAR_30 -> VAR_31 ; <S2SV_StartBug> for ( VAR_32 = 0 ; VAR_33 < 4 && VAR_34 -> VAR_35 [ VAR_36 ] ; VAR_37 ++ ) { <S2SV_EndBug> VAR_38 = VAR_39 -> VAR_40 [ VAR_41 ] ; VAR_42 = VAR_43 -> VAR_44 [ VAR_45 ] ; VAR_46 = VAR_47 -> VAR_48 [ VAR_49 ] ; if ( VAR_50 -> VAR_51 ) { for ( VAR_52 = 0 ; VAR_53 < VAR_54 ; VAR_55 ++ ) { if ( 1 + VAR_56 < VAR_57 -> VAR_58 ) { METHOD_3 ( VAR_59 , VAR_60 + VAR_61 , VAR_62 ) ; } else { METHOD_4 ( VAR_63 , VAR_64 - VAR_65 - VAR_66 , VAR_67 ) ; } VAR_68 += VAR_69 ; } } else { VAR_70 += ( VAR_71 - 1 ) * VAR_72 ; for ( VAR_73 = VAR_74 - 1 ; VAR_75 >= 0 ; VAR_76 -- ) { if ( VAR_77 > 0 ) { METHOD_5 ( VAR_78 , VAR_79 - VAR_80 , VAR_81 ) ; } else { METHOD_6 ( VAR_82 , VAR_83 + VAR_84 + VAR_85 , VAR_86 ) ; } VAR_87 -= VAR_88 ; } } } VAR_89 -> VAR_90 = VAR_91 -> VAR_92 ; return METHOD_7 ( VAR_93 , VAR_94 ) ; }",<S2SV_ModStart> [ VAR_49 ] && VAR_94 -> VAR_40 [ VAR_49 ],"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , ""picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n"" , s -> dst_tff ? ""up"" : ""down"" ) ; h = frame -> height ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size ) ; } else { memcpy ( data , data + line_step + line_step , line_size ) ; } data -= line_step ; } } } frame -> top_field_first = s -> dst_tff ; return ff_filter_frame ( outlink , frame ) ; }",<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
539,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { METHOD_1 ( VAR_2 , ""entering<S2SV_blank>CDROM_DRIVE_STATUS\\n"" ) ; if ( ! ( VAR_3 -> VAR_4 -> VAR_5 & VAR_6 ) ) return - VAR_7 ; if ( ! METHOD_2 ( VAR_8 ) || ( VAR_9 == VAR_10 || VAR_11 == VAR_12 ) ) return VAR_13 -> VAR_14 -> METHOD_3 ( VAR_15 , VAR_16 ) ; <S2SV_StartBug> if ( ( ( TYPE_2 ) VAR_17 >= VAR_18 -> VAR_19 ) ) <S2SV_EndBug> return - VAR_20 ; return METHOD_4 ( VAR_21 , VAR_22 ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> VAR_22 >= VAR_21 <S2SV_ModStart> VAR_21 -> VAR_19 <S2SV_ModEnd> ) return -,"CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""entering<S2SV_blank>CDROM_DRIVE_STATUS\\n"" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }",<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
540,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { const TYPE_3 * const VAR_2 = & VAR_3 -> VAR_4 ; TYPE_4 * const VAR_5 = & VAR_6 -> VAR_7 ; VAR_8 -> VAR_9 = VAR_10 ; <S2SV_StartBug> VAR_11 -> VAR_12 = ( ( TYPE_5 ) VAR_13 -> VAR_14 * 64 * 64 ) / <S2SV_EndBug> ( VAR_15 -> VAR_16 * VAR_17 -> VAR_18 ) ; }",<S2SV_ModStart> = VAR_10 ; if ( VAR_6 -> VAR_19 . VAR_20 == VAR_21 && VAR_13 -> VAR_22 != VAR_23 ) VAR_13 -> VAR_14 = ( TYPE_2 ) ( VAR_13 -> VAR_14 * VAR_24 [ VAR_13 -> VAR_22 ] ) ;,"CWE-119 void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }",<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
541,"CWE-189 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; if ! VAR_5 if ( ( TYPE_6 ) VAR_6 & ( sizeof ( TYPE_7 ) - 1 ) ) { for ( VAR_7 = 0 ; VAR_8 + 7 < VAR_9 ; VAR_10 += 8 ) { VAR_11 [ VAR_12 + 0 ] = VAR_13 [ VAR_14 + 0 ] - VAR_15 [ VAR_16 + 0 ] ; VAR_17 [ VAR_18 + 1 ] = VAR_19 [ VAR_20 + 1 ] - VAR_21 [ VAR_22 + 1 ] ; VAR_23 [ VAR_24 + 2 ] = VAR_25 [ VAR_26 + 2 ] - VAR_27 [ VAR_28 + 2 ] ; VAR_29 [ VAR_30 + 3 ] = VAR_31 [ VAR_32 + 3 ] - VAR_33 [ VAR_34 + 3 ] ; VAR_35 [ VAR_36 + 4 ] = VAR_37 [ VAR_38 + 4 ] - VAR_39 [ VAR_40 + 4 ] ; VAR_41 [ VAR_42 + 5 ] = VAR_43 [ VAR_44 + 5 ] - VAR_45 [ VAR_46 + 5 ] ; VAR_47 [ VAR_48 + 6 ] = VAR_49 [ VAR_50 + 6 ] - VAR_51 [ VAR_52 + 6 ] ; VAR_53 [ VAR_54 + 7 ] = VAR_55 [ VAR_56 + 7 ] - VAR_57 [ VAR_58 + 7 ] ; } } else <S2SV_StartBug> for ( VAR_59 = 0 ; VAR_60 <= VAR_61 - sizeof ( TYPE_8 ) ; VAR_62 += sizeof ( TYPE_9 ) ) { <S2SV_EndBug> TYPE_10 VAR_63 = * ( TYPE_11 * ) ( VAR_64 + VAR_65 ) ; TYPE_12 VAR_66 = * ( TYPE_13 * ) ( VAR_67 + VAR_68 ) ; * ( TYPE_14 * ) ( VAR_69 + VAR_70 ) = ( ( VAR_71 | VAR_72 ) - ( VAR_73 & VAR_74 ) ) ^ ( ( VAR_75 ^ VAR_76 ^ VAR_77 ) & VAR_78 ) ; } for ( ; VAR_79 < VAR_80 ; VAR_81 ++ ) VAR_82 [ VAR_83 + 0 ] = VAR_84 [ VAR_85 + 0 ] - VAR_86 [ VAR_87 + 0 ] ; }",<S2SV_ModStart> <= VAR_80 - ( TYPE_4 ),"CWE-189 static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ;  if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else   <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }",<S2SV_ModStart> <= w - ( int )
542,"CWE-000 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 ; VAR_3 = METHOD_1 ( VAR_4 ) ; if ( VAR_5 ) { METHOD_2 ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , VAR_6 ) ; return - VAR_7 ; } <S2SV_StartBug> if ( ! METHOD_3 ( VAR_8 , 0 , VAR_9 , VAR_10 ) ) { <S2SV_EndBug> METHOD_4 ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - VAR_11 ; } if ( VAR_12 ) { if ( ! METHOD_5 ( VAR_13 , 0 , VAR_14 , VAR_15 ) ) { METHOD_6 ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - VAR_16 ; } } if ( METHOD_7 ( VAR_17 , VAR_18 ) < 0 ) { METHOD_8 ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - VAR_19 ; } return 0 ; }","<S2SV_ModStart> } if ( METHOD_9 ( VAR_20 ) ) { if ( VAR_1 == VAR_21 ) VAR_1 = METHOD_10 ( VAR_17 ) ; VAR_6 = METHOD_11 ( VAR_17 , VAR_1 ) ; if ( VAR_6 ) { METHOD_8 ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , VAR_6 ) ; return - VAR_22 ; } } if (","CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } <S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }","<S2SV_ModStart> } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if ("
543,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 VAR_1 ; struct STRUCT_OR_UNION_2 * VAR_2 ; TYPE_1 VAR_3 ; TYPE_2 VAR_4 ; TYPE_3 VAR_5 ; if ( ! METHOD_1 ( VAR_6 ) ) return 0 ; VAR_7 = ! ( VAR_8 -> VAR_9 & VAR_10 ) ; METHOD_2 ( VAR_11 ) ; VAR_12 = METHOD_3 ( & VAR_13 -> VAR_14 ) ; if ( ! VAR_15 ) { VAR_16 -> VAR_17 |= VAR_18 ; return 0 ; } METHOD_4 ( & VAR_19 , 0 , sizeof ( VAR_20 ) ) ; if ( VAR_21 ) { VAR_22 . VAR_23 = METHOD_5 ( VAR_24 -> VAR_25 ) ; VAR_26 . VAR_27 = METHOD_6 ( VAR_28 -> VAR_29 ) ; VAR_30 = VAR_31 ; if ( METHOD_7 ( VAR_32 -> VAR_33 . VAR_34 ) ) VAR_35 |= METHOD_8 ( VAR_36 -> VAR_37 ) ; } else { VAR_38 = VAR_39 | METHOD_9 ( VAR_40 -> VAR_41 ) ; } VAR_42 = METHOD_10 ( VAR_43 , VAR_44 , & VAR_45 ) ; if ( VAR_46 < 0 ) { if ( VAR_47 -> VAR_48 ) METHOD_11 ( VAR_49 -> VAR_50 , 0 , sizeof ( struct STRUCT_OR_UNION_3 ) ) ; VAR_51 -> VAR_52 -- ; <S2SV_StartBug> METHOD_12 ( VAR_53 , VAR_54 , VAR_55 ) ; <S2SV_EndBug> return VAR_56 ; } VAR_57 -> VAR_58 |= VAR_59 ; if ( VAR_60 ) { VAR_61 -> VAR_62 = METHOD_13 ( VAR_63 ) ; METHOD_14 ( ! VAR_64 -> VAR_65 ) ; } return 0 ; }","<S2SV_ModStart> VAR_52 -- ; METHOD_15 <S2SV_ModEnd> ( VAR_64 ,","CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }","<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,"
544,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 ) { struct STRUCT_OR_UNION_1 * VAR_3 = ( struct STRUCT_OR_UNION_2 * ) VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 = VAR_7 ; TYPE_3 VAR_8 = 0 ; unsigned TYPE_4 VAR_9 ; TYPE_5 VAR_10 = 0 ; METHOD_1 ( & VAR_11 -> VAR_12 , VAR_13 ) ; if ( ! VAR_14 -> VAR_15 ) METHOD_2 ( VAR_16 , 0 ) ; if ( VAR_17 -> VAR_18 ) { VAR_19 = VAR_20 -> VAR_21 -> VAR_22 . VAR_23 -> VAR_24 ; VAR_25 = VAR_26 -> VAR_27 -> VAR_28 . VAR_29 -> VAR_30 ; } if ( VAR_31 -> VAR_32 ) VAR_33 = - VAR_34 ; else if ( ! VAR_35 ) VAR_36 = - VAR_37 ; METHOD_3 ( & VAR_38 -> VAR_39 , VAR_40 ) ; <S2SV_StartBug> return VAR_41 ? : METHOD_4 ( VAR_42 , VAR_43 , VAR_44 , VAR_45 ) ; <S2SV_EndBug> }","<S2SV_ModStart> VAR_40 ) ; if ( ! VAR_41 && VAR_4 -> VAR_46 != METHOD_5 ( VAR_42 -> VAR_47 ) >> VAR_48 ) VAR_41 = METHOD_6 ( VAR_7 , VAR_44 ) ;","CWE-264 static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; <S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> }","<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;"
545,"CWE-20 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; TYPE_3 VAR_6 = 0 ; TYPE_4 VAR_7 , VAR_8 = 0 ; TYPE_5 VAR_9 ; if ( VAR_10 & VAR_11 ) <S2SV_StartBug> return - VAR_12 ; <S2SV_EndBug> VAR_13 -> VAR_14 = 0 ; METHOD_1 ( ""sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu"" , VAR_15 , VAR_16 ) ; METHOD_2 ( VAR_17 ) ; VAR_18 = METHOD_3 ( VAR_19 , VAR_20 & VAR_21 , VAR_22 ) ; VAR_23 = METHOD_4 ( VAR_24 , VAR_25 & VAR_26 ) ; do { struct STRUCT_OR_UNION_6 * VAR_27 ; TYPE_6 VAR_28 ; VAR_29 = METHOD_5 ( & VAR_30 -> VAR_31 ) ; if ( ! VAR_32 ) { if ( VAR_33 >= VAR_34 ) break ; VAR_35 = METHOD_6 ( VAR_36 ) ; if ( VAR_37 ) break ; if ( VAR_38 -> VAR_39 & VAR_40 ) break ; VAR_41 = - VAR_42 ; if ( ! VAR_43 ) break ; VAR_44 = METHOD_7 ( VAR_45 , VAR_46 ) ; if ( METHOD_8 ( VAR_47 ) ) { VAR_48 = METHOD_9 ( VAR_49 ) ; goto VAR_50 ; } continue ; } VAR_51 = min_t ( unsigned TYPE_7 , VAR_52 -> VAR_53 , VAR_54 ) ; if ( METHOD_10 ( VAR_55 , 0 , VAR_56 -> VAR_57 , VAR_58 ) ) { METHOD_11 ( & VAR_59 -> VAR_60 , VAR_61 ) ; if ( ! VAR_62 ) VAR_63 = - VAR_64 ; break ; } VAR_65 += VAR_66 ; VAR_67 -= VAR_68 ; METHOD_12 ( VAR_69 , VAR_70 , VAR_71 ) ; if ( ! ( VAR_72 & VAR_73 ) ) { TYPE_8 VAR_74 = METHOD_13 ( VAR_75 ) ; if ( VAR_76 <= VAR_77 ) { METHOD_14 ( VAR_78 , VAR_79 ) ; } else { struct STRUCT_OR_UNION_7 * VAR_80 ; METHOD_15 ( VAR_81 , VAR_82 ) ; VAR_83 -= VAR_84 ; METHOD_16 ( VAR_85 , VAR_86 ) { if ( VAR_87 <= VAR_88 -> VAR_89 ) { VAR_90 -> VAR_91 -= VAR_92 ; VAR_93 -> VAR_94 -= VAR_95 ; METHOD_17 ( VAR_96 , VAR_97 ) ; break ; } else if ( VAR_98 -> VAR_99 ) { VAR_100 -= VAR_101 -> VAR_102 ; VAR_103 -> VAR_104 -= VAR_105 -> VAR_106 ; VAR_107 -> VAR_108 -= VAR_109 -> VAR_110 ; METHOD_18 ( VAR_111 , VAR_112 -> VAR_113 ) ; } } } if ( VAR_114 -> VAR_115 ) { METHOD_19 ( & VAR_116 -> VAR_117 , VAR_118 ) ; break ; } METHOD_20 ( VAR_119 ) ; } else { METHOD_21 ( & VAR_120 -> VAR_121 , VAR_122 ) ; break ; } } while ( VAR_123 ) ; VAR_124 : METHOD_22 ( VAR_125 ) ; return VAR_126 ? : VAR_127 ; }",<S2SV_ModStart> return - VAR_12 <S2SV_ModEnd> ; METHOD_1 (,"CWE-20 int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu"" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }",<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
546,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 * VAR_2 , struct STRUCT_OR_UNION_2 * * VAR_3 ) { struct STRUCT_OR_UNION_3 * VAR_4 = VAR_5 , * VAR_6 ; unsigned TYPE_2 VAR_7 ; struct STRUCT_OR_UNION_4 * * VAR_8 = VAR_9 ; struct STRUCT_OR_UNION_5 * VAR_10 ; TYPE_3 * VAR_11 ; unsigned TYPE_4 VAR_12 ; TYPE_5 VAR_13 ; unsigned TYPE_6 VAR_14 ; TYPE_7 VAR_15 ; TYPE_8 VAR_16 ; <S2SV_StartBug> if ( VAR_17 -> VAR_18 == 0 ) { <S2SV_EndBug> VAR_19 = - VAR_20 ; goto VAR_21 ; } if ( ! VAR_22 -> VAR_23 -> METHOD_1 ) { VAR_24 = - VAR_25 ; goto VAR_26 ; } VAR_27 = METHOD_2 ( & VAR_28 -> VAR_29 ) ; if ( VAR_30 == 0 ) { VAR_31 = - VAR_32 ; goto VAR_33 ; } if ( ( VAR_34 - 1 ) > ( VAR_35 >> VAR_36 ) ) { VAR_37 = - VAR_38 ; goto VAR_39 ; } METHOD_3 ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n"" , VAR_40 -> VAR_41 . VAR_42 , VAR_43 -> VAR_44 . VAR_45 , VAR_46 ) ; VAR_47 = METHOD_4 ( VAR_48 , sizeof ( struct STRUCT_OR_UNION_6 * ) , VAR_49 ) ; if ( ! VAR_50 ) { VAR_51 = - VAR_52 ; goto VAR_53 ; } VAR_54 = METHOD_5 ( sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_55 ) ; if ( ! VAR_56 ) { VAR_57 = - VAR_58 ; goto VAR_59 ; } METHOD_6 ( & VAR_60 -> VAR_61 , 1 ) ; METHOD_7 ( & VAR_62 -> VAR_63 ) ; VAR_64 -> VAR_65 = VAR_66 -> VAR_67 ; VAR_68 -> VAR_69 = VAR_70 ; if ( VAR_71 -> VAR_72 & VAR_73 ) VAR_74 -> VAR_75 = 1 ; if ( VAR_76 -> VAR_77 & VAR_78 ) VAR_79 -> VAR_80 = 1 ; if ( VAR_81 -> VAR_82 & VAR_83 ) VAR_84 -> VAR_85 = 1 ; VAR_86 = METHOD_8 ( VAR_87 -> VAR_88 . VAR_89 , VAR_90 , VAR_91 , 1 ) ; if ( VAR_92 < 0 ) goto VAR_93 ; VAR_94 = VAR_95 ; VAR_96 = METHOD_9 ( VAR_97 , sizeof ( * VAR_98 ) , VAR_99 ) ; if ( ! VAR_100 ) { VAR_101 = - VAR_102 ; goto VAR_103 ; } METHOD_10 ( ! VAR_104 ) ; METHOD_11 ( VAR_105 , VAR_106 ) ; for ( VAR_107 = 0 ; VAR_108 < VAR_109 ; VAR_110 ++ ) METHOD_12 ( & VAR_111 [ VAR_112 ] , VAR_113 [ VAR_114 ] , VAR_115 , 0 ) ; METHOD_13 ( ""RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n"" , VAR_116 ) ; VAR_117 = VAR_118 -> VAR_119 -> METHOD_14 ( VAR_120 , VAR_121 , VAR_122 , & VAR_123 -> VAR_124 ) ; if ( METHOD_15 ( VAR_125 ) ) { for ( VAR_126 = 0 ; VAR_127 < VAR_128 ; VAR_129 ++ ) METHOD_16 ( METHOD_17 ( & VAR_130 [ VAR_131 ] ) ) ; METHOD_18 ( VAR_132 ) ; VAR_133 = METHOD_19 ( VAR_134 ) ; goto VAR_135 ; } VAR_136 -> VAR_137 = VAR_138 ; METHOD_20 ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n"" , VAR_139 -> VAR_140 , ( TYPE_9 * ) ( unsigned TYPE_10 ) VAR_141 -> VAR_142 ) ; VAR_143 = METHOD_21 ( VAR_144 -> VAR_145 , VAR_146 -> VAR_147 . VAR_148 & ~ VAR_149 ) ; if ( VAR_150 ) * VAR_151 = VAR_152 ; if ( VAR_153 -> VAR_154 && METHOD_22 ( VAR_155 , ( TYPE_11 TYPE_12 * ) ( unsigned TYPE_13 ) VAR_156 -> VAR_157 ) ) { VAR_158 = - VAR_159 ; goto VAR_160 ; } METHOD_23 ( & VAR_161 -> VAR_162 , VAR_163 ) ; VAR_164 = METHOD_24 ( & VAR_165 -> VAR_166 , VAR_167 -> VAR_168 , VAR_169 ) ; METHOD_25 ( & VAR_170 -> VAR_171 , VAR_172 ) ; METHOD_26 ( VAR_173 && VAR_174 != VAR_175 ) ; METHOD_27 ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n"" , VAR_176 -> VAR_177 ) ; if ( VAR_178 ) { METHOD_28 ( & VAR_179 -> VAR_180 ) ; * VAR_181 = VAR_182 ; } VAR_183 = 0 ; VAR_184 : METHOD_29 ( VAR_185 ) ; if ( VAR_186 ) METHOD_30 ( VAR_187 ) ; return VAR_188 ; }",<S2SV_ModStart> VAR_18 == 0 || ! VAR_170 -> VAR_119,"CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n"" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( ""RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n"" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n"" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n"" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }",<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
547,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { TYPE_1 VAR_3 = VAR_4 -> VAR_5 . VAR_6 ; unsigned TYPE_2 VAR_7 ; TYPE_3 VAR_8 = - VAR_9 ; if ( VAR_10 -> VAR_11 . VAR_12 & VAR_13 ) { METHOD_1 ( VAR_14 , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , VAR_15 -> VAR_16 . VAR_17 ) ; return VAR_18 ; } METHOD_2 ( VAR_19 , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , VAR_20 ) ; METHOD_3 ( & VAR_21 -> VAR_22 -> VAR_23 , VAR_24 ) ; switch ( VAR_25 -> VAR_26 . VAR_27 . VAR_28 ) { case VAR_29 : METHOD_4 ( VAR_30 , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> METHOD_5 ( VAR_31 , VAR_32 ) ; <S2SV_EndBug> VAR_33 = 0 ; break ; case VAR_34 : METHOD_6 ( VAR_35 , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , VAR_36 ) ; break ; case VAR_37 : METHOD_7 ( VAR_38 , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , VAR_39 ) ; break ; case VAR_40 : METHOD_8 ( VAR_41 , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , VAR_42 ) ; break ; default : METHOD_9 ( VAR_43 , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , VAR_44 -> VAR_45 . VAR_46 . VAR_47 ) ; break ; } METHOD_10 ( VAR_48 , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , VAR_49 -> VAR_50 [ VAR_51 ] . VAR_52 . VAR_53 == VAR_54 ? ""Modified"" : ""Added"" , VAR_55 , VAR_56 -> VAR_57 [ VAR_58 ] . VAR_59 . VAR_60 . VAR_61 ) ; METHOD_11 ( VAR_62 , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , VAR_63 -> VAR_64 [ VAR_65 ] . VAR_66 . VAR_67 == VAR_68 ? ""Modified"" : ""Added"" , VAR_69 -> VAR_70 . VAR_71 ) ; METHOD_12 ( & VAR_72 -> VAR_73 -> VAR_74 , VAR_75 ) ; return VAR_76 ; }","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; VAR_76 = METHOD_5 ( VAR_72 , VAR_65 ) <S2SV_ModEnd> ; break ;","CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;"
548,"CWE-119 static TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , TYPE_2 * VAR_2 ) { unsigned TYPE_3 VAR_3 ; for ( VAR_4 = 0 ; VAR_5 < VAR_6 ; VAR_7 ++ ) { unsigned TYPE_4 VAR_8 = VAR_9 -> VAR_10 [ VAR_11 ] ; struct STRUCT_OR_UNION_1 * VAR_12 = ( struct STRUCT_OR_UNION_2 * ) ( VAR_13 + VAR_14 ) ; if ( ! ( VAR_15 & ( 1 << VAR_16 ) ) ) continue ; VAR_17 -> VAR_18 . VAR_19 = VAR_20 ; for ( ; ; ) { const struct STRUCT_OR_UNION_3 * VAR_21 = ( TYPE_5 * ) METHOD_1 ( VAR_22 ) ; TYPE_6 VAR_23 = VAR_24 -> VAR_25 & ( 1 << VAR_26 ) ; if ( VAR_27 -> VAR_28 & ( 1 << VAR_29 ) ) { METHOD_2 ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , VAR_30 , VAR_31 , VAR_32 -> VAR_33 ) ; return 0 ; } VAR_34 -> VAR_35 |= ( ( 1 << VAR_36 ) | ( 1 << VAR_37 ) ) ; <S2SV_StartBug> if ( ( VAR_38 -> VAR_39 == sizeof ( struct STRUCT_OR_UNION_4 ) && <S2SV_EndBug> ( METHOD_3 ( VAR_40 -> VAR_41 . VAR_42 . VAR_43 . VAR_44 , VAR_45 ) == 0 ) && <S2SV_StartBug> VAR_46 -> VAR_47 < 0 && <S2SV_EndBug> METHOD_4 ( & VAR_48 -> VAR_49 ) ) || VAR_50 ) { unsigned TYPE_7 VAR_51 , VAR_52 ; if ( ( METHOD_5 ( VAR_53 -> VAR_54 . VAR_55 . VAR_56 . VAR_57 , VAR_58 ) == 0 ) && VAR_59 -> VAR_60 < - VAR_61 - 1 ) { METHOD_6 ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , VAR_62 -> VAR_63 ) ; return 0 ; } do { VAR_64 -> VAR_65 ^= ( 1 << VAR_66 ) ; TYPE_8 TYPE_9 if ( VAR_67 -> VAR_68 & ( 1 << VAR_69 ) ) { METHOD_7 ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , VAR_70 , VAR_71 ) ; } VAR_72 = VAR_73 ; VAR_74 = VAR_75 -> VAR_76 . VAR_77 ; VAR_78 -> VAR_79 . VAR_80 = 0 ; if ( VAR_81 == VAR_82 ) goto VAR_83 ; VAR_84 = ( struct STRUCT_OR_UNION_5 * ) ( VAR_85 + VAR_86 ) ; } while ( VAR_87 == VAR_88 + VAR_89 -> VAR_90 ) ; VAR_91 = VAR_92 -> VAR_93 ; VAR_94 = ( struct STRUCT_OR_UNION_6 * ) ( VAR_95 + VAR_96 + VAR_97 ) ; VAR_98 -> VAR_99 . VAR_100 = VAR_101 ; VAR_102 += VAR_103 ; } else { TYPE_10 VAR_104 = VAR_105 -> VAR_106 ; if ( METHOD_8 ( VAR_107 -> VAR_108 . VAR_109 . VAR_110 . VAR_111 , VAR_112 ) == 0 && VAR_113 >= 0 ) { if ( VAR_114 > VAR_115 -> VAR_116 - sizeof ( struct STRUCT_OR_UNION_7 ) ) { METHOD_9 ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , VAR_117 ) ; return 0 ; } METHOD_10 ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , VAR_118 , VAR_119 ) ; } else { VAR_120 = VAR_121 + VAR_122 -> VAR_123 ; } VAR_124 = ( struct STRUCT_OR_UNION_8 * ) ( VAR_125 + VAR_126 ) ; VAR_127 -> VAR_128 . VAR_129 = VAR_130 ; VAR_131 = VAR_132 ; } } VAR_133 : METHOD_11 ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , VAR_134 ) ; } return 1 ; }",<S2SV_ModStart> if ( ( METHOD_4 ( VAR_127 <S2SV_ModEnd> ) && ( <S2SV_ModStart> VAR_106 < 0 <S2SV_ModEnd> ) || VAR_50,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ;  ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; }   oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }",<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
549,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 -> VAR_4 [ 0 ] ; struct STRUCT_OR_UNION_3 * VAR_5 = VAR_6 -> VAR_7 [ 1 ] ; struct STRUCT_OR_UNION_4 * VAR_8 ; struct STRUCT_OR_UNION_5 * VAR_9 ; struct STRUCT_OR_UNION_6 * STRUCT_OR_UNION_7 ; TYPE_1 VAR_10 , VAR_11 , VAR_12 = 0 , VAR_13 , VAR_14 ; enum VAR_15 VAR_16 ; TYPE_2 VAR_17 ; if ( ! METHOD_1 ( VAR_18 -> VAR_19 [ VAR_20 ] ) ) return - VAR_21 ; STRUCT_OR_UNION_8 = & VAR_22 -> STRUCT_OR_UNION_9 ; if ( ! VAR_23 -> VAR_24 -> METHOD_2 ) return - VAR_25 ; if ( VAR_26 -> VAR_27 ) return - VAR_28 ; if ( VAR_29 -> VAR_30 [ VAR_31 ] ) { VAR_32 = METHOD_3 ( VAR_33 -> VAR_34 [ VAR_35 ] ) ; if ( ! VAR_36 ) return - VAR_37 ; } else { VAR_38 = 0 ; for ( VAR_39 = 0 ; VAR_40 < VAR_41 ; VAR_42 ++ ) if ( STRUCT_OR_UNION_10 -> VAR_43 [ VAR_44 ] ) VAR_45 += STRUCT_OR_UNION_11 -> VAR_46 [ VAR_47 ] -> VAR_48 ; } if ( VAR_49 -> VAR_50 [ VAR_51 ] ) METHOD_4 ( VAR_52 , VAR_53 -> VAR_54 [ VAR_55 ] , VAR_56 ) VAR_57 ++ ; if ( VAR_58 > STRUCT_OR_UNION_12 -> VAR_59 ) return - VAR_60 ; if ( VAR_61 -> VAR_62 [ VAR_63 ] ) VAR_64 = METHOD_5 ( VAR_65 -> VAR_66 [ VAR_67 ] ) ; else VAR_68 = 0 ; if ( VAR_69 > STRUCT_OR_UNION_13 -> VAR_70 ) return - VAR_71 ; VAR_72 = METHOD_6 ( sizeof ( * VAR_73 ) + sizeof ( * VAR_74 -> VAR_75 ) * VAR_76 + sizeof ( * VAR_77 -> VAR_78 ) * VAR_79 + VAR_80 , VAR_81 ) ; if ( ! VAR_82 ) return - VAR_83 ; if ( VAR_84 ) VAR_85 -> VAR_86 = ( TYPE_3 * ) & VAR_87 -> VAR_88 [ VAR_89 ] ; VAR_90 -> VAR_91 = VAR_92 ; if ( VAR_93 ) { if ( VAR_94 -> VAR_95 ) VAR_96 -> VAR_97 = ( TYPE_4 * ) ( VAR_98 -> VAR_99 + VAR_100 ) ; else VAR_101 -> VAR_102 = ( TYPE_5 * ) ( VAR_103 -> VAR_104 + VAR_105 ) ; } VAR_106 = 0 ; if ( VAR_107 -> VAR_108 [ VAR_109 ] ) { METHOD_7 ( VAR_110 , VAR_111 -> VAR_112 [ VAR_113 ] , VAR_114 ) { struct STRUCT_OR_UNION_14 * VAR_115 ; VAR_116 = METHOD_8 ( STRUCT_OR_UNION_15 , METHOD_9 ( VAR_117 ) ) ; if ( ! VAR_118 ) { VAR_119 = - VAR_120 ; goto VAR_121 ; } if ( VAR_122 -> VAR_123 & VAR_124 ) continue ; VAR_125 -> VAR_126 [ VAR_127 ] = VAR_128 ; VAR_129 ++ ; } } else { for ( VAR_130 = 0 ; VAR_131 < VAR_132 ; VAR_133 ++ ) { TYPE_6 VAR_134 ; if ( ! STRUCT_OR_UNION_16 -> VAR_135 [ VAR_136 ] ) continue ; for ( VAR_137 = 0 ; VAR_138 < STRUCT_OR_UNION_17 -> VAR_139 [ VAR_140 ] -> VAR_141 ; VAR_142 ++ ) { struct STRUCT_OR_UNION_18 * VAR_143 ; VAR_144 = & STRUCT_OR_UNION_19 -> VAR_145 [ VAR_146 ] -> VAR_147 [ VAR_148 ] ; if ( VAR_149 -> VAR_150 & VAR_151 ) continue ; VAR_152 -> VAR_153 [ VAR_154 ] = VAR_155 ; VAR_156 ++ ; } } } if ( ! VAR_157 ) { VAR_158 = - VAR_159 ; goto VAR_160 ; } VAR_161 -> VAR_162 = VAR_163 ; VAR_164 = 0 ; if ( VAR_165 -> VAR_166 [ VAR_167 ] ) { <S2SV_StartBug> METHOD_10 ( VAR_168 , VAR_169 -> VAR_170 [ VAR_171 ] , VAR_172 ) { <S2SV_EndBug> if ( VAR_173 -> VAR_174 [ VAR_175 ] . VAR_176 > VAR_177 ) { VAR_178 = - VAR_179 ; goto VAR_180 ; } METHOD_11 ( VAR_181 -> VAR_182 [ VAR_183 ] . VAR_184 , METHOD_12 ( VAR_185 ) , METHOD_13 ( VAR_186 ) ) ; <S2SV_StartBug> VAR_187 -> VAR_188 [ VAR_189 ] . VAR_190 = METHOD_14 ( VAR_191 ) ; <S2SV_EndBug> VAR_192 ++ ; } } if ( VAR_193 -> VAR_194 [ VAR_195 ] ) { VAR_196 -> VAR_197 = METHOD_15 ( VAR_198 -> VAR_199 [ VAR_200 ] ) ; METHOD_16 ( ( TYPE_7 * ) VAR_201 -> VAR_202 , METHOD_17 ( VAR_203 -> VAR_204 [ VAR_205 ] ) , VAR_206 -> VAR_207 ) ; } VAR_208 -> VAR_209 = VAR_210 ; VAR_211 -> STRUCT_OR_UNION_20 = & VAR_212 -> STRUCT_OR_UNION_21 ; VAR_213 -> VAR_214 = VAR_215 ; VAR_216 = VAR_217 -> VAR_218 -> METHOD_18 ( & VAR_219 -> STRUCT_OR_UNION_22 , VAR_220 , VAR_221 ) ; if ( ! VAR_222 ) { METHOD_19 ( VAR_223 , VAR_224 ) ; METHOD_20 ( VAR_225 ) ; } else { VAR_226 : VAR_227 -> VAR_228 = VAR_229 ; METHOD_21 ( VAR_230 ) ; } return VAR_231 ; }",<S2SV_ModStart> VAR_172 ) { VAR_230 -> VAR_188 [ VAR_192 ] . VAR_190 = METHOD_15 ( VAR_191 ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> VAR_192 ++ ;,"CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }",<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
550,"CWE-476 static TYPE_0 <S2SV_StartBug> METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_EndBug> VAR_2 -> VAR_3 = VAR_4 ; VAR_5 -> VAR_6 = VAR_7 -> VAR_8 ; VAR_9 -> VAR_10 -> VAR_11 = VAR_12 ; VAR_13 -> VAR_14 = VAR_15 ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> , TYPE_2 * VAR_13 ) { if ( VAR_15 && <S2SV_ModStart> VAR_15 ; } }","CWE-476 static void <S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> newspan -> _next = before ; newspan -> _prev = before -> _prev ; before -> _prev -> _next = newspan ; before -> _prev = newspan ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> , sraSpan * before ) { if ( newspan && <S2SV_ModStart> newspan ; } }"
551,"CWE-835 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { struct STRUCT_OR_UNION_0 * VAR_3 = VAR_4 ; TYPE_4 * VAR_5 = VAR_6 -> VAR_7 -> VAR_8 ; TYPE_5 VAR_9 , VAR_10 ; <S2SV_StartBug> TYPE_6 VAR_11 = 0 ; <S2SV_EndBug> VAR_12 : if ( ! VAR_13 -> VAR_14 ) return VAR_15 ; if ( ! VAR_16 -> VAR_17 ) { TYPE_7 VAR_18 ; struct STRUCT_OR_UNION_1 * VAR_19 ; if ( VAR_20 -> VAR_21 && VAR_22 -> VAR_23 -> VAR_24 ) { VAR_25 -> VAR_26 = 0 ; for ( VAR_27 = 0 ; VAR_28 < VAR_29 -> VAR_30 ; VAR_31 ++ ) { if ( VAR_32 -> VAR_33 [ VAR_34 ] -> VAR_35 < VAR_36 ) { VAR_37 -> VAR_38 = 1 ; break ; } } } if ( ! VAR_39 -> VAR_40 ) { METHOD_1 ( VAR_41 -> VAR_42 , VAR_43 , ""No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n"" , VAR_44 -> VAR_45 ) ; return VAR_46 ; } VAR_47 = METHOD_2 ( VAR_48 ) ; VAR_49 : <S2SV_StartBug> if ( ! VAR_50 -> VAR_51 && <S2SV_EndBug> METHOD_3 ( ) - VAR_52 -> VAR_53 >= VAR_54 ) { if ( ( VAR_55 = METHOD_4 ( VAR_56 , VAR_57 -> VAR_58 , VAR_59 , VAR_60 ) ) < 0 ) { METHOD_5 ( VAR_61 -> VAR_62 , VAR_63 , ""Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n"" , VAR_64 -> VAR_65 ) ; return VAR_66 ; } VAR_67 = VAR_68 -> VAR_69 / 2 ; } if ( VAR_70 -> VAR_71 < VAR_72 -> VAR_73 ) { METHOD_6 ( VAR_74 , VAR_75 , ""skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n"" , VAR_76 -> VAR_77 - VAR_78 -> VAR_79 ) ; VAR_80 -> VAR_81 = VAR_82 -> VAR_83 ; } if ( VAR_84 -> VAR_85 >= VAR_86 -> VAR_87 + VAR_88 -> VAR_89 ) { if ( VAR_90 -> VAR_91 ) return VAR_92 ; while ( METHOD_7 ( ) - VAR_93 -> VAR_94 < VAR_95 ) { if ( METHOD_8 ( VAR_96 -> VAR_97 ) ) return VAR_98 ; METHOD_9 ( 100 * 1000 ) ; } goto VAR_99 ; } VAR_100 = METHOD_10 ( VAR_101 ) ; VAR_102 = METHOD_11 ( VAR_103 , VAR_104 ) ; if ( VAR_105 ) return VAR_106 ; VAR_107 = METHOD_12 ( VAR_108 , VAR_109 , VAR_110 ) ; if ( VAR_111 < 0 ) { if ( METHOD_13 ( VAR_112 -> VAR_113 ) ) return VAR_114 ; METHOD_14 ( VAR_115 -> VAR_116 , VAR_117 , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n"" , VAR_118 -> VAR_119 ) ; VAR_120 -> VAR_121 += 1 ; goto VAR_122 ; } VAR_123 = 1 ; } if ( VAR_124 -> VAR_125 < VAR_126 -> VAR_127 ) { TYPE_8 VAR_128 = METHOD_15 ( VAR_129 -> VAR_130 - VAR_131 -> VAR_132 , VAR_133 ) ; METHOD_16 ( VAR_134 , VAR_135 -> VAR_136 , VAR_137 ) ; VAR_138 -> VAR_139 += VAR_140 ; return VAR_141 ; } VAR_142 = METHOD_17 ( VAR_143 , METHOD_18 ( VAR_144 ) , VAR_145 , VAR_146 , VAR_147 ) ; if ( VAR_148 > 0 ) { if ( VAR_149 && VAR_150 -> VAR_151 != 0 ) { METHOD_19 ( VAR_152 , VAR_153 , VAR_154 , & VAR_155 ) ; } return VAR_156 ; } METHOD_20 ( VAR_157 -> VAR_158 , & VAR_159 -> VAR_160 ) ; VAR_161 -> VAR_162 ++ ; VAR_163 -> VAR_164 = VAR_165 -> VAR_166 ; goto VAR_167 ; }",<S2SV_ModStart> ; TYPE_8 VAR_149 = 0 ; TYPE_8 VAR_168 <S2SV_ModStart> ; VAR_122 : VAR_168 ++ ; if ( VAR_168 > VAR_163 -> VAR_169 ) return VAR_92 ;,"CWE-835 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , ""No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , ""skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n"" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }",<S2SV_ModStart> ; int just_opened = 0 ; int reload_count <S2SV_ModStart> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
552,"CWE-362 struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , const TYPE_0 * VAR_1 , TYPE_1 VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 = VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 VAR_7 ; struct STRUCT_OR_UNION_5 * VAR_8 ; TYPE_2 VAR_9 ; VAR_10 = METHOD_1 ( sizeof ( * VAR_11 ) + VAR_12 -> VAR_13 . VAR_14 , VAR_15 ) ; if ( ! VAR_16 ) return VAR_17 ; METHOD_2 ( ) ; VAR_18 = METHOD_3 ( VAR_19 -> VAR_20 ) ; if ( VAR_21 ) { VAR_22 -> VAR_23 = METHOD_4 ( VAR_24 * sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_25 ) ; if ( ! VAR_26 -> VAR_27 ) { METHOD_5 ( ) ; goto VAR_28 ; } if ( VAR_29 -> VAR_30 ) { for ( VAR_31 = 0 ; VAR_32 < VAR_33 ; VAR_34 ++ ) { VAR_35 -> VAR_36 [ VAR_37 ] . VAR_38 = VAR_39 -> VAR_40 + 1 ; VAR_41 -> VAR_42 [ VAR_43 ] . VAR_44 = METHOD_6 ( VAR_45 -> VAR_46 [ VAR_47 ] . VAR_48 , sizeof ( VAR_49 ) , VAR_50 ) ; if ( ! VAR_51 -> VAR_52 [ VAR_53 ] . VAR_54 ) { METHOD_7 ( ) ; goto VAR_55 ; } } } } METHOD_8 ( ) ; <S2SV_StartBug> METHOD_9 ( & VAR_56 -> VAR_57 ) ; <S2SV_EndBug> METHOD_10 ( & VAR_58 -> VAR_59 , VAR_60 ) ; METHOD_11 ( & VAR_61 -> VAR_62 . VAR_63 , VAR_64 ) ; METHOD_12 ( & VAR_65 -> VAR_66 . VAR_67 ) ; TYPE_3 TYPE_4 if ( VAR_68 ( & VAR_69 -> VAR_70 ) && ! VAR_71 -> VAR_72 . VAR_73 . VAR_74 ) METHOD_13 ( & VAR_75 -> VAR_76 ) ; VAR_77 -> VAR_78 = VAR_79 ; METHOD_14 ( VAR_80 -> VAR_81 . VAR_82 , VAR_83 , VAR_84 ) ; VAR_85 -> VAR_86 = VAR_87 ; VAR_88 -> VAR_89 = VAR_90 ; VAR_91 -> VAR_92 = VAR_93 ; VAR_94 -> VAR_95 = VAR_96 ; METHOD_15 ( & VAR_97 ) ; VAR_98 -> VAR_99 = VAR_100 . VAR_101 ; METHOD_16 ( & VAR_102 -> VAR_103 , 1024 , 8 ) ; for ( VAR_104 = 0 ; VAR_105 < METHOD_17 ( VAR_106 -> VAR_107 ) ; VAR_108 ++ ) METHOD_18 ( & VAR_109 -> VAR_110 [ VAR_111 ] , 1024 , 8 ) ; if ( METHOD_19 ( VAR_112 , VAR_113 , VAR_114 ) ) goto VAR_115 ; for ( VAR_116 = 0 ; VAR_117 < VAR_118 ; VAR_119 ++ ) { VAR_120 -> VAR_121 [ VAR_122 ] = VAR_123 ; } for ( VAR_124 = 0 ; VAR_125 < VAR_126 ; VAR_127 ++ ) { METHOD_20 ( & VAR_128 -> VAR_129 [ VAR_130 ] ) ; METHOD_21 ( & VAR_131 -> VAR_132 [ VAR_133 ] ) ; } for ( VAR_134 = 0 ; VAR_135 < VAR_136 ; VAR_137 ++ ) VAR_138 -> VAR_139 [ VAR_140 ] = METHOD_22 ( VAR_141 ) ; VAR_142 -> VAR_143 . VAR_144 = VAR_145 ; if ( VAR_146 -> VAR_147 . VAR_148 == VAR_149 || VAR_150 -> VAR_151 . VAR_152 == VAR_153 ) { struct STRUCT_OR_UNION_7 * VAR_154 = VAR_155 -> VAR_156 . VAR_157 -> VAR_158 [ METHOD_23 ( VAR_159 ) ] ; TYPE_5 VAR_160 = ( VAR_161 -> VAR_162 . VAR_163 & VAR_164 ) >> VAR_165 ; switch ( VAR_166 ) { case VAR_167 : VAR_168 -> VAR_169 = VAR_170 ; break ; case VAR_171 : VAR_172 -> VAR_173 = VAR_174 ; break ; case VAR_175 : VAR_176 -> VAR_177 = VAR_178 ; break ; default : METHOD_24 ( 1 ) ; } } METHOD_25 ( VAR_179 , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , VAR_180 -> VAR_181 . VAR_182 ) ; return VAR_183 ; VAR_184 : if ( VAR_185 -> VAR_186 ) { for ( VAR_187 = 0 ; VAR_188 < VAR_189 ; VAR_190 ++ ) METHOD_26 ( VAR_191 -> VAR_192 [ VAR_193 ] . VAR_194 ) ; METHOD_27 ( VAR_195 -> VAR_196 ) ; } METHOD_28 ( VAR_197 ) ; return VAR_198 ; }",<S2SV_ModStart> VAR_197 -> VAR_57 ) ; METHOD_9 ( & VAR_197 -> VAR_199,"CWE-362 struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ;  ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ;   memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }",<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
553,"CWE-787 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 * VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 * VAR_9 ; TYPE_11 VAR_10 ; TYPE_12 VAR_11 ; <S2SV_StartBug> VAR_12 = VAR_13 + 32 ; <S2SV_EndBug> VAR_14 = METHOD_1 ( VAR_15 ) ; if ( ! VAR_16 ) { METHOD_2 ( ) ; METHOD_3 ( ""[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer"" ) ; return - 1 ; } METHOD_4 ( & VAR_17 , '\\0' , sizeof ( VAR_18 ) ) ; VAR_19 . VAR_20 = VAR_21 ; VAR_22 . VAR_23 = VAR_24 ; VAR_25 . VAR_26 = VAR_27 ; VAR_28 . VAR_29 = VAR_30 ; VAR_31 . VAR_32 = VAR_33 ; VAR_34 . VAR_35 = 0 ; METHOD_5 ( & VAR_36 , VAR_37 , VAR_38 , - VAR_39 , 9 , VAR_40 ) ; METHOD_6 ( VAR_41 ) ; VAR_42 = ( TYPE_13 * ) VAR_43 + VAR_44 ; VAR_45 = VAR_46 ; while ( 1 ) { VAR_47 . VAR_48 = VAR_49 + VAR_50 . VAR_51 ; VAR_52 . VAR_53 = VAR_54 - ( VAR_55 - ( TYPE_14 * ) VAR_56 ) ; if ( VAR_57 . VAR_58 == 0 ) { VAR_59 = VAR_60 ; } VAR_61 = METHOD_7 ( & VAR_62 , VAR_63 ) ; if ( VAR_64 == VAR_65 ) { break ; } else if ( VAR_66 != VAR_67 ) { METHOD_8 ( & VAR_68 ) ; return - 1 ; } } if ( METHOD_9 ( & VAR_69 ) != VAR_70 ) { METHOD_10 ( VAR_71 ) ; return - 1 ; } * VAR_72 = VAR_73 . VAR_74 ; VAR_75 = VAR_76 + * VAR_77 ; VAR_78 = ( TYPE_15 * ) VAR_79 + VAR_80 ; VAR_81 = METHOD_11 ( VAR_82 , VAR_83 , VAR_84 ) ; * VAR_85 ++ = VAR_86 & 0xFF ; * VAR_87 ++ = ( VAR_88 >> 8 ) & 0xFF ; * VAR_89 ++ = ( VAR_90 >> 16 ) & 0xFF ; * VAR_91 ++ = ( VAR_92 >> 24 ) & 0xFF ; * VAR_93 ++ = VAR_94 & 0xFF ; * VAR_95 ++ = ( VAR_96 >> 8 ) & 0xFF ; * VAR_97 ++ = ( VAR_98 >> 16 ) & 0xFF ; * VAR_99 ++ = ( VAR_100 >> 24 ) & 0xFF ; * VAR_101 += VAR_102 + 8 ; * VAR_103 = VAR_104 ; return 0 ; }",<S2SV_ModStart> TYPE_12 VAR_92 ; TYPE_7 VAR_105 = ( ( TYPE_7 ) ( VAR_100 / 32000 ) + 1 ) * 5 ; VAR_54 = 10 + 8 + VAR_105 + VAR_100 <S2SV_ModEnd> ; VAR_104 =,"CWE-787 int flb_gzip_compress ( void * in_data , size_t in_len , void * * out_data , size_t * out_len ) { int flush ; int status ; int footer_start ; uint8_t * pb ; size_t out_size ; void * out_buf ; z_stream strm ; mz_ulong crc ; <S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> out_buf = flb_malloc ( out_size ) ; if ( ! out_buf ) { flb_errno ( ) ; flb_error ( ""[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer"" ) ; return - 1 ; } memset ( & strm , '\\0' , sizeof ( strm ) ) ; strm . zalloc = Z_NULL ; strm . zfree = Z_NULL ; strm . opaque = Z_NULL ; strm . next_in = in_data ; strm . avail_in = in_len ; strm . total_out = 0 ; deflateInit2 ( & strm , Z_DEFAULT_COMPRESSION , Z_DEFLATED , - Z_DEFAULT_WINDOW_BITS , 9 , Z_DEFAULT_STRATEGY ) ; gzip_header ( out_buf ) ; pb = ( uint8_t * ) out_buf + FLB_GZIP_HEADER_OFFSET ; flush = Z_NO_FLUSH ; while ( 1 ) { strm . next_out = pb + strm . total_out ; strm . avail_out = out_size - ( pb - ( uint8_t * ) out_buf ) ; if ( strm . avail_in == 0 ) { flush = Z_FINISH ; } status = deflate ( & strm , flush ) ; if ( status == Z_STREAM_END ) { break ; } else if ( status != Z_OK ) { deflateEnd ( & strm ) ; return - 1 ; } } if ( deflateEnd ( & strm ) != Z_OK ) { flb_free ( out_buf ) ; return - 1 ; } * out_len = strm . total_out ; footer_start = FLB_GZIP_HEADER_OFFSET + * out_len ; pb = ( uint8_t * ) out_buf + footer_start ; crc = mz_crc32 ( MZ_CRC32_INIT , in_data , in_len ) ; * pb ++ = crc & 0xFF ; * pb ++ = ( crc >> 8 ) & 0xFF ; * pb ++ = ( crc >> 16 ) & 0xFF ; * pb ++ = ( crc >> 24 ) & 0xFF ; * pb ++ = in_len & 0xFF ; * pb ++ = ( in_len >> 8 ) & 0xFF ; * pb ++ = ( in_len >> 16 ) & 0xFF ; * pb ++ = ( in_len >> 24 ) & 0xFF ; * out_len += FLB_GZIP_HEADER_OFFSET + 8 ; * out_data = out_buf ; return 0 ; }",<S2SV_ModStart> mz_ulong crc ; int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> ; out_buf =
554,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , unsigned TYPE_2 * VAR_1 , unsigned TYPE_3 * VAR_2 , unsigned TYPE_4 * VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; unsigned TYPE_7 VAR_6 [ VAR_7 ] ; unsigned TYPE_8 VAR_8 , VAR_9 ; unsigned TYPE_9 VAR_10 , VAR_11 ; unsigned TYPE_10 VAR_12 , VAR_13 ; unsigned TYPE_11 VAR_14 , VAR_15 ; if ( ! VAR_16 || ! VAR_17 || ! VAR_18 || ! VAR_19 ) { return 0 ; } if ( METHOD_1 ( VAR_20 , VAR_21 , 1 , VAR_22 ) != 1 ) { METHOD_2 ( VAR_23 , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } VAR_24 = VAR_25 [ 0 ] ; VAR_26 = VAR_27 [ 2 ] ; <S2SV_StartBug> VAR_28 = METHOD_3 ( & VAR_29 [ 5 ] ) ; <S2SV_EndBug> VAR_30 = VAR_31 [ 7 ] ; if 0 <S2SV_StartBug> VAR_32 = METHOD_4 ( & VAR_33 [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_34 = METHOD_5 ( & VAR_35 [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_36 = METHOD_6 ( & VAR_37 [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_38 = METHOD_7 ( & VAR_39 [ 14 ] ) ; <S2SV_EndBug> VAR_40 = VAR_41 [ 16 ] ; VAR_42 = VAR_43 [ 17 ] ; * VAR_44 = ( unsigned TYPE_12 ) VAR_45 ; * VAR_46 = ( unsigned TYPE_13 ) VAR_47 ; * VAR_48 = ( unsigned TYPE_14 ) VAR_49 ; if ( VAR_50 ) { unsigned TYPE_15 * VAR_51 = ( unsigned TYPE_16 * ) METHOD_8 ( VAR_52 ) ; if ( VAR_53 == 0 ) { METHOD_9 ( VAR_54 , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! METHOD_10 ( VAR_55 , VAR_56 , 1 , VAR_57 ) ) { METHOD_11 ( VAR_58 , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; METHOD_12 ( VAR_59 ) ; return 0 ; } METHOD_13 ( VAR_60 ) ; } if ( VAR_61 > 8 ) { METHOD_14 ( VAR_62 , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * VAR_63 = ! ( VAR_64 & 32 ) ; VAR_65 = VAR_66 * ( VAR_67 / 8 ) ; if ( VAR_68 > 0 ) { METHOD_15 ( VAR_69 , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; METHOD_16 ( VAR_70 , VAR_71 , VAR_72 ) ; } return 1 ; }",<S2SV_ModStart> ; VAR_66 = METHOD_17 <S2SV_ModEnd> ( & VAR_43 <S2SV_ModStart> 0 VAR_32 = METHOD_17 <S2SV_ModEnd> ( & VAR_43 <S2SV_ModStart> ; VAR_34 = METHOD_17 <S2SV_ModEnd> ( & VAR_43 <S2SV_ModStart> endif VAR_47 = METHOD_17 <S2SV_ModEnd> ( & VAR_43 <S2SV_ModStart> ; VAR_49 = METHOD_17 <S2SV_ModEnd> ( & VAR_43,"CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ;  if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug>   <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }",<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
555,"CWE-125 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 * VAR_5 ; register TYPE_7 * VAR_6 ; register TYPE_8 VAR_7 , VAR_8 ; register unsigned TYPE_9 * VAR_9 ; TYPE_10 VAR_10 ; TYPE_11 VAR_11 , VAR_12 ; TYPE_12 VAR_13 , VAR_14 , VAR_15 ; unsigned TYPE_13 * VAR_16 ; METHOD_1 ( VAR_17 != ( const TYPE_14 * ) VAR_18 ) ; METHOD_2 ( VAR_19 -> VAR_20 == VAR_21 ) ; if ( VAR_22 -> VAR_23 != VAR_24 ) ( TYPE_15 ) METHOD_3 ( VAR_25 , METHOD_4 ( ) , ""%s"" , VAR_26 -> VAR_27 ) ; METHOD_5 ( VAR_28 != ( TYPE_16 * ) VAR_29 ) ; METHOD_6 ( VAR_30 -> VAR_31 == VAR_32 ) ; VAR_33 = METHOD_7 ( VAR_34 , VAR_35 ) ; VAR_36 = METHOD_8 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; if ( VAR_41 == VAR_42 ) { VAR_43 = METHOD_9 ( VAR_44 ) ; return ( ( TYPE_17 * ) VAR_45 ) ; } VAR_46 . VAR_47 = METHOD_10 ( VAR_48 ) ; do { if ( VAR_49 . VAR_50 != 0x01DA ) METHOD_11 ( VAR_51 , ""ImproperImageHeader"" ) ; VAR_52 . VAR_53 = ( unsigned TYPE_18 ) METHOD_12 ( VAR_54 ) ; switch ( VAR_55 . VAR_56 ) { case 0x00 : VAR_57 -> VAR_58 = VAR_59 ; break ; case 0x01 : VAR_60 -> VAR_61 = VAR_62 ; break ; default : METHOD_13 ( VAR_63 , ""ImproperImageHeader"" ) ; } VAR_64 . VAR_65 = ( unsigned TYPE_19 ) METHOD_14 ( VAR_66 ) ; if ( ( VAR_67 . VAR_68 == 0 ) || ( VAR_69 . VAR_70 > 2 ) ) METHOD_15 ( VAR_71 , ""ImproperImageHeader"" ) ; VAR_72 . VAR_73 = METHOD_16 ( VAR_74 ) ; VAR_75 . VAR_76 = METHOD_17 ( VAR_77 ) ; VAR_78 . VAR_79 = METHOD_18 ( VAR_80 ) ; VAR_81 . VAR_82 = METHOD_19 ( VAR_83 ) ; if ( ( VAR_84 . VAR_85 == 0 ) || ( VAR_86 . VAR_87 > 4 ) ) METHOD_20 ( VAR_88 , ""ImproperImageHeader"" ) ; VAR_89 . VAR_90 = METHOD_21 ( VAR_91 ) ; VAR_92 . VAR_93 = METHOD_22 ( VAR_94 ) ; VAR_95 . VAR_96 = METHOD_23 ( VAR_97 ) ; <S2SV_StartBug> ( TYPE_20 ) METHOD_24 ( VAR_98 , sizeof ( VAR_99 . VAR_100 ) , ( unsigned TYPE_21 * ) <S2SV_EndBug> <S2SV_StartBug> VAR_101 . VAR_102 ) ; <S2SV_EndBug> VAR_103 . VAR_104 [ sizeof ( VAR_105 . VAR_106 ) - 1 ] = '\\0' ; if ( * VAR_107 . VAR_108 != '\\0' ) ( TYPE_22 ) METHOD_25 ( VAR_109 , ""label"" , VAR_110 . VAR_111 , VAR_112 ) ; VAR_113 . VAR_114 = METHOD_26 ( VAR_115 ) ; if ( VAR_116 . VAR_117 != 0 ) METHOD_27 ( VAR_118 , ""ImproperImageHeader"" ) ; VAR_119 = METHOD_28 ( VAR_120 , sizeof ( VAR_121 . VAR_122 ) , VAR_123 . VAR_124 ) ; <S2SV_StartBug> ( TYPE_23 ) VAR_125 ; <S2SV_EndBug> VAR_126 -> VAR_127 = VAR_128 . VAR_129 ; VAR_130 -> VAR_131 = VAR_132 . VAR_133 ; VAR_134 -> VAR_135 = ( TYPE_24 ) METHOD_29 ( VAR_136 . VAR_137 , VAR_138 ) ; if ( VAR_139 . VAR_140 == 0 ) VAR_141 -> VAR_142 = ( TYPE_25 ) METHOD_30 ( ( TYPE_26 ) 8 * VAR_143 . VAR_144 , VAR_145 ) ; if ( VAR_146 . VAR_147 < 3 ) { VAR_148 -> VAR_149 = VAR_150 ; VAR_151 -> VAR_152 = VAR_153 . VAR_154 > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( METHOD_31 ( VAR_155 ) != VAR_156 ) <S2SV_EndBug> METHOD_32 ( VAR_157 , ""ImproperImageHeader"" ) ; if ( ( VAR_158 -> VAR_159 != VAR_160 ) && ( VAR_161 -> VAR_162 != 0 ) ) if ( VAR_163 -> VAR_164 >= ( VAR_165 -> VAR_166 + VAR_167 -> VAR_168 - 1 ) ) break ; VAR_169 = METHOD_33 ( VAR_170 , VAR_171 -> VAR_172 , VAR_173 -> VAR_174 , VAR_175 ) ; if ( VAR_176 == VAR_177 ) return ( METHOD_34 ( VAR_178 ) ) ; VAR_179 = ( TYPE_27 ) VAR_180 . VAR_181 ; VAR_182 = ( TYPE_28 ) VAR_183 . VAR_184 * VAR_185 . VAR_186 ; if ( ( 4 * VAR_187 * VAR_188 ) != ( ( TYPE_29 ) ( TYPE_30 ) ( 4 * VAR_189 * VAR_190 ) ) ) METHOD_35 ( VAR_191 , ""MemoryAllocationFailed"" ) ; VAR_192 = METHOD_36 ( VAR_193 . VAR_194 , VAR_195 . VAR_196 * 4 * VAR_197 * sizeof ( * VAR_198 ) ) ; if ( VAR_199 == ( TYPE_31 * ) VAR_200 ) METHOD_37 ( VAR_201 , ""MemoryAllocationFailed"" ) ; VAR_202 = ( unsigned TYPE_32 * ) METHOD_38 ( VAR_203 ) ; if ( ( TYPE_33 ) VAR_204 . VAR_205 != 0x01 ) { unsigned TYPE_34 * VAR_206 ; VAR_207 = ( unsigned TYPE_35 * ) METHOD_39 ( VAR_208 . VAR_209 , VAR_210 * sizeof ( * VAR_211 ) ) ; if ( VAR_212 == ( unsigned TYPE_36 * ) VAR_213 ) METHOD_40 ( VAR_214 , ""MemoryAllocationFailed"" ) ; for ( VAR_215 = 0 ; VAR_216 < ( TYPE_37 ) VAR_217 . VAR_218 ; VAR_219 ++ ) { VAR_220 = VAR_221 + VAR_222 * VAR_223 ; for ( VAR_224 = 0 ; VAR_225 < ( TYPE_38 ) VAR_226 . VAR_227 ; VAR_228 ++ ) { VAR_229 = METHOD_41 ( VAR_230 , VAR_231 * VAR_232 . VAR_233 , VAR_234 ) ; if ( METHOD_42 ( VAR_235 ) != VAR_236 ) break ; if ( VAR_237 == 2 ) for ( VAR_238 = 0 ; VAR_239 < ( TYPE_39 ) VAR_240 . VAR_241 ; VAR_242 ++ ) { * VAR_243 = VAR_244 [ 2 * VAR_245 ] ; * ( VAR_246 + 1 ) = VAR_247 [ 2 * VAR_248 + 1 ] ; VAR_249 += 8 ; } else for ( VAR_250 = 0 ; VAR_251 < ( TYPE_40 ) VAR_252 . VAR_253 ; VAR_254 ++ ) { * VAR_255 = VAR_256 [ VAR_257 ] ; VAR_258 += 4 ; } } } VAR_259 = ( unsigned TYPE_41 * ) METHOD_43 ( VAR_260 ) ; } else { TYPE_42 * VAR_261 ; TYPE_43 * VAR_262 ; TYPE_44 VAR_263 , * VAR_264 ; unsigned TYPE_45 * VAR_265 ; unsigned TYPE_46 VAR_266 ; VAR_267 = ( TYPE_47 * ) METHOD_44 ( ( TYPE_48 ) VAR_268 . VAR_269 , VAR_270 . VAR_271 * sizeof ( * VAR_272 ) ) ; VAR_273 = ( TYPE_49 * ) METHOD_45 ( VAR_274 . VAR_275 , VAR_276 . VAR_277 * sizeof ( * VAR_278 ) ) ; VAR_279 = METHOD_46 ( ( TYPE_50 ) VAR_280 . VAR_281 + 10UL , 4UL * sizeof ( * VAR_282 ) ) ; if ( ( VAR_283 == ( TYPE_51 * ) VAR_284 ) || ( VAR_285 == ( TYPE_52 * ) VAR_286 ) || ( VAR_287 == ( TYPE_53 * ) VAR_288 ) ) { if ( VAR_289 == ( TYPE_54 * ) VAR_290 ) VAR_291 = ( TYPE_55 * ) METHOD_47 ( VAR_292 ) ; if ( VAR_293 == ( TYPE_56 * ) VAR_294 ) VAR_295 = ( TYPE_57 * ) METHOD_48 ( VAR_296 ) ; if ( VAR_297 == ( TYPE_58 * ) VAR_298 ) VAR_299 = METHOD_49 ( VAR_300 ) ; METHOD_50 ( VAR_301 , ""MemoryAllocationFailed"" ) ; } VAR_302 = ( unsigned TYPE_59 * ) METHOD_51 ( VAR_303 ) ; for ( VAR_304 = 0 ; VAR_305 < ( TYPE_60 ) ( VAR_306 . VAR_307 * VAR_308 . VAR_309 ) ; VAR_310 ++ ) VAR_311 [ VAR_312 ] = METHOD_52 ( VAR_313 ) ; for ( VAR_314 = 0 ; VAR_315 < ( TYPE_61 ) ( VAR_316 . VAR_317 * VAR_318 . VAR_319 ) ; VAR_320 ++ ) { VAR_321 [ VAR_322 ] = METHOD_53 ( VAR_323 ) ; if ( VAR_324 [ VAR_325 ] > ( 4 * ( TYPE_62 ) VAR_326 . VAR_327 + 10 ) ) METHOD_54 ( VAR_328 , ""ImproperImageHeader"" ) ; } VAR_329 = 0 ; VAR_330 = 0 ; for ( VAR_331 = 0 ; ( ( VAR_332 < ( TYPE_63 ) VAR_333 . VAR_334 ) && ( VAR_335 == 0 ) ) ; VAR_336 ++ ) for ( VAR_337 = 0 ; ( ( VAR_338 < ( TYPE_64 ) VAR_339 . VAR_340 ) && ( VAR_341 == 0 ) ) ; VAR_342 ++ ) { if ( VAR_343 [ VAR_344 + VAR_345 * VAR_346 . VAR_347 ] < VAR_348 ) VAR_349 = 1 ; VAR_350 = VAR_351 [ VAR_352 + VAR_353 * VAR_354 . VAR_355 ] ; } VAR_356 = ( TYPE_65 ) METHOD_55 ( VAR_357 ) ; if ( VAR_358 == 1 ) { for ( VAR_359 = 0 ; VAR_360 < ( TYPE_66 ) VAR_361 . VAR_362 ; VAR_363 ++ ) { VAR_364 = VAR_365 ; for ( VAR_366 = 0 ; VAR_367 < ( TYPE_67 ) VAR_368 . VAR_369 ; VAR_370 ++ ) { if ( VAR_371 != VAR_372 [ VAR_373 + VAR_374 * VAR_375 . VAR_376 ] ) { VAR_377 = VAR_378 [ VAR_379 + VAR_380 * VAR_381 . VAR_382 ] ; VAR_383 = ( TYPE_68 ) METHOD_56 ( VAR_384 , ( TYPE_69 ) VAR_385 , VAR_386 ) ; } VAR_387 = METHOD_57 ( VAR_388 , ( TYPE_70 ) VAR_389 [ VAR_390 + VAR_391 * VAR_392 . VAR_393 ] , VAR_394 ) ; if ( METHOD_58 ( VAR_395 ) != VAR_396 ) break ; VAR_397 += ( TYPE_71 ) VAR_398 [ VAR_399 + VAR_400 * VAR_401 . VAR_402 ] ; VAR_403 = METHOD_59 ( VAR_404 , ( TYPE_72 ) ( VAR_405 [ VAR_406 + VAR_407 * VAR_408 . VAR_409 ] / VAR_410 ) , VAR_411 , 1L * VAR_412 . VAR_413 , VAR_414 + VAR_415 * VAR_416 ) ; if ( VAR_417 == VAR_418 ) METHOD_60 ( VAR_419 , ""ImproperImageHeader"" ) ; VAR_420 += ( VAR_421 . VAR_422 * 4 * VAR_423 ) ; } } } else { TYPE_73 VAR_424 ; VAR_425 = METHOD_61 ( VAR_426 ) ; VAR_427 = VAR_428 ; for ( VAR_429 = 0 ; VAR_430 < ( TYPE_74 ) VAR_431 . VAR_432 ; VAR_433 ++ ) { for ( VAR_434 = 0 ; VAR_435 < ( TYPE_75 ) VAR_436 . VAR_437 ; VAR_438 ++ ) { if ( VAR_439 != VAR_440 [ VAR_441 + VAR_442 * VAR_443 . VAR_444 ] ) { VAR_445 = VAR_446 [ VAR_447 + VAR_448 * VAR_449 . VAR_450 ] ; VAR_451 = ( TYPE_76 ) METHOD_62 ( VAR_452 , ( TYPE_77 ) VAR_453 , VAR_454 ) ; } VAR_455 = METHOD_63 ( VAR_456 , ( TYPE_78 ) VAR_457 [ VAR_458 + VAR_459 * VAR_460 . VAR_461 ] , VAR_462 ) ; if ( METHOD_64 ( VAR_463 ) != VAR_464 ) break ; VAR_465 += ( TYPE_79 ) VAR_466 [ VAR_467 + VAR_468 * VAR_469 . VAR_470 ] ; VAR_471 = METHOD_65 ( VAR_472 , ( TYPE_80 ) ( VAR_473 [ VAR_474 + VAR_475 * VAR_476 . VAR_477 ] / VAR_478 ) , VAR_479 , 1L * VAR_480 . VAR_481 , VAR_482 + VAR_483 * VAR_484 ) ; if ( VAR_485 == VAR_486 ) METHOD_66 ( VAR_487 , ""ImproperImageHeader"" ) ; } VAR_488 += ( VAR_489 . VAR_490 * 4 * VAR_491 ) ; } VAR_492 = ( TYPE_81 ) METHOD_67 ( VAR_493 , VAR_494 , VAR_495 ) ; } VAR_496 = METHOD_68 ( VAR_497 ) ; VAR_498 = ( TYPE_82 * ) METHOD_69 ( VAR_499 ) ; VAR_500 = ( TYPE_83 * ) METHOD_70 ( VAR_501 ) ; } VAR_502 -> VAR_503 = VAR_504 . VAR_505 == 4 ? VAR_506 : VAR_507 ; VAR_508 -> VAR_509 = VAR_510 . VAR_511 ; VAR_512 -> VAR_513 = VAR_514 . VAR_515 ; if ( VAR_516 -> VAR_517 == VAR_518 ) { if ( VAR_519 == 2 ) { for ( VAR_520 = 0 ; VAR_521 < ( TYPE_84 ) VAR_522 -> VAR_523 ; VAR_524 ++ ) { VAR_525 = VAR_526 + ( VAR_527 -> VAR_528 - VAR_529 - 1 ) * 8 * VAR_530 -> VAR_531 ; VAR_532 = METHOD_71 ( VAR_533 , 0 , VAR_534 , VAR_535 -> VAR_536 , 1 , VAR_537 ) ; if ( VAR_538 == ( TYPE_85 * ) VAR_539 ) break ; for ( VAR_540 = 0 ; VAR_541 < ( TYPE_86 ) VAR_542 -> VAR_543 ; VAR_544 ++ ) { METHOD_72 ( VAR_545 , METHOD_73 ( ( unsigned TYPE_87 ) ( ( * ( VAR_546 + 0 ) << 8 ) | ( * ( VAR_547 + 1 ) ) ) ) , VAR_548 ) ; METHOD_74 ( VAR_549 , METHOD_75 ( ( unsigned TYPE_88 ) ( ( * ( VAR_550 + 2 ) << 8 ) | ( * ( VAR_551 + 3 ) ) ) ) , VAR_552 ) ; METHOD_76 ( VAR_553 , METHOD_77 ( ( unsigned TYPE_89 ) ( ( * ( VAR_554 + 4 ) << 8 ) | ( * ( VAR_555 + 5 ) ) ) ) , VAR_556 ) ; METHOD_78 ( VAR_557 , VAR_558 , VAR_559 ) ; if ( VAR_560 -> VAR_561 != VAR_562 ) METHOD_79 ( VAR_563 , METHOD_80 ( ( unsigned TYPE_90 ) ( ( * ( VAR_564 + 6 ) << 8 ) | ( * ( VAR_565 + 7 ) ) ) ) , VAR_566 ) ; VAR_567 += 8 ; VAR_568 += METHOD_81 ( VAR_569 ) ; } if ( METHOD_82 ( VAR_570 , VAR_571 ) == VAR_572 ) break ; if ( VAR_573 -> VAR_574 == ( TYPE_91 * ) VAR_575 ) { VAR_576 = METHOD_83 ( VAR_577 , VAR_578 , ( TYPE_92 ) VAR_579 , VAR_580 -> VAR_581 ) ; if ( VAR_582 == VAR_583 ) break ; } } } else for ( VAR_584 = 0 ; VAR_585 < ( TYPE_93 ) VAR_586 -> VAR_587 ; VAR_588 ++ ) { VAR_589 = VAR_590 + ( VAR_591 -> VAR_592 - VAR_593 - 1 ) * 4 * VAR_594 -> VAR_595 ; VAR_596 = METHOD_84 ( VAR_597 , 0 , VAR_598 , VAR_599 -> VAR_600 , 1 , VAR_601 ) ; if ( VAR_602 == ( TYPE_94 * ) VAR_603 ) break ; for ( VAR_604 = 0 ; VAR_605 < ( TYPE_95 ) VAR_606 -> VAR_607 ; VAR_608 ++ ) { METHOD_85 ( VAR_609 , METHOD_86 ( * VAR_610 ) , VAR_611 ) ; METHOD_87 ( VAR_612 , METHOD_88 ( * ( VAR_613 + 1 ) ) , VAR_614 ) ; METHOD_89 ( VAR_615 , METHOD_90 ( * ( VAR_616 + 2 ) ) , VAR_617 ) ; METHOD_91 ( VAR_618 , VAR_619 , VAR_620 ) ; if ( VAR_621 -> VAR_622 != VAR_623 ) METHOD_92 ( VAR_624 , METHOD_93 ( * ( VAR_625 + 3 ) ) , VAR_626 ) ; VAR_627 += 4 ; VAR_628 += METHOD_94 ( VAR_629 ) ; } if ( METHOD_95 ( VAR_630 , VAR_631 ) == VAR_632 ) break ; if ( VAR_633 -> VAR_634 == ( TYPE_96 * ) VAR_635 ) { VAR_636 = METHOD_96 ( VAR_637 , VAR_638 , ( TYPE_97 ) VAR_639 , VAR_640 -> VAR_641 ) ; if ( VAR_642 == VAR_643 ) break ; } } } else { if ( METHOD_97 ( VAR_644 , VAR_645 -> VAR_646 , VAR_647 ) == VAR_648 ) METHOD_98 ( VAR_649 , ""MemoryAllocationFailed"" ) ; if ( VAR_650 == 2 ) { for ( VAR_651 = 0 ; VAR_652 < ( TYPE_98 ) VAR_653 -> VAR_654 ; VAR_655 ++ ) { VAR_656 = VAR_657 + ( VAR_658 -> VAR_659 - VAR_660 - 1 ) * 8 * VAR_661 -> VAR_662 ; VAR_663 = METHOD_99 ( VAR_664 , 0 , VAR_665 , VAR_666 -> VAR_667 , 1 , VAR_668 ) ; if ( VAR_669 == ( TYPE_99 * ) VAR_670 ) break ; for ( VAR_671 = 0 ; VAR_672 < ( TYPE_100 ) VAR_673 -> VAR_674 ; VAR_675 ++ ) { VAR_676 = ( * VAR_677 << 8 ) ; VAR_678 |= ( * ( VAR_679 + 1 ) ) ; METHOD_100 ( VAR_680 , ( TYPE_101 ) VAR_681 , VAR_682 ) ; VAR_683 += 8 ; VAR_684 += METHOD_101 ( VAR_685 ) ; } if ( METHOD_102 ( VAR_686 , VAR_687 ) == VAR_688 ) break ; if ( VAR_689 -> VAR_690 == ( TYPE_102 * ) VAR_691 ) { VAR_692 = METHOD_103 ( VAR_693 , VAR_694 , ( TYPE_103 ) VAR_695 , VAR_696 -> VAR_697 ) ; if ( VAR_698 == VAR_699 ) break ; } } } else for ( VAR_700 = 0 ; VAR_701 < ( TYPE_104 ) VAR_702 -> VAR_703 ; VAR_704 ++ ) { VAR_705 = VAR_706 + ( VAR_707 -> VAR_708 - VAR_709 - 1 ) * 4 * VAR_710 -> VAR_711 ; VAR_712 = METHOD_104 ( VAR_713 , 0 , VAR_714 , VAR_715 -> VAR_716 , 1 , VAR_717 ) ; if ( VAR_718 == ( TYPE_105 * ) VAR_719 ) break ; for ( VAR_720 = 0 ; VAR_721 < ( TYPE_106 ) VAR_722 -> VAR_723 ; VAR_724 ++ ) { METHOD_105 ( VAR_725 , * VAR_726 , VAR_727 ) ; VAR_728 += 4 ; VAR_729 += METHOD_106 ( VAR_730 ) ; } if ( METHOD_107 ( VAR_731 , VAR_732 ) == VAR_733 ) break ; if ( VAR_734 -> VAR_735 == ( TYPE_107 * ) VAR_736 ) { VAR_737 = METHOD_108 ( VAR_738 , VAR_739 , ( TYPE_108 ) VAR_740 , VAR_741 -> VAR_742 ) ; if ( VAR_743 == VAR_744 ) break ; } } ( TYPE_109 ) METHOD_109 ( VAR_745 , VAR_746 ) ; } VAR_747 = METHOD_110 ( VAR_748 ) ; if ( METHOD_111 ( VAR_749 ) != VAR_750 ) { METHOD_112 ( VAR_751 , VAR_752 , ""UnexpectedEndOfFile"" , VAR_753 -> VAR_754 ) ; break ; } if ( VAR_755 -> VAR_756 != 0 ) if ( VAR_757 -> VAR_758 >= ( VAR_759 -> VAR_760 + VAR_761 -> VAR_762 - 1 ) ) break ; VAR_763 . VAR_764 = METHOD_113 ( VAR_765 ) ; if ( VAR_766 . VAR_767 == 0x01DA ) { METHOD_114 ( VAR_768 , VAR_769 , VAR_770 ) ; if ( METHOD_115 ( VAR_771 ) == ( TYPE_110 * ) VAR_772 ) { VAR_773 = METHOD_116 ( VAR_774 ) ; return ( ( TYPE_111 * ) VAR_775 ) ; } VAR_776 = METHOD_117 ( VAR_777 ) ; VAR_778 = METHOD_118 ( VAR_779 , VAR_780 , METHOD_119 ( VAR_781 ) , METHOD_120 ( VAR_782 ) ) ; if ( VAR_783 == VAR_784 ) break ; } } while ( VAR_785 . VAR_786 == 0x01DA ) ; ( TYPE_112 ) METHOD_121 ( VAR_787 ) ; return ( METHOD_122 ( VAR_788 ) ) ; }","<S2SV_ModStart> VAR_788 ) ; VAR_455 = <S2SV_ModEnd> METHOD_63 ( VAR_788 <S2SV_ModStart> VAR_785 . VAR_111 ) ; if ( VAR_455 != sizeof ( VAR_785 . VAR_111 ) ) METHOD_98 ( VAR_752 , ""ImproperImageHeader"" <S2SV_ModStart> VAR_124 ) ; if ( VAR_455 != sizeof ( VAR_785 . VAR_124 ) ) METHOD_98 ( VAR_752 , ""ImproperImageHeader"" ) <S2SV_ModEnd> ; VAR_788 -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( VAR_768 ->","CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->"
556,"CWE-20 TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { TYPE_1 VAR_1 = ( TYPE_2 ) STRUCT_OR_UNION_3 -> VAR_2 . VAR_3 [ VAR_4 ] ; METHOD_1 ( VAR_5 , STRUCT_OR_UNION_4 -> VAR_6 ) ; <S2SV_StartBug> if ( METHOD_2 ( STRUCT_OR_UNION_5 ) ) <S2SV_EndBug> METHOD_3 ( VAR_7 , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , VAR_8 , VAR_9 > VAR_10 ? ""file"" : ""buff"" ) ; }",<S2SV_ModStart> ; if ( METHOD_4 <S2SV_ModEnd> ( STRUCT_OR_UNION_5 ),"CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ; }",<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
557,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { VAR_1 -> VAR_2 . VAR_3 . VAR_4 = 1 ; VAR_5 -> VAR_6 . VAR_7 . VAR_8 = 1 ; <S2SV_StartBug> METHOD_1 ( VAR_9 -> VAR_10 . VAR_11 . VAR_12 , 0 , sizeof ( VAR_13 -> VAR_14 . VAR_15 . VAR_16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_2 ( VAR_17 -> VAR_18 . VAR_19 . VAR_20 , 0 , sizeof ( VAR_21 -> VAR_22 . VAR_23 . VAR_24 ) ) ; <S2SV_EndBug> VAR_25 -> VAR_26 . VAR_27 . VAR_28 [ VAR_29 ] = 2 ; VAR_30 -> VAR_31 . VAR_32 . VAR_33 [ VAR_34 ] = 0 ; VAR_35 -> VAR_36 . VAR_37 . VAR_38 [ VAR_39 ] = - 2 ; VAR_40 -> VAR_41 . VAR_42 . VAR_43 [ VAR_44 ] = - 2 ; VAR_45 -> VAR_46 . VAR_47 . VAR_48 [ 0 ] = 4 ; if ( VAR_49 -> VAR_50 . VAR_51 == VAR_52 ) VAR_53 -> VAR_54 . VAR_55 . VAR_56 [ 1 ] = - 12 ; else VAR_57 -> VAR_58 . VAR_59 . VAR_60 [ 1 ] = - 2 ; VAR_61 -> VAR_62 . VAR_63 . VAR_64 [ 2 ] = 2 ; VAR_65 -> VAR_66 . VAR_67 . VAR_68 [ 3 ] = 4 ; }",<S2SV_ModStart> = 1 ; METHOD_3 <S2SV_ModEnd> ( VAR_65 -> <S2SV_ModStart> ) ) ; METHOD_3 <S2SV_ModEnd> ( VAR_65 ->,"CWE-119 static void set_default_lf_deltas ( VP8_COMP * cpi ) { cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ LAST_FRAME ] = 0 ; cpi -> mb . e_mbd . ref_lf_deltas [ GOLDEN_FRAME ] = - 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ ALTREF_FRAME ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 0 ] = 4 ; if ( cpi -> oxcf . Mode == MODE_REALTIME ) cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 12 ; else cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 2 ] = 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 3 ] = 4 ; }",<S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->
558,"CWE-399 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , const struct STRUCT_OR_UNION_2 * VAR_2 , unsigned TYPE_1 VAR_3 ) { struct STRUCT_OR_UNION_3 * VAR_4 = METHOD_1 ( VAR_5 ) ; struct STRUCT_OR_UNION_4 * VAR_6 = METHOD_2 ( VAR_7 ) ; TYPE_2 VAR_8 = 0 ; TYPE_3 VAR_9 ; VAR_10 -> VAR_11 . VAR_12 = 0 ; switch ( VAR_13 -> VAR_14 ) { case VAR_15 : goto VAR_16 ; case VAR_17 : if ( VAR_18 -> VAR_19 ) return 1 ; if ( VAR_20 -> VAR_21 ) goto VAR_22 ; if ( VAR_23 -> VAR_24 ) { <S2SV_StartBug> if ( VAR_25 -> VAR_26 -> METHOD_3 ( VAR_27 , VAR_28 ) < 0 ) <S2SV_EndBug> return 1 ; METHOD_4 ( VAR_29 ) ; return 0 ; } goto VAR_30 ; case VAR_31 : VAR_32 = METHOD_5 ( VAR_33 , VAR_34 , VAR_35 , VAR_36 ) ; if ( VAR_37 >= 0 ) return VAR_38 ; METHOD_6 ( VAR_39 , VAR_40 , VAR_41 ) ; METHOD_7 ( VAR_42 ) ; METHOD_8 ( VAR_43 ) ; return 0 ; } VAR_44 = METHOD_9 ( VAR_45 , VAR_46 , VAR_47 , 0 ) ; if ( VAR_48 <= 0 ) return - VAR_49 ; if ( VAR_50 -> VAR_51 ) { TYPE_4 VAR_52 = METHOD_10 ( VAR_53 , VAR_54 , VAR_55 ) > 0 ; switch ( VAR_56 -> VAR_57 ) { case VAR_58 : if ( VAR_59 ) { VAR_60 -> VAR_61 = VAR_62 -> VAR_63 ; METHOD_11 ( ) ; METHOD_12 ( VAR_64 , VAR_65 ) ; VAR_66 -> METHOD_13 ( VAR_67 ) ; if ( VAR_68 -> VAR_69 ) METHOD_14 ( VAR_70 , VAR_71 , VAR_72 ) ; VAR_73 -> VAR_74 = METHOD_15 ( VAR_75 ) -> VAR_76 ; VAR_77 -> VAR_78 = METHOD_16 ( VAR_79 -> VAR_80 ) << VAR_81 -> VAR_82 . VAR_83 ; METHOD_17 ( VAR_84 , METHOD_18 ( VAR_85 ) -> VAR_86 ) ; if ( VAR_87 -> VAR_88 . VAR_89 ) VAR_90 -> VAR_91 -= VAR_92 ; VAR_93 -> VAR_94 -> METHOD_19 ( VAR_95 ) ; METHOD_20 ( VAR_96 ) ; METHOD_21 ( VAR_97 ) ; VAR_98 -> VAR_99 = VAR_100 ; METHOD_22 ( VAR_101 ) ; METHOD_23 ( VAR_102 ) ; METHOD_24 ( VAR_103 ) ; METHOD_25 ( VAR_104 ) ; } else { return 1 ; } break ; case VAR_105 : if ( VAR_106 -> VAR_107 == VAR_108 -> VAR_109 ) { METHOD_26 ( VAR_110 , VAR_111 ) ; VAR_112 -> VAR_113 |= VAR_114 ; METHOD_27 ( METHOD_28 ( VAR_115 ) ) ; if ( ! METHOD_29 ( VAR_116 , VAR_117 ) ) VAR_118 -> METHOD_30 ( VAR_119 ) ; else { TYPE_5 VAR_120 ; if ( VAR_121 -> VAR_122 < 0 || ( METHOD_31 ( VAR_123 ) -> VAR_124 != METHOD_32 ( VAR_125 ) -> VAR_126 && METHOD_33 ( METHOD_34 ( VAR_127 ) -> VAR_128 - VAR_129 -> VAR_130 , VAR_131 -> VAR_132 ) ) ) { METHOD_35 ( VAR_133 ) ; METHOD_36 ( METHOD_37 ( VAR_134 ) , VAR_135 ) ; return 1 ; } VAR_136 = METHOD_38 ( VAR_137 ) ; if ( VAR_138 > VAR_139 ) { METHOD_39 ( VAR_140 , VAR_141 - VAR_142 ) ; } else if ( VAR_143 -> VAR_144 || METHOD_40 ( VAR_145 ) ) { METHOD_41 ( VAR_146 , VAR_147 ) ; } else { METHOD_42 ( VAR_148 , VAR_149 , VAR_150 ) ; goto VAR_151 ; } } } break ; case VAR_152 : if ( VAR_153 -> VAR_154 == VAR_155 -> VAR_156 ) { METHOD_43 ( VAR_157 , VAR_158 , 0 ) ; goto VAR_159 ; } break ; case VAR_160 : if ( VAR_161 -> VAR_162 == VAR_163 -> VAR_164 ) { METHOD_44 ( VAR_165 ) ; METHOD_45 ( VAR_166 ) ; goto VAR_167 ; } break ; } } else goto VAR_168 ; METHOD_46 ( VAR_169 , VAR_170 , VAR_171 ) ; switch ( VAR_172 -> VAR_173 ) { case VAR_174 : case VAR_175 : case VAR_176 : if ( ! METHOD_47 ( METHOD_48 ( VAR_177 ) -> VAR_178 , VAR_179 -> VAR_180 ) ) break ; case VAR_181 : case VAR_182 : if ( VAR_183 -> VAR_184 & VAR_185 ) { if ( METHOD_49 ( VAR_186 ) -> VAR_187 != METHOD_50 ( VAR_188 ) -> VAR_189 && METHOD_51 ( METHOD_52 ( VAR_190 ) -> VAR_191 - VAR_192 -> VAR_193 , VAR_194 -> VAR_195 ) ) { METHOD_53 ( METHOD_54 ( VAR_196 ) , VAR_197 ) ; METHOD_55 ( VAR_198 ) ; return 1 ; } } case VAR_199 : METHOD_56 ( VAR_200 , VAR_201 ) ; VAR_202 = 1 ; break ; } if ( VAR_203 -> VAR_204 != VAR_205 ) { METHOD_57 ( VAR_206 ) ; METHOD_58 ( VAR_207 ) ; } if ( ! VAR_208 ) { VAR_209 : METHOD_59 ( VAR_210 ) ; } return 0 ; }",<S2SV_ModStart> { if ( VAR_192 -> VAR_193 ) goto VAR_209 ; if (,"CWE-399 int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }",<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (
559,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = METHOD_1 ( VAR_5 ) ; TYPE_1 VAR_6 = METHOD_2 ( VAR_7 -> VAR_8 ) ; TYPE_2 VAR_9 , VAR_10 ; TYPE_3 VAR_11 , VAR_12 ; TYPE_4 VAR_13 , VAR_14 ; <S2SV_StartBug> TYPE_5 VAR_15 = ( METHOD_3 ( VAR_16 -> VAR_17 ) == VAR_18 ) ? 64 : 32 ; <S2SV_EndBug> if ( VAR_19 == 32 ) { METHOD_4 ( VAR_20 , 4 ) ; METHOD_5 ( & VAR_21 , 4 ) ; } VAR_22 = VAR_23 . VAR_24 ; VAR_25 = VAR_26 . VAR_27 ; VAR_28 = VAR_29 . VAR_30 ; VAR_31 = VAR_32 . VAR_33 ; VAR_34 = METHOD_6 ( VAR_35 . VAR_36 ) ; VAR_37 = METHOD_7 ( VAR_38 -> VAR_39 ) ; if ( ( VAR_40 && ( VAR_41 != VAR_42 || VAR_43 != VAR_44 ) ) || VAR_45 > VAR_46 || VAR_47 > VAR_48 ) { METHOD_8 ( VAR_49 ) ; return 0 ; } if ( ! VAR_50 && VAR_51 != VAR_52 && VAR_53 != VAR_54 && VAR_55 != VAR_56 ) { METHOD_9 ( VAR_57 ) ; return 0 ; } switch ( VAR_58 ) { case VAR_59 : <S2SV_StartBug> if ( METHOD_10 ( VAR_60 -> VAR_61 , VAR_62 ) || <S2SV_EndBug> METHOD_11 ( VAR_63 -> VAR_64 , VAR_65 ) ) { VAR_66 -> VAR_67 = VAR_68 ; VAR_69 -> VAR_70 = VAR_71 ; } else { VAR_72 -> VAR_73 += VAR_74 ; VAR_75 -> VAR_76 += VAR_77 ; } if ( VAR_78 -> VAR_79 + VAR_80 < VAR_81 || VAR_82 -> VAR_83 + VAR_84 < VAR_85 ) { VAR_86 -> VAR_87 = 0 ; VAR_88 -> VAR_89 = VAR_90 ; } else { VAR_91 -> VAR_92 += VAR_93 ; VAR_94 -> VAR_95 += VAR_96 ; } VAR_97 -> VAR_98 = METHOD_12 ( VAR_99 -> VAR_100 , VAR_101 . VAR_102 ) ; break ; case VAR_103 : <S2SV_StartBug> if ( METHOD_13 ( VAR_104 -> VAR_105 , VAR_106 ) || <S2SV_EndBug> METHOD_14 ( VAR_107 -> VAR_108 , VAR_109 ) ) { VAR_110 -> VAR_111 = VAR_112 ; VAR_113 -> VAR_114 = VAR_115 ; } else { VAR_116 -> VAR_117 -= VAR_118 ; VAR_119 -> VAR_120 -= VAR_121 ; } if ( VAR_122 -> VAR_123 < VAR_124 ) { VAR_125 -> VAR_126 = 0 ; VAR_127 -> VAR_128 = VAR_129 ; } else { VAR_130 -> VAR_131 -= VAR_132 ; VAR_133 -> VAR_134 -= VAR_135 ; } VAR_136 -> VAR_137 = METHOD_15 ( VAR_138 -> VAR_139 , VAR_140 . VAR_141 ) ; break ; case VAR_142 : VAR_143 -> VAR_144 = METHOD_16 ( VAR_145 -> VAR_146 , VAR_147 . VAR_148 ) ; if ( VAR_149 < 0 || VAR_150 -> VAR_151 < 0 ) { METHOD_17 ( VAR_152 ) ; METHOD_18 ( VAR_153 ) ; break ; } if ( VAR_154 > VAR_155 || VAR_156 -> VAR_157 > VAR_158 ) { METHOD_19 ( VAR_159 ) ; METHOD_20 ( VAR_160 ) ; break ; } VAR_161 -> VAR_162 *= VAR_163 ; VAR_164 -> VAR_165 *= VAR_166 ; if ( VAR_167 -> VAR_168 > VAR_169 ) { VAR_170 -> VAR_171 = VAR_172 ; VAR_173 -> VAR_174 = VAR_175 ; } else { VAR_176 -> VAR_177 = VAR_178 -> VAR_179 ; VAR_180 -> VAR_181 = VAR_182 -> VAR_183 ; } break ; case VAR_184 : if ( VAR_185 && VAR_186 ) { METHOD_21 ( VAR_187 , VAR_188 -> VAR_189 . VAR_190 & VAR_191 . VAR_192 . VAR_193 ) ; break ; } VAR_194 -> VAR_195 = METHOD_22 ( VAR_196 -> VAR_197 , VAR_198 . VAR_199 ) ; VAR_200 -> VAR_201 = VAR_202 -> VAR_203 . VAR_204 ; VAR_205 -> VAR_206 = METHOD_23 ( VAR_207 -> VAR_208 , VAR_209 ) ; if ( VAR_210 -> VAR_211 < 0 || VAR_212 < 0 ) { VAR_213 -> VAR_214 = VAR_215 ; VAR_216 -> VAR_217 = VAR_218 ; } else { VAR_219 -> VAR_220 = VAR_221 -> VAR_222 ; VAR_223 -> VAR_224 = VAR_225 -> VAR_226 ; } METHOD_24 ( VAR_227 ) ; break ; case VAR_228 : if ( VAR_229 && VAR_230 ) { METHOD_25 ( VAR_231 , VAR_232 -> VAR_233 . VAR_234 | VAR_235 . VAR_236 . VAR_237 ) ; break ; } VAR_238 -> VAR_239 = METHOD_26 ( VAR_240 -> VAR_241 , VAR_242 . VAR_243 ) ; VAR_244 -> VAR_245 = METHOD_27 ( VAR_246 -> VAR_247 , VAR_248 ) ; VAR_249 -> VAR_250 = VAR_251 -> VAR_252 . VAR_253 | VAR_254 -> VAR_255 . VAR_256 ; if ( VAR_257 -> VAR_258 < 0 || VAR_259 < 0 ) { VAR_260 -> VAR_261 = VAR_262 ; VAR_263 -> VAR_264 = VAR_265 ; } else { VAR_266 -> VAR_267 = VAR_268 -> VAR_269 ; VAR_270 -> VAR_271 = VAR_272 -> VAR_273 ; } METHOD_28 ( VAR_274 ) ; break ; case VAR_275 : if ( VAR_276 >= VAR_277 ) { METHOD_29 ( VAR_278 , VAR_279 , VAR_280 -> VAR_281 ) ; break ; } VAR_282 -> VAR_283 = VAR_284 ; VAR_285 -> VAR_286 = VAR_287 ; if ( VAR_288 -> VAR_289 > 1ULL << ( 63 - VAR_290 ) ) { VAR_291 -> VAR_292 = 0 ; VAR_293 -> VAR_294 = VAR_295 ; } else { VAR_296 -> VAR_297 <<= VAR_298 ; VAR_299 -> VAR_300 <<= VAR_301 ; } VAR_302 -> VAR_303 = METHOD_30 ( VAR_304 -> VAR_305 , VAR_306 ) ; METHOD_31 ( VAR_307 ) ; break ; case VAR_308 : if ( VAR_309 >= VAR_310 ) { METHOD_32 ( VAR_311 , VAR_312 , VAR_313 -> VAR_314 ) ; break ; } VAR_315 -> VAR_316 = VAR_317 ; VAR_318 -> VAR_319 = VAR_320 ; VAR_321 -> VAR_322 = METHOD_33 ( VAR_323 -> VAR_324 , VAR_325 ) ; VAR_326 -> VAR_327 >>= VAR_328 ; VAR_329 -> VAR_330 >>= VAR_331 ; METHOD_34 ( VAR_332 ) ; break ; case VAR_333 : if ( VAR_334 >= VAR_335 ) { METHOD_35 ( VAR_336 , VAR_337 , VAR_338 -> VAR_339 ) ; break ; } VAR_340 -> VAR_341 >>= VAR_342 ; VAR_343 -> VAR_344 >>= VAR_345 ; VAR_346 -> VAR_347 = METHOD_36 ( VAR_348 -> VAR_349 , VAR_350 ) ; VAR_351 -> VAR_352 = 0 ; VAR_353 -> VAR_354 = VAR_355 ; METHOD_37 ( VAR_356 ) ; break ; default : METHOD_38 ( VAR_357 , VAR_358 , VAR_359 -> VAR_360 ) ; break ; } if ( METHOD_39 ( VAR_361 -> VAR_362 ) != VAR_363 ) { METHOD_40 ( VAR_364 , 4 ) ; } METHOD_41 ( VAR_365 ) ; METHOD_42 ( VAR_366 ) ; return 0 ; }","<S2SV_ModStart> 64 : 32 ; TYPE_6 VAR_367 = VAR_361 -> VAR_366 ; TYPE_0 VAR_368 <S2SV_ModStart> case VAR_59 : VAR_368 = METHOD_43 ( VAR_357 , VAR_361 ) ; if ( VAR_368 < 0 ) { METHOD_44 ( VAR_357 , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , VAR_367 ) ; return VAR_368 ; } <S2SV_ModStart> case VAR_103 : VAR_368 = METHOD_43 ( VAR_357 , VAR_361 ) ; if ( VAR_368 < 0 ) { METHOD_44 ( VAR_357 , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , VAR_367 ) ; return VAR_368 ; }","CWE-189 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","<S2SV_ModStart> 64 : 32 ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; }"
560,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) <S2SV_EndBug> { TYPE_1 VAR_1 [ ] = { 0x51 } ; TYPE_2 VAR_2 [ ] = { 0 } ; <S2SV_StartBug> if ( METHOD_1 ( VAR_3 -> VAR_4 , VAR_5 , 1 , VAR_6 , 1 , 0 ) < 0 ) <S2SV_EndBug> METHOD_2 ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> VAR_7 -> VAR_8 [ 0 ] . VAR_9 = METHOD_3 ( VAR_10 , & VAR_11 , <S2SV_EndBug> <S2SV_StartBug> & VAR_12 -> VAR_13 -> VAR_14 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_15 -> VAR_16 [ 0 ] . VAR_17 == VAR_18 ) <S2SV_EndBug> return - VAR_19 ; <S2SV_StartBug> if ( METHOD_4 ( VAR_20 , VAR_21 -> VAR_22 [ 0 ] . VAR_23 , <S2SV_EndBug> & VAR_24 , <S2SV_StartBug> & VAR_25 -> VAR_26 -> VAR_27 ) ) { <S2SV_EndBug> METHOD_5 ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } METHOD_6 ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - VAR_28 ; }","<S2SV_ModStart> struct STRUCT_OR_UNION_0 * VAR_29 ) { struct STRUCT_OR_UNION_1 * VAR_25 = VAR_29 -> VAR_26 ; struct STRUCT_OR_UNION_2 * VAR_30 = VAR_25 -> VAR_31 ; METHOD_7 ( & VAR_25 -> VAR_32 ) ; VAR_30 -> VAR_33 [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> METHOD_1 ( VAR_25 , VAR_30 -> VAR_33 <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , VAR_30 -> VAR_33 <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; METHOD_8 ( & VAR_25 -> VAR_32 ) ; VAR_29 <S2SV_ModEnd> -> VAR_22 [ <S2SV_ModStart> & VAR_25 -> <S2SV_ModEnd> VAR_27 ) ; <S2SV_ModStart> ; if ( VAR_29 <S2SV_ModEnd> -> VAR_22 [ <S2SV_ModStart> ( VAR_20 , VAR_29 <S2SV_ModEnd> -> VAR_22 [ <S2SV_ModStart> , & VAR_25 <S2SV_ModEnd> -> VAR_27 )","CWE-119 <S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - EIO ; }","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )"
561,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> if ( ! VAR_1 -> VAR_2 . VAR_3 ) <S2SV_EndBug> return - VAR_4 ; VAR_5 -> VAR_6 . VAR_7 = VAR_8 ; METHOD_1 ( VAR_9 , VAR_10 ) ; return 0 ; }",<S2SV_ModStart> -> VAR_6 . VAR_11 <S2SV_ModEnd> ) return -,"CWE-399 static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }",<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
562,"CWE-399 TYPE_0 TYPE_1 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 ) { switch ( VAR_3 ) { case VAR_4 : VAR_5 -> VAR_6 = * ( const TYPE_4 * ) VAR_7 ; return 0 ; case VAR_8 : VAR_9 -> VAR_10 = * ( const TYPE_5 * ) VAR_11 ; return 0 ; case VAR_12 : VAR_13 -> VAR_14 = * ( const TYPE_6 * ) VAR_15 ; return 0 ; case VAR_16 : VAR_17 -> VAR_18 = * ( const TYPE_7 * ) VAR_19 ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> VAR_20 = VAR_21 ; return - 1 ; } }",<S2SV_ModStart> return 0 ; case VAR_22 : VAR_17 -> VAR_23 = * ( const TYPE_7 * ) VAR_19 ; return 0 ;,"CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }",<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
563,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { TYPE_1 VAR_2 ; TYPE_2 VAR_3 ; if ( VAR_4 -> VAR_5 -> METHOD_1 ( VAR_6 , 3 , VAR_7 -> VAR_8 ) ) return METHOD_2 ( VAR_9 , 0 ) ; VAR_10 -> VAR_11 = VAR_12 -> VAR_13 ; VAR_14 -> VAR_15 = VAR_16 -> VAR_17 | 2 ; * METHOD_3 ( VAR_18 , VAR_19 ) = VAR_20 -> VAR_21 ; * METHOD_4 ( VAR_22 , VAR_23 ) = VAR_24 -> VAR_25 ; * METHOD_5 ( VAR_26 , VAR_27 ) = VAR_28 -> VAR_29 ; * METHOD_6 ( VAR_30 , VAR_31 ) = VAR_32 -> VAR_33 ; * METHOD_7 ( VAR_34 , VAR_35 ) = VAR_36 -> VAR_37 ; * METHOD_8 ( VAR_38 , VAR_39 ) = VAR_40 -> VAR_41 ; * METHOD_9 ( VAR_42 , VAR_43 ) = VAR_44 -> VAR_45 ; * METHOD_10 ( VAR_46 , VAR_47 ) = VAR_48 -> VAR_49 ; METHOD_11 ( VAR_50 , VAR_51 -> VAR_52 , VAR_53 ) ; METHOD_12 ( VAR_54 , VAR_55 -> VAR_56 , VAR_57 ) ; METHOD_13 ( VAR_58 , VAR_59 -> VAR_60 , VAR_61 ) ; METHOD_14 ( VAR_62 , VAR_63 -> VAR_64 , VAR_65 ) ; METHOD_15 ( VAR_66 , VAR_67 -> VAR_68 , VAR_69 ) ; METHOD_16 ( VAR_70 , VAR_71 -> VAR_72 , VAR_73 ) ; METHOD_17 ( VAR_74 , VAR_75 -> VAR_76 , VAR_77 ) ; if ( VAR_78 -> VAR_79 & VAR_80 ) { VAR_81 -> VAR_82 = VAR_83 ; VAR_84 = 3 ; } else { VAR_85 -> VAR_86 = VAR_87 ; VAR_88 = VAR_89 -> VAR_90 & 3 ; } <S2SV_StartBug> VAR_91 = METHOD_18 ( VAR_92 , VAR_93 -> VAR_94 , VAR_95 , VAR_96 , VAR_97 ) ; <S2SV_EndBug> if ( VAR_98 != VAR_99 ) return VAR_100 ; <S2SV_StartBug> VAR_101 = METHOD_19 ( VAR_102 , VAR_103 -> VAR_104 , VAR_105 , VAR_106 , VAR_107 ) ; <S2SV_EndBug> if ( VAR_108 != VAR_109 ) return VAR_110 ; <S2SV_StartBug> VAR_111 = METHOD_20 ( VAR_112 , VAR_113 -> VAR_114 , VAR_115 , VAR_116 , VAR_117 ) ; <S2SV_EndBug> if ( VAR_118 != VAR_119 ) return VAR_120 ; <S2SV_StartBug> VAR_121 = METHOD_21 ( VAR_122 , VAR_123 -> VAR_124 , VAR_125 , VAR_126 , VAR_127 ) ; <S2SV_EndBug> if ( VAR_128 != VAR_129 ) return VAR_130 ; <S2SV_StartBug> VAR_131 = METHOD_22 ( VAR_132 , VAR_133 -> VAR_134 , VAR_135 , VAR_136 , VAR_137 ) ; <S2SV_EndBug> if ( VAR_138 != VAR_139 ) return VAR_140 ; <S2SV_StartBug> VAR_141 = METHOD_23 ( VAR_142 , VAR_143 -> VAR_144 , VAR_145 , VAR_146 , VAR_147 ) ; <S2SV_EndBug> if ( VAR_148 != VAR_149 ) return VAR_150 ; <S2SV_StartBug> VAR_151 = METHOD_24 ( VAR_152 , VAR_153 -> VAR_154 , VAR_155 , VAR_156 , VAR_157 ) ; <S2SV_EndBug> if ( VAR_158 != VAR_159 ) return VAR_160 ; return VAR_161 ; }","<S2SV_ModStart> , VAR_95 , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , VAR_156 , VAR_157 , VAR_162 <S2SV_ModEnd> ) ; if","CWE-264 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }","<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if"
564,"CWE-000 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , enum VAR_1 VAR_2 ) { switch ( VAR_3 ) { case VAR_4 : <S2SV_StartBug> METHOD_1 ( & ( ( struct STRUCT_OR_UNION_0 * ) VAR_5 ) -> VAR_6 -> VAR_7 ) ; <S2SV_EndBug> break ; case VAR_8 : <S2SV_StartBug> METHOD_2 ( VAR_9 , VAR_10 ) ; <S2SV_EndBug> break ; default : METHOD_3 ( 1 ) ; break ; } return VAR_11 ; }",<S2SV_ModStart> case VAR_4 : VAR_11 = METHOD_4 ( VAR_11 <S2SV_ModEnd> ) ; break <S2SV_ModStart> case VAR_8 : VAR_11 =,"CWE-000 static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }",<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
565,"CWE-17 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { TYPE_7 VAR_6 , VAR_7 ; TYPE_8 VAR_8 , VAR_9 , VAR_10 , VAR_11 ; struct STRUCT_OR_UNION_0 * VAR_12 ; TYPE_9 * VAR_13 ; TYPE_10 * VAR_14 ; TYPE_11 VAR_15 [ 2 ] ; <S2SV_StartBug> signed TYPE_12 VAR_16 ; <S2SV_EndBug> if ( ! VAR_17 ) VAR_18 = & VAR_19 ; VAR_20 = METHOD_1 ( VAR_21 , VAR_22 ) ; if ( VAR_23 < 0 ) { METHOD_2 ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } VAR_24 = METHOD_3 ( VAR_25 ) ; if ( ! VAR_26 ) { METHOD_4 ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( TYPE_13 ) VAR_27 ) ; return - 1 ; } VAR_28 = METHOD_5 ( VAR_29 , VAR_30 ) ; if ( VAR_31 -> VAR_32 < 0 ) { METHOD_6 ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; METHOD_7 ( VAR_33 ) ; return - 1 ; } VAR_34 -> VAR_35 = VAR_36 ; if ( ! METHOD_8 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ) METHOD_9 ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; VAR_41 = METHOD_10 ( VAR_42 , 0 ) ; if ( VAR_43 -> VAR_44 == - 1 ) { VAR_45 -> VAR_46 = METHOD_11 ( VAR_47 , VAR_48 ) ; if ( VAR_49 -> VAR_50 == - 1 ) { METHOD_12 ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; METHOD_13 ( VAR_51 ) ; METHOD_14 ( VAR_52 ) ; return - 1 ; } } VAR_53 = METHOD_15 ( VAR_54 , VAR_55 | VAR_56 , 0 , VAR_57 ) ; if ( VAR_58 < 0 ) { METHOD_16 ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; METHOD_17 ( VAR_59 ) ; METHOD_18 ( VAR_60 ) ; return - 1 ; } VAR_61 = METHOD_19 ( ) ; if ( VAR_62 < 0 ) { METHOD_20 ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; METHOD_21 ( VAR_63 ) ; METHOD_22 ( VAR_64 ) ; return - 1 ; } if ( VAR_65 ) { TYPE_14 VAR_66 = VAR_67 ; METHOD_23 ( VAR_68 [ 1 ] ) ; METHOD_24 ( VAR_69 ) ; if ( VAR_70 -> VAR_71 & VAR_72 ) { if ( ! METHOD_25 ( VAR_73 , VAR_74 , VAR_75 ) ) goto VAR_76 ; } VAR_77 = 0 ; VAR_78 = METHOD_26 ( VAR_79 [ 0 ] , & VAR_80 , sizeof ( VAR_81 ) ) ; if ( VAR_82 <= 0 ) { METHOD_27 ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto VAR_83 ; } VAR_84 = METHOD_28 ( VAR_85 [ 0 ] , & VAR_86 , sizeof ( VAR_87 ) , VAR_88 ) ; if ( VAR_89 <= 0 ) { if ( VAR_90 != 0 ) METHOD_29 ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto VAR_91 ; } if ( VAR_92 -> VAR_93 == 0 ) { METHOD_30 ( VAR_94 , VAR_95 ) ; METHOD_31 ( VAR_96 , VAR_97 ) ; } VAR_98 = METHOD_32 ( VAR_99 ) ; if ( VAR_100 < 0 ) goto VAR_101 ; VAR_102 = VAR_103 ; VAR_104 = 0 ; VAR_105 = METHOD_33 ( VAR_106 [ 0 ] , & VAR_107 , sizeof ( VAR_108 ) ) ; if ( VAR_109 <= 0 ) { METHOD_34 ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto VAR_110 ; } VAR_111 = 1 ; VAR_112 = METHOD_35 ( VAR_113 [ 0 ] , & VAR_114 , sizeof ( VAR_115 ) , & VAR_116 ) ; if ( VAR_117 <= 0 ) { if ( VAR_118 != 0 ) METHOD_36 ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; goto VAR_119 ; } VAR_120 = 2 ; VAR_121 = METHOD_37 ( VAR_122 [ 0 ] , & VAR_123 , sizeof ( VAR_124 ) ) ; if ( VAR_125 <= 0 ) { METHOD_38 ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; goto VAR_126 ; } METHOD_39 ( VAR_127 [ 0 ] , VAR_128 ) ; METHOD_40 ( VAR_129 [ 0 ] ) ; METHOD_41 ( VAR_130 ) ; * VAR_131 = VAR_132 ; return 0 ; VAR_133 : METHOD_42 ( VAR_134 [ 0 ] , VAR_135 ) ; METHOD_43 ( VAR_136 [ 0 ] ) ; if ( VAR_137 ) ( TYPE_15 ) METHOD_44 ( VAR_138 ) ; METHOD_45 ( VAR_139 ) ; return - 1 ; } METHOD_46 ( VAR_140 [ 0 ] ) ; VAR_141 = 0 ; VAR_142 = - 1 ; VAR_143 = METHOD_47 ( VAR_144 [ 1 ] , & VAR_145 , sizeof ( VAR_146 ) , & VAR_147 ) ; if ( VAR_148 <= 0 ) { METHOD_48 ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; METHOD_49 ( VAR_149 [ 1 ] , VAR_150 ) ; METHOD_50 ( - 1 ) ; } <S2SV_StartBug> VAR_151 = METHOD_51 ( VAR_152 , VAR_153 -> VAR_154 ) ; <S2SV_EndBug> if ( VAR_155 < 0 ) { METHOD_52 ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; METHOD_53 ( VAR_156 [ 1 ] , VAR_157 ) ; METHOD_54 ( - 1 ) ; } if ( VAR_158 -> VAR_159 ) VAR_160 = VAR_161 -> VAR_162 ; else VAR_163 = VAR_164 ; VAR_165 = METHOD_55 ( VAR_166 ) ; if ( VAR_167 < 0 ) METHOD_56 ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , VAR_168 ) ; METHOD_57 ( VAR_169 ) ; { struct STRUCT_OR_UNION_1 VAR_170 = { . VAR_171 = VAR_172 [ 1 ] , . VAR_173 = VAR_174 , . VAR_175 = VAR_176 , . VAR_177 = VAR_178 , <S2SV_StartBug> . VAR_179 = VAR_180 <S2SV_EndBug> } ; VAR_181 = METHOD_58 ( VAR_182 , & VAR_183 , VAR_184 ) ; } if ( VAR_185 <= 0 ) { METHOD_59 ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; METHOD_60 ( VAR_186 [ 1 ] , VAR_187 ) ; METHOD_61 ( - 1 ) ; } VAR_188 = METHOD_62 ( VAR_189 [ 1 ] , & VAR_190 , sizeof ( VAR_191 ) ) ; if ( VAR_192 != sizeof ( VAR_193 ) ) { METHOD_63 ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; METHOD_64 ( VAR_194 [ 1 ] , VAR_195 ) ; METHOD_65 ( - 1 ) ; } METHOD_66 ( 0 ) ; }","<S2SV_ModStart> 2 ] ; TYPE_11 VAR_196 ; <S2SV_ModStart> ) ; } VAR_196 = METHOD_67 ( ""/proc"" , VAR_197 | VAR_198 ) ; if ( VAR_196 < 0 ) { METHOD_59 ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; METHOD_64 ( VAR_194 [ 1 ] , VAR_195 ) ; METHOD_66 ( - 1 ) ; } <S2SV_ModStart> VAR_180 = VAR_180 , . VAR_196 = VAR_196","CWE-17 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }","<S2SV_ModStart> 2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd"
566,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_7 * VAR_8 ; struct STRUCT_OR_UNION_8 * VAR_9 ; TYPE_3 VAR_10 ; unsigned TYPE_4 VAR_11 ; TYPE_5 VAR_12 ; TYPE_6 VAR_13 ; if ( METHOD_2 ( ! VAR_14 ) ) return - VAR_15 ; METHOD_3 ( VAR_16 ) ; if ( METHOD_4 ( STRUCT_OR_UNION_9 -> VAR_17 == VAR_18 ) ) { VAR_19 = - VAR_20 ; goto VAR_21 ; } <S2SV_StartBug> VAR_22 = METHOD_5 ( VAR_23 , VAR_24 & VAR_25 ) ; <S2SV_EndBug> VAR_26 : while ( METHOD_6 ( & VAR_27 -> VAR_28 ) ) { if ( STRUCT_OR_UNION_10 -> VAR_29 == VAR_30 ) { VAR_31 = - VAR_32 ; goto VAR_33 ; } if ( VAR_34 <= 0L ) { VAR_35 = VAR_36 ? VAR_37 : - VAR_38 ; goto VAR_39 ; } METHOD_7 ( VAR_40 ) ; VAR_41 = METHOD_8 ( * METHOD_9 ( VAR_42 ) , METHOD_10 ( STRUCT_OR_UNION_11 ) , VAR_43 ) ; METHOD_11 ( VAR_44 ) ; } VAR_45 = METHOD_12 ( & VAR_46 -> VAR_47 ) ; VAR_48 = METHOD_13 ( VAR_49 ) ; VAR_50 = METHOD_14 ( VAR_51 ) ; VAR_52 = METHOD_15 ( VAR_53 ) ; if ( ( ! VAR_54 ) && ( ! VAR_55 ) ) { METHOD_16 ( VAR_56 ) ; goto VAR_57 ; } METHOD_17 ( VAR_58 , VAR_59 ) ; VAR_60 = METHOD_18 ( VAR_61 , VAR_62 , VAR_63 ) ; if ( VAR_64 ) goto VAR_65 ; if ( ! VAR_66 ) { if ( METHOD_19 ( VAR_67 < VAR_68 ) ) { VAR_69 = VAR_70 ; VAR_71 -> VAR_72 |= VAR_73 ; } VAR_74 = METHOD_20 ( VAR_75 , METHOD_21 ( VAR_76 ) , VAR_77 -> VAR_78 , VAR_79 ) ; if ( VAR_80 ) goto VAR_81 ; VAR_82 = VAR_83 ; } else { if ( ( STRUCT_OR_UNION_12 -> VAR_84 == VAR_85 ) || ( ( VAR_86 == VAR_87 ) || VAR_88 -> VAR_89 ) ) VAR_90 = 0 ; else VAR_91 = - VAR_92 ; } if ( METHOD_22 ( ! ( VAR_93 & VAR_94 ) ) ) { if ( ( STRUCT_OR_UNION_13 -> VAR_95 != VAR_96 ) && ( ++ VAR_97 -> VAR_98 >= VAR_99 ) ) METHOD_23 ( VAR_100 -> VAR_101 , VAR_102 -> VAR_103 ) ; METHOD_24 ( VAR_104 ) ; } VAR_105 : METHOD_25 ( VAR_106 ) ; return VAR_107 ; }",<S2SV_ModStart> VAR_105 ; } VAR_88 -> VAR_108 = 0 ;,"CWE-200 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }",<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
567,"CWE-119 static TYPE_0 * METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , unsigned TYPE_2 * VAR_2 ) { <S2SV_StartBug> if ( * VAR_3 >= 30 && VAR_4 [ 29 ] == 0x05 && VAR_5 [ 30 ] == 0x09 ) { <S2SV_EndBug> METHOD_1 ( VAR_6 , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; VAR_7 [ 30 ] = 0x0c ; } return VAR_8 ; }",<S2SV_ModStart> * VAR_3 >= 31 <S2SV_ModEnd> && VAR_8 [,"CWE-119 static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 30 ] = 0x0c ; } return rdesc ; }",<S2SV_ModStart> * rsize >= 31 <S2SV_ModEnd> && rdesc [
568,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { TYPE_1 VAR_1 , VAR_2 ; TYPE_2 VAR_3 ; TYPE_3 VAR_4 = 0 ; struct STRUCT_OR_UNION_3 * VAR_5 = STRUCT_OR_UNION_4 -> VAR_6 . STRUCT_OR_UNION_5 ; TYPE_4 VAR_7 ; if ( ! VAR_8 ) return 0 ; VAR_9 = VAR_10 -> VAR_11 ; VAR_12 = VAR_13 + VAR_14 -> VAR_15 ; VAR_16 = VAR_17 ; if ( ! ( VAR_18 -> VAR_19 & VAR_20 ) ) VAR_21 |= VAR_22 ; if ( ! STRUCT_OR_UNION_6 -> VAR_23 . VAR_24 ) VAR_25 |= VAR_26 ; while ( VAR_27 < VAR_28 ) { unsigned TYPE_5 VAR_29 ; if ( METHOD_1 ( VAR_30 , METHOD_2 ( VAR_31 ) ) ) { VAR_32 += 1 ; continue ; } VAR_33 = METHOD_3 ( STRUCT_OR_UNION_7 , VAR_34 ) ; while ( ( VAR_35 + ( VAR_36 >> VAR_37 ) ) > VAR_38 ) VAR_39 >>= 1 ; while ( ( VAR_40 << VAR_41 ) & ( VAR_42 - 1 ) ) VAR_43 >>= 1 ; while ( METHOD_4 ( VAR_44 , VAR_45 ) & ( VAR_46 - 1 ) ) VAR_47 >>= 1 ; <S2SV_StartBug> VAR_48 = METHOD_5 ( VAR_49 , VAR_50 , VAR_51 ) ; <S2SV_EndBug> if ( METHOD_6 ( VAR_52 ) ) { VAR_53 += 1 ; continue ; } VAR_54 = METHOD_7 ( VAR_55 , METHOD_8 ( VAR_56 ) , METHOD_9 ( VAR_57 ) , VAR_58 , VAR_59 ) ; if ( VAR_60 ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , VAR_61 ) ; <S2SV_StartBug> METHOD_10 ( STRUCT_OR_UNION_8 , VAR_62 , VAR_63 ) ; <S2SV_EndBug> goto VAR_64 ; } VAR_65 += VAR_66 >> VAR_67 ; } return 0 ; VAR_68 : METHOD_11 ( STRUCT_OR_UNION_9 , VAR_69 -> VAR_70 , VAR_71 - VAR_72 -> VAR_73 ) ; return VAR_74 ; }","<S2SV_ModStart> VAR_71 , VAR_66 >> VAR_67 <S2SV_ModStart> VAR_62 , VAR_66 >> VAR_67","CWE-119 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; <S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ; return r ; }","<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT"
569,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { struct STRUCT_OR_UNION_0 * VAR_5 = ( struct STRUCT_OR_UNION_1 * ) ( TYPE_6 ) VAR_6 ; struct STRUCT_OR_UNION_2 * VAR_7 ; <S2SV_StartBug> if ( METHOD_1 ( VAR_8 ) ) <S2SV_EndBug> return 0 ; if ( VAR_9 > VAR_10 -> VAR_11 - sizeof ( struct STRUCT_OR_UNION_3 ) ) return 0 ; VAR_12 = METHOD_2 ( ( struct STRUCT_OR_UNION_4 * ) & VAR_13 -> VAR_14 [ VAR_15 ] , VAR_16 -> VAR_17 - VAR_18 , VAR_19 ) ; if ( VAR_20 ) return ( TYPE_7 * ) VAR_21 - ( TYPE_8 * ) VAR_22 -> VAR_23 ; return 0 ; }",<S2SV_ModStart> METHOD_1 ( VAR_22 ) ) return 0 ; if ( VAR_22 -> VAR_17 < sizeof ( struct STRUCT_OR_UNION_4,"CWE-125 static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }",<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
570,"CWE-358 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 * VAR_5 ) { struct STRUCT_OR_UNION_2 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_3 * VAR_8 = METHOD_2 ( VAR_9 ) ; struct STRUCT_OR_UNION_4 * VAR_10 ; unsigned TYPE_5 VAR_11 , VAR_12 ; TYPE_6 VAR_13 , VAR_14 = 0 ; TYPE_7 VAR_15 ; <S2SV_StartBug> TYPE_8 VAR_16 = METHOD_3 ( VAR_17 ) ; <S2SV_EndBug> TYPE_9 VAR_18 ; TYPE_10 VAR_19 ; if ( VAR_20 & VAR_21 ) return METHOD_4 ( VAR_22 , VAR_23 , VAR_24 , VAR_25 ) ; if ( VAR_26 -> VAR_27 && VAR_28 -> VAR_29 . VAR_30 . VAR_31 ) return METHOD_5 ( VAR_32 , VAR_33 , VAR_34 , VAR_35 ) ; VAR_36 : VAR_37 = METHOD_6 ( VAR_38 , VAR_39 | ( VAR_40 ? VAR_41 : 0 ) , & VAR_42 , & VAR_43 , & VAR_44 ) ; if ( ! VAR_45 ) goto VAR_46 ; VAR_47 = VAR_48 -> VAR_49 - sizeof ( struct STRUCT_OR_UNION_5 ) ; VAR_50 = VAR_51 ; if ( VAR_52 > VAR_53 ) VAR_54 = VAR_55 ; else if ( VAR_56 < VAR_57 ) VAR_58 -> VAR_59 |= VAR_60 ; VAR_61 = ( VAR_62 -> VAR_63 == METHOD_7 ( VAR_64 ) ) ; if ( VAR_65 < VAR_66 || METHOD_8 ( VAR_67 ) -> VAR_68 ) { <S2SV_StartBug> if ( METHOD_9 ( VAR_69 ) ) <S2SV_EndBug> goto VAR_70 ; } <S2SV_StartBug> if ( METHOD_10 ( VAR_71 ) ) <S2SV_EndBug> VAR_72 = METHOD_11 ( VAR_73 , sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_74 , VAR_75 ) ; else { VAR_76 = METHOD_12 ( VAR_77 , sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_78 ) ; if ( VAR_79 == - VAR_80 ) goto VAR_81 ; } if ( METHOD_13 ( VAR_82 ) ) { METHOD_14 ( VAR_83 , METHOD_15 ) ; if ( ! VAR_84 ) { METHOD_16 ( & VAR_85 -> VAR_86 ) ; if ( VAR_87 ) METHOD_17 ( METHOD_18 ( VAR_88 ) , VAR_89 , VAR_90 ) ; else METHOD_19 ( METHOD_20 ( VAR_91 ) , VAR_92 , VAR_93 ) ; } goto VAR_94 ; } if ( ! VAR_95 ) { if ( VAR_96 ) METHOD_21 ( METHOD_22 ( VAR_97 ) , VAR_98 , VAR_99 ) ; else METHOD_23 ( METHOD_24 ( VAR_100 ) , VAR_101 , VAR_102 ) ; } METHOD_25 ( VAR_103 , VAR_104 , VAR_105 ) ; if ( VAR_106 -> VAR_107 ) { DECLARE_SOCKADDR ( struct STRUCT_OR_UNION_8 * , VAR_108 , VAR_109 -> VAR_110 ) ; VAR_111 -> VAR_112 = VAR_113 ; VAR_114 -> VAR_115 = METHOD_26 ( VAR_116 ) -> VAR_117 ; VAR_118 -> VAR_119 = 0 ; if ( VAR_120 ) { METHOD_27 ( METHOD_28 ( VAR_121 ) -> VAR_122 , & VAR_123 -> VAR_124 ) ; VAR_125 -> VAR_126 = 0 ; } else { VAR_127 -> VAR_128 = METHOD_29 ( VAR_129 ) -> VAR_130 ; VAR_131 -> VAR_132 = METHOD_30 ( & VAR_133 -> VAR_134 , METHOD_31 ( VAR_135 ) ) ; } * VAR_136 = sizeof ( * VAR_137 ) ; } if ( VAR_138 -> VAR_139 . VAR_140 ) METHOD_32 ( VAR_141 , VAR_142 , VAR_143 ) ; if ( VAR_144 ) { if ( VAR_145 -> VAR_146 ) METHOD_33 ( VAR_147 , VAR_148 ) ; } else { if ( VAR_149 -> VAR_150 . VAR_151 ) METHOD_34 ( VAR_152 , VAR_153 , VAR_154 ) ; } VAR_155 = VAR_156 ; if ( VAR_157 & VAR_158 ) VAR_159 = VAR_160 ; VAR_161 : METHOD_35 ( VAR_162 , VAR_163 ) ; VAR_164 : return VAR_165 ; VAR_166 : VAR_167 = METHOD_36 ( VAR_168 ) ; if ( ! METHOD_37 ( VAR_169 , VAR_170 , VAR_171 ) ) { if ( VAR_172 ) { METHOD_38 ( METHOD_39 ( VAR_173 ) , VAR_174 , VAR_175 ) ; METHOD_40 ( METHOD_41 ( VAR_176 ) , VAR_177 , VAR_178 ) ; } else { METHOD_42 ( METHOD_43 ( VAR_179 ) , VAR_180 , VAR_181 ) ; METHOD_44 ( METHOD_45 ( VAR_182 ) , VAR_183 , VAR_184 ) ; } } METHOD_46 ( VAR_185 , VAR_186 ) ; METHOD_47 ( ) ; VAR_187 -> VAR_188 &= ~ VAR_189 ; goto VAR_190 ; }",<S2SV_ModStart> ( VAR_185 ) ; TYPE_10 VAR_191 = VAR_192 <S2SV_ModStart> VAR_68 ) { VAR_191 = ! <S2SV_ModEnd> METHOD_9 ( VAR_170 <S2SV_ModStart> ( VAR_170 ) ; if ( ! VAR_191 <S2SV_ModStart> } if ( VAR_191 ||,"CWE-358 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }",<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
571,"CWE-190 METHOD_0 ( TYPE_0 , TYPE_1 ) { TYPE_2 * VAR_0 = ( TYPE_3 * ) VAR_1 ( METHOD_1 ( ) VAR_2 ) ; TYPE_4 VAR_3 = 0 ; if ( zend_parse_parameters ( METHOD_2 ( ) VAR_4 , ""l"" , & VAR_5 ) == FAILURE ) { return ; } if ( VAR_6 <= 0 ) { php_error_docref ( TYPE_5 VAR_7 , VAR_8 , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; VAR_9 ; } <S2SV_StartBug> METHOD_3 ( VAR_10 ) = METHOD_4 ( VAR_11 + 1 ) ; <S2SV_EndBug> METHOD_5 ( VAR_12 ) = METHOD_6 ( VAR_13 -> VAR_14 . VAR_15 . VAR_16 , METHOD_7 ( VAR_17 ) , VAR_18 ) ; METHOD_8 ( VAR_19 ) [ METHOD_9 ( VAR_20 ) ] = 0 ; METHOD_10 ( VAR_21 ) = VAR_22 ; }","<S2SV_ModStart> VAR_9 ; } if ( VAR_18 > VAR_23 ) { php_error_docref ( TYPE_5 VAR_7 , VAR_8 , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , VAR_23 ) ; VAR_9 ; }","CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""l"" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }","<S2SV_ModStart> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; }"
572,"CWE-190 <S2SV_StartBug> TYPE_0 * METHOD_0 ( TYPE_1 * TYPE_2 , TYPE_3 VAR_0 ) <S2SV_EndBug> { VAR_1 * VAR_2 ; TYPE_4 * VAR_3 ; if ( ! ( VAR_4 = TYPE_5 ( VAR_5 ( TYPE_6 * , TYPE_7 ) , VAR_6 ) ) ) goto VAR_7 ; if ( ! ( VAR_8 = METHOD_1 ( VAR_9 ) ) ) goto VAR_10 ; METHOD_2 ( VAR_11 ) ; return VAR_12 ; VAR_13 : if ( VAR_14 ) METHOD_3 ( VAR_15 ) ; return 0 ; }","<S2SV_ModStart> * METHOD_0 ( TYPE_8 <S2SV_ModEnd> * TYPE_7 ,","CWE-190 <S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }","<S2SV_ModStart> * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf ,"
573,CWE-404 static TYPE_0 METHOD_0 ( TYPE_1 ) { struct STRUCT_OR_UNION_0 * VAR_0 ; TYPE_2 VAR_1 ; VAR_2 = METHOD_1 ( ) ; if ( ! VAR_3 ) return - VAR_4 ; VAR_5 = METHOD_2 ( VAR_6 ) ; if ( VAR_7 < 0 ) { METHOD_3 ( VAR_8 ) ; <S2SV_StartBug> return VAR_9 != - VAR_10 ? VAR_11 : 0 ; <S2SV_EndBug> } return METHOD_4 ( VAR_12 ) ; },<S2SV_ModStart> ; return VAR_11 <S2SV_ModEnd> ; } return,CWE-404 static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; },<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
574,CWE-190 TYPE_0 * METHOD_0 ( TYPE_1 VAR_0 ) { <S2SV_StartBug> TYPE_2 * VAR_1 = <S2SV_EndBug> <S2SV_StartBug> ( TYPE_3 * ) METHOD_1 ( METHOD_2 ( VAR_2 ) ) ; <S2SV_EndBug> VAR_3 -> VAR_4 = VAR_5 ; return VAR_6 ; },<S2SV_ModStart> VAR_5 ) { TYPE_1 VAR_7 = METHOD_2 ( VAR_5 ) ; if ( VAR_7 <= 0 ) return VAR_8 ; <S2SV_ModStart> ) METHOD_1 ( VAR_7 ) ; if ( ! VAR_6 ) return VAR_6 <S2SV_ModEnd> ; VAR_6 ->,CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ret -> size = size ; return ret ; },<S2SV_ModStart> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> ; ret ->
575,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; TYPE_1 VAR_3 = - VAR_4 ; unsigned TYPE_2 VAR_5 , VAR_6 ; <S2SV_StartBug> struct STRUCT_OR_UNION_3 VAR_7 = { <S2SV_EndBug> . VAR_8 = 0x0000beef , } ; <S2SV_StartBug> struct STRUCT_OR_UNION_4 VAR_9 ; <S2SV_EndBug> VAR_10 = METHOD_1 ( METHOD_2 ( VAR_11 ) , METHOD_3 ( METHOD_4 ( VAR_12 ) , 0 ) , VAR_13 , VAR_14 | VAR_15 | VAR_16 , 1 , VAR_17 -> VAR_18 [ 0 ] . VAR_19 . VAR_20 , <S2SV_StartBug> & VAR_21 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( VAR_22 ) , <S2SV_EndBug> 1000 ) ; <S2SV_StartBug> if ( VAR_23 < 0 ) { <S2SV_EndBug> METHOD_5 ( & VAR_24 -> VAR_25 , ""Couldn\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\n"" , VAR_26 ) ; return VAR_27 ; <S2SV_StartBug> } <S2SV_EndBug> VAR_28 = METHOD_6 ( METHOD_7 ( VAR_29 ) , METHOD_8 ( METHOD_9 ( VAR_30 ) , 0 ) , VAR_31 , VAR_32 | VAR_33 | VAR_34 , 1 , VAR_35 -> VAR_36 [ 0 ] . VAR_37 . VAR_38 , <S2SV_StartBug> & VAR_39 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( VAR_40 ) , <S2SV_EndBug> 1000 ) ; if ( VAR_41 < 0 ) { METHOD_10 ( & VAR_42 -> VAR_43 , ""Couldn\'t<S2SV_blank>get<S2SV_blank>device<S2SV_blank>config:<S2SV_blank>(err=%d)\\n"" , VAR_44 ) ; <S2SV_StartBug> return VAR_45 ; <S2SV_EndBug> } VAR_46 = VAR_47 . VAR_48 + 1 ; METHOD_11 ( & VAR_49 -> VAR_50 , ""Configuring<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>interfaces\\n"" , VAR_51 ) ; if ( VAR_52 > VAR_53 ) { METHOD_12 ( & VAR_54 -> VAR_55 , ""Driver<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>more<S2SV_blank>that<S2SV_blank>%d<S2SV_blank>CAN<S2SV_blank>interfaces\\n"" , VAR_56 ) ; <S2SV_StartBug> return - VAR_57 ; <S2SV_EndBug> } VAR_58 = METHOD_13 ( sizeof ( * VAR_59 ) , VAR_60 ) ; <S2SV_StartBug> if ( ! VAR_61 ) <S2SV_EndBug> return - VAR_62 ; <S2SV_StartBug> METHOD_14 ( & VAR_63 -> VAR_64 ) ; <S2SV_EndBug> METHOD_15 ( & VAR_65 -> VAR_66 , 0 ) ; METHOD_16 ( VAR_67 , VAR_68 ) ; VAR_69 -> VAR_70 = METHOD_17 ( VAR_71 ) ; for ( VAR_72 = 0 ; VAR_73 < VAR_74 ; VAR_75 ++ ) { <S2SV_StartBug> VAR_76 -> VAR_77 [ VAR_78 ] = METHOD_18 ( VAR_79 , VAR_80 , & VAR_81 ) ; <S2SV_EndBug> if ( METHOD_19 ( VAR_82 -> VAR_83 [ VAR_84 ] ) ) { VAR_85 = METHOD_20 ( VAR_86 -> VAR_87 [ VAR_88 ] ) ; VAR_89 = VAR_90 ; for ( VAR_91 = 0 ; VAR_92 < VAR_93 ; VAR_94 ++ ) METHOD_21 ( VAR_95 -> VAR_96 [ VAR_97 ] ) ; METHOD_22 ( & VAR_98 -> VAR_99 ) ; <S2SV_StartBug> METHOD_23 ( VAR_100 ) ; <S2SV_EndBug> return VAR_101 ; } VAR_102 -> VAR_103 [ VAR_104 ] -> VAR_105 = VAR_106 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","<S2SV_ModStart> ; struct STRUCT_OR_UNION_3 * VAR_22 <S2SV_ModEnd> ; struct STRUCT_OR_UNION_4 <S2SV_ModStart> ; struct STRUCT_OR_UNION_4 * VAR_81 ; VAR_22 = METHOD_24 ( sizeof ( * VAR_22 ) , VAR_60 ) ; if ( ! VAR_22 ) return - VAR_62 ; VAR_22 -> VAR_8 = 0x0000beef <S2SV_ModEnd> ; VAR_101 = <S2SV_ModStart> . VAR_38 , <S2SV_ModEnd> VAR_22 , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> 1000 ) ; METHOD_23 ( VAR_22 ) ; <S2SV_ModStart> VAR_101 ; } VAR_81 = METHOD_24 ( sizeof ( * VAR_81 ) , VAR_60 ) ; if ( ! VAR_81 ) return - VAR_62 ; <S2SV_ModStart> . VAR_38 , <S2SV_ModEnd> VAR_81 , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> VAR_101 ) ; METHOD_23 ( VAR_81 ) ; return VAR_101 ; } VAR_93 = VAR_81 -> <S2SV_ModEnd> VAR_93 + 1 <S2SV_ModStart> VAR_56 ) ; METHOD_23 ( VAR_81 ) ; <S2SV_ModStart> ! VAR_106 ) { METHOD_23 ( VAR_81 ) ; <S2SV_ModStart> - VAR_62 ; } <S2SV_ModStart> , VAR_80 , <S2SV_ModEnd> VAR_81 ) ; <S2SV_ModStart> ; METHOD_23 ( VAR_81 ) ; METHOD_23 ( <S2SV_ModStart> VAR_106 ; } METHOD_23 ( VAR_81 ) ;","CWE-119 static int gs_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct gs_usb * dev ; int rc = - ENOMEM ; unsigned int icount , i ; <S2SV_StartBug> struct gs_host_config hconf = { <S2SV_EndBug> . byte_order = 0x0000beef , } ; <S2SV_StartBug> struct gs_device_config dconf ; <S2SV_EndBug> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <S2SV_StartBug> & hconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( hconf ) , <S2SV_EndBug> 1000 ) ; <S2SV_StartBug> if ( rc < 0 ) { <S2SV_EndBug> dev_err ( & intf -> dev , ""Couldn\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\n"" , rc ) ; return rc ; <S2SV_StartBug> } <S2SV_EndBug> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <S2SV_StartBug> & dconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( dconf ) , <S2SV_EndBug> 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>device<S2SV_blank>config:<S2SV_blank>(err=%d)\\n"" , rc ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> } icount = dconf . icount + 1 ; dev_info ( & intf -> dev , ""Configuring<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>interfaces\\n"" , icount ) ; if ( icount > GS_MAX_INTF ) { dev_err ( & intf -> dev , ""Driver<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>more<S2SV_blank>that<S2SV_blank>%d<S2SV_blank>CAN<S2SV_blank>interfaces\\n"" , GS_MAX_INTF ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! dev ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> init_usb_anchor ( & dev -> rx_submitted ) ; <S2SV_EndBug> atomic_set ( & dev -> active_channels , 0 ) ; usb_set_intfdata ( intf , dev ) ; dev -> udev = interface_to_usbdev ( intf ) ; for ( i = 0 ; i < icount ; i ++ ) { <S2SV_StartBug> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <S2SV_EndBug> if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) { rc = PTR_ERR ( dev -> canch [ i ] ) ; icount = i ; for ( i = 0 ; i < icount ; i ++ ) gs_destroy_candev ( dev -> canch [ i ] ) ; usb_kill_anchored_urbs ( & dev -> rx_submitted ) ; <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> return rc ; } dev -> canch [ i ] -> parent = dev ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","<S2SV_ModStart> ; struct gs_host_config * hconf <S2SV_ModEnd> ; struct gs_device_config <S2SV_ModStart> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> ; rc = <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> hconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> 1000 ) ; kfree ( hconf ) ; <S2SV_ModStart> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> dconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> icount + 1 <S2SV_ModStart> GS_MAX_INTF ) ; kfree ( dconf ) ; <S2SV_ModStart> ! dev ) { kfree ( dconf ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> , intf , <S2SV_ModEnd> dconf ) ; <S2SV_ModStart> ; kfree ( dconf ) ; kfree ( <S2SV_ModStart> dev ; } kfree ( dconf ) ;"
576,"CWE-20 static TYPE_0 METHOD_0 ( unsigned TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 ) { unsigned TYPE_3 VAR_3 , VAR_4 = 0 ; TYPE_4 VAR_5 [ 11 ] ; do { switch ( * VAR_6 & 0xC0 ) { case 0x00 : <S2SV_StartBug> VAR_7 += 2 ; <S2SV_EndBug> VAR_8 += 2 ; VAR_9 -= 2 ; break ; case 0x40 : <S2SV_StartBug> VAR_10 += 3 ; <S2SV_EndBug> VAR_11 += 3 ; VAR_12 -= 3 ; break ; case 0x80 : <S2SV_StartBug> VAR_13 += 4 ; <S2SV_EndBug> VAR_14 += 4 ; VAR_15 -= 4 ; break ; case 0xC0 : <S2SV_StartBug> VAR_16 = VAR_17 [ 1 ] ; <S2SV_EndBug> if ( VAR_18 < 10 || VAR_19 > 20 ) return - 1 ; if ( * VAR_20 == VAR_21 ) { METHOD_1 ( & VAR_22 -> VAR_23 , VAR_24 + 7 , VAR_25 ) ; METHOD_2 ( VAR_26 , VAR_27 + 12 , VAR_28 - 10 ) ; VAR_29 [ VAR_30 - 10 ] = '\\0' ; METHOD_3 ( & VAR_31 -> VAR_32 , VAR_33 ) ; } if ( * VAR_34 == VAR_35 ) { METHOD_4 ( & VAR_36 -> VAR_37 , VAR_38 + 7 , VAR_39 ) ; METHOD_5 ( VAR_40 , VAR_41 + 12 , VAR_42 - 10 ) ; VAR_43 [ VAR_44 - 10 ] = '\\0' ; METHOD_6 ( & VAR_45 -> VAR_46 , VAR_47 ) ; } VAR_48 += VAR_49 + 2 ; VAR_50 += VAR_51 + 2 ; VAR_52 -= VAR_53 + 2 ; break ; } } while ( * VAR_54 != 0x00 && VAR_55 > 0 ) ; return VAR_56 ; }",<S2SV_ModStart> case 0x00 : if ( VAR_55 < 2 ) return - 1 ; <S2SV_ModStart> case 0x40 : if ( VAR_55 < 3 ) return - 1 ; <S2SV_ModStart> case 0x80 : if ( VAR_55 < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( VAR_55 < 2 ) return - 1 ;,"CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : <S2SV_StartBug> p += 2 ; <S2SV_EndBug> n += 2 ; len -= 2 ; break ; case 0x40 : <S2SV_StartBug> p += 3 ; <S2SV_EndBug> n += 3 ; len -= 3 ; break ; case 0x80 : <S2SV_StartBug> p += 4 ; <S2SV_EndBug> n += 4 ; len -= 4 ; break ; case 0xC0 : <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }",<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> case 0x40 : if ( len < 3 ) return - 1 ; <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ;
577,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 * VAR_3 , TYPE_1 * VAR_4 [ VAR_5 ] , struct STRUCT_OR_UNION_4 * * VAR_6 ) { TYPE_2 VAR_7 ; TYPE_3 VAR_8 ; TYPE_4 VAR_9 = 0 ; TYPE_5 VAR_10 ; TYPE_6 * VAR_11 = 0 ; TYPE_7 VAR_12 [ VAR_13 ] ; struct STRUCT_OR_UNION_5 * VAR_14 = METHOD_1 ( VAR_15 -> VAR_16 ) ; TYPE_8 * VAR_17 ; TYPE_9 VAR_18 ; if ( ! VAR_19 ) { METHOD_2 ( VAR_20 , 0 , sizeof ( * VAR_21 ) ) ; } else { VAR_22 = METHOD_3 ( VAR_23 , VAR_24 | VAR_25 , ( TYPE_10 ) VAR_26 , sizeof ( struct STRUCT_OR_UNION_6 ) ) ; if ( VAR_27 != VAR_28 ) return VAR_29 ; <S2SV_StartBug> METHOD_4 ( VAR_30 , VAR_31 ) ; <S2SV_EndBug> } if ( VAR_32 && METHOD_5 ( VAR_33 -> VAR_34 ) ) { return VAR_35 ; } for ( VAR_36 = 0 ; VAR_37 < VAR_38 ; VAR_39 ++ ) { VAR_40 [ VAR_41 ] = VAR_42 ; switch ( METHOD_6 ( VAR_43 -> VAR_44 , VAR_45 ) ) { case VAR_46 : case VAR_47 : case VAR_48 : VAR_49 = ( TYPE_11 * ) VAR_50 -> VAR_51 [ VAR_52 ] . VAR_53 . VAR_54 ; VAR_55 = VAR_56 -> VAR_57 [ VAR_58 ] . VAR_59 . VAR_60 ; if ( ! VAR_61 ) { if ( VAR_62 ) return VAR_63 ; break ; } if ( METHOD_7 ( VAR_64 , VAR_65 , VAR_66 ) ) { VAR_67 = METHOD_8 ( VAR_68 , sizeof ( VAR_69 ) ) ; if ( METHOD_9 ( VAR_70 , VAR_71 , & VAR_72 ) ) return VAR_73 ; VAR_74 [ VAR_75 ] = VAR_76 ; break ; } VAR_77 = METHOD_10 ( VAR_78 , VAR_79 , VAR_80 , & VAR_81 -> VAR_82 [ VAR_83 ] . VAR_84 . STRUCT_OR_UNION_7 , & VAR_85 -> VAR_86 [ VAR_87 ] . VAR_88 . VAR_89 ) ; if ( VAR_90 != VAR_91 ) return VAR_92 ; break ; default : break ; } } if ( VAR_93 == 0 ) return VAR_94 ; VAR_95 = METHOD_11 ( VAR_96 , VAR_97 , & VAR_98 ) ; if ( VAR_99 != VAR_100 ) return VAR_101 ; VAR_102 = 0 ; for ( VAR_103 = 0 ; VAR_104 < VAR_105 ; VAR_106 ++ ) { if ( ! VAR_107 [ VAR_108 ] ) continue ; VAR_109 = METHOD_12 ( VAR_110 -> VAR_111 [ VAR_112 ] . VAR_113 . VAR_114 , sizeof ( VAR_115 ) ) ; switch ( METHOD_13 ( VAR_116 -> VAR_117 , VAR_118 ) ) { case VAR_119 : case VAR_120 : VAR_121 = ( TYPE_12 * ) VAR_122 -> VAR_123 [ VAR_124 ] . VAR_125 . VAR_126 ; if ( VAR_127 ) { VAR_128 = METHOD_14 ( VAR_129 , VAR_130 , VAR_131 -> VAR_132 [ VAR_133 ] . VAR_134 . VAR_135 ) ; if ( VAR_136 != VAR_137 ) return VAR_138 ; VAR_139 -> VAR_140 [ VAR_141 ] . VAR_142 . VAR_143 = VAR_144 ; VAR_145 -> VAR_146 [ VAR_147 ] . VAR_148 . STRUCT_OR_UNION_8 = * VAR_149 ; VAR_150 [ VAR_151 ] = VAR_152 ; VAR_153 += VAR_154 ; VAR_155 += VAR_156 ; } break ; case VAR_157 : VAR_158 = ( TYPE_13 * ) VAR_159 -> VAR_160 [ VAR_161 ] . VAR_162 . VAR_163 ; if ( VAR_164 ) { VAR_165 -> VAR_166 [ VAR_167 ] . VAR_168 . VAR_169 = VAR_170 ; VAR_171 -> VAR_172 [ VAR_173 ] . VAR_174 . STRUCT_OR_UNION_9 = * VAR_175 ; VAR_176 [ VAR_177 ] = VAR_178 ; VAR_179 += VAR_180 ; VAR_181 += VAR_182 ; } break ; default : continue ; } } return VAR_183 ; }","<S2SV_ModStart> return VAR_138 ; VAR_138 = METHOD_4 ( VAR_78 , <S2SV_ModEnd> VAR_171 , VAR_31 <S2SV_ModStart> , VAR_31 ) ; if ( VAR_138 != VAR_183 ) return VAR_138","CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }","<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res"
578,"CWE-119 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 * VAR_3 ; TYPE_5 VAR_4 ; TYPE_6 VAR_5 , VAR_6 ; TYPE_7 VAR_7 ; TYPE_8 * VAR_8 ; register TYPE_9 * VAR_9 ; register TYPE_10 VAR_10 ; register TYPE_11 * VAR_11 ; register TYPE_12 VAR_12 ; register unsigned TYPE_13 * VAR_13 ; TYPE_14 VAR_14 , VAR_15 ; TYPE_15 VAR_16 ; unsigned TYPE_16 * VAR_17 ; METHOD_1 ( VAR_18 != ( const TYPE_17 * ) VAR_19 ) ; METHOD_2 ( VAR_20 -> VAR_21 == VAR_22 ) ; if ( VAR_23 -> VAR_24 != VAR_25 ) ( TYPE_18 ) METHOD_3 ( VAR_26 , METHOD_4 ( ) , ""%s"" , VAR_27 -> VAR_28 ) ; METHOD_5 ( VAR_29 != ( TYPE_19 * ) VAR_30 ) ; METHOD_6 ( VAR_31 -> VAR_32 == VAR_33 ) ; VAR_34 = METHOD_7 ( VAR_35 ) ; VAR_36 = METHOD_8 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; if ( VAR_41 == VAR_42 ) { VAR_43 = METHOD_9 ( VAR_44 ) ; return ( ( TYPE_20 * ) VAR_45 ) ; } ( TYPE_21 ) METHOD_10 ( & VAR_46 , 0 , sizeof ( VAR_47 ) ) ; VAR_48 . VAR_49 = METHOD_11 ( VAR_50 ) ; if ( VAR_51 . VAR_52 != 40 ) METHOD_12 ( VAR_53 , ""ImproperImageHeader"" ) ; VAR_54 . VAR_55 = ( TYPE_22 ) METHOD_13 ( VAR_56 ) ; VAR_57 . VAR_58 = ( TYPE_23 ) METHOD_14 ( VAR_59 ) ; VAR_60 . VAR_61 = METHOD_15 ( VAR_62 ) ; VAR_63 . VAR_64 = METHOD_16 ( VAR_65 ) ; VAR_66 . VAR_67 = METHOD_17 ( VAR_68 ) ; VAR_69 . VAR_70 = METHOD_18 ( VAR_71 ) ; VAR_72 . VAR_73 = METHOD_19 ( VAR_74 ) ; VAR_75 . VAR_76 = METHOD_20 ( VAR_77 ) ; VAR_78 . VAR_79 = METHOD_21 ( VAR_80 ) ; VAR_81 . VAR_82 = METHOD_22 ( VAR_83 ) ; if ( ( VAR_84 . VAR_85 == VAR_86 ) && ( ( VAR_87 . VAR_88 == 16 ) || ( VAR_89 . VAR_90 == 32 ) ) ) { VAR_91 . VAR_92 = METHOD_23 ( VAR_93 ) ; VAR_94 . VAR_95 = METHOD_24 ( VAR_96 ) ; VAR_97 . VAR_98 = METHOD_25 ( VAR_99 ) ; } VAR_100 -> VAR_101 = VAR_102 . VAR_103 == 32 ? VAR_104 : VAR_105 ; VAR_106 -> VAR_107 = ( TYPE_24 ) METHOD_26 ( VAR_108 . VAR_109 ) ; VAR_110 -> VAR_111 = ( TYPE_25 ) METHOD_27 ( VAR_112 . VAR_113 ) ; VAR_114 -> VAR_115 = 8 ; if ( ( VAR_116 . VAR_117 != 0 ) || ( VAR_118 . VAR_119 < 16 ) ) { TYPE_26 VAR_120 ; VAR_121 -> VAR_122 = VAR_123 ; VAR_124 -> VAR_125 = VAR_126 . VAR_127 ; VAR_128 = 1 ; if ( VAR_129 -> VAR_130 == 0 ) VAR_131 -> VAR_132 = VAR_133 << VAR_134 . VAR_135 ; } if ( VAR_136 -> VAR_137 ) { TYPE_27 VAR_138 ; TYPE_28 VAR_139 ; VAR_140 = METHOD_28 ( VAR_141 -> VAR_142 , & VAR_143 ) ; if ( VAR_144 & VAR_145 ) if ( ( VAR_146 . VAR_147 != 0 ) && ( VAR_148 . VAR_149 < VAR_150 -> VAR_151 ) ) VAR_152 -> VAR_153 = VAR_154 . VAR_155 ; if ( VAR_156 & VAR_157 ) if ( ( VAR_158 . VAR_159 != 0 ) && ( VAR_160 . VAR_161 < VAR_162 -> VAR_163 ) ) VAR_164 -> VAR_165 = VAR_166 . VAR_167 ; } <S2SV_StartBug> if ( VAR_168 -> VAR_169 == VAR_170 ) <S2SV_EndBug> { TYPE_29 VAR_171 , VAR_172 ; unsigned TYPE_30 * VAR_173 ; if ( METHOD_29 ( VAR_174 , VAR_175 -> VAR_176 ) == VAR_177 ) METHOD_30 ( VAR_178 , ""MemoryAllocationFailed"" ) ; VAR_179 = ( TYPE_31 ) VAR_180 -> VAR_181 ; VAR_182 = ( unsigned TYPE_32 * ) METHOD_31 ( VAR_183 , 4 * sizeof ( * VAR_184 ) ) ; if ( VAR_185 == ( unsigned TYPE_33 * ) VAR_186 ) METHOD_32 ( VAR_187 , ""MemoryAllocationFailed"" ) ; VAR_188 = 4 ; VAR_189 = METHOD_33 ( VAR_190 , VAR_191 * VAR_192 -> VAR_193 , VAR_194 ) ; if ( VAR_195 != ( TYPE_34 ) ( VAR_196 * VAR_197 -> VAR_198 ) ) METHOD_34 ( VAR_199 , ""InsufficientImageDataInFile"" ) ; VAR_200 = VAR_201 ; for ( VAR_202 = 0 ; VAR_203 < ( TYPE_35 ) VAR_204 -> VAR_205 ; VAR_206 ++ ) { VAR_207 -> VAR_208 [ VAR_209 ] . VAR_210 = METHOD_35 ( * VAR_211 ++ ) ; VAR_212 -> VAR_213 [ VAR_214 ] . VAR_215 = METHOD_36 ( * VAR_216 ++ ) ; VAR_217 -> VAR_218 [ VAR_219 ] . VAR_220 = METHOD_37 ( * VAR_221 ++ ) ; if ( VAR_222 == 4 ) VAR_223 ++ ; } VAR_224 = ( unsigned TYPE_36 * ) METHOD_38 ( VAR_225 ) ; } if ( VAR_226 . VAR_227 == VAR_228 ) VAR_229 . VAR_230 <<= 1 ; VAR_231 = 4 * ( ( VAR_232 -> VAR_233 * VAR_234 . VAR_235 + 31 ) / 32 ) ; VAR_236 = VAR_237 * VAR_238 -> VAR_239 ; VAR_240 = METHOD_39 ( ( TYPE_37 ) VAR_241 -> VAR_242 , METHOD_40 ( VAR_243 , VAR_244 -> VAR_245 + 256UL ) * sizeof ( * VAR_246 ) ) ; if ( VAR_247 == ( TYPE_38 * ) VAR_248 ) METHOD_41 ( VAR_249 , ""MemoryAllocationFailed"" ) ; VAR_250 = ( unsigned TYPE_39 * ) METHOD_42 ( VAR_251 ) ; if ( ( VAR_252 . VAR_253 == VAR_254 ) || ( VAR_255 . VAR_256 == VAR_257 ) ) { VAR_258 = METHOD_43 ( VAR_259 , VAR_260 , VAR_261 ) ; if ( VAR_262 != ( TYPE_40 ) ( VAR_263 ) ) METHOD_44 ( VAR_264 , ""InsufficientImageDataInFile"" ) ; } else { VAR_265 = METHOD_45 ( VAR_266 , VAR_267 . VAR_268 ? VAR_269 : VAR_270 , VAR_271 ) ; if ( VAR_272 == VAR_273 ) METHOD_46 ( VAR_274 , ""UnableToRunlengthDecodeImage"" ) ; } VAR_275 -> VAR_276 = VAR_277 ; VAR_278 -> VAR_279 = ( TYPE_41 ) VAR_280 . VAR_281 / 100.0 ; VAR_282 -> VAR_283 = ( TYPE_42 ) VAR_284 . VAR_285 / 100.0 ; switch ( VAR_286 . VAR_287 ) { case 1 : { for ( VAR_288 = ( TYPE_43 ) VAR_289 -> VAR_290 - 1 ; VAR_291 >= 0 ; VAR_292 -- ) { VAR_293 = VAR_294 + ( VAR_295 -> VAR_296 - VAR_297 - 1 ) * VAR_298 ; VAR_299 = METHOD_47 ( VAR_300 , 0 , VAR_301 , VAR_302 -> VAR_303 , 1 , VAR_304 ) ; if ( VAR_305 == ( TYPE_44 * ) VAR_306 ) break ; VAR_307 = METHOD_48 ( VAR_308 ) ; for ( VAR_309 = 0 ; VAR_310 < ( ( TYPE_45 ) VAR_311 -> VAR_312 - 7 ) ; VAR_313 += 8 ) { for ( VAR_314 = 0 ; VAR_315 < 8 ; VAR_316 ++ ) { VAR_317 = ( TYPE_46 ) ( ( * VAR_318 ) & ( 0x80 >> VAR_319 ) ? 0x01 : 0x00 ) ; METHOD_49 ( VAR_320 + VAR_321 + VAR_322 , VAR_323 ) ; } VAR_324 ++ ; } if ( ( VAR_325 -> VAR_326 % 8 ) != 0 ) { for ( VAR_327 = 0 ; VAR_328 < ( TYPE_47 ) ( VAR_329 -> VAR_330 % 8 ) ; VAR_331 ++ ) { VAR_332 = ( TYPE_48 ) ( ( * VAR_333 ) & ( 0x80 >> VAR_334 ) ? 0x01 : 0x00 ) ; METHOD_50 ( VAR_335 + VAR_336 + VAR_337 , VAR_338 ) ; } VAR_339 ++ ; } if ( METHOD_51 ( VAR_340 , VAR_341 ) == VAR_342 ) break ; if ( VAR_343 -> VAR_344 == ( TYPE_49 * ) VAR_345 ) { VAR_346 = METHOD_52 ( VAR_347 , VAR_348 , VAR_349 -> VAR_350 - VAR_351 - 1 , VAR_352 -> VAR_353 ) ; if ( VAR_354 == VAR_355 ) break ; } } ( TYPE_50 ) METHOD_53 ( VAR_356 ) ; break ; } case 4 : { for ( VAR_357 = ( TYPE_51 ) VAR_358 -> VAR_359 - 1 ; VAR_360 >= 0 ; VAR_361 -- ) { VAR_362 = VAR_363 + ( VAR_364 -> VAR_365 - VAR_366 - 1 ) * VAR_367 ; VAR_368 = METHOD_54 ( VAR_369 , 0 , VAR_370 , VAR_371 -> VAR_372 , 1 , VAR_373 ) ; if ( VAR_374 == ( TYPE_52 * ) VAR_375 ) break ; VAR_376 = METHOD_55 ( VAR_377 ) ; for ( VAR_378 = 0 ; VAR_379 < ( ( TYPE_53 ) VAR_380 -> VAR_381 - 1 ) ; VAR_382 += 2 ) { VAR_383 = METHOD_56 ( VAR_384 , ( * VAR_385 >> 4 ) & 0xf ) ; METHOD_57 ( VAR_386 + VAR_387 , VAR_388 ) ; VAR_389 = METHOD_58 ( VAR_390 , * VAR_391 & 0xf ) ; METHOD_59 ( VAR_392 + VAR_393 + 1 , VAR_394 ) ; VAR_395 ++ ; } if ( ( VAR_396 -> VAR_397 % 2 ) != 0 ) { VAR_398 = METHOD_60 ( VAR_399 , ( * VAR_400 >> 4 ) & 0xf ) ; METHOD_61 ( VAR_401 + VAR_402 , VAR_403 ) ; VAR_404 ++ ; } if ( METHOD_62 ( VAR_405 , VAR_406 ) == VAR_407 ) break ; if ( VAR_408 -> VAR_409 == ( TYPE_54 * ) VAR_410 ) { VAR_411 = METHOD_63 ( VAR_412 , VAR_413 , VAR_414 -> VAR_415 - VAR_416 - 1 , VAR_417 -> VAR_418 ) ; if ( VAR_419 == VAR_420 ) break ; } } ( TYPE_55 ) METHOD_64 ( VAR_421 ) ; break ; } case 8 : { if ( ( VAR_422 . VAR_423 == VAR_424 ) || ( VAR_425 . VAR_426 == VAR_427 ) ) VAR_428 = VAR_429 -> VAR_430 ; for ( VAR_431 = ( TYPE_56 ) VAR_432 -> VAR_433 - 1 ; VAR_434 >= 0 ; VAR_435 -- ) { VAR_436 = VAR_437 + ( VAR_438 -> VAR_439 - VAR_440 - 1 ) * VAR_441 ; VAR_442 = METHOD_65 ( VAR_443 , 0 , VAR_444 , VAR_445 -> VAR_446 , 1 , VAR_447 ) ; if ( VAR_448 == ( TYPE_57 * ) VAR_449 ) break ; VAR_450 = METHOD_66 ( VAR_451 ) ; for ( VAR_452 = 0 ; VAR_453 < ( TYPE_58 ) VAR_454 -> VAR_455 ; VAR_456 ++ ) { VAR_457 = METHOD_67 ( VAR_458 , * VAR_459 ) ; METHOD_68 ( VAR_460 + VAR_461 , VAR_462 ) ; VAR_463 ++ ; VAR_464 ++ ; } if ( METHOD_69 ( VAR_465 , VAR_466 ) == VAR_467 ) break ; if ( VAR_468 -> VAR_469 == ( TYPE_59 * ) VAR_470 ) { VAR_471 = METHOD_70 ( VAR_472 , VAR_473 , VAR_474 -> VAR_475 - VAR_476 - 1 , VAR_477 -> VAR_478 ) ; if ( VAR_479 == VAR_480 ) break ; } } ( TYPE_60 ) METHOD_71 ( VAR_481 ) ; break ; } case 16 : { unsigned TYPE_61 VAR_482 ; VAR_483 -> VAR_484 = VAR_485 ; if ( VAR_486 . VAR_487 == VAR_488 ) VAR_489 = 2 * VAR_490 -> VAR_491 ; for ( VAR_492 = ( TYPE_62 ) VAR_493 -> VAR_494 - 1 ; VAR_495 >= 0 ; VAR_496 -- ) { VAR_497 = VAR_498 + ( VAR_499 -> VAR_500 - VAR_501 - 1 ) * VAR_502 ; VAR_503 = METHOD_72 ( VAR_504 , 0 , VAR_505 , VAR_506 -> VAR_507 , 1 , VAR_508 ) ; if ( VAR_509 == ( TYPE_63 * ) VAR_510 ) break ; for ( VAR_511 = 0 ; VAR_512 < ( TYPE_64 ) VAR_513 -> VAR_514 ; VAR_515 ++ ) { VAR_516 = ( * VAR_517 ++ ) ; VAR_518 |= ( * VAR_519 ++ << 8 ) ; if ( VAR_520 . VAR_521 == 0 ) { METHOD_73 ( VAR_522 , METHOD_74 ( METHOD_75 ( ( unsigned TYPE_65 ) ( ( VAR_523 >> 10 ) & 0x1f ) ) ) ) ; METHOD_76 ( VAR_524 , METHOD_77 ( METHOD_78 ( ( unsigned TYPE_66 ) ( ( VAR_525 >> 5 ) & 0x1f ) ) ) ) ; METHOD_79 ( VAR_526 , METHOD_80 ( METHOD_81 ( ( unsigned TYPE_67 ) ( VAR_527 & 0x1f ) ) ) ) ; } else { METHOD_82 ( VAR_528 , METHOD_83 ( METHOD_84 ( ( unsigned TYPE_68 ) ( ( VAR_529 >> 11 ) & 0x1f ) ) ) ) ; METHOD_85 ( VAR_530 , METHOD_86 ( METHOD_87 ( ( unsigned TYPE_69 ) ( ( VAR_531 >> 5 ) & 0x3f ) ) ) ) ; METHOD_88 ( VAR_532 , METHOD_89 ( METHOD_90 ( ( unsigned TYPE_70 ) ( VAR_533 & 0x1f ) ) ) ) ; } VAR_534 ++ ; } if ( METHOD_91 ( VAR_535 , VAR_536 ) == VAR_537 ) break ; if ( VAR_538 -> VAR_539 == ( TYPE_71 * ) VAR_540 ) { VAR_541 = METHOD_92 ( VAR_542 , VAR_543 , VAR_544 -> VAR_545 - VAR_546 - 1 , VAR_547 -> VAR_548 ) ; if ( VAR_549 == VAR_550 ) break ; } } break ; } case 24 : case 32 : { for ( VAR_551 = ( TYPE_72 ) VAR_552 -> VAR_553 - 1 ; VAR_554 >= 0 ; VAR_555 -- ) { VAR_556 = VAR_557 + ( VAR_558 -> VAR_559 - VAR_560 - 1 ) * VAR_561 ; VAR_562 = METHOD_93 ( VAR_563 , 0 , VAR_564 , VAR_565 -> VAR_566 , 1 , VAR_567 ) ; if ( VAR_568 == ( TYPE_73 * ) VAR_569 ) break ; for ( VAR_570 = 0 ; VAR_571 < ( TYPE_74 ) VAR_572 -> VAR_573 ; VAR_574 ++ ) { METHOD_94 ( VAR_575 , METHOD_95 ( * VAR_576 ++ ) ) ; METHOD_96 ( VAR_577 , METHOD_97 ( * VAR_578 ++ ) ) ; METHOD_98 ( VAR_579 , METHOD_99 ( * VAR_580 ++ ) ) ; if ( VAR_581 -> VAR_582 != VAR_583 ) METHOD_100 ( VAR_584 , METHOD_101 ( * VAR_585 ++ ) ) ; VAR_586 ++ ; } if ( METHOD_102 ( VAR_587 , VAR_588 ) == VAR_589 ) break ; if ( VAR_590 -> VAR_591 == ( TYPE_75 * ) VAR_592 ) { VAR_593 = METHOD_103 ( VAR_594 , VAR_595 , VAR_596 -> VAR_597 - VAR_598 - 1 , VAR_599 -> VAR_600 ) ; if ( VAR_601 == VAR_602 ) break ; } } break ; } default : METHOD_104 ( VAR_603 , ""ImproperImageHeader"" ) ; } VAR_604 = METHOD_105 ( VAR_605 ) ; if ( METHOD_106 ( VAR_606 ) != VAR_607 ) METHOD_107 ( VAR_608 , VAR_609 , ""UnexpectedEndOfFile"" , VAR_610 -> VAR_611 ) ; if ( VAR_612 . VAR_613 < 0 ) { TYPE_76 * VAR_614 ; VAR_615 = METHOD_108 ( VAR_616 , VAR_617 ) ; if ( VAR_618 != ( TYPE_77 * ) VAR_619 ) { METHOD_109 ( VAR_620 , VAR_621 ) ; VAR_622 = METHOD_110 ( VAR_623 ) ; VAR_624 = VAR_625 ; } } ( TYPE_78 ) METHOD_111 ( VAR_626 ) ; return ( METHOD_112 ( VAR_627 ) ) ; }","<S2SV_ModStart> VAR_613 ; } VAR_601 = METHOD_113 ( VAR_627 , VAR_627 -> VAR_573 , VAR_627 -> VAR_600 ) ; if ( VAR_601 == VAR_607 ) { METHOD_114 ( VAR_617 , & VAR_627 -> VAR_617 ) ; return ( METHOD_9 ( VAR_627 ) ) ; }","CWE-119 static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { DIBInfo dib_info ; Image * image ; IndexPacket index ; ssize_t bit , y ; MagickBooleanType status ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_line , length ; ssize_t count ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; if ( dib_info . size != 40 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; dib_info . planes = ReadBlobLSBShort ( image ) ; dib_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; dib_info . compression = ReadBlobLSBLong ( image ) ; dib_info . image_size = ReadBlobLSBLong ( image ) ; dib_info . x_pixels = ReadBlobLSBLong ( image ) ; dib_info . y_pixels = ReadBlobLSBLong ( image ) ; dib_info . number_colors = ReadBlobLSBLong ( image ) ; dib_info . colors_important = ReadBlobLSBLong ( image ) ; if ( ( dib_info . compression == BI_BITFIELDS ) && ( ( dib_info . bits_per_pixel == 16 ) || ( dib_info . bits_per_pixel == 32 ) ) ) { dib_info . red_mask = ReadBlobLSBLong ( image ) ; dib_info . green_mask = ReadBlobLSBLong ( image ) ; dib_info . blue_mask = ReadBlobLSBLong ( image ) ; } image -> matte = dib_info . bits_per_pixel == 32 ? MagickTrue : MagickFalse ; image -> columns = ( size_t ) MagickAbsoluteValue ( dib_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( dib_info . height ) ; image -> depth = 8 ; if ( ( dib_info . number_colors != 0 ) || ( dib_info . bits_per_pixel < 16 ) ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = dib_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << dib_info . bits_per_pixel ; } if ( image_info -> size ) { RectangleInfo geometry ; MagickStatusType flags ; flags = ParseAbsoluteGeometry ( image_info -> size , & geometry ) ; if ( flags & WidthValue ) if ( ( geometry . width != 0 ) && ( geometry . width < image -> columns ) ) image -> columns = geometry . width ; if ( flags & HeightValue ) if ( ( geometry . height != 0 ) && ( geometry . height < image -> rows ) ) image -> rows = geometry . height ; } <S2SV_StartBug> if ( image -> storage_class == PseudoClass ) <S2SV_EndBug> { size_t length , packet_size ; unsigned char * dib_colormap ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) image -> colors ; dib_colormap = ( unsigned char * ) AcquireQuantumMemory ( length , 4 * sizeof ( * dib_colormap ) ) ; if ( dib_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; packet_size = 4 ; count = ReadBlob ( image , packet_size * image -> colors , dib_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = dib_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } dib_colormap = ( unsigned char * ) RelinquishMagickMemory ( dib_colormap ) ; } if ( dib_info . compression == BI_RLE4 ) dib_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * dib_info . bits_per_pixel + 31 ) / 32 ) ; length = bytes_per_line * image -> rows ; pixel_info = AcquireVirtualMemory ( ( size_t ) image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( dib_info . compression == BI_RGB ) || ( dib_info . compression == BI_BITFIELDS ) ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) ( length ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } else { status = DecodeImage ( image , dib_info . compression ? MagickTrue : MagickFalse , pixels ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = ( double ) dib_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) dib_info . y_pixels / 100.0 ; switch ( dib_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , * p & 0xf ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( dib_info . compression == BI_RLE8 ) || ( dib_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { unsigned short word ; image -> storage_class = DirectClass ; if ( dib_info . compression == BI_RLE8 ) bytes_per_line = 2 * image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { word = ( * p ++ ) ; word |= ( * p ++ << 8 ) ; if ( dib_info . red_mask == 0 ) { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 10 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x1f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } else { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 11 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor6to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x3f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( dib_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; image = DestroyImage ( image ) ; image = flipped_image ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
579,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { TYPE_1 VAR_2 = VAR_3 ; TYPE_2 VAR_4 = VAR_5 -> VAR_6 ; TYPE_3 VAR_7 = VAR_8 -> VAR_9 ; switch ( VAR_10 ) { case VAR_11 : case VAR_12 : case VAR_13 : case VAR_14 : case VAR_15 : case VAR_16 : break ; case VAR_17 : return METHOD_1 ( VAR_18 , VAR_19 ) ; case VAR_20 : VAR_21 &= ~ ( TYPE_4 ) 0x40 ; VAR_22 &= ~ ( TYPE_5 ) 0x100 ; VAR_23 &= ~ ( TYPE_6 ) 0x8 ; if ( VAR_24 != 0 ) { METHOD_2 ( VAR_25 , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , VAR_26 ) ; return 1 ; } break ; case VAR_27 : if ( VAR_28 != 0 ) { METHOD_3 ( VAR_29 , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , VAR_30 ) ; return 1 ; } break ; case VAR_31 : if ( ! VAR_32 ) { break ; } else if ( VAR_33 & ~ ( VAR_34 | VAR_35 ) ) { return 1 ; } METHOD_4 ( VAR_36 , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , VAR_37 , VAR_38 ) ; break ; case 0x200 ... 0x2ff : return METHOD_5 ( VAR_39 , VAR_40 , VAR_41 ) ; case VAR_42 : METHOD_6 ( VAR_43 , VAR_44 ) ; break ; case VAR_45 ... VAR_46 + 0x3ff : return METHOD_7 ( VAR_47 , VAR_48 , VAR_49 ) ; case VAR_50 : METHOD_8 ( VAR_51 , VAR_52 ) ; break ; case VAR_53 : if ( METHOD_9 ( VAR_54 ) ) { if ( ! VAR_55 -> VAR_56 ) { TYPE_7 VAR_57 = VAR_58 - VAR_59 -> VAR_60 . VAR_61 ; VAR_62 -> METHOD_10 ( VAR_63 , VAR_64 , VAR_65 ) ; } VAR_66 -> VAR_67 . VAR_68 = VAR_69 ; } break ; case VAR_70 : VAR_71 -> VAR_72 . VAR_73 = VAR_74 ; break ; case VAR_75 : case VAR_76 : VAR_77 -> VAR_78 -> VAR_79 . VAR_80 = VAR_81 ; METHOD_11 ( VAR_82 -> VAR_83 , VAR_84 ) ; break ; case VAR_85 : case VAR_86 : { METHOD_12 ( VAR_87 ) ; VAR_88 -> VAR_89 . VAR_90 = VAR_91 ; METHOD_13 ( VAR_92 , VAR_93 ) ; if ( ! ( VAR_94 & 1 ) ) break ; <S2SV_StartBug> VAR_95 -> VAR_96 . VAR_97 = VAR_98 & ~ ( VAR_99 | 1 ) ; <S2SV_EndBug> VAR_100 -> VAR_101 . VAR_102 = METHOD_14 ( VAR_103 -> VAR_104 , VAR_105 >> VAR_106 ) ; if ( METHOD_15 ( VAR_107 -> VAR_108 . VAR_109 ) ) VAR_110 -> VAR_111 . VAR_112 = VAR_113 ; break ; } case VAR_114 : if ( METHOD_16 ( VAR_115 , VAR_116 ) ) return 1 ; break ; case VAR_117 : if ( METHOD_17 ( ! METHOD_18 ( ) ) ) return 1 ; if ( VAR_118 & VAR_119 ) return 1 ; if ( METHOD_19 ( VAR_120 -> VAR_121 , & VAR_122 -> VAR_123 . VAR_124 . VAR_125 , VAR_126 & VAR_127 ) ) return 1 ; VAR_128 -> VAR_129 . VAR_130 . VAR_131 = VAR_132 ; if ( ! ( VAR_133 & VAR_134 ) ) break ; VAR_135 -> VAR_136 . VAR_137 . VAR_138 = VAR_139 -> VAR_140 . VAR_141 ; METHOD_20 ( ) ; METHOD_21 ( VAR_142 ) ; METHOD_22 ( ) ; METHOD_23 ( VAR_143 , VAR_144 ) ; break ; case VAR_145 : if ( METHOD_24 ( VAR_146 , VAR_147 ) ) return 1 ; break ; case VAR_148 : case VAR_149 : case VAR_150 ... VAR_151 + 4 * VAR_152 - 1 : return METHOD_25 ( VAR_153 , VAR_154 , VAR_155 ) ; case VAR_156 : case VAR_157 : case VAR_158 : case VAR_159 : if ( VAR_160 != 0 ) METHOD_26 ( VAR_161 , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , VAR_162 , VAR_163 ) ; break ; case VAR_164 : case VAR_165 : case VAR_166 : case VAR_167 : METHOD_27 ( VAR_168 , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , VAR_169 , VAR_170 ) ; break ; case VAR_171 : case VAR_172 : VAR_173 = VAR_174 ; case VAR_175 : case VAR_176 : if ( METHOD_28 ( VAR_177 , VAR_178 ) ) return METHOD_29 ( VAR_179 , VAR_180 , VAR_181 ) ; if ( VAR_182 || VAR_183 != 0 ) METHOD_30 ( VAR_184 , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , VAR_185 , VAR_186 ) ; break ; case VAR_187 : break ; case VAR_188 ... VAR_189 : if ( METHOD_31 ( VAR_190 ) ) { TYPE_8 VAR_191 ; METHOD_32 ( & VAR_192 -> VAR_193 -> VAR_194 ) ; VAR_195 = METHOD_33 ( VAR_196 , VAR_197 , VAR_198 ) ; METHOD_34 ( & VAR_199 -> VAR_200 -> VAR_201 ) ; return VAR_202 ; } else return METHOD_35 ( VAR_203 , VAR_204 , VAR_205 ) ; break ; case VAR_206 : METHOD_36 ( VAR_207 , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , VAR_208 , VAR_209 ) ; break ; case VAR_210 : if ( ! METHOD_37 ( VAR_211 ) ) return 1 ; VAR_212 -> VAR_213 . VAR_214 . VAR_215 = VAR_216 ; break ; case VAR_217 : if ( ! METHOD_38 ( VAR_218 ) ) return 1 ; VAR_219 -> VAR_220 . VAR_221 . VAR_222 = VAR_223 ; break ; default : if ( VAR_224 && ( VAR_225 == VAR_226 -> VAR_227 -> VAR_228 . METHOD_39 . VAR_229 ) ) return METHOD_40 ( VAR_230 , VAR_231 ) ; if ( METHOD_41 ( VAR_232 , VAR_233 ) ) return METHOD_42 ( VAR_234 , VAR_235 , VAR_236 ) ; if ( ! VAR_237 ) { METHOD_43 ( VAR_238 , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , VAR_239 , VAR_240 ) ; return 1 ; } else { METHOD_44 ( VAR_241 , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , VAR_242 , VAR_243 ) ; break ; } } return 0 ; }",<S2SV_ModStart> | 1 ) ; if ( VAR_241 -> VAR_228 . VAR_97 & ( sizeof ( struct STRUCT_OR_UNION_2 ) - 1 ) ) break,"CWE-119 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }",<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
580,"CWE-125 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; struct STRUCT_OR_UNION_2 * VAR_2 ; unsigned TYPE_1 VAR_3 ; TYPE_2 VAR_4 ; VAR_5 = METHOD_1 ( & VAR_6 -> VAR_7 , sizeof ( * VAR_8 ) , VAR_9 ) ; if ( ! VAR_10 ) return - VAR_11 ; VAR_12 -> VAR_13 = & VAR_14 -> VAR_15 ; VAR_16 -> VAR_17 = METHOD_2 ( VAR_18 -> VAR_19 . VAR_20 -> VAR_21 ) ; if ( METHOD_3 ( VAR_22 -> VAR_23 ) ) return METHOD_4 ( VAR_24 -> VAR_25 ) ; <S2SV_StartBug> for ( VAR_26 = 0 ; VAR_27 <= VAR_28 ; VAR_29 ++ ) { <S2SV_EndBug> VAR_30 = METHOD_5 ( VAR_31 , VAR_32 , & VAR_33 -> VAR_34 [ VAR_35 ] ) ; if ( VAR_36 ) return VAR_37 ; } METHOD_6 ( & VAR_38 -> VAR_39 , VAR_40 ) ; VAR_41 = METHOD_7 ( VAR_42 -> VAR_43 , VAR_44 ) ; return METHOD_8 ( VAR_45 ) ; }",<S2SV_ModStart> 0 ; VAR_35 < <S2SV_ModEnd> VAR_28 ; VAR_35,"CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }",<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
581,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 ; TYPE_4 * VAR_3 = VAR_4 ; TYPE_5 VAR_5 = VAR_6 ; static TYPE_6 VAR_7 = VAR_8 ; if ( ! VAR_9 && METHOD_1 ( & VAR_10 ) ) return ( VAR_11 ) ; switch ( VAR_12 -> VAR_13 ) { case VAR_14 : if ( * VAR_15 ) { if ( ( VAR_16 = METHOD_2 ( VAR_17 , * VAR_18 , & VAR_19 ) ) != 0 ) return VAR_20 ; } if ( ! METHOD_3 ( VAR_21 , & VAR_22 ) ) return VAR_23 ; if ( VAR_24 ) METHOD_4 ( VAR_25 ) ; break ; case VAR_26 : if ( ! METHOD_5 ( VAR_27 , & VAR_28 ) ) return VAR_29 ; if ( VAR_30 ) { VAR_31 = METHOD_6 ( VAR_32 , VAR_33 , & VAR_34 ) ; if ( VAR_35 != 0 ) return VAR_36 ; * VAR_37 = VAR_38 ; METHOD_7 ( VAR_39 ) ; } else * VAR_40 = VAR_41 ; break ; case VAR_42 : if ( * VAR_43 != VAR_44 ) METHOD_8 ( VAR_45 , * VAR_46 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return VAR_47 ; }",<S2SV_ModStart> VAR_46 ) ; * VAR_46 = VAR_44 ;,"CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }",<S2SV_ModStart> objp ) ; * objp = NULL ;
582,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , const struct STRUCT_OR_UNION_1 * VAR_4 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = METHOD_1 ( VAR_5 -> VAR_6 ) ; struct STRUCT_OR_UNION_4 * VAR_7 = VAR_8 ; struct STRUCT_OR_UNION_5 * VAR_9 = METHOD_2 ( VAR_10 ) ; struct STRUCT_OR_UNION_6 * VAR_11 ; struct STRUCT_OR_UNION_7 * VAR_12 ; const struct STRUCT_OR_UNION_8 * VAR_13 = VAR_14 ; struct STRUCT_OR_UNION_9 * VAR_15 ; struct STRUCT_OR_UNION_10 VAR_16 ; struct STRUCT_OR_UNION_11 VAR_17 ; struct STRUCT_OR_UNION_12 VAR_18 ; struct STRUCT_OR_UNION_13 VAR_19 = { 0 } ; struct STRUCT_OR_UNION_14 VAR_20 ; TYPE_4 VAR_21 = 0 ; TYPE_5 VAR_22 = 0 ; TYPE_6 VAR_23 ; TYPE_7 VAR_24 = 0 ; TYPE_8 VAR_25 = METHOD_3 ( STRUCT_OR_UNION_15 , VAR_26 -> VAR_27 ) ; if ( ( TYPE_9 * ) VAR_28 < VAR_29 -> VAR_30 || ( METHOD_4 ( VAR_31 ) + sizeof ( * VAR_32 ) ) > METHOD_5 ( VAR_33 ) ) return ; VAR_34 = METHOD_6 ( & VAR_35 -> VAR_36 ) ; if ( METHOD_7 ( STRUCT_OR_UNION_16 , & VAR_37 -> VAR_38 , VAR_39 -> VAR_40 , 0 ) || METHOD_8 ( STRUCT_OR_UNION_17 , VAR_41 -> VAR_42 , & VAR_43 -> VAR_44 ) ) VAR_45 = & VAR_46 -> VAR_47 ; if ( VAR_48 & VAR_49 || VAR_50 -> VAR_51 != VAR_52 ) { if ( VAR_53 != VAR_54 && ! ( VAR_55 == VAR_56 && VAR_57 == VAR_58 && ( METHOD_9 ( VAR_59 , VAR_60 ) ) ) ) return ; VAR_61 = VAR_62 ; } VAR_63 = METHOD_10 ( & VAR_64 -> VAR_65 ) ; if ( METHOD_11 ( VAR_66 ) ) VAR_67 = VAR_68 -> VAR_69 -> VAR_70 ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> VAR_71 = METHOD_12 ( METHOD_13 ( VAR_72 ) -> VAR_73 ) ; <S2SV_EndBug> if ( ( VAR_74 == VAR_75 ) || ( VAR_76 & VAR_77 ) ) { METHOD_14 ( ""icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & VAR_78 -> VAR_79 , & VAR_80 -> VAR_81 ) ; return ; } if ( METHOD_15 ( VAR_82 ) ) { METHOD_16 ( ""icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & VAR_83 -> VAR_84 , & VAR_85 -> VAR_86 ) ; return ; } METHOD_17 ( VAR_87 ) ; METHOD_18 ( & VAR_88 , 0 , sizeof ( VAR_89 ) ) ; VAR_90 . VAR_91 = VAR_92 ; VAR_93 . VAR_94 = VAR_95 -> VAR_96 ; if ( VAR_97 ) VAR_98 = VAR_99 ; if ( VAR_100 ) VAR_101 . VAR_102 = * VAR_103 ; VAR_104 . VAR_105 = VAR_106 ; VAR_107 . VAR_108 = VAR_109 ; VAR_110 . VAR_111 = VAR_112 ; VAR_113 . VAR_114 = VAR_115 ; METHOD_19 ( VAR_116 , METHOD_20 ( & VAR_117 ) ) ; VAR_118 = METHOD_21 ( STRUCT_OR_UNION_18 ) ; if ( ! VAR_119 ) return ; VAR_120 -> VAR_121 = VAR_122 ; VAR_123 = METHOD_22 ( VAR_124 ) ; if ( ! METHOD_23 ( VAR_125 , VAR_126 , & VAR_127 ) ) goto VAR_128 ; VAR_129 . VAR_130 = VAR_131 ; VAR_132 . VAR_133 = VAR_134 ; VAR_135 . VAR_136 = 0 ; VAR_137 . VAR_138 = METHOD_24 ( VAR_139 ) ; if ( ! VAR_140 . VAR_141 && METHOD_25 ( & VAR_142 . VAR_143 ) ) VAR_144 . VAR_145 = VAR_146 -> VAR_147 ; else if ( ! VAR_148 . VAR_149 ) VAR_150 . VAR_151 = VAR_152 -> VAR_153 ; VAR_154 . VAR_155 = VAR_156 -> VAR_157 ; VAR_158 . VAR_159 = METHOD_26 ( VAR_160 . VAR_161 , VAR_162 . VAR_163 ) ; VAR_164 = METHOD_27 ( STRUCT_OR_UNION_19 , VAR_165 , VAR_166 , & VAR_167 ) ; if ( METHOD_28 ( VAR_168 ) ) goto VAR_169 ; VAR_170 . VAR_171 = METHOD_29 ( VAR_172 , & VAR_173 , VAR_174 ) ; VAR_175 . VAR_176 = VAR_177 -> VAR_178 ; VAR_179 . VAR_180 = VAR_181 ; VAR_182 . VAR_183 = VAR_184 ; VAR_185 . VAR_186 = METHOD_30 ( VAR_187 ) ; VAR_188 . VAR_189 = VAR_190 ; VAR_191 = VAR_192 -> VAR_193 - VAR_194 . VAR_195 ; VAR_196 = min_t ( unsigned TYPE_10 , VAR_197 , VAR_198 - sizeof ( struct STRUCT_OR_UNION_20 ) - sizeof ( struct STRUCT_OR_UNION_21 ) ) ; if ( VAR_199 < 0 ) { METHOD_31 ( ""icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & VAR_200 -> VAR_201 , & VAR_202 -> VAR_203 ) ; goto VAR_204 ; } METHOD_32 ( ) ; VAR_205 = METHOD_33 ( VAR_206 -> VAR_207 ) ; VAR_208 = METHOD_34 ( VAR_209 , VAR_210 , & VAR_211 , VAR_212 + sizeof ( struct STRUCT_OR_UNION_22 ) , sizeof ( struct STRUCT_OR_UNION_23 ) , & VAR_213 , & VAR_214 , ( struct STRUCT_OR_UNION_24 * ) VAR_215 , VAR_216 , & VAR_217 ) ; if ( VAR_218 ) { METHOD_35 ( STRUCT_OR_UNION_25 , VAR_219 , VAR_220 ) ; METHOD_36 ( VAR_221 ) ; } else { VAR_222 = METHOD_37 ( VAR_223 , & VAR_224 , & VAR_225 , VAR_226 + sizeof ( struct STRUCT_OR_UNION_26 ) ) ; } METHOD_38 ( ) ; VAR_227 : METHOD_39 ( VAR_228 ) ; VAR_229 : METHOD_40 ( VAR_230 ) ; }",<S2SV_ModStart> VAR_70 ; else { VAR_228 = METHOD_13 ( VAR_206 ) ; <S2SV_ModStart> = METHOD_12 ( VAR_228 ? VAR_228 -> VAR_207 : VAR_206 -> VAR_207 ) ; } <S2SV_ModEnd> if ( (,"CWE-20 static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( ""icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( ""icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }",<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
583,"CWE-59 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , unsigned TYPE_4 VAR_3 , <S2SV_StartBug> const TYPE_5 * VAR_4 , TYPE_6 VAR_5 ) <S2SV_EndBug> { TYPE_7 TYPE_8 struct STRUCT_OR_UNION_0 VAR_6 ; <S2SV_StartBug> if ( METHOD_1 ( VAR_7 , VAR_8 , VAR_9 , VAR_10 & ~ VAR_11 , VAR_12 ) ) { <S2SV_EndBug> if ( VAR_13 ) { METHOD_2 ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , VAR_14 , VAR_15 , METHOD_3 ( VAR_16 ) ) ; return 0 ; } else { METHOD_4 ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , VAR_17 , VAR_18 ) ; return - 1 ; } } if ( ( VAR_19 & VAR_20 ) || ( VAR_21 & VAR_22 ) ) { METHOD_5 ( ""remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options"" , VAR_23 ? VAR_24 : ""(none)"" , VAR_25 ? VAR_26 : ""(none)"" ) ; unsigned TYPE_9 VAR_27 = 0 ; if ( VAR_28 & VAR_29 ) VAR_30 |= VAR_31 ; TYPE_10 TYPE_11 if ( STRUCT_OR_UNION_1 ( VAR_32 , & VAR_33 ) == 0 ) { unsigned TYPE_12 VAR_34 = VAR_35 ; if ( VAR_36 . VAR_37 & VAR_38 ) VAR_39 |= VAR_40 ; if ( VAR_41 . VAR_42 & VAR_43 ) VAR_44 |= VAR_45 ; if ( VAR_46 . VAR_47 & VAR_48 ) VAR_49 |= VAR_50 ; if ( VAR_51 . VAR_52 & VAR_53 ) VAR_54 |= VAR_55 ; METHOD_6 ( ""(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu"" , VAR_56 , VAR_57 . VAR_58 , VAR_59 ) ; if ( ! ( VAR_60 & VAR_61 ) ) { if ( ! ( VAR_62 & ~ VAR_63 ) && VAR_64 == 0 ) { METHOD_7 ( ""mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount"" , VAR_65 ) ; goto VAR_66 ; } } VAR_67 |= VAR_68 ; } if ( METHOD_8 ( VAR_69 , VAR_70 , VAR_71 , <S2SV_StartBug> VAR_72 | VAR_73 , VAR_74 ) ) { <S2SV_EndBug> if ( VAR_75 ) { METHOD_9 ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , VAR_76 , VAR_77 , METHOD_10 ( VAR_78 ) ) ; return 0 ; } else { METHOD_11 ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , VAR_79 , VAR_80 ) ; return - 1 ; } } } TYPE_13 TYPE_14 VAR_81 : METHOD_12 ( ""mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'"" , VAR_82 , VAR_83 , VAR_84 ) ; return 0 ; }","<S2SV_ModStart> , TYPE_6 VAR_75 , const TYPE_5 * VAR_85 <S2SV_ModStart> endif if ( safe_mount <S2SV_ModEnd> ( VAR_82 , <S2SV_ModStart> VAR_73 , VAR_74 , VAR_85 <S2SV_ModStart> , VAR_74 ) < 0","CWE-59 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> {  ifdef HAVE_STATVFS struct statvfs sb ;   <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( ""remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options"" , fsname ? fsname : ""(none)"" , target ? target : ""(none)"" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ;  ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( ""(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu"" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( ""mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount"" , mountflags ) ; goto skipremount ; } } mountflags |= required_flags ; }   if ( mount ( fsname , target , fstype , <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } }  ifdef HAVE_STATVFS skipremount :   DEBUG ( ""mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'"" , fsname , target , fstype ) ; return 0 ; }","<S2SV_ModStart> , int optional , const char * rootfs <S2SV_ModStart> endif if ( safe_mount <S2SV_ModEnd> ( fsname , <S2SV_ModStart> MS_REMOUNT , data , rootfs <S2SV_ModStart> , data ) < 0"
584,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { if ( ( VAR_2 & VAR_3 ) == VAR_4 ) { METHOD_1 ( VAR_5 , <S2SV_StartBug> 1 , 0 , VAR_6 , 0 ) ; <S2SV_EndBug> return METHOD_2 ( VAR_7 , VAR_8 ) ; } if ( ( VAR_9 & VAR_10 ) == VAR_11 ) { METHOD_3 ( VAR_12 , <S2SV_StartBug> 1 , 0 , VAR_13 , 0 ) ; <S2SV_EndBug> return METHOD_4 ( VAR_14 , VAR_15 ) ; } return - 1 ; }","<S2SV_ModStart> VAR_12 , 1 <S2SV_ModEnd> , VAR_14 , <S2SV_ModStart> , 1 , <S2SV_ModEnd> VAR_14 , 0","CWE-400 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_sc ( regs , opcode ) ; } return - 1 ; }","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0"
585,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 VAR_2 ; <S2SV_StartBug> TYPE_4 TYPE_5 * VAR_3 = VAR_4 ; <S2SV_EndBug> TYPE_6 VAR_5 ; TYPE_7 * VAR_6 = VAR_7 ; TYPE_8 VAR_8 ; TYPE_9 VAR_9 = - 1 ; TYPE_10 VAR_10 = - 1 ; TYPE_11 VAR_11 [ ] = { - 1 , - 1 } ; const TYPE_12 * VAR_12 ; TYPE_13 VAR_13 ; TYPE_14 VAR_14 ; struct STRUCT_OR_UNION_0 VAR_15 ; TYPE_15 VAR_16 ; TYPE_16 TYPE_17 VAR_17 ; TYPE_18 TYPE_19 * VAR_18 = VAR_19 ; TYPE_20 VAR_20 ; struct STRUCT_OR_UNION_1 VAR_21 ; TYPE_21 TYPE_22 * VAR_22 = VAR_23 ; if ( VAR_24 == 2 && ( METHOD_1 ( VAR_25 [ 1 ] , ""--version"" ) == 0 ) ) METHOD_2 ( ) ; VAR_26 = METHOD_3 ( ) ; VAR_27 = METHOD_4 ( ) ; METHOD_5 ( ) ; if ( METHOD_6 ( VAR_28 , 1 , 0 , 0 , 0 ) < 0 ) METHOD_7 ( ""prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed"" ) ; METHOD_8 ( ) ; VAR_29 = VAR_30 [ 0 ] ; if ( METHOD_9 ( 1 ) ) VAR_31 = METHOD_10 ( 1 ) ; VAR_32 ++ ; VAR_33 -- ; if ( VAR_34 == 0 ) METHOD_11 ( VAR_35 , VAR_36 ) ; METHOD_12 ( & VAR_37 , ( const TYPE_23 * * * ) & VAR_38 ) ; VAR_39 = VAR_40 ; VAR_41 = VAR_42 ; if ( ( VAR_43 [ 0 ] || VAR_44 [ 1 ] ) && VAR_45 ) METHOD_13 ( ""--cap-add<S2SV_blank>in<S2SV_blank>setuid<S2SV_blank>mode<S2SV_blank>can<S2SV_blank>be<S2SV_blank>used<S2SV_blank>only<S2SV_blank>by<S2SV_blank>root"" ) ; if ( VAR_46 != - 1 && ! VAR_47 ) METHOD_14 ( ""--userns-block-fd<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( VAR_48 != - 1 && VAR_49 == - 1 ) METHOD_15 ( ""--userns-block-fd<S2SV_blank>requires<S2SV_blank>--info-fd"" ) ; if ( ! VAR_50 && METHOD_16 ( ) != 0 ) VAR_51 = VAR_52 ; TYPE_24 TYPE_25 if ( VAR_53 && METHOD_17 ( ) != 0 ) VAR_54 = VAR_55 ; if ( VAR_56 && STRUCT_OR_UNION_2 ( ""/proc/self/ns/user"" , & VAR_57 ) == 0 ) { TYPE_26 VAR_58 = VAR_59 ; if ( STRUCT_OR_UNION_3 ( ""/sys/module/user_namespace/parameters/enable"" , & VAR_60 ) == 0 ) { TYPE_27 TYPE_28 * VAR_61 = VAR_62 ; VAR_63 = METHOD_18 ( VAR_64 , ""/sys/module/user_namespace/parameters/enable"" ) ; if ( VAR_65 != VAR_66 && VAR_67 [ 0 ] == 'N' ) VAR_68 = VAR_69 ; } if ( STRUCT_OR_UNION_4 ( ""/proc/sys/user/max_user_namespaces"" , & VAR_70 ) == 0 ) { TYPE_29 TYPE_30 * VAR_71 = VAR_72 ; VAR_73 = METHOD_19 ( VAR_74 , ""/proc/sys/user/max_user_namespaces"" ) ; if ( VAR_75 != VAR_76 && METHOD_20 ( VAR_77 , ""0\\n"" ) == 0 ) VAR_78 = VAR_79 ; } if ( ! VAR_80 ) VAR_81 = VAR_82 ; } if ( VAR_83 == 0 ) METHOD_21 ( VAR_84 , VAR_85 ) ; METHOD_22 ( ( ""Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n"" ) ) ; if ( VAR_86 == - 1 ) VAR_87 = VAR_88 ; if ( VAR_89 == - 1 ) VAR_90 = VAR_91 ; if ( ! VAR_92 && VAR_93 != VAR_94 ) METHOD_23 ( ""Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! VAR_95 && VAR_96 != VAR_97 ) METHOD_24 ( ""Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! VAR_98 && VAR_99 != VAR_100 ) METHOD_25 ( ""Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts"" ) ; if ( VAR_101 && ! VAR_102 ) METHOD_26 ( ""Specifying<S2SV_blank>--as-pid-1<S2SV_blank>requires<S2SV_blank>--unshare-pid"" ) ; if ( VAR_103 && VAR_104 != VAR_105 ) METHOD_27 ( ""Specifying<S2SV_blank>--as-pid-1<S2SV_blank>and<S2SV_blank>--lock-file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>permitted"" ) ; VAR_106 = METHOD_28 ( ""/proc"" , VAR_107 ) ; if ( VAR_108 == - 1 ) METHOD_29 ( ""Can\'t<S2SV_blank>open<S2SV_blank>/proc"" ) ; <S2SV_StartBug> VAR_109 = METHOD_30 ( ""/run/user/%d/.bubblewrap"" , VAR_110 ) ; <S2SV_EndBug> if ( METHOD_31 ( VAR_111 , 0755 ) ) { METHOD_32 ( VAR_112 ) ; VAR_113 = METHOD_33 ( ""/tmp/.bubblewrap-%d"" , VAR_114 ) ; if ( METHOD_34 ( VAR_115 , 0755 ) ) METHOD_35 ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ; } METHOD_36 ( ( ""creating<S2SV_blank>new<S2SV_blank>namespace\\n"" ) ) ; if ( VAR_116 && ! VAR_117 ) { VAR_118 = METHOD_37 ( 0 , VAR_119 | VAR_120 ) ; if ( VAR_121 == - 1 ) METHOD_38 ( ""eventfd()"" ) ; } METHOD_39 ( ) ; VAR_122 = VAR_123 | VAR_124 ; if ( VAR_125 ) VAR_126 |= VAR_127 ; if ( VAR_128 ) VAR_129 |= VAR_130 ; if ( VAR_131 ) VAR_132 |= VAR_133 ; if ( VAR_134 ) VAR_135 |= VAR_136 ; if ( VAR_137 ) VAR_138 |= VAR_139 ; if ( VAR_140 ) { if ( STRUCT_OR_UNION_5 ( ""/proc/self/ns/cgroup"" , & VAR_141 ) ) { if ( VAR_142 == VAR_143 ) METHOD_40 ( ""Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it"" ) ; else METHOD_41 ( ""stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed"" ) ; } VAR_144 |= VAR_145 ; } if ( VAR_146 ) if ( ! STRUCT_OR_UNION_6 ( ""/proc/self/ns/cgroup"" , & VAR_147 ) ) VAR_148 |= VAR_149 ; VAR_150 = METHOD_42 ( 0 , VAR_151 ) ; if ( VAR_152 == - 1 ) METHOD_43 ( ""eventfd()"" ) ; if ( VAR_153 != - 1 ) { TYPE_31 VAR_154 ; VAR_155 = METHOD_44 ( VAR_156 , VAR_157 ) ; if ( VAR_158 == - 1 ) METHOD_45 ( ""pipe2()"" ) ; } VAR_159 = METHOD_46 ( VAR_160 , VAR_161 ) ; if ( VAR_162 == - 1 ) { if ( VAR_163 ) { if ( VAR_164 == VAR_165 ) METHOD_47 ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems."" ) ; else if ( VAR_166 == VAR_167 && ! VAR_168 ) METHOD_48 ( ""No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'."" ) ; } METHOD_49 ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed"" ) ; } VAR_169 = VAR_170 ; VAR_171 = VAR_172 ; if ( VAR_173 != 0 ) { if ( VAR_174 && VAR_175 && VAR_176 == - 1 ) { METHOD_50 ( VAR_177 , VAR_178 , VAR_179 , VAR_180 , VAR_181 , VAR_182 , VAR_183 ) ; } METHOD_51 ( VAR_184 ) ; METHOD_52 ( ) ; if ( VAR_185 != - 1 ) { TYPE_32 TYPE_33 * VAR_186 = METHOD_53 ( ""{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i\\n}\\n"" , VAR_187 ) ; METHOD_54 ( VAR_188 , VAR_189 , VAR_190 ) ; METHOD_55 ( VAR_191 ) ; } if ( VAR_192 != - 1 ) { TYPE_34 TYPE_35 * VAR_193 = METHOD_56 ( ""{<S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i<S2SV_blank>}\\n"" , VAR_194 ) ; METHOD_57 ( VAR_195 , VAR_196 , VAR_197 ) ; } if ( VAR_198 != - 1 ) { TYPE_36 VAR_199 [ 1 ] ; ( TYPE_37 ) METHOD_58 ( METHOD_59 ( VAR_200 , VAR_201 , 1 ) ) ; METHOD_60 ( VAR_202 ) ; } VAR_203 = 1 ; TYPE_38 = METHOD_61 ( VAR_204 , & VAR_205 , 8 ) ; METHOD_62 ( VAR_206 ) ; return METHOD_63 ( VAR_207 , VAR_208 , VAR_209 [ 0 ] ) ; } if ( VAR_210 != - 1 ) METHOD_64 ( VAR_211 ) ; if ( VAR_212 != - 1 ) METHOD_65 ( VAR_213 ) ; TYPE_39 = METHOD_66 ( VAR_214 , & VAR_215 , 8 ) ; METHOD_67 ( VAR_216 ) ; METHOD_68 ( ) ; if ( VAR_217 ) METHOD_69 ( ) ; VAR_218 = VAR_219 ; VAR_220 = VAR_221 ; if ( ! VAR_222 && VAR_223 && VAR_224 == - 1 ) { if ( VAR_225 ) { VAR_226 = 0 ; VAR_227 = 0 ; } METHOD_70 ( VAR_228 , VAR_229 , VAR_230 , VAR_231 , - 1 , VAR_232 , VAR_233 ) ; } VAR_234 = METHOD_71 ( 0 ) ; METHOD_72 ( ) ; if ( METHOD_73 ( VAR_235 , ""/"" , VAR_236 , VAR_237 | VAR_238 , VAR_239 ) < 0 ) METHOD_74 ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave"" ) ; if ( METHOD_75 ( ""tmpfs"" , VAR_240 , ""tmpfs"" , VAR_241 | VAR_242 , VAR_243 ) != 0 ) METHOD_76 ( ""Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs"" ) ; VAR_244 = METHOD_77 ( ) ; if ( METHOD_78 ( VAR_245 ) != 0 ) METHOD_79 ( ""chdir<S2SV_blank>base_path"" ) ; if ( METHOD_80 ( ""newroot"" , 0755 ) ) METHOD_81 ( ""Creating<S2SV_blank>newroot<S2SV_blank>failed"" ) ; if ( METHOD_82 ( ""newroot"" , ""newroot"" , VAR_246 , VAR_247 | VAR_248 | VAR_249 , VAR_250 ) < 0 ) METHOD_83 ( ""setting<S2SV_blank>up<S2SV_blank>newroot<S2SV_blank>bind"" ) ; if ( METHOD_84 ( ""oldroot"" , 0755 ) ) METHOD_85 ( ""Creating<S2SV_blank>oldroot<S2SV_blank>failed"" ) ; if ( METHOD_86 ( VAR_251 , ""oldroot"" ) ) METHOD_87 ( ""pivot_root"" ) ; if ( METHOD_88 ( ""/"" ) != 0 ) METHOD_89 ( ""chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)"" ) ; if ( VAR_252 ) { TYPE_40 VAR_253 ; TYPE_41 VAR_254 [ 2 ] ; if ( METHOD_90 ( VAR_255 , VAR_256 | VAR_257 , 0 , VAR_258 ) != 0 ) METHOD_91 ( ""Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket"" ) ; VAR_259 = METHOD_92 ( ) ; if ( VAR_260 == - 1 ) METHOD_93 ( ""Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper"" ) ; if ( VAR_261 == 0 ) { METHOD_94 ( VAR_262 ) ; METHOD_95 ( VAR_263 [ 0 ] ) ; METHOD_96 ( VAR_264 , VAR_265 [ 1 ] ) ; METHOD_97 ( 0 ) ; } else { TYPE_42 VAR_266 ; TYPE_43 VAR_267 [ 2048 ] ; TYPE_44 VAR_268 , VAR_269 ; const TYPE_45 * VAR_270 , * VAR_271 ; TYPE_46 TYPE_47 VAR_272 = - 1 ; VAR_273 = VAR_274 [ 0 ] ; METHOD_98 ( VAR_275 [ 1 ] ) ; do { VAR_276 = METHOD_99 ( VAR_277 , VAR_278 , sizeof ( VAR_279 ) , & VAR_280 , & VAR_281 , & VAR_282 ) ; METHOD_100 ( - 1 , VAR_283 , VAR_284 , VAR_285 , VAR_286 ) ; if ( METHOD_101 ( VAR_287 , VAR_288 , 1 ) != 1 ) METHOD_102 ( ""Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket"" ) ; } while ( VAR_289 != VAR_290 ) ; METHOD_103 ( VAR_291 , & VAR_292 , 0 ) ; } } else { METHOD_104 ( VAR_293 , - 1 ) ; } METHOD_105 ( ) ; if ( METHOD_106 ( ""oldroot"" , ""oldroot"" , VAR_294 , VAR_295 | VAR_296 , VAR_297 ) != 0 ) METHOD_107 ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate"" ) ; if ( METHOD_108 ( ""oldroot"" , VAR_298 ) ) METHOD_109 ( ""unmount<S2SV_blank>old<S2SV_blank>root"" ) ; { TYPE_48 TYPE_49 VAR_299 = METHOD_110 ( ""/"" , VAR_300 | VAR_301 ) ; if ( VAR_302 < 0 ) METHOD_111 ( ""can\'t<S2SV_blank>open<S2SV_blank>/"" ) ; if ( METHOD_112 ( ""/newroot"" ) != 0 ) METHOD_113 ( ""chdir<S2SV_blank>/newroot"" ) ; if ( METHOD_114 ( ""."" , ""."" ) != 0 ) METHOD_115 ( ""pivot_root(/newroot)"" ) ; if ( METHOD_116 ( VAR_303 ) < 0 ) METHOD_117 ( ""fchdir<S2SV_blank>to<S2SV_blank>oldroot"" ) ; if ( METHOD_118 ( ""."" , VAR_304 ) < 0 ) METHOD_119 ( ""umount<S2SV_blank>old<S2SV_blank>root"" ) ; if ( METHOD_120 ( ""/"" ) != 0 ) METHOD_121 ( ""chdir<S2SV_blank>/"" ) ; } if ( VAR_305 && ( VAR_306 != VAR_307 || VAR_308 != VAR_309 ) && VAR_310 == - 1 ) { if ( METHOD_122 ( VAR_311 ) ) METHOD_123 ( ""unshare<S2SV_blank>user<S2SV_blank>ns"" ) ; METHOD_124 ( VAR_312 , VAR_313 , VAR_314 , VAR_315 , - 1 , VAR_316 , VAR_317 ) ; } METHOD_125 ( ! VAR_318 ) ; if ( VAR_319 != - 1 ) { TYPE_50 VAR_320 [ 1 ] ; ( TYPE_51 ) METHOD_126 ( METHOD_127 ( VAR_321 , VAR_322 , 1 ) ) ; METHOD_128 ( VAR_323 ) ; } if ( VAR_324 != - 1 ) { VAR_325 = METHOD_129 ( VAR_326 , & VAR_327 ) ; if ( VAR_328 == VAR_329 ) METHOD_130 ( ""Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data"" ) ; if ( VAR_330 % 8 != 0 ) METHOD_131 ( ""Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8"" ) ; VAR_331 . VAR_332 = VAR_333 / 8 ; VAR_334 . VAR_335 = ( struct STRUCT_OR_UNION_7 * ) VAR_336 ; METHOD_132 ( VAR_337 ) ; } METHOD_133 ( VAR_338 ) ; VAR_339 = ""/"" ; if ( VAR_340 ) { if ( METHOD_134 ( VAR_341 ) ) METHOD_135 ( ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s"" , VAR_342 ) ; VAR_343 = VAR_344 ; } else if ( METHOD_136 ( VAR_345 ) == 0 ) { VAR_346 = VAR_347 ; } else { const TYPE_52 * VAR_348 = METHOD_137 ( ""HOME"" ) ; if ( VAR_349 != VAR_350 && METHOD_138 ( VAR_351 ) == 0 ) VAR_352 = VAR_353 ; } METHOD_139 ( ""PWD"" , VAR_354 , 1 ) ; METHOD_140 ( VAR_355 ) ; if ( VAR_356 && METHOD_141 ( ) == ( TYPE_53 ) - 1 ) METHOD_142 ( ""setsid"" ) ; if ( METHOD_143 ( VAR_357 ) == - 1 ) METHOD_144 ( ""label_exec<S2SV_blank>%s"" , VAR_358 [ 0 ] ) ; METHOD_145 ( ( ""forking<S2SV_blank>for<S2SV_blank>child\\n"" ) ) ; if ( ! VAR_359 && ( VAR_360 || VAR_361 != VAR_362 || VAR_363 != - 1 ) ) { VAR_364 = METHOD_146 ( ) ; if ( VAR_365 == - 1 ) METHOD_147 ( ""Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1"" ) ; if ( VAR_366 != 0 ) { METHOD_148 ( VAR_367 ) ; { TYPE_54 VAR_368 [ 3 ] ; TYPE_55 VAR_369 = 0 ; if ( VAR_370 != - 1 ) VAR_371 [ VAR_372 ++ ] = VAR_373 ; if ( VAR_374 != - 1 ) VAR_375 [ VAR_376 ++ ] = VAR_377 ; VAR_378 [ VAR_379 ++ ] = - 1 ; METHOD_149 ( VAR_380 , VAR_381 , VAR_382 ) ; } return METHOD_150 ( VAR_383 , VAR_384 , VAR_385 != VAR_386 ? & VAR_387 : VAR_388 ) ; } } METHOD_151 ( ( ""launch<S2SV_blank>executable<S2SV_blank>%s\\n"" , VAR_389 [ 0 ] ) ) ; if ( VAR_390 != - 1 ) METHOD_152 ( VAR_391 ) ; if ( ! VAR_392 ) { if ( VAR_393 != - 1 ) METHOD_153 ( VAR_394 ) ; } METHOD_154 ( ) ; METHOD_155 ( ) ; if ( ! VAR_395 ) METHOD_156 ( ) ; if ( VAR_396 != VAR_397 && METHOD_157 ( VAR_398 , VAR_399 , & VAR_400 ) != 0 ) METHOD_158 ( ""prctl(PR_SET_SECCOMP)"" ) ; if ( VAR_401 [ 1 ] != - 1 ) { TYPE_56 VAR_402 = 0 ; TYPE_57 = METHOD_159 ( VAR_403 [ 1 ] , & VAR_404 , 1 ) ; } if ( METHOD_160 ( VAR_405 [ 0 ] , VAR_406 ) == - 1 ) { if ( VAR_407 [ 1 ] != - 1 ) { TYPE_58 VAR_408 = VAR_409 ; TYPE_59 VAR_410 = 0 ; TYPE_60 = METHOD_161 ( VAR_411 [ 1 ] , & VAR_412 , 1 ) ; VAR_413 = VAR_414 ; } METHOD_162 ( ""execvp<S2SV_blank>%s"" , VAR_415 [ 0 ] ) ; } return 0 ; }","<S2SV_ModStart> TYPE_3 VAR_338 ; const <S2SV_ModEnd> TYPE_59 * VAR_251 <S2SV_ModStart> ; VAR_251 = ""/tmp"" ; <S2SV_ModEnd> METHOD_151 ( (","CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ; <S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , ""--version"" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( ""prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed"" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( ""--cap-add<S2SV_blank>in<S2SV_blank>setuid<S2SV_blank>mode<S2SV_blank>can<S2SV_blank>be<S2SV_blank>used<S2SV_blank>only<S2SV_blank>by<S2SV_blank>root"" ) ; if ( opt_userns_block_fd != - 1 && ! opt_unshare_user ) die ( ""--userns-block-fd<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( opt_userns_block_fd != - 1 && opt_info_fd == - 1 ) die ( ""--userns-block-fd<S2SV_blank>requires<S2SV_blank>--info-fd"" ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ;  ifdef ENABLE_REQUIRE_USERNS if ( is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ;   if ( opt_unshare_user_try && stat ( ""/proc/self/ns/user"" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( ""/sys/module/user_namespace/parameters/enable"" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , ""/sys/module/user_namespace/parameters/enable"" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( stat ( ""/proc/sys/user/max_user_namespaces"" , & sbuf ) == 0 ) { cleanup_free char * max_user_ns = NULL ; max_user_ns = load_file_at ( AT_FDCWD , ""/proc/sys/user/max_user_namespaces"" ) ; if ( max_user_ns != NULL && strcmp ( max_user_ns , ""0\\n"" ) == 0 ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( ""Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n"" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( ""Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( ""Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( ""Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts"" ) ; if ( opt_as_pid_1 && ! opt_unshare_pid ) die ( ""Specifying<S2SV_blank>--as-pid-1<S2SV_blank>requires<S2SV_blank>--unshare-pid"" ) ; if ( opt_as_pid_1 && lock_files != NULL ) die ( ""Specifying<S2SV_blank>--as-pid-1<S2SV_blank>and<S2SV_blank>--lock-file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>permitted"" ) ; proc_fd = open ( ""/proc"" , O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>open<S2SV_blank>/proc"" ) ; <S2SV_StartBug> base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; <S2SV_EndBug> if ( ensure_dir ( base_path , 0755 ) ) { free ( base_path ) ; base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ; if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ; } __debug__ ( ( ""creating<S2SV_blank>new<S2SV_blank>namespace\\n"" ) ) ; if ( opt_unshare_pid && ! opt_as_pid_1 ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) { if ( errno == ENOENT ) die ( ""Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it"" ) ; else die_with_error ( ""stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed"" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; if ( opt_json_status_fd != - 1 ) { int ret ; ret = pipe2 ( setup_finished_pipe , O_CLOEXEC ) ; if ( ret == - 1 ) die_with_error ( ""pipe2()"" ) ; } pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems."" ) ; else if ( errno == EPERM && ! is_privileged ) die ( ""No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'."" ) ; } die_with_error ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed"" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( FALSE ) ; handle_die_with_parent ( ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i\\n}\\n"" , pid ) ; dump_info ( opt_info_fd , output , TRUE ) ; close ( opt_info_fd ) ; } if ( opt_json_status_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{<S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i<S2SV_blank>}\\n"" , pid ) ; dump_info ( opt_json_status_fd , output , TRUE ) ; } if ( opt_userns_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_userns_block_fd , b , 1 ) ) ; close ( opt_userns_block_fd ) ; } val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; return monitor_child ( event_fd , pid , setup_finished_pipe [ 0 ] ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; if ( opt_json_status_fd != - 1 ) close ( opt_json_status_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net ) loopback_setup ( ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave"" ) ; if ( mount ( ""tmpfs"" , base_path , ""tmpfs"" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs"" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( ""chdir<S2SV_blank>base_path"" ) ; if ( mkdir ( ""newroot"" , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>newroot<S2SV_blank>failed"" ) ; if ( mount ( ""newroot"" , ""newroot"" , NULL , MS_MGC_VAL | MS_BIND | MS_REC , NULL ) < 0 ) die_with_error ( ""setting<S2SV_blank>up<S2SV_blank>newroot<S2SV_blank>bind"" ) ; if ( mkdir ( ""oldroot"" , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>oldroot<S2SV_blank>failed"" ) ; if ( pivot_root ( base_path , ""oldroot"" ) ) die_with_error ( ""pivot_root"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)"" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( ""Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket"" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper"" ) ; if ( child == 0 ) { drop_privs ( FALSE ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( ""Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket"" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } close_ops_fd ( ) ; if ( mount ( ""oldroot"" , ""oldroot"" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate"" ) ; if ( umount2 ( ""oldroot"" , MNT_DETACH ) ) die_with_error ( ""unmount<S2SV_blank>old<S2SV_blank>root"" ) ; { cleanup_fd int oldrootfd = open ( ""/"" , O_DIRECTORY | O_RDONLY ) ; if ( oldrootfd < 0 ) die_with_error ( ""can\'t<S2SV_blank>open<S2SV_blank>/"" ) ; if ( chdir ( ""/newroot"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/newroot"" ) ; if ( pivot_root ( ""."" , ""."" ) != 0 ) die_with_error ( ""pivot_root(/newroot)"" ) ; if ( fchdir ( oldrootfd ) < 0 ) die_with_error ( ""fchdir<S2SV_blank>to<S2SV_blank>oldroot"" ) ; if ( umount2 ( ""."" , MNT_DETACH ) < 0 ) die_with_error ( ""umount<S2SV_blank>old<S2SV_blank>root"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/"" ) ; } if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) && opt_userns_block_fd == - 1 ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( ""unshare<S2SV_blank>user<S2SV_blank>ns"" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } drop_privs ( ! is_privileged ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_block_fd , b , 1 ) ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( ""Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data"" ) ; if ( seccomp_len % 8 != 0 ) die ( ""Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8"" ) ; seccomp_prog . len = seccomp_len / 8 ; seccomp_prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; } umask ( old_umask ) ; new_cwd = ""/"" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s"" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( ""HOME"" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( ""PWD"" , new_cwd , 1 ) ; free ( old_cwd ) ; if ( opt_new_session && setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ; __debug__ ( ( ""forking<S2SV_blank>for<S2SV_blank>child\\n"" ) ) ; if ( ! opt_as_pid_1 && ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1"" ) ; if ( pid != 0 ) { drop_all_caps ( FALSE ) ; { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid , seccomp_data != NULL ? & seccomp_prog : NULL ) ; } } __debug__ ( ( ""launch<S2SV_blank>executable<S2SV_blank>%s\\n"" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( ! opt_as_pid_1 ) { if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; } unblock_sigchild ( ) ; handle_die_with_parent ( ) ; if ( ! is_privileged ) set_ambient_capabilities ( ) ; if ( seccomp_data != NULL && prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & seccomp_prog ) != 0 ) die_with_error ( ""prctl(PR_SET_SECCOMP)"" ) ; if ( setup_finished_pipe [ 1 ] != - 1 ) { char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; } if ( execvp ( argv [ 0 ] , argv ) == - 1 ) { if ( setup_finished_pipe [ 1 ] != - 1 ) { int saved_errno = errno ; char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; errno = saved_errno ; } die_with_error ( ""execvp<S2SV_blank>%s"" , argv [ 0 ] ) ; } return 0 ; }","<S2SV_ModStart> mode_t old_umask ; const <S2SV_ModEnd> char * base_path <S2SV_ModStart> ; base_path = ""/tmp"" ; <S2SV_ModEnd> __debug__ ( ("
586,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_EndBug> TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { if ( VAR_4 == VAR_5 ) { <S2SV_StartBug> METHOD_1 ( VAR_6 , VAR_7 , VAR_8 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> TYPE_5 VAR_9 [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> TYPE_6 * VAR_10 = & VAR_11 [ 0 ] ; <S2SV_EndBug> TYPE_7 VAR_12 , VAR_13 ; <S2SV_StartBug> TYPE_8 VAR_14 [ 4 ] , VAR_15 [ 4 ] ; <S2SV_EndBug> const TYPE_9 VAR_16 = VAR_17 [ VAR_18 ] ; for ( VAR_19 = 0 ; VAR_20 < 4 ; ++ VAR_21 ) { for ( VAR_22 = 0 ; VAR_23 < 4 ; ++ VAR_24 ) VAR_25 [ VAR_26 ] = VAR_27 [ VAR_28 * VAR_29 + VAR_30 ] * 16 ; if ( VAR_31 == 0 && VAR_32 [ 0 ] ) VAR_33 [ 0 ] += 1 ; VAR_34 . METHOD_2 ( VAR_35 , VAR_36 ) ; for ( VAR_37 = 0 ; VAR_38 < 4 ; ++ VAR_39 ) <S2SV_StartBug> VAR_40 [ VAR_41 * 4 + VAR_42 ] = VAR_43 [ VAR_44 ] ; <S2SV_EndBug> } for ( VAR_45 = 0 ; VAR_46 < 4 ; ++ VAR_47 ) { for ( VAR_48 = 0 ; VAR_49 < 4 ; ++ VAR_50 ) VAR_51 [ VAR_52 ] = VAR_53 [ VAR_54 + VAR_55 * 4 ] ; VAR_56 . METHOD_3 ( VAR_57 , VAR_58 ) ; for ( VAR_59 = 0 ; VAR_60 < 4 ; ++ VAR_61 ) VAR_62 [ VAR_63 + VAR_64 * 4 ] = ( VAR_65 [ VAR_66 ] + 1 ) >> 2 ; } } }","<S2SV_ModStart> * VAR_27 , TYPE_10 <S2SV_ModEnd> * VAR_62 , <S2SV_ModStart> VAR_5 ) { METHOD_4 <S2SV_ModEnd> ( VAR_27 , <S2SV_ModStart> } else { TYPE_10 <S2SV_ModEnd> VAR_53 [ 4 <S2SV_ModStart> 4 ] ; <S2SV_ModEnd> TYPE_7 VAR_64 , <S2SV_ModStart> , VAR_66 ; TYPE_10 <S2SV_ModEnd> VAR_57 [ 4 <S2SV_ModStart> ++ VAR_66 ) VAR_53 <S2SV_ModEnd> [ VAR_66 *","CWE-119 <S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ; } } }","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> DCT_DCT ) { vpx_fdct4x4_c <S2SV_ModEnd> ( input , <S2SV_ModStart> } else { tran_low_t <S2SV_ModEnd> out [ 4 <S2SV_ModStart> 4 ] ; <S2SV_ModEnd> int i , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> temp_in [ 4 <S2SV_ModStart> ++ j ) out <S2SV_ModEnd> [ j *"
587,"CWE-119 <S2SV_StartBug> static const TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 ) <S2SV_EndBug> { TYPE_3 * VAR_2 ; if ( * VAR_3 != '[' ) { <S2SV_StartBug> VAR_4 = VAR_5 ; <S2SV_EndBug> return 0 ; } VAR_6 -> VAR_7 = VAR_8 ; VAR_9 = METHOD_1 ( VAR_10 + 1 ) ; if ( * VAR_11 == ']' ) <S2SV_StartBug> return VAR_12 + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( VAR_13 -> VAR_14 = VAR_15 = METHOD_2 ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( VAR_16 = METHOD_3 ( METHOD_4 ( VAR_17 , METHOD_5 ( VAR_18 ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * VAR_19 == ',' ) { TYPE_4 * VAR_20 ; if ( ! ( VAR_21 = METHOD_6 ( ) ) ) return 0 ; VAR_22 -> VAR_23 = VAR_24 ; VAR_25 -> VAR_26 = VAR_27 ; <S2SV_StartBug> VAR_28 = VAR_29 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( VAR_30 = METHOD_7 ( METHOD_8 ( VAR_31 , METHOD_9 ( VAR_32 + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * VAR_33 == ']' ) <S2SV_StartBug> return VAR_34 + 1 ; <S2SV_EndBug> VAR_35 = VAR_36 ; return 0 ; }","<S2SV_ModStart> TYPE_2 * VAR_36 , const TYPE_2 * * VAR_35 <S2SV_ModStart> '[' ) { * VAR_35 = VAR_36 ; return 0 ; <S2SV_ModEnd> } VAR_13 -> <S2SV_ModStart> == ']' ) return VAR_36 + 1 ; <S2SV_ModEnd> VAR_13 -> VAR_31 <S2SV_ModStart> METHOD_6 ( ) ; if ( ! VAR_13 -> VAR_31 ) return 0 ; <S2SV_ModEnd> VAR_36 = METHOD_9 <S2SV_ModStart> ( VAR_36 ) , VAR_35 ) ) ; if ( ! VAR_36 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = VAR_31 ; VAR_31 = VAR_29 ; <S2SV_ModEnd> VAR_36 = METHOD_9 <S2SV_ModStart> + 1 ) , VAR_35 ) ) ; if ( ! VAR_36 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == ']' ) return VAR_36 + 1 ; * VAR_35 = VAR_36 ; <S2SV_ModEnd> return 0 ;","CWE-119 <S2SV_StartBug> static const char * parse_array ( cJSON * item , const char * value ) <S2SV_EndBug> { cJSON * child ; if ( * value != '[' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } item -> type = cJSON_Array ; value = skip ( value + 1 ) ; if ( * value == ']' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * value == ']' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ep = value ; return 0 ; }","<S2SV_ModStart> char * value , const char * * ep <S2SV_ModStart> '[' ) { * ep = value ; return 0 ; <S2SV_ModEnd> } item -> <S2SV_ModStart> == ']' ) return value + 1 ; <S2SV_ModEnd> item -> child <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> value = skip <S2SV_ModStart> ( value ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = child ; child = new_item ; <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == ']' ) return value + 1 ; * ep = value ; <S2SV_ModEnd> return 0 ;"
588,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 * VAR_2 , TYPE_3 * VAR_3 , TYPE_4 * VAR_4 , TYPE_5 * * VAR_5 ) { union STRUCT_OR_UNION_1 * VAR_6 = & VAR_7 -> VAR_8 ; TYPE_6 VAR_9 ; <S2SV_StartBug> TYPE_7 VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 ; <S2SV_EndBug> TYPE_8 VAR_17 ; TYPE_9 VAR_18 , VAR_19 , VAR_20 , VAR_21 , VAR_22 ; TYPE_10 VAR_23 , VAR_24 ; TYPE_11 VAR_25 [ VAR_26 ] = """" , VAR_27 [ 6 ] = """" ; struct STRUCT_OR_UNION_2 STRUCT_OR_UNION_3 ; VAR_28 * VAR_29 ; TYPE_12 VAR_30 , VAR_31 , VAR_32 , VAR_33 = 0 ; if ( METHOD_1 ( VAR_34 , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & VAR_35 , & VAR_36 , & VAR_37 , & VAR_38 , & VAR_39 , & VAR_40 , & VAR_41 ) == 7 ) { VAR_42 = METHOD_2 ( VAR_43 , <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> & VAR_44 , & VAR_45 , & VAR_46 , & VAR_47 , & VAR_48 , & VAR_49 , & VAR_50 , VAR_51 , VAR_52 , & VAR_53 , & VAR_54 , & VAR_55 , & VAR_56 , & VAR_57 , & VAR_58 , & VAR_59 , & VAR_60 ) ; if ( VAR_61 != 17 ) { * VAR_62 = VAR_63 ; * VAR_64 = METHOD_3 ( ""cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values"" ) ; return VAR_65 ; } } else { VAR_66 = METHOD_4 ( VAR_67 , <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> VAR_68 , VAR_69 , & VAR_70 , & VAR_71 , & VAR_72 , & VAR_73 , & VAR_74 , & VAR_75 , & VAR_76 , & VAR_77 ) ; if ( VAR_78 != 10 ) { * VAR_79 = VAR_80 ; * VAR_81 = METHOD_5 ( ""cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output"" ) ; return VAR_82 ; } <S2SV_StartBug> VAR_83 = VAR_84 = VAR_85 = VAR_86 = VAR_87 = VAR_88 = VAR_89 = 0 ; <S2SV_EndBug> } if ( VAR_90 > VAR_91 ) { * VAR_92 = VAR_93 ; * VAR_94 = METHOD_6 ( ""cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , VAR_95 , VAR_96 ) ; return VAR_97 ; } VAR_98 -> VAR_99 = VAR_100 ; VAR_101 -> VAR_102 = VAR_103 | VAR_104 ; STRUCT_OR_UNION_4 . VAR_105 = VAR_106 - 1900 ; STRUCT_OR_UNION_5 . VAR_107 = VAR_108 - 1 ; STRUCT_OR_UNION_6 . VAR_109 = VAR_110 ; STRUCT_OR_UNION_7 . VAR_111 = VAR_112 ; STRUCT_OR_UNION_8 . VAR_113 = VAR_114 ; STRUCT_OR_UNION_9 . VAR_115 = VAR_116 ; STRUCT_OR_UNION_10 . VAR_117 = - 1 ; VAR_118 -> VAR_119 . VAR_120 = METHOD_7 ( & STRUCT_OR_UNION_11 ) ; VAR_121 -> VAR_122 . VAR_123 = VAR_124 * 10000000 ; VAR_125 -> VAR_126 = VAR_127 ; if ( METHOD_8 ( VAR_128 , ""TEST:"" , 5 ) == 0 ) { VAR_129 -> VAR_130 . VAR_131 = VAR_132 ; } else if ( METHOD_9 ( VAR_133 , ""PPoATM:"" , 7 ) == 0 ) { VAR_134 -> VAR_135 . VAR_136 = VAR_137 ; } else if ( METHOD_10 ( VAR_138 , ""PPoFR:"" , 6 ) == 0 ) { VAR_139 -> VAR_140 . VAR_141 = VAR_142 ; } else if ( METHOD_11 ( VAR_143 , ""ATM:"" , 4 ) == 0 ) { VAR_144 -> VAR_145 . VAR_146 = VAR_147 ; } else if ( METHOD_12 ( VAR_148 , ""FR:"" , 3 ) == 0 ) { VAR_149 -> VAR_150 . VAR_151 = VAR_152 ; } else if ( METHOD_13 ( VAR_153 , ""HDLC:"" , 5 ) == 0 ) { VAR_154 -> VAR_155 . VAR_156 = VAR_157 ; } else if ( METHOD_14 ( VAR_158 , ""PPP:"" , 4 ) == 0 ) { VAR_159 -> VAR_160 . VAR_161 = VAR_162 ; } else if ( METHOD_15 ( VAR_163 , ""ETH:"" , 4 ) == 0 ) { VAR_164 -> VAR_165 . VAR_166 = VAR_167 ; } else { VAR_168 -> VAR_169 . VAR_170 = VAR_171 ; } if ( METHOD_16 ( VAR_172 , ""l2-tx"" , 5 ) == 0 ) { VAR_173 -> VAR_174 . VAR_175 = VAR_176 ; } else if ( METHOD_17 ( VAR_177 , ""l2-rx"" , 5 ) == 0 ) { VAR_178 -> VAR_179 . VAR_180 = VAR_181 ; } METHOD_18 ( VAR_182 -> VAR_183 . VAR_184 , VAR_185 , VAR_186 ) ; VAR_187 -> VAR_188 . VAR_189 = VAR_190 ; VAR_191 -> VAR_192 . VAR_193 = VAR_194 ; VAR_195 -> VAR_196 . VAR_197 = VAR_198 ; VAR_199 -> VAR_200 . VAR_201 = VAR_202 ; VAR_203 -> VAR_204 . VAR_205 = VAR_206 ; METHOD_19 ( VAR_207 , VAR_208 ) ; VAR_209 = METHOD_20 ( VAR_210 ) ; VAR_211 = VAR_212 / 16 + ( ( VAR_213 % 16 ) ? 1 : 0 ) ; for ( VAR_214 = 0 ; VAR_215 < VAR_216 ; VAR_217 ++ ) { if ( METHOD_21 ( VAR_218 , VAR_219 , VAR_220 ) == VAR_221 ) { * VAR_222 = METHOD_22 ( VAR_223 , VAR_224 ) ; if ( * VAR_225 == 0 ) { * VAR_226 = VAR_227 ; } return VAR_228 ; } if ( METHOD_23 ( VAR_229 ) ) { break ; } if ( ( VAR_230 = METHOD_24 ( VAR_231 , VAR_232 , VAR_233 * 16 ) ) == - 1 ) { * VAR_234 = VAR_235 ; * VAR_236 = METHOD_25 ( ""cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers"" ) ; return VAR_237 ; } VAR_238 += VAR_239 ; } VAR_240 -> VAR_241 = VAR_242 ; return VAR_243 ; }","<S2SV_ModStart> VAR_116 , VAR_124 , <S2SV_ModEnd> VAR_213 ; TYPE_12 <S2SV_ModStart> ( VAR_231 , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , & VAR_106 <S2SV_ModStart> ( VAR_231 , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , VAR_180 , <S2SV_ModStart> VAR_124 = 0 ; } if ( VAR_213 < 0 ) { * VAR_234 = VAR_235 ; * VAR_236 = METHOD_25 ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return VAR_237","CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = """" , direction [ 6 ] = """" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values"" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output"" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , ""TEST:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , ""PPoATM:"" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , ""PPoFR:"" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , ""ATM:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , ""FR:"" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , ""HDLC:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , ""PPP:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , ""ETH:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , ""l2-tx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , ""l2-rx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers"" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }","<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE"
589,"CWE-59 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * * VAR_1 ) { METHOD_1 ( VAR_2 , """" ) ; if VAR_3 METHOD_2 ( VAR_4 , VAR_5 ) ; METHOD_3 ( VAR_6 ) ; METHOD_4 ( VAR_7 ) ; const TYPE_3 * VAR_8 = METHOD_5 ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { VAR_9 = 1 << 0 , VAR_10 = 1 << 1 , VAR_11 = 1 << 2 , VAR_12 = 1 << 3 , VAR_13 = 1 << 4 , VAR_14 = 1 << 5 , } ; const TYPE_4 * VAR_15 = ""build_ids"" ; const TYPE_5 * VAR_16 = VAR_17 ; const TYPE_6 * VAR_18 = VAR_19 ; const TYPE_7 * VAR_20 = VAR_21 ; struct STRUCT_OR_UNION_0 VAR_22 [ ] = { METHOD_6 ( & VAR_23 ) , METHOD_7 ( 'y' , ""yes"" , VAR_24 , METHOD_8 ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , METHOD_9 ( 'i' , ""ids"" , & VAR_25 , ""BUILD_IDS_FILE"" , METHOD_10 ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , METHOD_11 ( 'e' , ""exact"" , & VAR_26 , ""EXACT"" , METHOD_12 ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , METHOD_13 ( 'r' , ""repo"" , & VAR_27 , ""REPO"" , METHOD_14 ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , METHOD_15 ( 's' , ""size_mb"" , & VAR_28 , ""SIZE_MB"" , METHOD_16 ( ""Ignored<S2SV_blank>option"" ) ) , METHOD_17 ( ) } ; const unsigned VAR_29 = METHOD_18 ( VAR_30 , VAR_31 , VAR_32 , VAR_33 ) ; const TYPE_8 VAR_34 = METHOD_19 ( ) ; const TYPE_9 VAR_35 = METHOD_20 ( ) ; const TYPE_10 VAR_36 = METHOD_21 ( ) ; const TYPE_11 VAR_37 = METHOD_22 ( ) ; TYPE_12 * VAR_38 = VAR_39 ; if ( METHOD_23 ( ""-"" , VAR_40 ) != 0 ) { if ( METHOD_24 ( VAR_41 , VAR_42 ) < 0 ) METHOD_25 ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( METHOD_26 ( VAR_43 , VAR_44 ) < 0 ) METHOD_27 ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const TYPE_13 VAR_45 = METHOD_28 ( VAR_46 , VAR_47 ) ; if ( METHOD_29 ( VAR_48 , VAR_49 ) < 0 ) METHOD_30 ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( METHOD_31 ( VAR_50 , VAR_51 ) < 0 ) METHOD_32 ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( VAR_52 < 0 ) METHOD_33 ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , VAR_53 ) ; VAR_54 = METHOD_34 ( ""/proc/self/fd/%d"" , VAR_55 ) ; } <S2SV_StartBug> const TYPE_14 * VAR_56 [ 11 ] ; <S2SV_EndBug> { const TYPE_15 * VAR_57 [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned VAR_58 = 0 ; VAR_59 [ VAR_60 ++ ] = VAR_61 ; VAR_62 [ VAR_63 ++ ] = ""--ids"" ; VAR_64 [ VAR_65 ++ ] = ( VAR_66 != VAR_67 ) ? VAR_68 : ""-"" ; if ( VAR_69 > 0 ) VAR_70 [ VAR_71 ++ ] = VAR_72 [ VAR_73 <= 3 ? VAR_74 : 3 ] ; if ( ( VAR_75 & VAR_76 ) ) VAR_77 [ VAR_78 ++ ] = ""-y"" ; if ( ( VAR_79 & VAR_80 ) ) { VAR_81 [ VAR_82 ++ ] = ""--exact"" ; VAR_83 [ VAR_84 ++ ] = VAR_85 ; } if ( ( VAR_86 & VAR_87 ) ) { VAR_88 [ VAR_89 ++ ] = ""--repo"" ; VAR_90 [ VAR_91 ++ ] = VAR_92 ; } <S2SV_StartBug> VAR_93 [ VAR_94 ++ ] = ""--"" ; <S2SV_EndBug> VAR_95 [ VAR_96 ] = VAR_97 ; } if ( VAR_98 != VAR_99 ) METHOD_35 ( METHOD_36 ( VAR_100 , VAR_101 ) ) ; if ( VAR_102 != VAR_103 ) { METHOD_37 ( METHOD_38 ( VAR_104 , VAR_105 ) ) ; if 1 static const TYPE_16 * VAR_106 [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const TYPE_17 VAR_107 = sizeof ( VAR_108 ) / sizeof ( TYPE_18 * ) ; TYPE_19 * VAR_109 [ sizeof ( VAR_110 ) / sizeof ( TYPE_20 * ) ] = { 0 } ; TYPE_21 * VAR_111 = VAR_112 ; for ( TYPE_22 VAR_113 = 0 ; VAR_114 < VAR_115 ; VAR_116 ++ ) if ( ( VAR_117 = METHOD_39 ( VAR_118 [ VAR_119 ] ) ) != VAR_120 ) VAR_121 [ VAR_122 ] = METHOD_40 ( VAR_123 ) ; METHOD_41 ( ) ; for ( TYPE_23 VAR_124 = 0 ; VAR_125 < VAR_126 ; VAR_127 ++ ) if ( VAR_128 [ VAR_129 ] != VAR_130 ) { METHOD_42 ( VAR_131 [ VAR_132 ] , VAR_133 [ VAR_134 ] ) ; METHOD_43 ( VAR_135 [ VAR_136 ] ) ; } else static const TYPE_24 VAR_137 [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const TYPE_25 * VAR_138 = VAR_139 ; do { METHOD_44 ( VAR_140 ) ; VAR_141 += METHOD_45 ( VAR_142 ) + 1 ; } while ( * VAR_143 ) ; TYPE_26 VAR_144 [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( VAR_145 != 0 ) strcpy ( VAR_146 , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; METHOD_46 ( VAR_147 ) ; METHOD_47 ( 0022 ) ; } <S2SV_StartBug> METHOD_48 ( VAR_148 , ( TYPE_27 * * ) VAR_149 ) ; <S2SV_EndBug> METHOD_49 ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , VAR_150 ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ) ; } TYPE_27 VAR_151 [ ] = VAR_152 ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( METHOD_50 ( VAR_151 ) == VAR_130 ) METHOD_33 ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; METHOD_51 ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , VAR_151 ) ; const TYPE_27 * VAR_149 [ 13 <S2SV_ModEnd> ] ; { <S2SV_ModStart> ++ ] = ""--tmpdir"" ; VAR_149 [ VAR_136 ++ ] = VAR_151 ; VAR_149 [ VAR_136 ++ ] = <S2SV_ModStart> ) ; } TYPE_28 VAR_153 = METHOD_52 ( ) ; if ( VAR_153 < 0 ) METHOD_33 ( ""fork"" ) ; if ( VAR_153 == 0 ) { <S2SV_ModStart> ) ; } TYPE_13 VAR_154 ; if ( METHOD_53 ( VAR_153 , & VAR_154 , 0 ) < 0 ) METHOD_33 ( ""waitpid"" ) ; if ( METHOD_54 ( VAR_151 ) >= 0 ) METHOD_51 ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , VAR_151 ) ; else if ( VAR_155 != VAR_156 ) METHOD_55 ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( METHOD_56 ( VAR_154 ) ) return METHOD_57 ( VAR_154 ) ; if ( METHOD_58 ( VAR_154 ) ) METHOD_49 ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , METHOD_59 ( VAR_154 ) ) ; METHOD_49 ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; }","CWE-59 int main ( int argc , char * * argv ) { setlocale ( LC_ALL , """" ) ;  if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ;   abrt_init ( argv ) ; const char * program_usage_string = _ ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = ""build_ids"" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , ""yes"" , NULL , _ ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , OPT_STRING ( 'i' , ""ids"" , & build_ids , ""BUILD_IDS_FILE"" , _ ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , OPT_STRING ( 'e' , ""exact"" , & exact , ""EXACT"" , _ ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , OPT_STRING ( 'r' , ""repo"" , & repo , ""REPO"" , _ ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , OPT_STRING ( 's' , ""size_mb"" , & size_mb , ""SIZE_MB"" , _ ( ""Ignored<S2SV_blank>option"" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( ""-"" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , build_ids ) ; build_ids_self_fd = xasprintf ( ""/proc/self/fd/%d"" , build_ids_fd ) ; } <S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> { const char * verbs [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = ""--ids"" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : ""-"" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = ""-y"" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = ""--exact"" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = ""--repo"" ; args [ i ++ ] = repo ; } <S2SV_StartBug> args [ i ++ ] = ""--"" ; <S2SV_EndBug> args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ;  if 1 static const char * whitelist [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; }  else static const char forbid [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ;   char path_env [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; } <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> error_msg_and_die ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ) ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> ] ; { <S2SV_ModStart> ++ ] = ""--tmpdir"" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ; if ( pid == 0 ) { <S2SV_ModStart> ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ; error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; }"
590,"CWE-20 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , TYPE_1 VAR_3 ) { TYPE_2 VAR_4 ; if ( VAR_5 -> VAR_6 ) { if ( VAR_7 == VAR_8 ) { TYPE_3 VAR_9 = METHOD_1 ( VAR_10 -> VAR_11 , VAR_12 -> VAR_13 , VAR_14 ) ; if ( VAR_15 < 0 ) return VAR_16 ; } <S2SV_StartBug> VAR_17 -> VAR_18 = VAR_19 ; <S2SV_EndBug> } else VAR_20 -> VAR_21 = VAR_22 ; VAR_23 = METHOD_2 ( VAR_24 , ( struct STRUCT_OR_UNION_3 TYPE_4 * ) VAR_25 -> VAR_26 , VAR_27 -> VAR_28 ) ; if ( VAR_29 >= 0 ) VAR_30 -> VAR_31 = VAR_32 ; return VAR_33 ; }",<S2SV_ModStart> VAR_16 ; } if ( VAR_30 -> VAR_21 ),"CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }",<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
591,"CWE-310 TYPE_0 METHOD_0 ( TYPE_1 ) { if 0 VAR_0 = METHOD_1 ( ""OpenSSL"" ) ; VAR_1 = METHOD_2 ( VAR_2 , ""OpenSSLError"" , VAR_3 ) ; VAR_4 = METHOD_3 ( VAR_5 , ""Cipher"" , VAR_6 ) ; VAR_7 = METHOD_4 ( VAR_8 , ""CipherError"" , VAR_9 ) ; METHOD_5 ( VAR_10 , VAR_11 ) ; METHOD_6 ( VAR_12 , VAR_13 ) ; METHOD_7 ( VAR_14 , ""ciphers"" , VAR_15 , 0 ) ; METHOD_8 ( VAR_16 , ""initialize"" , VAR_17 , 1 ) ; METHOD_9 ( VAR_18 , ""reset"" , VAR_19 , 0 ) ; METHOD_10 ( VAR_20 , ""encrypt"" , VAR_21 , - 1 ) ; METHOD_11 ( VAR_22 , ""decrypt"" , VAR_23 , - 1 ) ; METHOD_12 ( VAR_24 , ""pkcs5_keyivgen"" , VAR_25 , - 1 ) ; METHOD_13 ( VAR_26 , ""update"" , VAR_27 , - 1 ) ; METHOD_14 ( VAR_28 , ""final"" , VAR_29 , 0 ) ; METHOD_15 ( VAR_30 , ""name"" , VAR_31 , 0 ) ; METHOD_16 ( VAR_32 , ""key="" , VAR_33 , 1 ) ; METHOD_17 ( VAR_34 , ""auth_data="" , VAR_35 , 1 ) ; METHOD_18 ( VAR_36 , ""auth_tag="" , VAR_37 , 1 ) ; METHOD_19 ( VAR_38 , ""auth_tag"" , VAR_39 , - 1 ) ; METHOD_20 ( VAR_40 , ""auth_tag_len="" , VAR_41 , 1 ) ; METHOD_21 ( VAR_42 , ""authenticated?"" , VAR_43 , 0 ) ; METHOD_22 ( VAR_44 , ""key_len="" , VAR_45 , 1 ) ; METHOD_23 ( VAR_46 , ""key_len"" , VAR_47 , 0 ) ; METHOD_24 ( VAR_48 , ""iv="" , VAR_49 , 1 ) ; METHOD_25 ( VAR_50 , ""iv_len="" , VAR_51 , 1 ) ; METHOD_26 ( VAR_52 , ""iv_len"" , VAR_53 , 0 ) ; METHOD_27 ( VAR_54 , ""block_size"" , VAR_55 , 0 ) ; METHOD_28 ( VAR_56 , ""padding="" , VAR_57 , 1 ) ; VAR_58 = METHOD_29 ( ""auth_tag_len"" ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ""auth_tag_len"" ) ; VAR_59 = METHOD_29 ( ""key_set"" ) ;","CWE-310 void Init_ossl_cipher ( void ) {  if 0 mOSSL = rb__module ( ""OpenSSL"" ) ; eOSSLError = rb__class_under ( mOSSL , ""OpenSSLError"" , rb_eStandardError ) ;   cCipher = rb__class_under ( mOSSL , ""Cipher"" , rb_cObject ) ; eCipherError = rb__class_under ( cCipher , ""CipherError"" , eOSSLError ) ; rb__alloc_func ( cCipher , ossl_cipher_alloc ) ; rb__copy_func ( cCipher , ossl_cipher_copy ) ; rb__module_function ( cCipher , ""ciphers"" , ossl_s_ciphers , 0 ) ; rb__method ( cCipher , ""initialize"" , ossl_cipher_initialize , 1 ) ; rb__method ( cCipher , ""reset"" , ossl_cipher_reset , 0 ) ; rb__method ( cCipher , ""encrypt"" , ossl_cipher_encrypt , - 1 ) ; rb__method ( cCipher , ""decrypt"" , ossl_cipher_decrypt , - 1 ) ; rb__method ( cCipher , ""pkcs5_keyivgen"" , ossl_cipher_pkcs5_keyivgen , - 1 ) ; rb__method ( cCipher , ""update"" , ossl_cipher_update , - 1 ) ; rb__method ( cCipher , ""final"" , ossl_cipher_final , 0 ) ; rb__method ( cCipher , ""name"" , ossl_cipher_name , 0 ) ; rb__method ( cCipher , ""key="" , ossl_cipher_set_key , 1 ) ; rb__method ( cCipher , ""auth_data="" , ossl_cipher_set_auth_data , 1 ) ; rb__method ( cCipher , ""auth_tag="" , ossl_cipher_set_auth_tag , 1 ) ; rb__method ( cCipher , ""auth_tag"" , ossl_cipher_get_auth_tag , - 1 ) ; rb__method ( cCipher , ""auth_tag_len="" , ossl_cipher_set_auth_tag_len , 1 ) ; rb__method ( cCipher , ""authenticated?"" , ossl_cipher_is_authenticated , 0 ) ; rb__method ( cCipher , ""key_len="" , ossl_cipher_set_key_length , 1 ) ; rb__method ( cCipher , ""key_len"" , ossl_cipher_key_length , 0 ) ; rb__method ( cCipher , ""iv="" , ossl_cipher_set_iv , 1 ) ; rb__method ( cCipher , ""iv_len="" , ossl_cipher_set_iv_length , 1 ) ; rb__method ( cCipher , ""iv_len"" , ossl_cipher_iv_length , 0 ) ; rb__method ( cCipher , ""block_size"" , ossl_cipher_block_size , 0 ) ; rb__method ( cCipher , ""padding="" , ossl_cipher_set_padding , 1 ) ; id_auth_tag_len = rb_intern_const ( ""auth_tag_len"" ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> ""auth_tag_len"" ) ; id_key_set = rb_intern_const ( ""key_set"" ) ;"
592,"CWE-22 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = METHOD_1 ( VAR_2 ) ; TYPE_3 * VAR_3 = METHOD_2 ( VAR_4 ) ; TYPE_4 * VAR_5 = METHOD_3 ( VAR_6 ) ; TYPE_5 * VAR_7 = """" ; METHOD_4 ( VAR_8 ) ; if ( ! METHOD_5 ( VAR_9 , ""/"" ) ) { if ( METHOD_6 ( ""WikiHome"" , VAR_10 ) != 0 ) METHOD_7 ( VAR_11 , ""/WikiHome?create"" ) ; VAR_12 = ""/WikiHome"" ; } if ( ! METHOD_8 ( VAR_13 , ""/styles.css"" ) ) { METHOD_9 ( VAR_14 , ""text/css"" ) ; METHOD_10 ( VAR_15 , ""%s"" , VAR_16 ) ; METHOD_11 ( VAR_17 ) ; METHOD_12 ( 0 ) ; } if ( ! METHOD_13 ( VAR_18 , ""/favicon.ico"" ) ) { METHOD_14 ( VAR_19 , ""image/ico"" ) ; METHOD_15 ( VAR_20 , VAR_21 , VAR_22 ) ; METHOD_16 ( VAR_23 ) ; METHOD_17 ( 0 ) ; } VAR_24 = VAR_25 + 1 ; if ( ! METHOD_18 ( VAR_26 , ""api/"" , 4 ) ) { TYPE_6 * VAR_27 ; VAR_28 += 4 ; for ( VAR_29 = VAR_30 ; * VAR_31 != '\\0' ; VAR_32 ++ ) if ( * VAR_33 == '?' ) { * VAR_34 = '\\0' ; break ; } METHOD_19 ( VAR_35 , VAR_36 , VAR_37 ) ; METHOD_20 ( 0 ) ; } <S2SV_StartBug> if ( METHOD_21 ( VAR_38 , '/' ) ) <S2SV_EndBug> { METHOD_22 ( VAR_39 , 404 , ""Not<S2SV_blank>Found"" ) ; METHOD_23 ( VAR_40 , ""<html><body>404<S2SV_blank>Not<S2SV_blank>Found</body></html>\\n"" ) ; METHOD_24 ( VAR_41 ) ; METHOD_25 ( 0 ) ; } if ( ! METHOD_26 ( VAR_42 , ""Changes"" ) ) { METHOD_27 ( VAR_43 ) ; } else if ( ! METHOD_28 ( VAR_44 , ""ChangesRss"" ) ) { METHOD_29 ( VAR_45 ) ; } else if ( ! METHOD_30 ( VAR_46 , ""Search"" ) ) { METHOD_31 ( VAR_47 , METHOD_32 ( VAR_48 , ""expr"" ) ) ; } else if ( ! METHOD_33 ( VAR_49 , ""Create"" ) ) { if ( ( VAR_50 = METHOD_34 ( VAR_51 , ""title"" ) ) != VAR_52 ) { METHOD_35 ( VAR_53 , METHOD_36 ( VAR_54 , ""title"" ) ) ; } else { METHOD_37 ( VAR_55 ) ; } } else { if ( ( VAR_56 = METHOD_38 ( VAR_57 , ""wikitext"" ) ) != VAR_58 ) { METHOD_39 ( VAR_59 , VAR_60 ) ; } if ( METHOD_40 ( VAR_61 , VAR_62 ) == 0 ) { VAR_63 = METHOD_41 ( VAR_64 ) ; if ( ! METHOD_42 ( VAR_65 , ""edit"" ) ) { METHOD_43 ( VAR_66 , VAR_67 , VAR_68 ) ; } else { METHOD_44 ( VAR_69 , VAR_70 , VAR_71 ) ; } } else { if ( ! METHOD_45 ( VAR_72 , ""create"" ) ) { METHOD_46 ( VAR_73 , VAR_74 , VAR_75 ) ; } else { TYPE_7 VAR_76 [ 1024 ] ; METHOD_47 ( VAR_77 , 1024 , ""%s?create"" , VAR_78 ) ; METHOD_48 ( VAR_79 , VAR_80 ) ; } } } }",<S2SV_ModStart> } if ( ! METHOD_49 ( VAR_78 <S2SV_ModEnd> ) ) {,"CWE-22 void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = """" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , ""/"" ) ) { if ( access ( ""WikiHome"" , R_OK ) != 0 ) wiki_redirect ( res , ""/WikiHome?create"" ) ; page = ""/WikiHome"" ; } if ( ! strcmp ( page , ""/styles.css"" ) ) { http_response_set_content_type ( res , ""text/css"" ) ; http_response_printf ( res , ""%s"" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , ""/favicon.ico"" ) ) { http_response_set_content_type ( res , ""image/ico"" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , ""api/"" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; } <S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> { http_response_set_status ( res , 404 , ""Not<S2SV_blank>Found"" ) ; http_response_printf ( res , ""<html><body>404<S2SV_blank>Not<S2SV_blank>Found</body></html>\\n"" ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , ""Changes"" ) ) { wiki_show_changes_page ( res ) ; } else if ( ! strcmp ( page , ""ChangesRss"" ) ) { wiki_show_changes_page_rss ( res ) ; } else if ( ! strcmp ( page , ""Search"" ) ) { wiki_show_search_results_page ( res , http_request_param_get ( req , ""expr"" ) ) ; } else if ( ! strcmp ( page , ""Create"" ) ) { if ( ( wikitext = http_request_param_get ( req , ""title"" ) ) != NULL ) { wiki_redirect ( res , http_request_param_get ( req , ""title"" ) ) ; } else { wiki_show_create_page ( res ) ; } } else { if ( ( wikitext = http_request_param_get ( req , ""wikitext"" ) ) != NULL ) { file_write ( page , wikitext ) ; } if ( access ( page , R_OK ) == 0 ) { wikitext = file_read ( page ) ; if ( ! strcmp ( command , ""edit"" ) ) { wiki_show_edit_page ( res , wikitext , page ) ; } else { wiki_show_page ( res , wikitext , page ) ; } } else { if ( ! strcmp ( command , ""create"" ) ) { wiki_show_edit_page ( res , NULL , page ) ; } else { char buf [ 1024 ] ; snprintf ( buf , 1024 , ""%s?create"" , page ) ; wiki_redirect ( res , buf ) ; } } } }",<S2SV_ModStart> } if ( ! page_name_is_good ( page <S2SV_ModEnd> ) ) {
593,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { <S2SV_StartBug> TYPE_5 VAR_4 = 0 , VAR_5 = 1 ; <S2SV_EndBug> TYPE_6 VAR_6 , VAR_7 , VAR_8 ; TYPE_7 VAR_9 ; <S2SV_StartBug> TYPE_8 VAR_10 ; <S2SV_EndBug> TYPE_9 VAR_11 ; TYPE_10 VAR_12 ; TYPE_11 VAR_13 ; TYPE_12 VAR_14 , VAR_15 ; TYPE_13 VAR_16 = METHOD_1 ( VAR_17 ) ; TYPE_14 VAR_18 = METHOD_2 ( VAR_19 ) ; TYPE_15 VAR_20 = METHOD_3 ( VAR_21 ) ; TYPE_16 VAR_22 = METHOD_4 ( VAR_23 ) ; TYPE_17 VAR_24 = METHOD_5 ( VAR_25 ) ; TYPE_18 VAR_26 = METHOD_6 ( VAR_27 ) ? 3 : 1 ; TYPE_19 VAR_28 = 16 ; if ( VAR_29 == 3 && METHOD_7 ( VAR_30 ) != 127 ) { METHOD_8 ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return VAR_31 ; } if ( VAR_32 == - 1 ) VAR_33 = 0x7ffff000 / ( VAR_34 * VAR_35 ) ; VAR_36 = VAR_37 * VAR_38 * VAR_39 ; if ( VAR_40 > 0xff000000 ) { if ( VAR_41 ) METHOD_9 ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , VAR_42 ) ; VAR_43 = 0 ; VAR_44 = 1 ; } else if ( VAR_45 ) METHOD_10 ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , VAR_46 ) ; METHOD_11 ( VAR_47 ) ; VAR_48 . VAR_49 = VAR_50 ; VAR_51 . VAR_52 = VAR_53 ; VAR_54 . VAR_55 = VAR_56 ; VAR_57 . VAR_58 = VAR_59 * VAR_60 * VAR_61 ; VAR_62 . VAR_63 = VAR_64 * VAR_65 ; VAR_66 . VAR_67 = VAR_68 ; if ( VAR_69 > 2 || VAR_70 != 0x5 - VAR_71 ) { VAR_72 = sizeof ( VAR_73 ) ; VAR_74 . VAR_75 = 22 ; VAR_76 . VAR_77 = VAR_78 ; VAR_79 . VAR_80 = VAR_81 ; VAR_82 . VAR_83 = VAR_84 ; VAR_85 . VAR_86 = 0xfffe ; VAR_87 . VAR_88 = VAR_89 * 8 ; VAR_90 . VAR_91 [ 4 ] = 0x10 ; VAR_92 . VAR_93 [ 6 ] = 0x80 ; VAR_94 . VAR_95 [ 9 ] = 0xaa ; VAR_96 . VAR_97 [ 11 ] = 0x38 ; VAR_98 . VAR_99 [ 12 ] = 0x9b ; VAR_100 . VAR_101 [ 13 ] = 0x71 ; } METHOD_12 ( VAR_102 . VAR_103 , VAR_104 ? ""RF64"" : ""RIFF"" , sizeof ( VAR_105 . VAR_106 ) ) ; METHOD_13 ( VAR_107 . VAR_108 , ""WAVE"" , sizeof ( VAR_109 . VAR_110 ) ) ; VAR_111 = sizeof ( VAR_112 ) + VAR_113 + sizeof ( VAR_114 ) + ( ( VAR_115 + 1 ) & ~ ( TYPE_20 ) 1 ) ; if ( VAR_116 ) VAR_117 += sizeof ( VAR_118 ) + sizeof ( VAR_119 ) ; <S2SV_StartBug> if ( VAR_120 ) VAR_121 += sizeof ( VAR_122 ) ; <S2SV_EndBug> METHOD_14 ( VAR_123 . VAR_124 , ""fmt<S2SV_blank>"" , sizeof ( VAR_125 . VAR_126 ) ) ; METHOD_15 ( VAR_127 . VAR_128 , ""data"" , sizeof ( VAR_129 . VAR_130 ) ) ; VAR_131 . VAR_132 = VAR_133 ; if ( VAR_134 ) { METHOD_16 ( VAR_135 ) ; METHOD_17 ( VAR_136 . VAR_137 , ""junk"" , sizeof ( VAR_138 . VAR_139 ) ) ; VAR_140 . VAR_141 = sizeof ( VAR_142 ) - 8 ; METHOD_18 ( & VAR_143 , VAR_144 ) ; } if ( VAR_145 ) { METHOD_19 ( VAR_146 . VAR_147 , ""ds64"" , sizeof ( VAR_148 . VAR_149 ) ) ; <S2SV_StartBug> VAR_150 . VAR_151 = sizeof ( VAR_152 ) ; <S2SV_EndBug> METHOD_20 ( VAR_153 ) ; VAR_154 . VAR_155 = VAR_156 ; VAR_157 . VAR_158 = VAR_159 ; <S2SV_StartBug> VAR_160 . VAR_161 = VAR_162 ; <S2SV_EndBug> VAR_163 . VAR_164 = ( TYPE_21 ) - 1 ; VAR_165 . VAR_166 = ( TYPE_22 ) - 1 ; METHOD_21 ( & VAR_167 , VAR_168 ) ; METHOD_22 ( & VAR_169 , VAR_170 ) ; } else { VAR_171 . VAR_172 = ( TYPE_23 ) VAR_173 ; VAR_174 . VAR_175 = ( TYPE_24 ) VAR_176 ; } <S2SV_StartBug> METHOD_23 ( & VAR_177 , VAR_178 ) ; <S2SV_EndBug> METHOD_24 ( & VAR_179 , VAR_180 ) ; METHOD_25 ( & VAR_181 , VAR_182 ) ; METHOD_26 ( & VAR_183 , VAR_184 ) ; if ( ! METHOD_27 ( VAR_185 , & VAR_186 , sizeof ( VAR_187 ) , & VAR_188 ) || VAR_189 != sizeof ( VAR_190 ) || ( VAR_191 && ( ! METHOD_28 ( VAR_192 , & VAR_193 , sizeof ( VAR_194 ) , & VAR_195 ) || VAR_196 != sizeof ( VAR_197 ) ) ) || <S2SV_StartBug> ( VAR_198 && ( ! METHOD_29 ( VAR_199 , & VAR_200 , sizeof ( VAR_201 ) , & VAR_202 ) || VAR_203 != sizeof ( VAR_204 ) ) ) || <S2SV_EndBug> ( VAR_205 && ( ! METHOD_30 ( VAR_206 , & VAR_207 , sizeof ( VAR_208 ) , & VAR_209 ) || VAR_210 != sizeof ( VAR_211 ) ) ) || ! METHOD_31 ( VAR_212 , & VAR_213 , sizeof ( VAR_214 ) , & VAR_215 ) || VAR_216 != sizeof ( VAR_217 ) || ! METHOD_32 ( VAR_218 , & VAR_219 , VAR_220 , & VAR_221 ) || VAR_222 != VAR_223 || ! METHOD_33 ( VAR_224 , & VAR_225 , sizeof ( VAR_226 ) , & VAR_227 ) || VAR_228 != sizeof ( VAR_229 ) ) { METHOD_34 ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return VAR_230 ; } return VAR_231 ; }","<S2SV_ModStart> VAR_205 = 1 , VAR_232 = 0 <S2SV_ModStart> ; TYPE_8 VAR_204 ; TYPE_25 VAR_233 <S2SV_ModStart> VAR_204 ) ; VAR_173 += VAR_232 * sizeof ( TYPE_25 ) ; if ( VAR_205 ) VAR_173 += <S2SV_ModEnd> sizeof ( VAR_211 <S2SV_ModStart> ( VAR_204 ) + ( VAR_232 * sizeof ( TYPE_25 ) ) <S2SV_ModStart> VAR_161 = VAR_162 ; VAR_204 . VAR_234 = VAR_232 <S2SV_ModStart> VAR_176 ; } if ( VAR_232 ) { METHOD_19 ( VAR_233 . VAR_149 , ""dmmy"" , sizeof ( VAR_233 . VAR_149 ) ) ; VAR_233 . VAR_235 = 12345678 ; METHOD_26 ( & VAR_233 , VAR_236 ) ; } <S2SV_ModStart> ) ) ) ) { METHOD_34 ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return VAR_230 ; } while ( VAR_232 -- ) if ( ! METHOD_33 ( VAR_224 , & VAR_233 , sizeof ( VAR_233 ) , & VAR_228 ) || VAR_228 != sizeof ( VAR_233 ) ) { METHOD_34 ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return VAR_230 ; } if ( <S2SV_ModEnd> ( VAR_205 &&","CWE-125 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&"
594,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 ) { struct STRUCT_OR_UNION_1 * VAR_2 ; if ( VAR_3 < VAR_4 -> VAR_5 ) return - VAR_6 ; VAR_7 = METHOD_1 ( VAR_8 , sizeof ( * VAR_9 ) , VAR_10 | VAR_11 ) ; if ( METHOD_2 ( ! VAR_12 ) ) return - VAR_13 ; if ( VAR_14 -> VAR_15 ) { unsigned TYPE_2 VAR_16 ; unsigned TYPE_3 VAR_17 ; VAR_18 = VAR_19 -> VAR_20 + VAR_21 -> VAR_22 ; if ( VAR_23 < VAR_24 -> VAR_25 ) VAR_26 = 0 ; else VAR_27 &= ( VAR_28 -> VAR_29 - 1 ) ; VAR_30 = VAR_31 -> VAR_32 - VAR_33 ; if ( VAR_34 ) METHOD_3 ( VAR_35 , VAR_36 -> VAR_37 + VAR_38 -> VAR_39 , VAR_40 * sizeof ( struct STRUCT_OR_UNION_2 ) ) ; if ( VAR_41 ) METHOD_4 ( VAR_42 + VAR_43 , VAR_44 -> VAR_45 , VAR_46 * sizeof ( struct STRUCT_OR_UNION_3 ) ) ; } <S2SV_StartBug> VAR_47 -> VAR_48 = 0 ; <S2SV_EndBug> METHOD_5 ( VAR_49 -> VAR_50 ) ; VAR_51 -> VAR_52 = VAR_53 ; VAR_54 -> VAR_55 = VAR_56 ; return VAR_57 * VAR_58 ; }","<S2SV_ModStart> ) ; } METHOD_6 ( VAR_54 , VAR_54 -> VAR_55 , VAR_57 ) ;","CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }","<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;"
595,"CWE-416 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 , struct STRUCT_OR_UNION_0 * VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 , TYPE_6 VAR_6 ) { TYPE_7 * VAR_7 = VAR_8 + 0x2a1 , * VAR_9 , * VAR_10 , * VAR_11 , * VAR_12 , VAR_13 ; TYPE_8 VAR_14 , VAR_15 , VAR_16 , VAR_17 , VAR_18 ; TYPE_9 VAR_19 = 0 , VAR_20 ; METHOD_1 ( ""in<S2SV_blank>wwunpack\\n"" ) ; while ( 1 ) { if ( ! METHOD_2 ( VAR_21 , VAR_22 [ VAR_23 ] . VAR_24 , VAR_25 , 17 ) ) { METHOD_3 ( ""WWPack:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>structs<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section\\n"" ) ; break ; } VAR_26 = VAR_27 [ VAR_28 ] . VAR_29 - METHOD_4 ( VAR_30 ) ; VAR_31 += 8 ; VAR_32 = METHOD_5 ( VAR_33 ) * 4 ; VAR_34 += 4 ; VAR_35 = METHOD_6 ( VAR_36 ) ; VAR_37 += 4 ; VAR_38 = VAR_39 = VAR_40 + VAR_41 + VAR_42 + 4 - VAR_43 ; if ( ! VAR_44 || ! METHOD_7 ( VAR_45 , VAR_46 , VAR_47 , VAR_48 ) ) { METHOD_8 ( ""WWPack:<S2SV_blank>Compressed<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; break ; } METHOD_9 ( ""WWP:<S2SV_blank>src:<S2SV_blank>%x,<S2SV_blank>szd:<S2SV_blank>%x,<S2SV_blank>srcend:<S2SV_blank>%x<S2SV_blank>-<S2SV_blank>%x\\n"" , VAR_49 , VAR_50 , VAR_51 , VAR_52 + 4 - VAR_53 ) ; if ( ! ( VAR_54 = METHOD_10 ( VAR_55 ) ) ) { METHOD_11 ( ""WWPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>compd\\n"" ) ; break ; } METHOD_12 ( VAR_56 , VAR_57 , VAR_58 ) ; METHOD_13 ( VAR_59 , - 1 , VAR_60 ) ; VAR_61 = VAR_62 ; VAR_63 ; while ( ! VAR_64 ) { TYPE_10 VAR_65 , VAR_66 ; TYPE_11 VAR_67 ; VAR_68 ; if ( ! VAR_69 ) { if ( VAR_70 - VAR_71 >= VAR_72 || ! METHOD_14 ( VAR_73 , VAR_74 , VAR_75 , 1 ) ) VAR_76 = 1 ; else * VAR_77 ++ = * VAR_78 ++ ; continue ; } METHOD_15 ( 2 ) ; if ( VAR_79 == 3 ) { TYPE_12 VAR_80 , VAR_81 = 31 ; METHOD_16 ( 2 ) ; VAR_82 = VAR_83 + 5 ; if ( VAR_84 >= 2 ) { VAR_85 ++ ; VAR_86 += 0x80 ; } VAR_87 = ( 1 << VAR_88 ) - VAR_89 ; METHOD_17 ( VAR_90 ) ; if ( VAR_91 || VAR_92 == 0x1ff ) break ; VAR_93 += VAR_94 ; if ( ! METHOD_18 ( VAR_95 , VAR_96 , VAR_97 , 2 ) || ! METHOD_19 ( VAR_98 , VAR_99 , VAR_100 - VAR_101 , 2 ) ) { VAR_102 = 1 ; } else { VAR_103 [ 0 ] = * ( VAR_104 - VAR_105 ) ; VAR_106 [ 1 ] = * ( VAR_107 - VAR_108 + 1 ) ; VAR_109 += 2 ; } continue ; } VAR_110 = VAR_111 ; METHOD_20 ( 3 ) ; if ( VAR_112 < 6 ) { VAR_113 = VAR_114 ; switch ( VAR_115 ) { case 4 : VAR_116 ++ ; case 3 : VAR_117 ; VAR_118 += VAR_119 ; case 0 : case 1 : case 2 : VAR_120 += 5 ; break ; case 5 : VAR_121 = 12 ; break ; } METHOD_21 ( VAR_122 ) ; VAR_123 += ( 1 << VAR_124 ) - 31 ; } else if ( VAR_125 == 6 ) { METHOD_22 ( 0x0e ) ; VAR_126 += 0x1fe1 ; } else { METHOD_23 ( 0x0f ) ; VAR_127 += 0x5fe1 ; } VAR_128 = VAR_129 ; if ( ! VAR_130 ) { VAR_131 ; if ( ! VAR_132 ) { VAR_133 ; VAR_134 += 5 ; } else { METHOD_24 ( 3 ) ; if ( VAR_135 ) { VAR_136 += 6 ; } else { METHOD_25 ( 4 ) ; if ( VAR_137 ) { VAR_138 += 13 ; } else { TYPE_13 VAR_139 = 4 ; TYPE_14 VAR_140 = 0x0d ; do { if ( VAR_141 == 7 ) { VAR_142 = 0x0e ; VAR_143 = 0 ; break ; } VAR_144 = ( ( VAR_145 + 2 ) << 1 ) - 1 ; VAR_146 ; VAR_147 ++ ; } while ( ! VAR_148 ) ; METHOD_26 ( VAR_149 ) ; VAR_150 += VAR_151 ; } } } VAR_152 = VAR_153 ; } else { VAR_154 = VAR_155 + 2 ; } if ( ! METHOD_27 ( VAR_156 , VAR_157 , VAR_158 , VAR_159 ) || ! METHOD_28 ( VAR_160 , VAR_161 , VAR_162 - VAR_163 , VAR_164 ) ) VAR_165 = 1 ; else while ( VAR_166 -- ) { * VAR_167 = * ( VAR_168 - VAR_169 ) ; VAR_170 ++ ; } } METHOD_29 ( VAR_171 ) ; if ( VAR_172 ) { METHOD_30 ( ""WWPack:<S2SV_blank>decompression<S2SV_blank>error\\n"" ) ; break ; } if ( VAR_173 || ! * VAR_174 ++ ) break ; } if ( ! VAR_175 ) { if ( VAR_176 + 6 > VAR_177 || VAR_178 + 7 > VAR_179 || VAR_180 + 0x28 > VAR_181 || VAR_182 + 0x50 > VAR_183 || VAR_184 + 0x14 > VAR_185 ) return VAR_186 ; VAR_187 [ VAR_188 + 6 ] = ( TYPE_15 ) VAR_189 ; VAR_190 [ VAR_191 + 7 ] = ( TYPE_16 ) ( VAR_192 >> 8 ) ; <S2SV_StartBug> METHOD_31 ( & VAR_193 [ VAR_194 + 0x28 ] , METHOD_32 ( VAR_195 + 0x295 ) + VAR_196 [ VAR_197 ] . VAR_198 + 0x299 ) ; <S2SV_EndBug> METHOD_33 ( & VAR_199 [ VAR_200 + 0x50 ] , METHOD_34 ( & VAR_201 [ VAR_202 + 0x50 ] ) - VAR_203 [ VAR_204 ] . VAR_205 ) ; VAR_206 = & VAR_207 [ ( 0xffff & METHOD_35 ( & VAR_208 [ VAR_209 + 0x14 ] ) ) + VAR_210 + 0x18 ] ; for ( VAR_211 = 0 ; VAR_212 < VAR_213 ; VAR_214 ++ ) { if ( ! METHOD_36 ( VAR_215 , VAR_216 , VAR_217 , 0x28 ) ) { METHOD_37 ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return VAR_218 ; } METHOD_38 ( VAR_219 + 8 , VAR_220 [ VAR_221 ] . VAR_222 ) ; METHOD_39 ( VAR_223 + 12 , VAR_224 [ VAR_225 ] . VAR_226 ) ; METHOD_40 ( VAR_227 + 16 , VAR_228 [ VAR_229 ] . VAR_230 ) ; METHOD_41 ( VAR_231 + 20 , VAR_232 [ VAR_233 ] . VAR_234 ) ; VAR_235 += 0x28 ; } if ( ! METHOD_42 ( VAR_236 , VAR_237 , VAR_238 , 0x28 ) ) { METHOD_43 ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return VAR_239 ; } METHOD_44 ( VAR_240 , 0 , 0x28 ) ; VAR_241 = ( TYPE_17 ) METHOD_45 ( VAR_242 , VAR_243 , VAR_244 ) != VAR_245 ; } return VAR_246 ; }","<S2SV_ModStart> 8 ) ; if ( ! METHOD_42 ( VAR_195 , VAR_232 [ VAR_213 ] . VAR_24 , VAR_195 + 0x295 , 4 ) || ! METHOD_42 ( VAR_195 , VAR_232 [ VAR_213 ] . VAR_24 , VAR_195 + 0x295 + VAR_232 [ VAR_213 ] . VAR_234 , 4 ) || ! METHOD_42 ( VAR_195 , VAR_232 [ VAR_213 ] . VAR_24 , VAR_195 + 0x295 + VAR_232 [ VAR_213 ] . VAR_234 + 0x299 , 4 ) ) { METHOD_43 ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n"" ) ; return VAR_239 ; }","CWE-416 int wwunpack ( uint8_t * exe , uint32_t exesz , uint8_t * wwsect , struct cli_exe_section * sects , uint16_t scount , uint32_t pe , int desc ) { uint8_t * structs = wwsect + 0x2a1 , * compd , * ccur , * unpd , * ucur , bc ; uint32_t src , srcend , szd , bt , bits ; int error = 0 , i ; cli_dbgmsg ( ""in<S2SV_blank>wwunpack\\n"" ) ; while ( 1 ) { if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , structs , 17 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>structs<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section\\n"" ) ; break ; } src = sects [ scount ] . rva - cli_readint32 ( structs ) ; structs += 8 ; szd = cli_readint32 ( structs ) * 4 ; structs += 4 ; srcend = cli_readint32 ( structs ) ; structs += 4 ; unpd = ucur = exe + src + srcend + 4 - szd ; if ( ! szd || ! CLI_ISCONTAINED ( exe , exesz , unpd , szd ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Compressed<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; break ; } cli_dbgmsg ( ""WWP:<S2SV_blank>src:<S2SV_blank>%x,<S2SV_blank>szd:<S2SV_blank>%x,<S2SV_blank>srcend:<S2SV_blank>%x<S2SV_blank>-<S2SV_blank>%x\\n"" , src , szd , srcend , srcend + 4 - szd ) ; if ( ! ( compd = cli_malloc ( szd ) ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>compd\\n"" ) ; break ; } memcpy ( compd , unpd , szd ) ; memset ( unpd , - 1 , szd ) ; ccur = compd ; RESEED ; while ( ! error ) { uint32_t backbytes , backsize ; uint8_t saved ; BIT ; if ( ! bits ) { if ( ccur - compd >= szd || ! CLI_ISCONTAINED ( exe , exesz , ucur , 1 ) ) error = 1 ; else * ucur ++ = * ccur ++ ; continue ; } BITS ( 2 ) ; if ( bits == 3 ) { uint8_t shifted , subbed = 31 ; BITS ( 2 ) ; shifted = bits + 5 ; if ( bits >= 2 ) { shifted ++ ; subbed += 0x80 ; } backbytes = ( 1 << shifted ) - subbed ; BITS ( shifted ) ; if ( error || bits == 0x1ff ) break ; backbytes += bits ; if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , 2 ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , 2 ) ) { error = 1 ; } else { ucur [ 0 ] = * ( ucur - backbytes ) ; ucur [ 1 ] = * ( ucur - backbytes + 1 ) ; ucur += 2 ; } continue ; } saved = bits ; BITS ( 3 ) ; if ( bits < 6 ) { backbytes = bits ; switch ( bits ) { case 4 : backbytes ++ ; case 3 : BIT ; backbytes += bits ; case 0 : case 1 : case 2 : backbytes += 5 ; break ; case 5 : backbytes = 12 ; break ; } BITS ( backbytes ) ; bits += ( 1 << backbytes ) - 31 ; } else if ( bits == 6 ) { BITS ( 0x0e ) ; bits += 0x1fe1 ; } else { BITS ( 0x0f ) ; bits += 0x5fe1 ; } backbytes = bits ; if ( ! saved ) { BIT ; if ( ! bits ) { BIT ; bits += 5 ; } else { BITS ( 3 ) ; if ( bits ) { bits += 6 ; } else { BITS ( 4 ) ; if ( bits ) { bits += 13 ; } else { uint8_t cnt = 4 ; uint16_t shifted = 0x0d ; do { if ( cnt == 7 ) { cnt = 0x0e ; shifted = 0 ; break ; } shifted = ( ( shifted + 2 ) << 1 ) - 1 ; BIT ; cnt ++ ; } while ( ! bits ) ; BITS ( cnt ) ; bits += shifted ; } } } backsize = bits ; } else { backsize = saved + 2 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , backsize ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , backsize ) ) error = 1 ; else while ( backsize -- ) { * ucur = * ( ucur - backbytes ) ; ucur ++ ; } } free ( compd ) ; if ( error ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>decompression<S2SV_blank>error\\n"" ) ; break ; } if ( error || ! * structs ++ ) break ; } if ( ! error ) { if ( pe + 6 > exesz || pe + 7 > exesz || pe + 0x28 > exesz || pe + 0x50 > exesz || pe + 0x14 > exesz ) return CL_EFORMAT ; exe [ pe + 6 ] = ( uint8_t ) scount ; exe [ pe + 7 ] = ( uint8_t ) ( scount >> 8 ) ; <S2SV_StartBug> cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ; <S2SV_EndBug> cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ; structs = & exe [ ( 0xffff & cli_readint32 ( & exe [ pe + 0x14 ] ) ) + pe + 0x18 ] ; for ( i = 0 ; i < scount ; i ++ ) { if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return CL_EFORMAT ; } cli_writeint32 ( structs + 8 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 12 , sects [ i ] . rva ) ; cli_writeint32 ( structs + 16 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 20 , sects [ i ] . rva ) ; structs += 0x28 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return CL_EFORMAT ; } memset ( structs , 0 , 0x28 ) ; error = ( uint32_t ) cli_writen ( desc , exe , exesz ) != exesz ; } return error ; }","<S2SV_ModStart> 8 ) ; if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n"" ) ; return CL_EFORMAT ; }"
596,"CWE-119 static TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 ( VAR_1 ) * VAR_2 , TYPE_3 VAR_3 ) { const TYPE_4 * VAR_4 = """" ; const TYPE_5 * VAR_5 = """" ; TYPE_6 * VAR_6 = VAR_7 ; TYPE_7 ( VAR_8 ) * VAR_9 = VAR_10 ; TYPE_8 VAR_11 [ sizeof ( TYPE_9 ( VAR_12 ) ) ] = { 0 } ; TYPE_10 * VAR_13 ; TYPE_11 VAR_14 , VAR_15 ; if ( VAR_16 -> VAR_17 > VAR_18 -> VAR_19 . VAR_20 ) { return VAR_21 ; } VAR_22 = & VAR_23 -> VAR_24 [ VAR_25 -> VAR_26 ] ; <S2SV_StartBug> if ( VAR_27 -> VAR_28 < 1 ) { <S2SV_EndBug> return VAR_29 ; } TYPE_12 ( VAR_30 ) * VAR_31 = METHOD_1 ( VAR_32 -> VAR_33 , sizeof ( TYPE_13 ) ) ; if ( ! VAR_34 ) { return VAR_35 ; } if ( VAR_36 -> VAR_37 && VAR_38 -> VAR_39 < VAR_40 -> VAR_41 ) { VAR_42 = & VAR_43 -> VAR_44 [ VAR_45 -> VAR_46 ] ; } if ( VAR_47 && VAR_48 -> VAR_49 && VAR_50 -> VAR_51 < VAR_52 -> VAR_53 ) { VAR_54 = & VAR_55 -> VAR_56 [ VAR_57 -> VAR_58 ] ; } if ( ! VAR_59 ) { METHOD_2 ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return VAR_60 ; } VAR_61 = METHOD_3 ( ) ; VAR_62 = ( TYPE_14 * ) VAR_63 + VAR_64 -> VAR_65 ; METHOD_4 ( VAR_66 , ""section_name"" , VAR_67 , 0 ) ; METHOD_5 ( VAR_68 , ""entries"" , VAR_69 -> VAR_70 , 0 ) ; METHOD_6 ( VAR_71 , ""addr"" , VAR_72 -> VAR_73 , 0 ) ; METHOD_7 ( VAR_74 , ""offset"" , VAR_75 -> VAR_76 , 0 ) ; METHOD_8 ( VAR_77 , ""link"" , VAR_78 -> VAR_79 , 0 ) ; METHOD_9 ( VAR_80 , ""link_section_name"" , VAR_81 , 0 ) ; for ( VAR_82 = 0 , VAR_83 = 0 ; VAR_84 >= 0 && VAR_85 < VAR_86 -> VAR_87 && ( ( TYPE_15 * ) VAR_88 + VAR_89 < VAR_90 ) ; ++ VAR_91 ) { TYPE_16 * VAR_92 = METHOD_10 ( ) ; TYPE_17 * VAR_93 = ( ( TYPE_18 * ) VAR_94 ) + VAR_95 ; TYPE_19 VAR_96 [ 32 ] = { 0 } ; TYPE_20 ( VAR_97 ) * VAR_98 = ( TYPE_21 ( VAR_99 ) * ) VAR_100 ; TYPE_22 ( TYPE_23 ) VAR_101 = { 0 } ; TYPE_24 VAR_102 = 0 ; TYPE_25 VAR_103 = 0 ; METHOD_11 ( VAR_104 -> VAR_105 , VAR_106 -> VAR_107 + VAR_108 , VAR_109 , sizeof ( TYPE_26 ( VAR_110 ) ) ) ; VAR_111 -> VAR_112 = METHOD_12 ( VAR_113 , VAR_114 ) VAR_115 -> VAR_116 = METHOD_13 ( VAR_117 , VAR_118 ) VAR_119 -> VAR_120 = METHOD_14 ( VAR_121 , VAR_122 ) VAR_123 -> VAR_124 = METHOD_15 ( VAR_125 , VAR_126 ) VAR_127 -> VAR_128 = METHOD_16 ( VAR_129 , VAR_130 ) VAR_131 -> VAR_132 = METHOD_17 ( VAR_133 , VAR_134 ) VAR_135 -> VAR_136 = METHOD_18 ( VAR_137 , VAR_138 ) TYPE_27 VAR_139 = VAR_140 -> VAR_141 ; if ( VAR_142 < 1 ) { METHOD_19 ( VAR_143 ) ; goto VAR_144 ; } VAR_145 += VAR_146 ; if ( VAR_147 > VAR_148 || VAR_149 + sizeof ( TYPE_28 ( TYPE_29 ) ) > VAR_150 ) { METHOD_20 ( VAR_151 ) ; goto VAR_152 ; } VAR_153 = 0 ; VAR_154 . VAR_155 = METHOD_21 ( VAR_156 , VAR_157 ) VAR_158 . VAR_159 = METHOD_22 ( VAR_160 , VAR_161 ) VAR_162 = VAR_163 + VAR_164 -> VAR_165 ; if ( VAR_166 . VAR_167 > VAR_168 -> VAR_169 ) { METHOD_23 ( VAR_170 ) ; goto VAR_171 ; } METHOD_24 ( VAR_172 , ""idx"" , VAR_173 , 0 ) ; METHOD_25 ( VAR_174 , ""vd_version"" , VAR_175 -> VAR_176 , 0 ) ; METHOD_26 ( VAR_177 , ""vd_ndx"" , VAR_178 -> VAR_179 , 0 ) ; METHOD_27 ( VAR_180 , ""vd_cnt"" , VAR_181 -> VAR_182 , 0 ) ; METHOD_28 ( VAR_183 , ""vda_name"" , & VAR_184 -> VAR_185 [ VAR_186 . VAR_187 ] , 0 ) ; METHOD_29 ( VAR_188 , ""flags"" , METHOD_30 ( VAR_189 -> VAR_190 ) , 0 ) ; for ( VAR_191 = 1 ; VAR_192 < VAR_193 -> VAR_194 ; ++ VAR_195 ) { TYPE_30 VAR_196 ; TYPE_31 * VAR_197 = METHOD_31 ( ) ; VAR_198 += VAR_199 . VAR_200 ; VAR_201 += VAR_202 . VAR_203 ; if ( VAR_204 > VAR_205 || VAR_206 + sizeof ( TYPE_32 ( TYPE_33 ) ) > VAR_207 ) { METHOD_32 ( VAR_208 ) ; METHOD_33 ( VAR_209 ) ; goto VAR_210 ; } VAR_211 = 0 ; VAR_212 . VAR_213 = METHOD_34 ( VAR_214 , VAR_215 ) VAR_216 . VAR_217 = METHOD_35 ( VAR_218 , VAR_219 ) if ( VAR_220 . VAR_221 > VAR_222 -> VAR_223 ) { METHOD_36 ( VAR_224 ) ; METHOD_37 ( VAR_225 ) ; goto VAR_226 ; } METHOD_38 ( VAR_227 , ""idx"" , VAR_228 , 0 ) ; METHOD_39 ( VAR_229 , ""parent"" , VAR_230 , 0 ) ; METHOD_40 ( VAR_231 , ""vda_name"" , & VAR_232 -> VAR_233 [ VAR_234 . VAR_235 ] , 0 ) ; METHOD_41 ( VAR_236 , sizeof ( VAR_237 ) , ""parent%d"" , VAR_238 - 1 ) ; METHOD_42 ( VAR_239 , VAR_240 , VAR_241 ) ; } METHOD_43 ( VAR_242 , sizeof ( VAR_243 ) , ""verdef%d"" , VAR_244 ) ; METHOD_44 ( VAR_245 , VAR_246 , VAR_247 ) ; if ( ! VAR_248 -> VAR_249 ) { METHOD_45 ( VAR_250 ) ; goto VAR_251 ; } if ( ( TYPE_34 ) VAR_252 -> VAR_253 < 1 ) { METHOD_46 ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } VAR_254 += VAR_255 -> VAR_256 ; } METHOD_47 ( VAR_257 ) ; return VAR_258 ; VAR_259 : METHOD_48 ( VAR_260 ) ; METHOD_49 ( VAR_261 ) ; return VAR_262 ; }",<S2SV_ModStart> VAR_65 < 1 || VAR_106 -> VAR_65 > VAR_263,"CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }",<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
597,"CWE-310 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , const unsigned TYPE_2 * VAR_1 , TYPE_3 VAR_2 , const unsigned TYPE_4 * VAR_3 , TYPE_5 VAR_4 , TYPE_6 * VAR_5 ) { VAR_6 * VAR_7 ; <S2SV_StartBug> TYPE_7 VAR_8 = - 1 ; <S2SV_EndBug> VAR_9 = METHOD_1 ( ) ; if ( VAR_10 == VAR_11 ) return ( VAR_12 ) ; <S2SV_StartBug> if ( METHOD_2 ( & VAR_13 , & VAR_14 , VAR_15 ) == VAR_16 ) goto VAR_17 ; <S2SV_EndBug> VAR_18 = METHOD_3 ( VAR_19 , VAR_20 , VAR_21 , VAR_22 ) ; VAR_23 : <S2SV_StartBug> METHOD_4 ( VAR_24 ) ; <S2SV_EndBug> return ( VAR_25 ) ; }","<S2SV_ModStart> * VAR_24 ; const unsigned TYPE_4 * VAR_26 = VAR_14 ; unsigned TYPE_4 * VAR_27 = VAR_16 ; TYPE_7 VAR_28 = - 1 ; <S2SV_ModStart> VAR_24 , & VAR_26 <S2SV_ModEnd> , VAR_15 ) <S2SV_ModStart> == VAR_16 ) goto VAR_23 ; VAR_28 = METHOD_5 ( VAR_24 , & VAR_27 ) ; if ( VAR_28 != VAR_15 || METHOD_6 ( VAR_14 , VAR_27 , VAR_28 ) ) <S2SV_ModStart> ; VAR_23 : if ( VAR_28 > 0 ) { METHOD_7 ( VAR_27 , VAR_28 ) ; METHOD_8 ( VAR_27 ) ; }","CWE-310 int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) { ECDSA_SIG * s ; <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> s = ECDSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ; err : <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> return ( ret ) ; }","<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }"
598,"CWE-400 static enum VAR_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { struct STRUCT_OR_UNION_2 * * VAR_3 = VAR_4 ; struct STRUCT_OR_UNION_3 * VAR_5 ; TYPE_0 VAR_6 = VAR_7 -> VAR_8 ; struct STRUCT_OR_UNION_4 * VAR_9 = & VAR_10 ; TYPE_1 VAR_11 ; enum VAR_12 VAR_13 ; TYPE_2 VAR_14 ; if ( ! ( VAR_15 -> VAR_16 -> VAR_17 & VAR_18 ) ) goto VAR_19 ; if ( METHOD_1 ( VAR_20 ) || METHOD_2 ( VAR_21 ) || VAR_22 -> VAR_23 ) goto VAR_24 ; METHOD_3 ( VAR_25 , VAR_26 ) ; METHOD_4 ( ) ; METHOD_5 ( VAR_27 , VAR_28 , VAR_29 ) { if ( VAR_30 -> VAR_31 != VAR_32 || ! VAR_33 -> VAR_34 . METHOD_6 ) continue ; METHOD_7 ( VAR_35 , METHOD_8 ( VAR_36 ) ) ; METHOD_9 ( VAR_37 ) ; METHOD_10 ( VAR_38 ) -> VAR_39 = 0 ; METHOD_11 ( VAR_40 ) -> VAR_41 = 0 ; METHOD_12 ( VAR_42 ) -> VAR_43 = 0 ; <S2SV_StartBug> METHOD_13 ( VAR_44 ) -> VAR_45 = 0 ; <S2SV_EndBug> METHOD_14 ( VAR_46 ) -> VAR_47 = 0 ; switch ( VAR_48 -> VAR_49 ) { case VAR_50 : METHOD_15 ( VAR_51 ) -> VAR_52 = VAR_53 -> VAR_54 ; METHOD_16 ( VAR_55 ) -> VAR_56 = 1 ; METHOD_17 ( VAR_57 ) -> VAR_58 = 0 ; break ; case VAR_59 : METHOD_18 ( VAR_60 ) -> VAR_61 = VAR_62 -> VAR_63 + 1 ; METHOD_19 ( VAR_64 ) -> VAR_65 = 0 ; break ; default : METHOD_20 ( VAR_66 ) -> VAR_67 = 0 ; METHOD_21 ( VAR_68 ) -> VAR_69 = 0 ; } VAR_70 = VAR_71 -> VAR_72 . METHOD_22 ( & VAR_73 -> VAR_74 , VAR_75 ) ; break ; } METHOD_23 ( ) ; if ( & VAR_76 -> VAR_77 == VAR_78 ) goto VAR_79 ; VAR_80 = METHOD_24 ( VAR_81 ) -> VAR_82 ; VAR_83 = METHOD_25 ( VAR_84 ) -> VAR_85 ? VAR_86 : VAR_87 ; if ( VAR_88 ) { struct STRUCT_OR_UNION_5 * VAR_89 = * VAR_90 ; * VAR_91 = VAR_92 -> VAR_93 ; VAR_94 -> VAR_95 = VAR_96 ; METHOD_26 ( VAR_97 ) ; VAR_98 -> VAR_99 -- ; } if ( VAR_100 ) goto VAR_101 ; if ( METHOD_27 ( VAR_102 ) -> VAR_103 ) goto VAR_104 ; if ( METHOD_28 ( VAR_105 -> VAR_106 >= VAR_107 ) ) { struct STRUCT_OR_UNION_6 * VAR_108 = VAR_109 -> VAR_110 ; while ( VAR_111 -> VAR_112 ) { VAR_113 = & VAR_114 -> VAR_115 ; VAR_116 = * VAR_117 ; } * VAR_118 = VAR_119 ; VAR_120 -> VAR_121 = VAR_122 ; METHOD_29 ( VAR_123 ) ; } else { VAR_124 -> VAR_125 ++ ; } METHOD_30 ( VAR_126 ) -> VAR_127 = 1 ; METHOD_31 ( VAR_128 ) -> VAR_129 = VAR_130 ; METHOD_32 ( VAR_131 ) -> VAR_132 = VAR_133 ; METHOD_33 ( VAR_134 ) -> VAR_135 = METHOD_34 ( VAR_136 ) ; VAR_137 -> VAR_138 = VAR_139 -> VAR_140 ; VAR_141 -> VAR_142 = VAR_143 ; VAR_144 = VAR_145 ; VAR_146 : VAR_147 = METHOD_35 ( VAR_148 ) - METHOD_36 ( VAR_149 ) ; if ( VAR_150 > 0 ) METHOD_37 ( VAR_151 , VAR_152 ) ; VAR_153 : return VAR_154 ; VAR_155 : VAR_156 = VAR_157 ; goto VAR_158 ; }",<S2SV_ModStart> VAR_151 ) -> VAR_159 <S2SV_ModEnd> = 0 ;,"CWE-400 static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; } pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; break ; } rcu_read_unlock ( ) ; if ( & ptype -> list == head ) goto normal ; same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; if ( pp ) { struct sk_buff * nskb = * pp ; * pp = nskb -> next ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; napi -> gro_count -- ; } if ( same_flow ) goto ok ; if ( NAPI_GRO_CB ( skb ) -> flush ) goto normal ; if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { struct sk_buff * nskb = napi -> gro_list ; while ( nskb -> next ) { pp = & nskb -> next ; nskb = * pp ; } * pp = NULL ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; } else { napi -> gro_count ++ ; } NAPI_GRO_CB ( skb ) -> count = 1 ; NAPI_GRO_CB ( skb ) -> age = jiffies ; NAPI_GRO_CB ( skb ) -> last = skb ; skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; skb -> next = napi -> gro_list ; napi -> gro_list = skb ; ret = GRO_HELD ; pull : grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; if ( grow > 0 ) gro_pull_from_frag0 ( skb , grow ) ; ok : return ret ; normal : ret = GRO_NORMAL ; goto pull ; }",<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 0 ;
599,"CWE-19 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_1 , struct STRUCT_OR_UNION_3 * VAR_2 METHOD_1 { struct STRUCT_OR_UNION_4 * VAR_3 = STRUCT_OR_UNION_5 -> VAR_4 ; struct STRUCT_OR_UNION_6 * VAR_5 = VAR_6 ; struct STRUCT_OR_UNION_7 * VAR_7 = & VAR_8 -> VAR_9 ; <S2SV_StartBug> struct STRUCT_OR_UNION_8 * VAR_10 = VAR_11 ; <S2SV_EndBug> TYPE_2 VAR_12 = 0 ; <S2SV_StartBug> struct STRUCT_OR_UNION_9 * VAR_13 = METHOD_2 ( STRUCT_OR_UNION_10 METHOD_3 ; <S2SV_EndBug> METHOD_4 ( VAR_14 METHOD_5 ( ( struct STRUCT_OR_UNION_11 * METHOD_6 ( VAR_15 METHOD_7 METHOD_8 if ( VAR_16 -> VAR_17 && VAR_18 -> VAR_19 > VAR_20 -> VAR_21 METHOD_9 return - VAR_22 ; if ( VAR_23 -> VAR_24 METHOD_10 { <S2SV_StartBug> VAR_25 = METHOD_11 ( VAR_26 , VAR_27 -> VAR_28 -> VAR_29 , <S2SV_EndBug> VAR_30 -> VAR_31 -> VAR_32 METHOD_12 ; METHOD_13 ( VAR_33 -> VAR_34 , ""get_write_access"" METHOD_14 ; VAR_35 = METHOD_15 ( VAR_36 , VAR_37 -> VAR_38 METHOD_16 ; if ( VAR_39 METHOD_17 goto VAR_40 ; METHOD_18 ( VAR_41 -> VAR_42 METHOD_19 ; if ( METHOD_20 ( VAR_43 -> VAR_44 METHOD_21 -> VAR_45 == METHOD_22 ( 1 METHOD_23 METHOD_24 { <S2SV_StartBug> if ( VAR_46 METHOD_25 { <S2SV_EndBug> METHOD_26 ( VAR_47 METHOD_27 ; VAR_48 = VAR_49 ; } METHOD_28 ( VAR_50 -> VAR_51 , ""modifying<S2SV_blank>in-place"" METHOD_29 ; VAR_52 = METHOD_30 ( VAR_53 , VAR_54 METHOD_31 ; if ( ! VAR_55 METHOD_32 { if ( ! METHOD_33 ( VAR_56 -> VAR_57 METHOD_34 METHOD_35 METHOD_36 ( METHOD_37 ( VAR_58 -> VAR_59 METHOD_38 , VAR_60 -> VAR_61 METHOD_39 ; METHOD_40 ( VAR_62 , VAR_63 -> VAR_64 METHOD_41 ; } METHOD_42 ( VAR_65 -> VAR_66 METHOD_43 ; if ( VAR_67 == - VAR_68 METHOD_44 goto VAR_69 ; if ( ! VAR_70 METHOD_45 VAR_71 = METHOD_46 ( VAR_72 , STRUCT_OR_UNION_12 , VAR_73 -> VAR_74 METHOD_47 ; if ( VAR_75 METHOD_48 goto VAR_76 ; goto VAR_77 ; } else { TYPE_3 VAR_78 = ( TYPE_4 * METHOD_49 VAR_79 -> VAR_80 - VAR_81 -> VAR_82 -> VAR_83 ; METHOD_50 ( VAR_84 -> VAR_85 METHOD_51 ; <S2SV_StartBug> if ( VAR_86 METHOD_52 { <S2SV_EndBug> METHOD_53 ( VAR_87 METHOD_54 ; VAR_88 = VAR_89 ; } METHOD_55 ( VAR_90 -> VAR_91 , ""cloning"" METHOD_56 ; VAR_92 -> VAR_93 = METHOD_57 ( VAR_94 -> VAR_95 -> VAR_96 , VAR_97 METHOD_58 ; VAR_98 = - VAR_99 ; if ( VAR_100 -> VAR_101 == VAR_102 METHOD_59 goto VAR_103 ; METHOD_60 ( VAR_104 -> VAR_105 , METHOD_61 ( VAR_106 -> VAR_107 METHOD_62 , VAR_108 -> VAR_109 -> VAR_110 METHOD_63 ; VAR_111 -> VAR_112 = METHOD_64 ( METHOD_65 ( VAR_113 -> VAR_114 METHOD_66 + 1 METHOD_67 ; METHOD_68 ( VAR_115 -> VAR_116 METHOD_69 -> VAR_117 = METHOD_70 ( 1 METHOD_71 ; VAR_118 -> VAR_119 = METHOD_72 ( VAR_120 -> VAR_121 + VAR_122 METHOD_73 ; VAR_123 -> VAR_124 = VAR_125 -> VAR_126 + VAR_127 -> VAR_128 -> VAR_129 ; } } else { VAR_130 -> VAR_131 = METHOD_74 ( VAR_132 -> VAR_133 , VAR_134 METHOD_75 ; VAR_135 = - VAR_136 ; if ( VAR_137 -> VAR_138 == VAR_139 METHOD_76 goto VAR_140 ; METHOD_77 ( VAR_141 -> VAR_142 METHOD_78 -> VAR_143 = METHOD_79 ( VAR_144 METHOD_80 ; METHOD_81 ( VAR_145 -> VAR_146 METHOD_82 -> VAR_147 = METHOD_83 ( 1 METHOD_84 ; METHOD_85 ( VAR_148 -> VAR_149 METHOD_86 -> VAR_150 = METHOD_87 ( 1 METHOD_88 ; VAR_151 -> VAR_152 = METHOD_89 ( METHOD_90 ( VAR_153 -> VAR_154 METHOD_91 + 1 METHOD_92 ; VAR_155 -> VAR_156 = METHOD_93 ( METHOD_94 ( VAR_157 -> VAR_158 METHOD_95 + 1 METHOD_96 ; VAR_159 -> VAR_160 = VAR_161 -> VAR_162 + VAR_163 -> VAR_164 ; } VAR_165 = METHOD_97 ( VAR_166 , VAR_167 METHOD_98 ; if ( VAR_168 == - VAR_169 METHOD_99 goto VAR_170 ; if ( VAR_171 METHOD_100 goto VAR_172 ; if ( ! METHOD_101 ( VAR_173 -> VAR_174 METHOD_102 METHOD_103 METHOD_104 ( METHOD_105 ( VAR_175 -> VAR_176 METHOD_106 , VAR_177 -> VAR_178 METHOD_107 ; VAR_179 : if ( ! METHOD_108 ( VAR_180 -> VAR_181 METHOD_109 METHOD_110 { VAR_182 = METHOD_111 ( STRUCT_OR_UNION_13 , METHOD_112 ( VAR_183 -> VAR_184 METHOD_113 , & VAR_185 METHOD_114 ; if ( VAR_186 METHOD_115 { if ( VAR_187 == VAR_188 -> VAR_189 METHOD_116 METHOD_117 ( VAR_190 , ""keeping"" METHOD_118 ; else { VAR_191 = METHOD_119 ( STRUCT_OR_UNION_14 , METHOD_120 ( METHOD_121 ( VAR_192 METHOD_122 , 1 METHOD_123 METHOD_124 ; if ( VAR_193 METHOD_125 goto VAR_194 ; METHOD_126 ( VAR_195 , ""get_write_access"" METHOD_127 ; VAR_196 = METHOD_128 ( VAR_197 , VAR_198 METHOD_129 ; if ( VAR_199 METHOD_130 goto VAR_200 ; METHOD_131 ( VAR_201 METHOD_132 ; <S2SV_StartBug> METHOD_133 ( & METHOD_134 ( VAR_202 METHOD_135 -> VAR_203 , 1 METHOD_136 ; <S2SV_EndBug> METHOD_137 ( VAR_204 , ""reusing;<S2SV_blank>refcount<S2SV_blank>now=%d"" , METHOD_138 ( METHOD_139 ( VAR_205 METHOD_140 -> VAR_206 METHOD_141 METHOD_142 ; METHOD_143 ( VAR_207 METHOD_144 ; VAR_208 = METHOD_145 ( VAR_209 , STRUCT_OR_UNION_15 , VAR_210 METHOD_146 ; if ( VAR_211 METHOD_147 goto VAR_212 ; } <S2SV_StartBug> METHOD_148 ( VAR_213 METHOD_149 ; <S2SV_EndBug> VAR_214 = VAR_215 ; } else if ( VAR_216 -> VAR_217 && VAR_218 -> VAR_219 == VAR_220 -> VAR_221 -> VAR_222 METHOD_150 { METHOD_151 ( VAR_223 -> VAR_224 , ""keeping<S2SV_blank>this<S2SV_blank>block"" METHOD_152 ; VAR_225 = VAR_226 -> VAR_227 ; METHOD_153 ( VAR_228 METHOD_154 ; } else { TYPE_5 VAR_229 , VAR_230 ; VAR_231 = METHOD_155 ( VAR_232 , METHOD_156 ( STRUCT_OR_UNION_16 METHOD_157 -> VAR_233 METHOD_158 ; if ( ! ( METHOD_159 ( STRUCT_OR_UNION_17 , VAR_234 METHOD_160 METHOD_161 METHOD_162 VAR_235 = VAR_236 & VAR_237 ; VAR_238 = METHOD_163 ( VAR_239 , STRUCT_OR_UNION_18 , VAR_240 , 0 , VAR_241 , & VAR_242 METHOD_164 ; if ( VAR_243 METHOD_165 goto VAR_244 ; if ( ! ( METHOD_166 ( STRUCT_OR_UNION_19 , VAR_245 METHOD_167 METHOD_168 METHOD_169 METHOD_170 ( VAR_246 > VAR_247 METHOD_171 ; METHOD_172 ( STRUCT_OR_UNION_20 , ""creating<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned TYPE_6 TYPE_7 METHOD_173 VAR_248 METHOD_174 ; VAR_249 = METHOD_175 ( VAR_250 , VAR_251 METHOD_176 ; if ( METHOD_177 ( ! VAR_252 METHOD_178 METHOD_179 { VAR_253 = - VAR_254 ; VAR_255 : METHOD_180 ( VAR_256 , STRUCT_OR_UNION_21 , VAR_257 , VAR_258 , 1 , VAR_259 METHOD_181 ; goto VAR_260 ; } METHOD_182 ( VAR_261 METHOD_183 ; VAR_262 = METHOD_184 ( VAR_263 , VAR_264 METHOD_185 ; if ( VAR_265 METHOD_186 { METHOD_187 ( VAR_266 METHOD_188 ; VAR_267 = - VAR_268 ; goto VAR_269 ; } METHOD_189 ( VAR_270 -> VAR_271 , VAR_272 -> VAR_273 , VAR_274 -> VAR_275 METHOD_190 ; METHOD_191 ( VAR_276 METHOD_192 ; METHOD_193 ( VAR_277 METHOD_194 ; METHOD_195 ( VAR_278 , VAR_279 METHOD_196 ; VAR_280 = METHOD_197 ( VAR_281 , STRUCT_OR_UNION_22 , VAR_282 METHOD_198 ; if ( VAR_283 METHOD_199 goto VAR_284 ; } } METHOD_200 ( STRUCT_OR_UNION_23 METHOD_201 -> VAR_285 = VAR_286 ? VAR_287 -> VAR_288 : 0 ; if ( VAR_289 -> VAR_290 && VAR_291 -> VAR_292 != VAR_293 METHOD_202 METHOD_203 ( VAR_294 , STRUCT_OR_UNION_24 , VAR_295 -> VAR_296 METHOD_204 ; VAR_297 = 0 ; VAR_298 : if ( VAR_299 METHOD_205 <S2SV_StartBug> METHOD_206 ( VAR_300 METHOD_207 ; <S2SV_EndBug> METHOD_208 ( VAR_301 METHOD_209 ; if ( ! ( VAR_302 -> VAR_303 && VAR_304 -> VAR_305 == VAR_306 -> VAR_307 -> VAR_308 METHOD_210 METHOD_211 METHOD_212 ( VAR_309 -> VAR_310 METHOD_213 ; return VAR_311 ; VAR_312 : METHOD_214 ( STRUCT_OR_UNION_25 , METHOD_215 ( METHOD_216 ( VAR_313 METHOD_217 , 1 METHOD_218 METHOD_219 ; goto VAR_314 ; VAR_315 : METHOD_220 ( STRUCT_OR_UNION_26 , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , METHOD_221 ( STRUCT_OR_UNION_27 METHOD_222 -> VAR_316 METHOD_223 ; goto VAR_317 ; METHOD_224 }","<S2SV_ModStart> VAR_309 ; struct STRUCT_OR_UNION_28 <S2SV_ModEnd> * VAR_300 = <S2SV_ModStart> 0 ; struct STRUCT_OR_UNION_29 <S2SV_ModEnd> * VAR_278 = <S2SV_ModStart> VAR_310 METHOD_223 { <S2SV_ModEnd> METHOD_126 ( VAR_306 <S2SV_ModStart> METHOD_223 METHOD_223 { TYPE_8 VAR_318 = METHOD_138 ( METHOD_139 ( VAR_306 -> VAR_307 METHOD_223 -> VAR_319 METHOD_223 ; METHOD_225 ( VAR_278 , VAR_318 , VAR_306 -> VAR_307 -> VAR_288 METHOD_223 ; <S2SV_ModEnd> METHOD_151 ( VAR_306 <S2SV_ModStart> VAR_307 METHOD_223 ; <S2SV_ModEnd> METHOD_151 ( VAR_306 <S2SV_ModStart> VAR_301 METHOD_223 ; if ( METHOD_226 ( & VAR_300 -> VAR_320 METHOD_223 METHOD_223 { METHOD_193 ( VAR_301 METHOD_223 ; METHOD_214 ( STRUCT_OR_UNION_27 , METHOD_215 ( METHOD_216 ( VAR_313 METHOD_223 , 1 METHOD_223 METHOD_223 ; METHOD_208 ( VAR_301 METHOD_223 ; METHOD_227 ( VAR_278 , VAR_300 METHOD_223 ; VAR_300 = VAR_257 ; VAR_301 = VAR_257 ; goto VAR_179 ; } <S2SV_ModStart> VAR_312 ; } METHOD_228 ( VAR_278 , VAR_300 METHOD_223 ; METHOD_227 ( VAR_278 , <S2SV_ModEnd> VAR_300 METHOD_223 ; <S2SV_ModStart> ( VAR_300 METHOD_223 METHOD_227 ( VAR_278 , <S2SV_ModEnd> VAR_300 METHOD_223 ;","CWE-19 static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ; <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug>   header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) { <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""modifying<S2SV_blank>in-place"" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; } unlock_buffer ( bs -> bh ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ; if ( error ) goto cleanup ; goto inserted ; } else { int offset = ( char * ) s -> here - bs -> bh -> b_data ; unlock_buffer ( bs -> bh ) ; <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> mb_cache_entry_release ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""cloning"" ) ; s -> base = kmalloc ( bs -> bh -> b_size , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; memcpy ( s -> base , BHDR ( bs -> bh ) , bs -> bh -> b_size ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> here = ENTRY ( s -> base + offset ) ; s -> end = s -> base + bs -> bh -> b_size ; } } else { s -> base = kzalloc ( sb -> s_blocksize , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; header ( s -> base ) -> h_magic = cpu_to_le32 ( EXT4_XATTR_MAGIC ) ; header ( s -> base ) -> h_blocks = cpu_to_le32 ( 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; s -> here = ENTRY ( header ( s -> base ) + 1 ) ; s -> end = s -> base + sb -> s_blocksize ; } error = ext4_xattr_set_entry ( i , s ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; inserted : if ( ! IS_LAST_ENTRY ( s -> first ) ) { new_bh = ext4_xattr_cache_find ( inode , header ( s -> base ) , & ce ) ; if ( new_bh ) { if ( new_bh == bs -> bh ) ea_bdebug ( new_bh , ""keeping"" ) ; else { error = dquot_alloc_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; if ( error ) goto cleanup ; BUFFER_TRACE ( new_bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , new_bh ) ; if ( error ) goto cleanup_dquot ; lock_buffer ( new_bh ) ; <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> ea_bdebug ( new_bh , ""reusing;<S2SV_blank>refcount<S2SV_blank>now=%d"" , le32_to_cpu ( BHDR ( new_bh ) -> h_refcount ) ) ; unlock_buffer ( new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup_dquot ; } <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ce = NULL ; } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) { ea_bdebug ( bs -> bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; new_bh = bs -> bh ; get_bh ( new_bh ) ; } else { ext4_fsblk_t goal , block ; goal = ext4_group_first_block_no ( sb , EXT4_I ( inode ) -> i_block_group ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) goal = goal & EXT4_MAX_BLOCK_FILE_PHYS ; block = ext4_new_meta_blocks ( handle , inode , goal , 0 , NULL , & error ) ; if ( error ) goto cleanup ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) BUG_ON ( block > EXT4_MAX_BLOCK_FILE_PHYS ) ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { error = - ENOMEM ; getblk_failed : ext4_free_blocks ( handle , inode , NULL , block , 1 , EXT4_FREE_BLOCKS_METADATA ) ; goto cleanup ; } lock_buffer ( new_bh ) ; error = ext4_journal_get_create_access ( handle , new_bh ) ; if ( error ) { unlock_buffer ( new_bh ) ; error = - EIO ; goto getblk_failed ; } memcpy ( new_bh -> b_data , s -> base , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext4_xattr_cache_insert ( ext4_mb_cache , new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup ; } } EXT4_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; if ( bs -> bh && bs -> bh != new_bh ) ext4_xattr_release_block ( handle , inode , bs -> bh ) ; error = 0 ; cleanup : if ( ce ) <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> brelse ( new_bh ) ; if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree ( s -> base ) ; return error ; cleanup_dquot : dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; goto cleanup ; bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; goto cleanup ;   header }","<S2SV_ModStart> s ; struct mb2_cache_entry <S2SV_ModEnd> * ce = <S2SV_ModStart> 0 ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = <S2SV_ModStart> base ) { <S2SV_ModEnd> BUFFER_TRACE ( bs <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> ea_bdebug ( bs <S2SV_ModStart> bh ) ; <S2SV_ModEnd> ea_bdebug ( bs <S2SV_ModStart> new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; <S2SV_ModStart> ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ;"
600,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( ) { <S2SV_EndBug> METHOD_1 ( VAR_0 , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , VAR_1 ) ; METHOD_2 ( VAR_2 ) ; }",<S2SV_ModStart> TYPE_0 METHOD_0 ( TYPE_0,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",<S2SV_ModStart> void usage_exit ( void
601,"CWE-287 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { <S2SV_EndBug> TYPE_2 * VAR_1 = METHOD_1 ( VAR_2 -> VAR_3 -> VAR_4 , & VAR_5 ) ; if ( VAR_6 -> VAR_7 != 0 ) { METHOD_2 ( VAR_8 , VAR_9 , METHOD_3 ( VAR_10 ) ) ; if ( ( METHOD_4 ( VAR_11 -> VAR_12 , VAR_13 ) != VAR_14 -> VAR_15 ) ) { METHOD_5 ( VAR_16 , VAR_17 -> VAR_18 , VAR_19 ) ; } } }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> TYPE_0 METHOD_0 (,"CWE-287 <S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }",<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (
602,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = VAR_2 -> VAR_3 -> VAR_4 ; TYPE_3 VAR_5 = VAR_6 -> VAR_7 -> VAR_8 ; TYPE_4 VAR_9 = VAR_10 -> VAR_11 -> VAR_12 ; METHOD_1 ( VAR_13 > 4 ) ; TYPE_5 VAR_14 ; if ( VAR_15 < 4 ) { VAR_16 = METHOD_2 ( VAR_17 , VAR_18 + VAR_19 , 4 - VAR_20 ) ; if ( VAR_21 < 0 ) goto VAR_22 ; if ( VAR_23 ) { if ( VAR_24 > 0 ) METHOD_3 ( ""TPKT:<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket\\n"" , VAR_25 ) ; } VAR_26 += VAR_27 ; if ( VAR_28 == 4 ) { if ( ( VAR_29 [ 0 ] == 3 ) && ( VAR_30 [ 1 ] == 0 ) ) { VAR_31 -> VAR_32 = ( VAR_33 [ 2 ] * 0x100 ) + VAR_34 [ 3 ] ; if ( VAR_35 ) METHOD_4 ( ""TPKT:<S2SV_blank>header<S2SV_blank>complete<S2SV_blank>(msg<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%i)\\n"" , VAR_36 -> VAR_37 ) ; if ( VAR_38 -> VAR_39 > VAR_40 ) { if ( VAR_41 ) METHOD_5 ( ""TPKT:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto VAR_42 ; } } else { if ( VAR_43 ) METHOD_6 ( ""TPKT:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>TPKT<S2SV_blank>header.\\n"" ) ; goto VAR_44 ; } } else goto VAR_45 ; } <S2SV_StartBug> VAR_46 = METHOD_7 ( VAR_47 , VAR_48 + VAR_49 , VAR_50 -> VAR_51 - VAR_52 ) ; <S2SV_EndBug> if ( VAR_53 < 0 ) goto VAR_54 ; VAR_55 += VAR_56 ; if ( VAR_57 < VAR_58 -> VAR_59 ) goto VAR_60 ; if ( VAR_61 ) METHOD_8 ( ""TPKT:<S2SV_blank>message<S2SV_blank>complete<S2SV_blank>(size<S2SV_blank>=<S2SV_blank>%i)\\n"" , VAR_62 -> VAR_63 ) ; VAR_64 -> VAR_65 -> VAR_66 = VAR_67 ; return VAR_68 ; VAR_69 : if ( VAR_70 ) METHOD_9 ( ""TPKT:<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>socket<S2SV_blank>error\\n"" ) ; return VAR_71 ; VAR_72 : if ( VAR_73 ) METHOD_10 ( ""TPKT:<S2SV_blank>Error<S2SV_blank>parsing<S2SV_blank>message\\n"" ) ; return VAR_74 ; VAR_75 : if ( VAR_76 ) if ( VAR_77 != 0 ) METHOD_11 ( ""TPKT:<S2SV_blank>waiting<S2SV_blank>(read<S2SV_blank>%i<S2SV_blank>of<S2SV_blank>%i)\\n"" , VAR_78 , VAR_79 -> VAR_80 ) ; VAR_81 -> VAR_82 -> VAR_83 = VAR_84 ; return VAR_85 ; }",<S2SV_ModStart> VAR_75 ; } if ( VAR_81 -> VAR_80 <= VAR_84 ) goto VAR_72 ;,"CWE-119 TpktState CotpConnection_readToTpktBuffer ( CotpConnection * self ) { uint8_t * buffer = self -> readBuffer -> buffer ; int bufferSize = self -> readBuffer -> maxSize ; int bufPos = self -> readBuffer -> size ; assert ( bufferSize > 4 ) ; int readBytes ; if ( bufPos < 4 ) { readBytes = readFromSocket ( self , buffer + bufPos , 4 - bufPos ) ; if ( readBytes < 0 ) goto exit_closed ; if ( DEBUG_COTP ) { if ( readBytes > 0 ) printf ( ""TPKT:<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket\\n"" , readBytes ) ; } bufPos += readBytes ; if ( bufPos == 4 ) { if ( ( buffer [ 0 ] == 3 ) && ( buffer [ 1 ] == 0 ) ) { self -> packetSize = ( buffer [ 2 ] * 0x100 ) + buffer [ 3 ] ; if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>header<S2SV_blank>complete<S2SV_blank>(msg<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%i)\\n"" , self -> packetSize ) ; if ( self -> packetSize > bufferSize ) { if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto exit_error ; } } else { if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>TPKT<S2SV_blank>header.\\n"" ) ; goto exit_error ; } } else goto exit_waiting ; } <S2SV_StartBug> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <S2SV_EndBug> if ( readBytes < 0 ) goto exit_closed ; bufPos += readBytes ; if ( bufPos < self -> packetSize ) goto exit_waiting ; if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>message<S2SV_blank>complete<S2SV_blank>(size<S2SV_blank>=<S2SV_blank>%i)\\n"" , self -> packetSize ) ; self -> readBuffer -> size = bufPos ; return TPKT_PACKET_COMPLETE ; exit_closed : if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>socket<S2SV_blank>error\\n"" ) ; return TPKT_ERROR ; exit_error : if ( DEBUG_COTP ) printf ( ""TPKT:<S2SV_blank>Error<S2SV_blank>parsing<S2SV_blank>message\\n"" ) ; return TPKT_ERROR ; exit_waiting : if ( DEBUG_COTP ) if ( bufPos != 0 ) printf ( ""TPKT:<S2SV_blank>waiting<S2SV_blank>(read<S2SV_blank>%i<S2SV_blank>of<S2SV_blank>%i)\\n"" , bufPos , self -> packetSize ) ; self -> readBuffer -> size = bufPos ; return TPKT_WAITING ; }",<S2SV_ModStart> exit_waiting ; } if ( self -> packetSize <= bufPos ) goto exit_error ;
603,"CWE-416 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 ) { TYPE_2 VAR_2 ; <S2SV_StartBug> TYPE_3 VAR_3 ; <S2SV_EndBug> if ( VAR_4 -> VAR_5 == VAR_6 ) return ; VAR_7 = VAR_8 -> VAR_9 - VAR_10 -> VAR_11 ; if ( VAR_12 -> VAR_13 ) VAR_14 += VAR_15 -> VAR_16 -> VAR_17 ; if ( VAR_18 -> VAR_19 + VAR_20 > VAR_21 -> VAR_22 ) VAR_23 = VAR_24 -> VAR_25 - VAR_26 -> VAR_27 ; for ( VAR_28 = 0 ; VAR_29 < VAR_30 ; VAR_31 ++ ) { TYPE_4 VAR_32 = VAR_33 -> VAR_34 [ VAR_35 ] ; if ( ! METHOD_1 ( VAR_36 ) ) { <S2SV_StartBug> if ( METHOD_2 ( VAR_37 ) -> VAR_38 == VAR_39 ) { <S2SV_EndBug> VAR_40 -> VAR_41 [ VAR_42 ] = METHOD_3 ( ) ; } else { METHOD_4 ( VAR_43 , METHOD_5 ( VAR_44 ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }",<S2SV_ModStart> ; TYPE_3 VAR_30 ; TYPE_4 VAR_45 <S2SV_ModStart> ) ) { <S2SV_ModEnd> METHOD_4 ( VAR_43 <S2SV_ModStart> ; } } VAR_30 = VAR_40 -> VAR_25 - VAR_40 -> VAR_41 ; VAR_45 = METHOD_3 ( ) ; for ( ; VAR_42 < VAR_30 ; VAR_42 ++ ) { VAR_40 -> VAR_41 [ VAR_42 ] = VAR_45 ;,"CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }",<S2SV_ModStart> ; size_t e ; mrb_value nil <S2SV_ModStart> ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb <S2SV_ModStart> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
604,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { struct STRUCT_OR_UNION_3 * VAR_1 = STRUCT_OR_UNION_4 -> VAR_2 . VAR_3 [ 0 ] ; struct STRUCT_OR_UNION_5 * VAR_4 ; TYPE_1 * VAR_5 ; TYPE_2 * VAR_6 = VAR_7 ; const TYPE_3 * VAR_8 = VAR_9 ; TYPE_4 VAR_10 = VAR_11 -> VAR_12 ; TYPE_5 VAR_13 = 0 ; <S2SV_StartBug> if ( METHOD_1 ( VAR_14 , & STRUCT_OR_UNION_6 -> VAR_15 ) ) <S2SV_EndBug> return - VAR_16 ; if ( VAR_17 <= 0 || VAR_18 > 32767 || ! VAR_19 -> VAR_20 ) return - VAR_21 ; VAR_22 = METHOD_2 ( VAR_23 + 1 , VAR_24 ) ; if ( ! VAR_25 ) return - VAR_26 ; VAR_27 [ VAR_28 ] = 0 ; METHOD_3 ( VAR_29 , VAR_30 -> VAR_31 , VAR_32 ) ; VAR_33 = METHOD_4 ( VAR_34 , & VAR_35 , & VAR_36 , VAR_37 , VAR_38 ) ; if ( VAR_39 < 0 ) goto VAR_40 ; VAR_41 = METHOD_5 ( VAR_42 , VAR_43 -> VAR_44 ) ; if ( VAR_45 < 0 ) goto VAR_46 ; VAR_47 = METHOD_6 ( STRUCT_OR_UNION_7 , VAR_48 -> VAR_49 , VAR_50 , VAR_51 -> VAR_52 ) ; if ( METHOD_7 ( VAR_53 ) ) { VAR_54 = METHOD_8 ( VAR_55 ) ; goto VAR_56 ; } METHOD_9 ( VAR_57 , VAR_58 -> VAR_59 , VAR_60 , VAR_61 -> VAR_62 ) ; METHOD_10 ( VAR_63 -> VAR_64 , VAR_65 -> VAR_66 , VAR_67 ) ; METHOD_11 ( VAR_68 -> VAR_69 , VAR_70 -> VAR_71 , VAR_72 -> VAR_73 ) ; METHOD_12 ( STRUCT_OR_UNION_8 , VAR_74 ) ; METHOD_13 ( & VAR_75 -> VAR_76 , VAR_77 ) ; VAR_78 : METHOD_14 ( VAR_79 ) ; return VAR_80 ; }",<S2SV_ModStart> ; if ( METHOD_15 ( STRUCT_OR_UNION_8 <S2SV_ModEnd> ) ) return,"CWE-20 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kzfree ( buf ) ; return ret ; }",<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
605,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * * VAR_2 , TYPE_4 * VAR_3 ) { if ( VAR_4 -> VAR_5 ) { METHOD_1 ( VAR_6 , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , VAR_7 -> VAR_8 , VAR_9 -> VAR_10 , VAR_11 , VAR_12 -> VAR_13 , VAR_14 -> VAR_15 ) ; METHOD_2 ( VAR_16 , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * VAR_17 ) [ 0 ] , ( * VAR_18 ) [ 1 ] , ( * VAR_19 ) [ 2 ] , ( * VAR_20 ) [ 3 ] ) ; } for ( ; VAR_21 -> VAR_22 > 0 ; VAR_23 -> VAR_24 -- ) { VAR_25 -> VAR_26 [ VAR_27 -> VAR_28 ++ ] = VAR_29 -> VAR_30 [ VAR_31 -> VAR_32 ++ ] ; } if ( ! * VAR_33 && VAR_34 == VAR_35 ) { VAR_36 = 0 ; } VAR_37 -> VAR_38 = VAR_39 -> VAR_40 ; if ( VAR_41 == VAR_42 ) { TYPE_5 * VAR_43 = METHOD_3 ( VAR_44 -> VAR_45 , & VAR_46 -> VAR_47 , ( * VAR_48 ) + VAR_49 -> VAR_50 + VAR_51 ) ; <S2SV_StartBug> if ( ! VAR_52 ) <S2SV_EndBug> <S2SV_StartBug> return METHOD_4 ( VAR_53 ) ; <S2SV_EndBug> VAR_54 -> VAR_55 = VAR_56 ; METHOD_5 ( & VAR_57 -> VAR_58 [ VAR_59 -> VAR_60 ] , * VAR_61 , * VAR_62 ) ; VAR_63 -> VAR_64 += * VAR_65 ; return - 1 ; } * VAR_66 = VAR_67 -> VAR_68 = VAR_69 -> VAR_70 + VAR_71 ; if ( VAR_72 -> VAR_73 ) { TYPE_6 * VAR_74 = METHOD_6 ( VAR_75 -> VAR_76 , & VAR_77 -> VAR_78 , VAR_79 + VAR_80 -> VAR_81 + VAR_82 ) ; <S2SV_StartBug> if ( ! VAR_83 ) <S2SV_EndBug> <S2SV_StartBug> return METHOD_7 ( VAR_84 ) ; <S2SV_EndBug> VAR_85 -> VAR_86 = VAR_87 ; if ( VAR_88 > - VAR_89 ) METHOD_8 ( & VAR_90 -> VAR_91 [ VAR_92 -> VAR_93 ] , * VAR_94 , VAR_95 + VAR_96 ) ; VAR_97 -> VAR_98 = 0 ; * VAR_99 = VAR_100 -> VAR_101 ; } for ( ; VAR_102 < 0 ; VAR_103 ++ ) { VAR_104 -> VAR_105 = ( VAR_106 -> VAR_107 << 8 ) | VAR_108 -> VAR_109 [ VAR_110 -> VAR_111 + VAR_112 ] ; VAR_113 -> VAR_114 = ( VAR_115 -> VAR_116 << 8 ) | VAR_117 -> VAR_118 [ VAR_119 -> VAR_120 + VAR_121 ] ; VAR_122 -> VAR_123 ++ ; } if ( VAR_124 -> VAR_125 ) { METHOD_9 ( VAR_126 , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , VAR_127 -> VAR_128 , VAR_129 -> VAR_130 , VAR_131 , VAR_132 -> VAR_133 , VAR_134 -> VAR_135 ) ; METHOD_10 ( VAR_136 , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * VAR_137 ) [ 0 ] , ( * VAR_138 ) [ 1 ] , ( * VAR_139 ) [ 2 ] , ( * VAR_140 ) [ 3 ] ) ; } return 0 ; }",<S2SV_ModStart> ! VAR_87 ) { VAR_134 -> VAR_133 = 0 ; <S2SV_ModStart> VAR_84 ) ; } <S2SV_ModStart> ! VAR_87 ) { VAR_134 -> VAR_135 = VAR_134 -> VAR_133 = 0 ; <S2SV_ModStart> VAR_84 ) ; },"CWE-119 int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; if ( next > - FF_INPUT_BUFFER_PADDING_SIZE ) memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ) ; pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { av_dlog ( NULL , ""overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n"" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , ""%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n"" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; }",<S2SV_ModStart> ! new_buffer ) { pc -> index = 0 ; <S2SV_ModStart> ENOMEM ) ; } <S2SV_ModStart> ! new_buffer ) { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> ENOMEM ) ; }
606,"CWE-119 TYPE_0 TYPE_1 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_2 * VAR_1 , <S2SV_StartBug> const TYPE_3 * VAR_2 , const TYPE_4 VAR_3 [ 2 ] ) <S2SV_EndBug> { TYPE_5 VAR_4 ; VAR_5 * VAR_6 ; TYPE_6 VAR_7 ; TYPE_7 VAR_8 ; if ( METHOD_1 ( VAR_9 , VAR_10 , & VAR_11 , & VAR_12 , & VAR_13 ) == - 1 ) return - 1 ; if ( METHOD_2 ( VAR_14 ) ) { const TYPE_8 * VAR_15 ; if ( METHOD_3 ( VAR_16 , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( METHOD_4 ( VAR_17 , "",<S2SV_blank>%s<S2SV_blank>Endian"" , VAR_18 . VAR_19 == 0xfffe ? ""Little"" : ""Big"" ) == - 1 ) return - 2 ; switch ( VAR_20 . VAR_21 ) { case 2 : if ( METHOD_5 ( VAR_22 , "",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d"" , VAR_23 . VAR_24 & 0xff , ( TYPE_9 ) VAR_25 . VAR_26 >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( METHOD_6 ( VAR_27 , "",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d"" , ( TYPE_10 ) VAR_28 . VAR_29 >> 8 , VAR_30 . VAR_31 & 0xff ) == - 1 ) return - 2 ; break ; default : if ( METHOD_7 ( VAR_32 , "",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d"" , VAR_33 . VAR_34 , VAR_35 . VAR_36 & 0xff , ( TYPE_11 ) VAR_37 . VAR_38 >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> VAR_39 = METHOD_8 ( VAR_40 , VAR_41 ) ; <S2SV_EndBug> if ( VAR_42 ) if ( METHOD_9 ( VAR_43 , "",<S2SV_blank>%s"" , VAR_44 ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> VAR_45 = METHOD_10 ( VAR_46 , VAR_47 , VAR_48 , VAR_49 ) ; <S2SV_EndBug> METHOD_11 ( VAR_50 ) ; return VAR_51 == - 1 ? - 2 : VAR_52 ; }","<S2SV_ModStart> VAR_9 , const TYPE_12 * VAR_53 <S2SV_ModEnd> ) { TYPE_5 <S2SV_ModStart> break ; } if ( VAR_53 ) { <S2SV_ModStart> = METHOD_8 ( VAR_53 -> VAR_54 <S2SV_ModEnd> , VAR_41 ) <S2SV_ModStart> - 2 ; } <S2SV_ModStart> , VAR_48 , VAR_53 <S2SV_ModEnd> ) ; METHOD_11","CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( file_printf ( ms , "",<S2SV_blank>%s<S2SV_blank>Endian"" , si . si_byte_order == 0xfffe ? ""Little"" : ""Big"" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d"" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d"" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , "",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d"" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> free ( info ) ; return m == - 1 ? - 2 : m ; }","<S2SV_ModStart> sst , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { cdf_summary_info_header_t <S2SV_ModStart> break ; } if ( root_storage ) { <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc ) <S2SV_ModStart> - 2 ; } <S2SV_ModStart> , count , root_storage <S2SV_ModEnd> ) ; free"
607,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 , VAR_5 = 0 ; TYPE_6 VAR_6 ; TYPE_7 VAR_7 = 1 ; TYPE_8 VAR_8 = VAR_9 ; TYPE_9 VAR_10 = 0 ; VAR_11 -> VAR_12 = 0 ; while ( VAR_13 ) { VAR_14 = VAR_15 ; VAR_16 = METHOD_1 ( VAR_17 , & VAR_18 , & VAR_19 ) ; if ( ! METHOD_2 ( VAR_20 + VAR_21 , ""ptr"" , 3 ) ) { continue ; } else if ( ! METHOD_3 ( VAR_22 + VAR_23 , ""byte"" , 4 ) ) { VAR_24 -> VAR_25 |= VAR_26 | VAR_27 ; VAR_28 -> VAR_29 = VAR_30 ; VAR_31 = VAR_32 ; } else if ( ! METHOD_4 ( VAR_33 + VAR_34 , ""word"" , 4 ) ) { VAR_35 -> VAR_36 |= VAR_37 | VAR_38 ; VAR_39 -> VAR_40 = VAR_41 ; VAR_42 = VAR_43 ; } else if ( ! METHOD_5 ( VAR_44 + VAR_45 , ""dword"" , 5 ) ) { VAR_46 -> VAR_47 |= VAR_48 | VAR_49 ; VAR_50 -> VAR_51 = VAR_52 ; VAR_53 = VAR_54 ; } else if ( ! METHOD_6 ( VAR_55 + VAR_56 , ""qword"" , 5 ) ) { VAR_57 -> VAR_58 |= VAR_59 | VAR_60 ; VAR_61 -> VAR_62 = VAR_63 ; VAR_64 = VAR_65 ; } else if ( ! METHOD_7 ( VAR_66 + VAR_67 , ""oword"" , 5 ) ) { VAR_68 -> VAR_69 |= VAR_70 | VAR_71 ; VAR_72 -> VAR_73 = VAR_74 ; VAR_75 = VAR_76 ; } else if ( ! METHOD_8 ( VAR_77 + VAR_78 , ""tbyte"" , 5 ) ) { VAR_79 -> VAR_80 |= VAR_81 | VAR_82 ; VAR_83 -> VAR_84 = VAR_85 ; VAR_86 = VAR_87 ; } else { VAR_88 = 0 ; } } if ( VAR_89 [ VAR_90 ] == '[' ) { if ( ! VAR_91 -> VAR_92 ) { VAR_93 -> VAR_94 = VAR_95 ; } VAR_96 -> VAR_97 = VAR_98 -> VAR_99 [ 0 ] = VAR_100 -> VAR_101 [ 1 ] = 0 ; TYPE_10 VAR_102 = 1 ; TYPE_11 VAR_103 = VAR_104 ; TYPE_12 VAR_105 = VAR_106 ; while ( VAR_107 [ VAR_108 ] != ']' ) { if ( VAR_109 > VAR_110 ) { break ; } VAR_111 = VAR_112 ; if ( ! VAR_113 [ VAR_114 ] ) { break ; } VAR_115 = METHOD_9 ( VAR_116 , & VAR_117 , & VAR_118 ) ; if ( VAR_119 == VAR_120 ) { if ( VAR_121 [ VAR_122 ] == '+' || VAR_123 [ VAR_124 ] == '-' || VAR_125 [ VAR_126 ] == ']' ) { if ( VAR_127 != VAR_128 ) { <S2SV_StartBug> VAR_129 -> VAR_130 [ VAR_131 ] = VAR_132 ; <S2SV_EndBug> VAR_133 -> VAR_134 [ VAR_135 ] = VAR_136 ; <S2SV_StartBug> ++ VAR_137 ; <S2SV_EndBug> } else { <S2SV_StartBug> VAR_138 -> VAR_139 += VAR_140 ; <S2SV_EndBug> <S2SV_StartBug> VAR_141 -> VAR_142 [ VAR_143 ] = VAR_144 ; <S2SV_EndBug> } VAR_145 = 1 ; VAR_146 = VAR_147 ; } else if ( VAR_148 [ VAR_149 ] == '*' ) { } } else if ( VAR_150 == VAR_151 ) { TYPE_13 VAR_152 = 0 ; if ( VAR_153 != VAR_154 ) { VAR_155 -> VAR_156 = 0 ; } VAR_157 = VAR_158 ; VAR_159 = METHOD_10 ( VAR_160 , VAR_161 , & VAR_162 , & VAR_163 ) ; if ( VAR_164 ) { VAR_165 -> VAR_166 = VAR_167 ; if ( VAR_168 > 8 ) { VAR_169 -> VAR_170 = VAR_171 ; VAR_172 -> VAR_173 = VAR_174 - 9 ; } VAR_175 = VAR_176 ; } else if ( VAR_177 > 8 ) { VAR_178 -> VAR_179 = VAR_180 - 9 ; } if ( VAR_181 & VAR_182 & VAR_183 ) { VAR_184 -> VAR_185 = VAR_186 ; VAR_187 -> VAR_188 = VAR_189 ; METHOD_11 ( VAR_190 , VAR_191 , & VAR_192 , VAR_193 , VAR_194 ) ; return VAR_195 ; } if ( ! VAR_196 ) { VAR_197 -> VAR_198 |= VAR_199 ; } VAR_200 -> VAR_201 = VAR_202 ; VAR_203 -> VAR_204 = VAR_205 ; if ( ! ( VAR_206 & VAR_207 ) ) { VAR_208 -> VAR_209 = 0 ; } } else { TYPE_14 * VAR_210 = METHOD_12 ( VAR_211 , '+' ) ; VAR_212 -> VAR_213 = 1 ; if ( ! VAR_214 ) { VAR_215 = METHOD_13 ( VAR_216 , '-' ) ; if ( VAR_217 ) { VAR_218 -> VAR_219 = - 1 ; } } TYPE_15 * VAR_220 = METHOD_14 ( VAR_221 , '+' ) ; TYPE_16 * VAR_222 = METHOD_15 ( VAR_223 , '-' ) ; TYPE_17 * VAR_224 = METHOD_16 ( VAR_225 , ']' ) ; if ( VAR_226 && VAR_227 && VAR_228 < VAR_229 && VAR_230 < VAR_231 ) { VAR_232 -> VAR_233 = - 1 ; } TYPE_18 * VAR_234 ; VAR_235 = METHOD_17 ( METHOD_18 ( VAR_236 + VAR_237 ) + 1 ) ; METHOD_19 ( VAR_238 , VAR_239 + VAR_240 ) ; METHOD_20 ( VAR_241 , ""+-"" ) ; TYPE_19 VAR_242 = METHOD_21 ( VAR_243 , VAR_244 ) ; METHOD_22 ( VAR_245 ) ; VAR_246 *= VAR_247 ; } } } else if ( VAR_248 == VAR_249 ) { VAR_250 = VAR_251 ; VAR_252 * VAR_253 ; if ( VAR_254 ) { VAR_255 -> VAR_256 = VAR_257 ; METHOD_23 ( VAR_258 -> VAR_259 , VAR_260 , VAR_261 - 1 ) ; VAR_262 -> VAR_263 [ VAR_264 - 1 ] = '\\0' ; return VAR_265 ; } VAR_266 -> VAR_267 = METHOD_24 ( VAR_268 , VAR_269 , & VAR_270 , & VAR_271 -> VAR_272 ) ; VAR_273 -> VAR_274 = VAR_275 ; if ( VAR_276 -> VAR_277 > 8 ) { VAR_278 -> VAR_279 = VAR_280 ; VAR_281 -> VAR_282 -= 9 ; } if ( VAR_283 -> VAR_284 & VAR_285 & VAR_286 ) { METHOD_25 ( VAR_287 , VAR_288 , & VAR_289 , VAR_290 , VAR_291 ) ; return VAR_292 ; } if ( VAR_293 -> VAR_294 == VAR_295 ) { VAR_296 -> VAR_297 = VAR_298 ; if ( VAR_299 -> VAR_300 && VAR_301 -> VAR_302 -> VAR_303 == 0 ) { return VAR_304 ; } VAR_305 -> VAR_306 = VAR_307 ; TYPE_20 * VAR_308 = VAR_309 -> VAR_310 ? ( TYPE_21 * ) ( VAR_311 -> VAR_312 -> VAR_313 ) : VAR_314 ; if ( VAR_315 && ( VAR_316 = METHOD_26 ( VAR_317 -> VAR_318 , VAR_319 ) ) ) { VAR_320 -> VAR_321 = VAR_322 ; } TYPE_22 * VAR_323 = METHOD_27 ( VAR_324 , '-' ) ; if ( VAR_325 ) { VAR_326 -> VAR_327 = - 1 ; VAR_328 = ++ VAR_329 ; } VAR_330 -> VAR_331 = METHOD_28 ( VAR_332 , VAR_333 ) ; } else if ( VAR_334 -> VAR_335 < VAR_336 ) { METHOD_29 ( VAR_337 -> VAR_338 , VAR_339 , VAR_340 - 1 ) ; VAR_341 -> VAR_342 [ VAR_343 - 1 ] = '\\0' ; } } else { VAR_344 -> VAR_345 = VAR_346 ; VAR_347 -> VAR_348 = 1 ; TYPE_23 * VAR_349 = METHOD_30 ( VAR_350 , '-' ) ; if ( VAR_351 ) { VAR_352 -> VAR_353 = - 1 ; VAR_354 = ++ VAR_355 ; } VAR_356 -> VAR_357 = METHOD_31 ( VAR_358 , VAR_359 ) ; } return VAR_360 ; }",<S2SV_ModStart> VAR_336 ) { if ( VAR_291 < 2 ) { <S2SV_ModStart> = VAR_246 ; } <S2SV_ModStart> += VAR_246 ; if ( VAR_291 < 2 ) { <S2SV_ModStart> = VAR_336 ; },"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }",<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
608,"CWE-415 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = 0 ; TYPE_2 VAR_2 ; struct STRUCT_OR_UNION_1 * VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 ; VAR_5 = METHOD_1 ( & VAR_6 -> VAR_7 , sizeof ( struct STRUCT_OR_UNION_3 ) , VAR_8 ) ; if ( ! VAR_9 ) return - VAR_10 ; METHOD_2 ( & VAR_11 -> VAR_12 ) ; VAR_13 = METHOD_3 ( VAR_14 , VAR_15 , 0 ) ; if ( ! VAR_16 ) { METHOD_4 ( & VAR_17 -> VAR_18 , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\n"" ) ; return - VAR_19 ; } VAR_20 -> VAR_21 = METHOD_5 ( & VAR_22 -> VAR_23 , VAR_24 -> VAR_25 , METHOD_6 ( VAR_26 ) ) ; if ( ! VAR_27 -> VAR_28 ) return - VAR_29 ; VAR_30 = METHOD_7 ( VAR_31 , 0 ) ; if ( VAR_32 < 0 ) { METHOD_8 ( & VAR_33 -> VAR_34 , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\n"" ) ; return - VAR_35 ; } VAR_36 -> VAR_37 = VAR_38 ; VAR_39 -> VAR_40 . VAR_41 = VAR_42 ; VAR_43 -> VAR_44 . VAR_45 = VAR_46 ; VAR_47 -> VAR_48 . VAR_49 = VAR_50 ; VAR_51 -> VAR_52 . VAR_53 = VAR_54 ; VAR_55 -> VAR_56 . VAR_57 = VAR_58 ; VAR_59 -> VAR_60 . VAR_61 = VAR_62 ; VAR_63 -> VAR_64 . VAR_65 = 0 ; VAR_66 -> VAR_67 . VAR_68 = VAR_69 -> VAR_70 ; VAR_71 -> VAR_72 . VAR_73 = VAR_74 ; VAR_75 -> VAR_76 . VAR_77 = & VAR_78 -> VAR_79 ; VAR_80 -> VAR_81 . VAR_82 = VAR_83 ; if d ( VAR_84 ) VAR_85 -> VAR_86 . VAR_87 = VAR_88 -> VAR_89 . VAR_90 ; VAR_91 -> VAR_92 = VAR_93 ; VAR_94 -> VAR_95 = METHOD_9 ( VAR_96 ) ; VAR_97 . VAR_98 = METHOD_10 ( & VAR_99 -> VAR_100 ) ; <S2SV_StartBug> VAR_101 -> VAR_102 = METHOD_11 ( & VAR_103 , <S2SV_EndBug> <S2SV_StartBug> & VAR_104 -> VAR_105 , VAR_106 ) ; <S2SV_EndBug> if ( METHOD_12 ( VAR_107 -> VAR_108 ) ) { METHOD_13 ( & VAR_109 -> VAR_110 , ""Couldn\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\n"" ) ; return METHOD_14 ( VAR_111 -> VAR_112 ) ; } VAR_113 = METHOD_15 ( & VAR_114 -> VAR_115 , VAR_116 ) ; if ( VAR_117 ) <S2SV_StartBug> goto VAR_118 ; <S2SV_EndBug> VAR_119 = METHOD_16 ( & VAR_120 -> VAR_121 , METHOD_17 ( & VAR_122 -> VAR_123 ) , 0 , 0 , VAR_124 ) ; if ( VAR_125 ) { METHOD_18 ( & VAR_126 -> VAR_127 , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\n"" ) ; goto VAR_128 ; } VAR_129 = METHOD_19 ( & VAR_130 -> VAR_131 , & VAR_132 , 0 , VAR_133 , VAR_134 ) ; if ( VAR_135 ) { METHOD_20 ( & VAR_136 -> VAR_137 , ""could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\n"" ) ; VAR_138 = - VAR_139 ; goto VAR_140 ; } METHOD_21 ( & VAR_141 -> VAR_142 , & VAR_143 , VAR_144 , VAR_145 ) ; METHOD_22 ( VAR_146 , VAR_147 ) ; METHOD_23 ( & VAR_148 -> VAR_149 , ""amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\n"" ) ; return VAR_150 ; VAR_151 : METHOD_24 ( & VAR_152 -> VAR_153 ) ; <S2SV_StartBug> VAR_154 : <S2SV_EndBug> METHOD_25 ( VAR_155 -> VAR_156 ) ; return VAR_157 ; }","<S2SV_ModStart> -> VAR_156 = METHOD_26 ( & VAR_148 -> VAR_149 , <S2SV_ModEnd> & VAR_103 , <S2SV_ModStart> & VAR_103 , <S2SV_ModEnd> VAR_155 ) ; <S2SV_ModStart> ( VAR_157 ) return VAR_157 <S2SV_ModEnd> ; VAR_157 = <S2SV_ModStart> VAR_153 ) ; <S2SV_ModEnd> return VAR_157 ;","CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\n"" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\n"" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ;  if d ( CONFIG_OF_GPIO ) gpio_dev -> gc . of_node = pdev -> dev . of_node ;   gpio_dev -> groups = kerncz_groups ; gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> if ( IS_ERR ( gpio_dev -> pctrl ) ) { dev_err ( & pdev -> dev , ""Couldn\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\n"" ) ; return PTR_ERR ( gpio_dev -> pctrl ) ; } ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret ) <S2SV_StartBug> goto out1 ; <S2SV_EndBug> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; if ( ret ) { dev_err ( & pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\n"" ) ; goto out2 ; } ret = gpiochip_irqchip_add ( & gpio_dev -> gc , & amd_gpio_irqchip , 0 , handle_simple_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( & pdev -> dev , ""could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\n"" ) ; ret = - ENODEV ; goto out2 ; } gpiochip_set_chained_irqchip ( & gpio_dev -> gc , & amd_gpio_irqchip , irq_base , amd_gpio_irq_handler ) ; platform_set_drvdata ( pdev , gpio_dev ) ; dev_dbg ( & pdev -> dev , ""amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\n"" ) ; return ret ; out2 : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> out1 : <S2SV_EndBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; return ret ; }","<S2SV_ModStart> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> & amd_pinctrl_desc , <S2SV_ModStart> & amd_pinctrl_desc , <S2SV_ModEnd> gpio_dev ) ; <S2SV_ModStart> ( ret ) return ret <S2SV_ModEnd> ; ret = <S2SV_ModStart> gc ) ; <S2SV_ModEnd> return ret ;"
609,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { VAR_2 -> VAR_3 = METHOD_1 ( 16 , VAR_4 ) ; VAR_5 -> VAR_6 = METHOD_2 ( 16 , VAR_7 ) ; <S2SV_StartBug> VAR_8 -> VAR_9 = METHOD_3 ( 3 , VAR_10 ) ; <S2SV_EndBug> VAR_11 -> VAR_12 = METHOD_4 ( 1 , VAR_13 ) ; VAR_14 -> VAR_15 = METHOD_5 ( 1 , VAR_16 ) ; VAR_17 -> VAR_18 = METHOD_6 ( 2 , VAR_19 ) + 1 ; VAR_20 -> VAR_21 = METHOD_7 ( 2 , VAR_22 ) ; VAR_23 -> VAR_24 = METHOD_8 ( 1 , VAR_25 ) ; VAR_26 -> VAR_27 = METHOD_9 ( 1 , VAR_28 ) ; VAR_29 -> VAR_30 = METHOD_10 ( 1 , VAR_31 ) ; VAR_32 -> VAR_33 = METHOD_11 ( 1 , VAR_34 ) ; VAR_35 -> VAR_36 = METHOD_12 ( 2 , VAR_37 ) ; VAR_38 -> VAR_39 = METHOD_13 ( 1 , VAR_40 ) ; if ( VAR_41 -> VAR_42 ) { VAR_43 -> VAR_44 = METHOD_14 ( 6 , VAR_45 ) - 32 ; } VAR_46 -> VAR_47 = METHOD_15 ( 2 , VAR_48 ) ; VAR_49 -> VAR_50 = ( VAR_51 -> VAR_52 & 1 ) * 20 + ( VAR_53 -> VAR_54 & 2 ) * 22 + ( ( VAR_55 -> VAR_56 & 3 ) == 3 ) * 2 + 400 ; VAR_57 -> VAR_58 = METHOD_16 ( 4 , VAR_59 ) ; if ( VAR_60 -> VAR_61 != 400 ) { VAR_62 -> VAR_63 = METHOD_17 ( 1 , VAR_64 ) ; VAR_65 -> VAR_66 = METHOD_18 ( 1 , VAR_67 ) ; } VAR_68 -> VAR_69 = METHOD_19 ( 1 , VAR_70 ) ? 10 : 8 ; if ( VAR_71 -> VAR_72 == 10 ) VAR_73 -> VAR_74 += 2 * METHOD_20 ( 1 , VAR_75 ) ; VAR_76 -> VAR_77 = METHOD_21 ( 1 , VAR_78 ) ? 10 : 8 ; if ( VAR_79 -> VAR_80 == 10 ) VAR_81 -> VAR_82 += 2 * METHOD_22 ( 1 , VAR_83 ) ; }","<S2SV_ModStart> 3 , VAR_83 ) ; VAR_81 -> VAR_9 = METHOD_24 ( VAR_81 -> VAR_9 , METHOD_23 ( VAR_84 ) , METHOD_23 ( VAR_85 )","CWE-119 void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter = get_flc ( 1 , stream ) ; } decoder_info -> bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> bitdepth == 10 ) decoder_info -> bitdepth += 2 * get_flc ( 1 , stream ) ; decoder_info -> input_bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> input_bitdepth == 10 ) decoder_info -> input_bitdepth += 2 * get_flc ( 1 , stream ) ; }","<S2SV_ModStart> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )"
610,"CWE-358 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 * VAR_5 ) { struct STRUCT_OR_UNION_2 * VAR_6 = METHOD_1 ( VAR_7 ) ; DECLARE_SOCKADDR ( struct STRUCT_OR_UNION_3 * , VAR_8 , VAR_9 -> msg_name ) ; struct STRUCT_OR_UNION_4 * VAR_10 ; unsigned TYPE_5 VAR_11 , VAR_12 ; TYPE_6 VAR_13 , VAR_14 = 0 ; TYPE_7 VAR_15 ; <S2SV_StartBug> TYPE_8 VAR_16 = METHOD_2 ( VAR_17 ) ; <S2SV_EndBug> TYPE_9 VAR_18 ; if ( VAR_19 & VAR_20 ) return METHOD_3 ( VAR_21 , VAR_22 , VAR_23 , VAR_24 ) ; VAR_25 : VAR_26 = METHOD_4 ( VAR_27 , VAR_28 | ( VAR_29 ? VAR_30 : 0 ) , & VAR_31 , & VAR_32 , & VAR_33 ) ; if ( ! VAR_34 ) goto VAR_35 ; VAR_36 = VAR_37 -> VAR_38 - sizeof ( struct STRUCT_OR_UNION_5 ) ; VAR_39 = VAR_40 ; if ( VAR_41 > VAR_42 ) VAR_43 = VAR_44 ; else if ( VAR_45 < VAR_46 ) VAR_47 -> VAR_48 |= VAR_49 ; if ( VAR_50 < VAR_51 || METHOD_5 ( VAR_52 ) -> VAR_53 ) { <S2SV_StartBug> if ( METHOD_6 ( VAR_54 ) ) <S2SV_EndBug> goto VAR_55 ; } <S2SV_StartBug> if ( METHOD_7 ( VAR_56 ) ) <S2SV_EndBug> VAR_57 = METHOD_8 ( VAR_58 , sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_59 , VAR_60 ) ; else { VAR_61 = METHOD_9 ( VAR_62 , sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_63 ) ; if ( VAR_64 == - VAR_65 ) goto VAR_66 ; } if ( METHOD_10 ( VAR_67 ) ) { METHOD_11 ( VAR_68 , METHOD_12 ) ; if ( ! VAR_69 ) { METHOD_13 ( & VAR_70 -> VAR_71 ) ; METHOD_14 ( METHOD_15 ( VAR_72 ) , VAR_73 , VAR_74 ) ; } goto VAR_75 ; } if ( ! VAR_76 ) METHOD_16 ( METHOD_17 ( VAR_77 ) , VAR_78 , VAR_79 ) ; METHOD_18 ( VAR_80 , VAR_81 , VAR_82 ) ; if ( VAR_83 ) { VAR_84 -> VAR_85 = VAR_86 ; VAR_87 -> VAR_88 = METHOD_19 ( VAR_89 ) -> VAR_90 ; VAR_91 -> VAR_92 . VAR_93 = METHOD_20 ( VAR_94 ) -> VAR_95 ; METHOD_21 ( VAR_96 -> VAR_97 , 0 , sizeof ( VAR_98 -> VAR_99 ) ) ; * VAR_100 = sizeof ( * VAR_101 ) ; } if ( VAR_102 -> VAR_103 ) METHOD_22 ( VAR_104 , VAR_105 , sizeof ( struct STRUCT_OR_UNION_8 ) ) ; VAR_106 = VAR_107 ; if ( VAR_108 & VAR_109 ) VAR_110 = VAR_111 ; VAR_112 : METHOD_23 ( VAR_113 , VAR_114 ) ; VAR_115 : return VAR_116 ; VAR_117 : VAR_118 = METHOD_24 ( VAR_119 ) ; if ( ! METHOD_25 ( VAR_120 , VAR_121 , VAR_122 ) ) { METHOD_26 ( METHOD_27 ( VAR_123 ) , VAR_124 , VAR_125 ) ; METHOD_28 ( METHOD_29 ( VAR_126 ) , VAR_127 , VAR_128 ) ; } METHOD_30 ( VAR_129 , VAR_130 ) ; METHOD_31 ( ) ; VAR_131 -> VAR_132 &= ~ VAR_133 ; goto VAR_134 ; }",<S2SV_ModStart> ( VAR_129 ) ; TYPE_9 VAR_135 = VAR_136 <S2SV_ModStart> VAR_53 ) { VAR_135 = ! <S2SV_ModEnd> METHOD_6 ( VAR_121 <S2SV_ModStart> ( VAR_121 ) ; if ( ! VAR_135 <S2SV_ModStart> } if ( VAR_135 ||,"CWE-358 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }",<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
611,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 , VAR_4 ; if ( VAR_5 < 2 ) return 0 ; METHOD_1 ( * VAR_6 , 2 ) ; VAR_7 = VAR_8 [ 1 ] ; VAR_9 = VAR_10 [ 0 ] ; if ( VAR_11 < VAR_12 ) return 0 ; if ( VAR_13 < 2 ) { METHOD_2 ( ( VAR_14 , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , METHOD_3 ( VAR_15 , ""Unknown"" , VAR_16 ) , VAR_17 , VAR_18 ) ) ; return 0 ; } METHOD_4 ( ( VAR_19 , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , METHOD_5 ( VAR_20 , ""Unknown"" , VAR_21 ) , VAR_22 , VAR_23 ) ) ; switch ( VAR_24 ) { case VAR_25 : if ( VAR_26 != 6 ) { METHOD_6 ( ( VAR_27 , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return VAR_28 ; } <S2SV_StartBug> METHOD_7 ( * ( VAR_29 + 2 ) , 4 ) ; <S2SV_EndBug> METHOD_8 ( ( VAR_30 , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , METHOD_9 ( VAR_31 + 2 ) ) ) ; break ; default : if ( VAR_32 -> VAR_33 < 2 ) METHOD_10 ( VAR_34 , & VAR_35 [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_36 - 2 ) ; break ; } if ( VAR_37 -> VAR_38 > 1 ) METHOD_11 ( VAR_39 , & VAR_40 [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , VAR_41 - 2 ) ; return VAR_42 ; VAR_43 : METHOD_12 ( ( VAR_44 , ""[|bacp]"" ) ) ; return 0 ; }",<S2SV_ModStart> VAR_42 ; } METHOD_13 <S2SV_ModEnd> ( VAR_40 + <S2SV_ModStart> VAR_40 + 2 <S2SV_ModEnd> ) ; METHOD_12,"CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }",<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
612,CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * const VAR_1 = & VAR_2 -> VAR_3 ; VAR_4 -> VAR_5 = 0 ; <S2SV_StartBug> if VAR_6 <S2SV_EndBug> if ( ! VAR_7 -> VAR_8 ) VAR_9 -> VAR_10 = 0 ; VAR_11 -> VAR_12 = 1 ; },<S2SV_ModStart> = 0 ; <S2SV_ModEnd> VAR_11 -> VAR_10,CWE-119 static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; rc -> frames_since_golden = 0 ; <S2SV_StartBug>  if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled )   rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 1 ; },<S2SV_ModStart> = 0 ; <S2SV_ModEnd> rc -> source_alt_ref_pending
613,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , TYPE_2 VAR_2 , struct STRUCT_OR_UNION_1 VAR_3 [ ] , TYPE_3 VAR_4 ) { const struct STRUCT_OR_UNION_2 * VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 ; TYPE_4 VAR_8 = 0 ; TYPE_5 VAR_9 = 0 ; METHOD_1 ( ) ; VAR_10 = METHOD_2 ( VAR_11 -> VAR_12 ) ; while ( ( TYPE_6 ) VAR_13 > VAR_14 ) { TYPE_7 VAR_15 ; if ( METHOD_3 ( VAR_16 >= VAR_17 ) ) { VAR_18 = - VAR_19 ; break ; } VAR_20 = METHOD_4 ( VAR_21 , VAR_22 , VAR_23 ) ; if ( METHOD_5 ( ! VAR_24 ) ) { VAR_25 = - VAR_26 ; break ; } VAR_27 = VAR_28 + VAR_29 ; VAR_30 = VAR_31 -> VAR_32 - VAR_33 + VAR_34 -> VAR_35 ; <S2SV_StartBug> VAR_36 -> VAR_37 = METHOD_6 ( ( TYPE_8 ) VAR_38 , VAR_39 ) ; <S2SV_EndBug> VAR_40 -> VAR_41 = ( TYPE_9 TYPE_10 * ) ( unsigned TYPE_11 ) ( VAR_42 -> VAR_43 + VAR_44 - VAR_45 -> VAR_46 ) ; VAR_47 += VAR_48 ; VAR_49 += VAR_50 ; ++ VAR_51 ; } METHOD_7 ( ) ; return VAR_52 ; }",<S2SV_ModStart> TYPE_8 ) VAR_38 - VAR_47,"CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }",<S2SV_ModStart> u64 ) len - s
614,"CWE-362 static unsigned TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_1 * VAR_2 ; <S2SV_EndBug> unsigned TYPE_2 VAR_3 ; TYPE_3 VAR_4 ; VAR_5 = METHOD_1 ( VAR_6 , VAR_7 ) ; if ( VAR_8 < 0 ) return 0 ; if ( METHOD_2 ( VAR_9 ) || METHOD_3 ( VAR_10 ) ) return - 1L ; if ( ! VAR_11 ) return 0 ; <S2SV_StartBug> VAR_12 = METHOD_4 ( VAR_13 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VAR_14 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> VAR_15 = METHOD_5 ( VAR_16 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_17 -> VAR_18 ) <S2SV_EndBug> VAR_19 = ( VAR_20 << 12 ) + 0xfff ; return VAR_21 ; }","<S2SV_ModStart> { struct STRUCT_OR_UNION_1 <S2SV_ModEnd> VAR_17 ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! METHOD_4 ( & VAR_17 , VAR_13 ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = METHOD_5 ( & <S2SV_ModStart> if ( VAR_17 . <S2SV_ModEnd> VAR_18 ) VAR_21","CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = get_desc_limit ( & <S2SV_ModStart> if ( desc . <S2SV_ModEnd> g ) limit"
615,"CWE-416 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 ; TYPE_4 * VAR_3 , * VAR_4 , * VAR_5 ; TYPE_5 * VAR_6 ; TYPE_6 VAR_7 , VAR_8 ; TYPE_7 VAR_9 ; register TYPE_8 * VAR_10 ; register TYPE_9 VAR_11 ; TYPE_10 VAR_12 , VAR_13 ; TYPE_11 VAR_14 ; unsigned TYPE_12 VAR_15 [ VAR_16 ] ; METHOD_1 ( VAR_17 != ( const TYPE_13 * ) VAR_18 ) ; METHOD_2 ( VAR_19 -> VAR_20 == VAR_21 ) ; if ( VAR_22 -> VAR_23 != VAR_24 ) ( TYPE_14 ) METHOD_3 ( VAR_25 , METHOD_4 ( ) , ""%s"" , VAR_26 -> VAR_27 ) ; METHOD_5 ( VAR_28 != ( TYPE_15 * ) VAR_29 ) ; METHOD_6 ( VAR_30 -> VAR_31 == VAR_32 ) ; VAR_33 = METHOD_7 ( VAR_34 , VAR_35 ) ; VAR_36 = VAR_37 ; VAR_38 = METHOD_8 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; if ( VAR_43 == VAR_44 ) return ( ( TYPE_16 * ) VAR_45 ) ; VAR_46 = METHOD_9 ( VAR_47 , 5 , VAR_48 ) ; if ( ( VAR_49 != 5 ) || ( METHOD_10 ( ( TYPE_17 * ) VAR_50 , ""SFW95"" , 5 ) != 0 ) ) METHOD_11 ( VAR_51 , ""ImproperImageHeader"" ) ; VAR_52 = METHOD_12 ( VAR_53 ) ; ( TYPE_18 ) METHOD_13 ( VAR_54 , ( TYPE_19 ) VAR_55 , ( TYPE_20 * ) VAR_56 ) ; METHOD_14 ( VAR_57 , ( TYPE_21 * ) VAR_58 , 0 ) ; VAR_59 = METHOD_15 ( VAR_60 -> VAR_61 ) ; for ( ; ; ) { for ( VAR_62 = METHOD_16 ( VAR_63 ) ; VAR_64 != VAR_65 ; VAR_66 = METHOD_17 ( VAR_67 ) ) { for ( VAR_68 = 0 ; VAR_69 < 17 ; VAR_70 ++ ) VAR_71 [ VAR_72 ] = VAR_73 [ VAR_74 + 1 ] ; VAR_75 [ 17 ] = ( unsigned TYPE_22 ) VAR_76 ; if ( METHOD_18 ( ( TYPE_23 * ) ( VAR_77 + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( VAR_78 == VAR_79 ) break ; if ( METHOD_19 ( ( TYPE_24 * ) ( VAR_80 + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( TYPE_25 ) METHOD_20 ( VAR_81 -> VAR_82 ) ; METHOD_21 ( VAR_83 , ""ImproperImageHeader"" ) ; } VAR_84 = ( TYPE_26 * ) VAR_85 ; if ( VAR_86 != - 1 ) VAR_87 = METHOD_22 ( VAR_88 , ""wb"" ) ; if ( ( VAR_89 == - 1 ) || ( VAR_90 == ( TYPE_27 * ) VAR_91 ) ) { ( TYPE_28 ) METHOD_23 ( VAR_92 -> VAR_93 ) ; METHOD_24 ( VAR_94 , VAR_95 , ""UnableToWriteFile"" , VAR_96 -> VAR_97 ) ; VAR_98 = METHOD_25 ( VAR_99 ) ; return ( ( TYPE_29 * ) VAR_100 ) ; } VAR_101 = METHOD_26 ( ""SFW94A"" , 1 , 6 , VAR_102 ) ; ( TYPE_30 ) VAR_103 ; VAR_104 = 65535UL * VAR_105 [ 2 ] + 256L * VAR_106 [ 1 ] + VAR_107 [ 0 ] ; for ( VAR_108 = 0 ; VAR_109 < ( TYPE_31 ) VAR_110 ; VAR_111 ++ ) { VAR_112 = METHOD_27 ( VAR_113 ) ; ( TYPE_32 ) METHOD_28 ( VAR_114 , VAR_115 ) ; } ( TYPE_33 ) METHOD_29 ( VAR_116 ) ; VAR_117 = METHOD_30 ( VAR_118 , VAR_119 ) ; if ( VAR_120 == ( TYPE_34 * ) VAR_121 ) break ; ( TYPE_35 ) METHOD_31 ( VAR_122 -> VAR_123 , VAR_124 , ""slide_%02ld.sfw"" , ( TYPE_36 ) VAR_125 -> VAR_126 ) ; if ( VAR_127 == ( TYPE_37 * ) VAR_128 ) VAR_129 = VAR_130 ; else { for ( VAR_131 = VAR_132 ; VAR_133 -> VAR_134 != ( TYPE_38 * ) VAR_135 ; VAR_136 = METHOD_32 ( VAR_137 ) ) ; VAR_138 -> VAR_139 = VAR_140 ; VAR_141 -> VAR_142 = VAR_143 -> VAR_144 + 1 ; VAR_145 -> VAR_146 = VAR_147 ; } if ( VAR_148 -> VAR_149 != 0 ) if ( VAR_150 -> VAR_151 >= ( VAR_152 -> VAR_153 + VAR_154 -> VAR_155 - 1 ) ) break ; VAR_156 = METHOD_33 ( VAR_157 , VAR_158 , METHOD_34 ( VAR_159 ) , METHOD_35 ( VAR_160 ) ) ; if ( VAR_161 == VAR_162 ) break ; } if ( VAR_163 != - 1 ) ( TYPE_39 ) METHOD_36 ( VAR_164 ) ; ( TYPE_40 ) METHOD_37 ( VAR_165 -> VAR_166 ) ; VAR_167 = METHOD_38 ( VAR_168 ) ; <S2SV_StartBug> ( TYPE_41 ) METHOD_39 ( VAR_169 ) ; <S2SV_EndBug> VAR_170 = METHOD_40 ( VAR_171 ) ; if ( METHOD_41 ( VAR_172 ) != VAR_173 ) { TYPE_42 * VAR_174 ; VAR_175 = METHOD_42 ( VAR_176 ) ; ( TYPE_43 ) METHOD_43 ( VAR_177 , METHOD_44 ( ) , VAR_178 , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , VAR_179 -> VAR_180 , VAR_181 ) ; VAR_182 = METHOD_45 ( VAR_183 ) ; } ( TYPE_44 ) METHOD_46 ( VAR_184 ) ; return ( METHOD_47 ( VAR_185 ) ) ; }",<S2SV_ModStart> VAR_168 ) ; <S2SV_ModEnd> if ( METHOD_41,"CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; pwp_image = AcquireImage ( image_info , exception ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
616,"CWE-119 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 , const TYPE_0 * VAR_2 ) { struct STRUCT_OR_UNION_3 * VAR_3 = container_of ( VAR_4 , struct STRUCT_OR_UNION_4 , VAR_5 ) ; struct STRUCT_OR_UNION_5 * VAR_6 ; <S2SV_StartBug> unsigned TYPE_1 VAR_7 ; <S2SV_EndBug> TYPE_2 VAR_8 ; if ( METHOD_1 ( VAR_9 , ""tpgt_"" ) != VAR_10 ) return METHOD_2 ( - VAR_11 ) ; <S2SV_StartBug> if ( METHOD_3 ( VAR_12 + 5 , 10 , & VAR_13 ) || VAR_14 > VAR_15 ) <S2SV_EndBug> return METHOD_4 ( - VAR_16 ) ; VAR_17 = METHOD_5 ( sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_18 ) ; if ( ! VAR_19 ) { METHOD_6 ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return METHOD_7 ( - VAR_20 ) ; } METHOD_8 ( & VAR_21 -> VAR_22 ) ; METHOD_9 ( & VAR_23 -> VAR_24 ) ; VAR_25 -> VAR_26 = VAR_27 ; VAR_28 -> VAR_29 = VAR_30 ; VAR_31 = METHOD_10 ( & VAR_32 -> VAR_33 , VAR_34 , & VAR_35 -> VAR_36 , VAR_37 , VAR_38 ) ; if ( VAR_39 < 0 ) { METHOD_11 ( VAR_40 ) ; return VAR_41 ; } METHOD_12 ( & VAR_42 ) ; METHOD_13 ( & VAR_43 -> VAR_44 , & VAR_45 ) ; METHOD_14 ( & VAR_46 ) ; return & VAR_47 -> VAR_48 ; }",<S2SV_ModStart> * VAR_47 ; TYPE_3 <S2SV_ModEnd> VAR_30 ; TYPE_2 <S2SV_ModStart> ; if ( METHOD_15 <S2SV_ModEnd> ( VAR_12 + <S2SV_ModStart> ) || VAR_30 >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return METHOD_7,"CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }",<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
617,"CWE-345 static <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) <S2SV_EndBug> { TYPE_3 VAR_2 ; struct STRUCT_OR_UNION_0 VAR_3 ; <S2SV_StartBug> VAR_4 = METHOD_1 ( VAR_5 ) ; <S2SV_EndBug> for ( ; METHOD_2 ( VAR_6 , & VAR_7 ) ; METHOD_3 ( & VAR_8 ) ) { switch ( VAR_9 . VAR_10 ) { case VAR_11 : <S2SV_StartBug> VAR_12 . VAR_13 = VAR_14 ; <S2SV_EndBug> break ; case VAR_15 : <S2SV_StartBug> VAR_16 . VAR_17 = VAR_18 ; <S2SV_EndBug> break ; case VAR_19 : VAR_20 . VAR_21 = VAR_22 ; break ; case VAR_23 : VAR_24 . VAR_25 = VAR_26 ; break ; case VAR_27 : VAR_28 . VAR_29 = VAR_30 ; break ; case VAR_31 : VAR_32 . VAR_33 = VAR_34 ; break ; case VAR_35 : VAR_36 . VAR_37 = VAR_38 ; break ; case VAR_39 : VAR_40 . VAR_41 = VAR_42 ; break ; case VAR_43 : case VAR_44 : case VAR_45 : case VAR_46 : case VAR_47 : case VAR_48 : default : <S2SV_StartBug> if ( ! ( VAR_49 . VAR_50 >= VAR_51 && VAR_52 . VAR_53 < VAR_54 ) ) <S2SV_EndBug> continue ; break ; } <S2SV_StartBug> if ( ! METHOD_4 ( VAR_55 , VAR_56 . VAR_57 ) ) { <S2SV_EndBug> switch ( VAR_58 . VAR_59 ) { case VAR_60 : continue ; break ; case VAR_61 : case VAR_62 : case VAR_63 : case VAR_64 : case VAR_65 : if ( VAR_66 . VAR_67 != 1 ) continue ; break ; case VAR_68 : case VAR_69 : case VAR_70 : if ( VAR_71 . VAR_72 >= 16 * 1024 ) continue ; break ; case VAR_73 : continue ; break ; } <S2SV_StartBug> ( TYPE_4 ) METHOD_5 ( VAR_74 , & VAR_75 , VAR_76 ) ; <S2SV_EndBug> } } METHOD_6 ( VAR_77 ) ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static TYPE_5 <S2SV_ModEnd> METHOD_0 ( TYPE_2 <S2SV_ModStart> , TYPE_2 VAR_5 , TYPE_6 * * VAR_78 ) { const struct STRUCT_OR_UNION_1 * VAR_79 <S2SV_ModEnd> ; struct STRUCT_OR_UNION_0 <S2SV_ModStart> STRUCT_OR_UNION_0 VAR_75 ; METHOD_7 ( & VAR_75 ) ; for ( VAR_79 = VAR_80 ; VAR_79 -> VAR_81 ; VAR_79 ++ ) { if ( METHOD_4 ( VAR_74 , VAR_79 -> VAR_82 ) ) break ; if ( METHOD_8 ( VAR_5 , VAR_79 -> VAR_81 , & VAR_75 , VAR_83 | VAR_84 ) ) { if ( VAR_79 -> VAR_81 != VAR_79 -> VAR_82 ) <S2SV_ModEnd> VAR_75 . VAR_57 <S2SV_ModStart> . VAR_57 = VAR_79 -> VAR_82 ; if ( VAR_75 . VAR_59 != METHOD_9 ( <S2SV_ModEnd> VAR_75 . VAR_57 <S2SV_ModStart> VAR_75 . VAR_57 ) ) break ; if ( VAR_75 . VAR_72 < 1 || VAR_75 . VAR_72 > 16 * 1024 * 1024 ) break ; if ( VAR_79 -> VAR_72 && VAR_75 . VAR_72 != VAR_79 -> VAR_72 ) break ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! METHOD_5 <S2SV_ModEnd> ( VAR_74 , <S2SV_ModStart> ( VAR_74 , <S2SV_ModEnd> & VAR_75 , <S2SV_ModStart> , VAR_76 ) ) break ; METHOD_3 ( & VAR_75 ) ; } } METHOD_3 ( & VAR_75 ) ; if ( VAR_79 -> VAR_81 ) { METHOD_11 ( VAR_78 , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , METHOD_10 ( VAR_79 -> VAR_82 ) , VAR_79 -> VAR_82 ) ; } return VAR_79 -> VAR_81 <S2SV_ModEnd> ; } <S2SV_null>","CWE-345 static <S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> { HeaderIterator hi ; struct rpmtd_s td ; <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> break ; case RPMSIGTAG_PGP : <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> continue ; break ; } <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 ) continue ; break ; case RPM_I18NSTRING_TYPE : continue ; break ; } <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> } } headerFreeIterator ( hi ) ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> static rpmTagVal <S2SV_ModEnd> headerMergeLegacySigs ( Header <S2SV_ModStart> , Header sigh , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> ; struct rpmtd_s <S2SV_ModStart> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> td . tag <S2SV_ModStart> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> td . tag <S2SV_ModStart> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! headerPut <S2SV_ModEnd> ( h , <S2SV_ModStart> ( h , <S2SV_ModEnd> & td , <S2SV_ModStart> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> ; } <S2SV_null>"
618,"CWE-835 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 ; if ( VAR_3 == VAR_4 ) return ( - 1 ) ; if ( VAR_5 ) { if ( ( VAR_6 -> VAR_7 != VAR_8 ) && ( VAR_9 -> VAR_10 -> VAR_11 ) ) METHOD_1 ( VAR_12 , ""%s(%d):<S2SV_blank>"" , VAR_13 -> VAR_14 -> VAR_15 , VAR_16 -> VAR_17 -> VAR_18 ) ; METHOD_2 ( VAR_19 , <S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , VAR_20 -> VAR_21 + 1 , VAR_22 -> VAR_23 ) ; <S2SV_EndBug> } VAR_24 = METHOD_3 ( VAR_25 , VAR_26 ) ; if ( VAR_27 -> VAR_28 == VAR_29 ) return ( - 1 ) ; VAR_30 ; return ( VAR_31 ) ; }","<S2SV_ModStart> VAR_26 -> VAR_23 ) ; } if ( ( ( VAR_27 -> VAR_21 > 40 ) && ( ( VAR_27 -> VAR_32 & VAR_33 ) == 0 ) ) || ( VAR_27 -> VAR_21 > 1024 ) ) { METHOD_4 ( VAR_27 , VAR_34 , VAR_8 ) ; while ( VAR_27 -> VAR_21 > 1 ) METHOD_6 ( METHOD_5 ( VAR_27 ) ) ; return ( - 1","CWE-835 int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , ""%s(%d):<S2SV_blank>"" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , <S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }","<S2SV_ModStart> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1"
619,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { struct STRUCT_OR_UNION_2 * VAR_1 = STRUCT_OR_UNION_3 -> VAR_2 ; struct STRUCT_OR_UNION_4 VAR_3 ; TYPE_2 VAR_4 = 0 , VAR_5 ; <S2SV_StartBug> if ( ! METHOD_1 ( VAR_6 ) ) <S2SV_EndBug> return 0 ; METHOD_2 ( & METHOD_3 ( VAR_7 ) -> VAR_8 ) ; if ( ! METHOD_4 ( & METHOD_5 ( STRUCT_OR_UNION_5 ) -> VAR_9 ) ) goto VAR_10 ; METHOD_6 ( ( METHOD_7 ( STRUCT_OR_UNION_6 -> VAR_11 ) || METHOD_8 ( STRUCT_OR_UNION_7 -> VAR_12 ) || METHOD_9 ( STRUCT_OR_UNION_8 -> VAR_13 ) ) || STRUCT_OR_UNION_9 -> VAR_14 == 0 ) ; METHOD_10 ( METHOD_11 ( VAR_15 ) -> VAR_16 , ""get_write_access"" ) ; VAR_17 = METHOD_12 ( VAR_18 , METHOD_13 ( VAR_19 ) -> VAR_20 ) ; if ( VAR_21 ) goto VAR_22 ; VAR_23 = METHOD_14 ( VAR_24 , STRUCT_OR_UNION_10 , & VAR_25 ) ; if ( VAR_26 ) goto VAR_27 ; if ( METHOD_15 ( STRUCT_OR_UNION_11 ) && METHOD_16 ( STRUCT_OR_UNION_12 ) <= ( METHOD_17 ( METHOD_18 ( VAR_28 ) -> VAR_29 -> VAR_30 ) ) ) goto VAR_31 ; METHOD_19 ( STRUCT_OR_UNION_13 ) = METHOD_20 ( METHOD_21 ( VAR_32 ) -> VAR_33 -> VAR_34 ) ; METHOD_22 ( VAR_35 ) -> VAR_36 -> VAR_37 = METHOD_23 ( STRUCT_OR_UNION_14 -> VAR_38 ) ; VAR_39 = METHOD_24 ( VAR_40 , VAR_41 ) ; VAR_42 = METHOD_25 ( VAR_43 , STRUCT_OR_UNION_15 , & VAR_44 ) ; if ( ! VAR_45 ) VAR_46 = VAR_47 ; VAR_48 : if ( ! VAR_49 ) METHOD_26 ( & METHOD_27 ( STRUCT_OR_UNION_16 ) -> VAR_50 , & METHOD_28 ( VAR_51 ) -> VAR_52 ) ; METHOD_29 ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n"" , STRUCT_OR_UNION_17 -> VAR_53 ) ; METHOD_30 ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n"" , STRUCT_OR_UNION_18 -> VAR_54 , METHOD_31 ( STRUCT_OR_UNION_19 ) ) ; VAR_55 : METHOD_32 ( & METHOD_33 ( VAR_56 ) -> VAR_57 ) ; METHOD_34 ( STRUCT_OR_UNION_20 -> VAR_58 , VAR_59 ) ; return VAR_60 ; }",<S2SV_ModStart> if ( ! METHOD_33 ( VAR_56 ) -> VAR_61 <S2SV_ModEnd> ) return 0,"CWE-20 int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) -> i_orphan , & EXT4_SB ( sb ) -> s_orphan ) ; jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n"" , inode -> i_ino ) ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n"" , inode -> i_ino , NEXT_ORPHAN ( inode ) ) ; out_unlock : mutex_unlock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; ext4_std_error ( inode -> i_sb , err ) ; return err ; }",<S2SV_ModStart> if ( ! EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> ) return 0
620,"CWE-125 static const TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const struct STRUCT_OR_UNION_0 * VAR_2 , TYPE_3 TYPE_4 VAR_3 , const TYPE_5 * VAR_4 , TYPE_6 TYPE_7 VAR_5 , TYPE_8 TYPE_9 VAR_6 , TYPE_10 TYPE_11 VAR_7 , TYPE_12 TYPE_13 VAR_8 ) { struct STRUCT_OR_UNION_1 VAR_9 ; const TYPE_14 * VAR_10 [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const TYPE_15 * VAR_11 = ( const TYPE_16 * ) VAR_12 + sizeof ( VAR_13 ) ; unsigned TYPE_17 VAR_14 ; <S2SV_StartBug> METHOD_1 ( * VAR_15 ) ; <S2SV_EndBug> METHOD_2 ( & VAR_16 , VAR_17 , sizeof ( VAR_18 ) ) ; METHOD_3 ( VAR_19 , METHOD_4 ( VAR_20 ) , VAR_21 . VAR_22 . VAR_23 ) ; VAR_24 = METHOD_5 ( VAR_25 . VAR_26 . VAR_27 ) ; METHOD_6 ( ( VAR_28 , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , VAR_29 - 4 , METHOD_7 ( VAR_30 . VAR_31 , VAR_32 ) ) ) ; if ( VAR_33 > 4 ) { if ( VAR_34 -> VAR_35 > 1 ) { METHOD_8 ( ( VAR_36 , ""<S2SV_blank>authdata=("" ) ) ; if ( ! METHOD_9 ( VAR_37 , ( const TYPE_18 * ) VAR_38 , VAR_39 - sizeof ( VAR_40 ) ) ) goto VAR_41 ; METHOD_10 ( ( VAR_42 , "")<S2SV_blank>"" ) ) ; } else if ( VAR_43 -> VAR_44 ) { if ( ! METHOD_11 ( VAR_45 , VAR_46 , VAR_47 ) ) goto VAR_48 ; } } return ( const TYPE_19 * ) VAR_49 + VAR_50 ; VAR_51 : METHOD_12 ( ( VAR_52 , ""<S2SV_blank>[|%s]"" , METHOD_13 ( VAR_53 ) ) ) ; return VAR_54 ; }","<S2SV_ModStart> TYPE_17 VAR_50 ; METHOD_14 ( * VAR_49 , sizeof ( VAR_40 ) <S2SV_ModEnd> ) ; METHOD_2","CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }","<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY"
621,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , struct STRUCT_OR_UNION_2 * * VAR_3 , struct STRUCT_OR_UNION_3 * VAR_4 ) { TYPE_2 VAR_5 [ VAR_6 ] ; if ( ! VAR_7 -> VAR_8 -> METHOD_1 ) return - VAR_9 ; <S2SV_StartBug> VAR_10 -> VAR_11 -> METHOD_2 ( VAR_12 , VAR_13 ) ; <S2SV_EndBug> return METHOD_3 ( VAR_14 , VAR_15 , sizeof ( VAR_16 ) , VAR_17 ) ; }","<S2SV_ModStart> - VAR_9 ; METHOD_4 ( VAR_17 , 0 , sizeof ( VAR_17 ) ) ;","CWE-399 static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }","<S2SV_ModStart> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;"
622,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , struct STRUCT_OR_UNION_4 * STRUCT_OR_UNION_5 ) { if ( STRUCT_OR_UNION_6 -> VAR_0 & VAR_1 ) return 0 ; <S2SV_StartBug> if ( METHOD_1 ( STRUCT_OR_UNION_7 ) -> METHOD_2 ( STRUCT_OR_UNION_8 , VAR_2 ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( METHOD_3 ( STRUCT_OR_UNION_9 , STRUCT_OR_UNION_10 ) && ( STRUCT_OR_UNION_11 -> VAR_3 == VAR_4 || <S2SV_EndBug> ( STRUCT_OR_UNION_12 -> VAR_5 -> VAR_6 == 0 && STRUCT_OR_UNION_13 -> VAR_7 -> VAR_8 == VAR_9 && <S2SV_StartBug> STRUCT_OR_UNION_14 -> VAR_10 -> VAR_11 != VAR_12 ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }","<S2SV_ModStart> ; if ( ! METHOD_3 ( STRUCT_OR_UNION_9 , STRUCT_OR_UNION_14 ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> STRUCT_OR_UNION_14 -> VAR_10 <S2SV_ModStart> VAR_12 ) ) <S2SV_ModEnd> return 1 ;","CWE-20 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }","<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;"
623,"CWE-362 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , <S2SV_StartBug> struct STRUCT_OR_UNION_2 * VAR_1 ) <S2SV_EndBug> { <S2SV_StartBug> struct STRUCT_OR_UNION_3 * VAR_2 ; <S2SV_EndBug> TYPE_2 VAR_3 ; TYPE_3 VAR_4 = 0 ; VAR_5 = METHOD_1 ( STRUCT_OR_UNION_4 ) ; VAR_6 = VAR_7 [ VAR_8 ] . VAR_9 ; <S2SV_StartBug> METHOD_2 ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" <S2SV_EndBug> ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , STRUCT_OR_UNION_5 -> VAR_10 , <S2SV_StartBug> ( unsigned TYPE_4 TYPE_5 ) METHOD_3 ( VAR_11 -> VAR_12 ) , <S2SV_EndBug> METHOD_4 ( VAR_13 ) ) ; VAR_14 = METHOD_5 ( VAR_15 , STRUCT_OR_UNION_6 , VAR_16 + VAR_17 ) ; if ( VAR_18 ) goto VAR_19 ; METHOD_6 ( VAR_20 ) ; METHOD_7 ( VAR_21 , STRUCT_OR_UNION_7 , VAR_22 , VAR_23 ) ; VAR_24 = METHOD_8 ( VAR_25 , STRUCT_OR_UNION_8 , VAR_26 + VAR_27 -> VAR_28 ) ; VAR_29 : METHOD_9 ( STRUCT_OR_UNION_9 , VAR_30 ) ; return VAR_31 ; }","<S2SV_ModStart> STRUCT_OR_UNION_9 , struct STRUCT_OR_UNION_10 * VAR_32 , struct <S2SV_ModStart> STRUCT_OR_UNION_3 * VAR_23 ; TYPE_6 VAR_12 ; unsigned TYPE_3 VAR_33 <S2SV_ModStart> . VAR_9 ; VAR_12 = METHOD_3 ( VAR_23 -> VAR_12 ) ; VAR_33 = METHOD_4 ( VAR_23 ) ; <S2SV_ModStart> TYPE_5 TYPE_5 ) VAR_12 , VAR_33 ) ; if ( VAR_12 != VAR_32 -> VAR_34 || VAR_33 > VAR_32 -> VAR_35 ) { VAR_31 = METHOD_10 ( VAR_25 , STRUCT_OR_UNION_9 , VAR_32 , VAR_30 , VAR_36 ) ; if ( VAR_31 < 0 ) goto VAR_29 ; METHOD_11 ( VAR_30 ) ; VAR_30 = METHOD_12 ( STRUCT_OR_UNION_9 , VAR_32 -> VAR_34 , VAR_30 ) ; if ( METHOD_13 ( VAR_30 ) ) { VAR_31 = METHOD_14 ( VAR_30 ) ; goto VAR_29 ; } VAR_17 = METHOD_1 ( STRUCT_OR_UNION_9 ) ; VAR_23 = VAR_30 [ VAR_17 ] . VAR_9 ; } <S2SV_ModEnd> VAR_31 = METHOD_5","CWE-362 static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , <S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> { <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; <S2SV_StartBug> ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" <S2SV_EndBug> ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }","<S2SV_ModStart> inode , struct ext4_map_blocks * map , struct <S2SV_ModStart> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> err = ext4_ext_get_access"
624,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; struct STRUCT_OR_UNION_2 * VAR_2 ; TYPE_1 VAR_3 ; if ( METHOD_1 ( ) ) return - VAR_4 ; VAR_5 = METHOD_2 ( & VAR_6 , VAR_7 -> VAR_8 , METHOD_3 ( VAR_9 -> VAR_10 ) ) ; if ( ! VAR_11 ) return - VAR_12 ; METHOD_4 ( VAR_13 -> VAR_14 , VAR_15 ) ; VAR_16 -> VAR_17 = VAR_18 -> VAR_19 . VAR_20 ; VAR_21 -> VAR_22 = VAR_23 -> VAR_24 . VAR_25 ; VAR_26 -> VAR_27 = VAR_28 -> VAR_29 . VAR_30 ; VAR_31 -> VAR_32 = 1 ; VAR_33 -> VAR_34 = VAR_35 -> VAR_36 -> VAR_37 ; VAR_38 -> VAR_39 = VAR_40 -> VAR_41 ; VAR_42 = METHOD_5 ( VAR_43 ) ; VAR_44 -> VAR_45 = VAR_46 -> VAR_47 . VAR_48 ; VAR_49 -> VAR_50 = VAR_51 -> VAR_52 . VAR_53 ; VAR_54 = METHOD_6 ( VAR_55 , 0 , 0 ) ; if ( VAR_56 ) METHOD_7 ( VAR_57 ) ; else VAR_58 -> VAR_59 = VAR_60 ; <S2SV_StartBug> return VAR_61 ; <S2SV_EndBug> }","<S2SV_ModStart> = VAR_60 ; if ( VAR_58 -> VAR_36 -> VAR_62 & VAR_63 ) METHOD_8 ( VAR_58 , VAR_64 , VAR_65 , VAR_65 ) ;","CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }","<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;"
625,"CWE-399 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 * VAR_5 ) { struct STRUCT_OR_UNION_2 * VAR_6 = METHOD_1 ( VAR_7 ) ; struct STRUCT_OR_UNION_3 * VAR_8 = METHOD_2 ( VAR_9 ) ; struct STRUCT_OR_UNION_4 * VAR_10 ; unsigned TYPE_5 VAR_11 , VAR_12 ; TYPE_6 VAR_13 , VAR_14 = 0 ; TYPE_7 VAR_15 ; TYPE_8 VAR_16 = METHOD_3 ( VAR_17 ) ; TYPE_9 VAR_18 ; TYPE_10 VAR_19 ; if ( VAR_20 & VAR_21 ) return METHOD_4 ( VAR_22 , VAR_23 , VAR_24 , VAR_25 ) ; if ( VAR_26 -> VAR_27 && VAR_28 -> VAR_29 . VAR_30 . VAR_31 ) return METHOD_5 ( VAR_32 , VAR_33 , VAR_34 , VAR_35 ) ; VAR_36 : VAR_37 = METHOD_6 ( VAR_38 , VAR_39 | ( VAR_40 ? VAR_41 : 0 ) , & VAR_42 , & VAR_43 , & VAR_44 ) ; if ( ! VAR_45 ) goto VAR_46 ; VAR_47 = VAR_48 -> VAR_49 - sizeof ( struct STRUCT_OR_UNION_5 ) ; VAR_50 = VAR_51 ; if ( VAR_52 > VAR_53 ) VAR_54 = VAR_55 ; else if ( VAR_56 < VAR_57 ) VAR_58 -> VAR_59 |= VAR_60 ; VAR_61 = ( VAR_62 -> VAR_63 == METHOD_7 ( VAR_64 ) ) ; if ( VAR_65 < VAR_66 || METHOD_8 ( VAR_67 ) -> VAR_68 ) { if ( METHOD_9 ( VAR_69 ) ) goto VAR_70 ; } if ( METHOD_10 ( VAR_71 ) ) VAR_72 = METHOD_11 ( VAR_73 , sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_74 , VAR_75 ) ; else { VAR_76 = METHOD_12 ( VAR_77 , sizeof ( struct STRUCT_OR_UNION_7 ) , VAR_78 ) ; if ( VAR_79 == - VAR_80 ) goto VAR_81 ; } if ( METHOD_13 ( VAR_82 ) ) { METHOD_14 ( VAR_83 , METHOD_15 ) ; if ( ! VAR_84 ) { METHOD_16 ( & VAR_85 -> VAR_86 ) ; if ( VAR_87 ) METHOD_17 ( METHOD_18 ( VAR_88 ) , VAR_89 , VAR_90 ) ; else METHOD_19 ( METHOD_20 ( VAR_91 ) , VAR_92 , VAR_93 ) ; } goto VAR_94 ; } if ( ! VAR_95 ) { if ( VAR_96 ) METHOD_21 ( METHOD_22 ( VAR_97 ) , VAR_98 , VAR_99 ) ; else METHOD_23 ( METHOD_24 ( VAR_100 ) , VAR_101 , VAR_102 ) ; } METHOD_25 ( VAR_103 , VAR_104 , VAR_105 ) ; if ( VAR_106 -> VAR_107 ) { DECLARE_SOCKADDR ( struct STRUCT_OR_UNION_8 * , VAR_108 , VAR_109 -> VAR_110 ) ; VAR_111 -> VAR_112 = VAR_113 ; VAR_114 -> VAR_115 = METHOD_26 ( VAR_116 ) -> VAR_117 ; VAR_118 -> VAR_119 = 0 ; if ( VAR_120 ) { METHOD_27 ( METHOD_28 ( VAR_121 ) -> VAR_122 , & VAR_123 -> VAR_124 ) ; VAR_125 -> VAR_126 = 0 ; } else { VAR_127 -> VAR_128 = METHOD_29 ( VAR_129 ) -> VAR_130 ; VAR_131 -> VAR_132 = METHOD_30 ( & VAR_133 -> VAR_134 , METHOD_31 ( VAR_135 ) ) ; } * VAR_136 = sizeof ( * VAR_137 ) ; } if ( VAR_138 -> VAR_139 . VAR_140 ) METHOD_32 ( VAR_141 , VAR_142 , VAR_143 ) ; if ( VAR_144 ) { if ( VAR_145 -> VAR_146 ) METHOD_33 ( VAR_147 , VAR_148 ) ; } else { if ( VAR_149 -> VAR_150 . VAR_151 ) METHOD_34 ( VAR_152 , VAR_153 , VAR_154 ) ; } VAR_155 = VAR_156 ; if ( VAR_157 & VAR_158 ) VAR_159 = VAR_160 ; VAR_161 : METHOD_35 ( VAR_162 , VAR_163 ) ; VAR_164 : return VAR_165 ; VAR_166 : VAR_167 = METHOD_36 ( VAR_168 ) ; if ( ! METHOD_37 ( VAR_169 , VAR_170 , VAR_171 ) ) { if ( VAR_172 ) { METHOD_38 ( METHOD_39 ( VAR_173 ) , VAR_174 , VAR_175 ) ; METHOD_40 ( METHOD_41 ( VAR_176 ) , VAR_177 , VAR_178 ) ; } else { METHOD_42 ( METHOD_43 ( VAR_179 ) , VAR_180 , VAR_181 ) ; METHOD_44 ( METHOD_45 ( VAR_182 ) , VAR_183 , VAR_184 ) ; } } METHOD_46 ( VAR_185 , VAR_186 ) ; <S2SV_StartBug> if ( VAR_187 ) <S2SV_EndBug> return - VAR_188 ; VAR_189 -> VAR_190 &= ~ VAR_191 ; goto VAR_192 ; }",<S2SV_ModStart> VAR_186 ) ; METHOD_47 ( ) <S2SV_ModEnd> ; VAR_189 ->,"CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }",<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
626,"CWE-59 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 ( * VAR_1 ) ( TYPE_3 * ) , const TYPE_4 * VAR_2 ) { TYPE_5 VAR_3 ; TYPE_6 VAR_4 ; if ( VAR_5 -> VAR_6 ) { VAR_7 = 0 ; if ( ! ( VAR_8 = METHOD_1 ( VAR_9 -> VAR_10 , VAR_11 | VAR_12 | VAR_13 | VAR_14 ) ) ) VAR_15 -> VAR_16 = VAR_17 ; else { VAR_18 = VAR_19 ; if ( VAR_20 != VAR_21 ) METHOD_2 ( VAR_22 , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , VAR_23 , VAR_24 -> VAR_25 ) ; } if ( ! VAR_26 || VAR_27 == VAR_28 ) { if ( VAR_29 -> VAR_30 ) METHOD_3 ( VAR_31 , VAR_32 , VAR_33 , VAR_34 -> VAR_35 ) ; <S2SV_StartBug> if ( ( VAR_36 -> VAR_37 = METHOD_4 ( VAR_38 -> VAR_39 , VAR_40 | VAR_41 | VAR_42 ) ) == - 1 ) { <S2SV_EndBug> METHOD_5 ( VAR_43 , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , VAR_44 , VAR_45 -> VAR_46 , VAR_47 ) ; if ( VAR_48 -> VAR_49 ) { METHOD_6 ( VAR_50 -> VAR_51 ) ; VAR_52 -> VAR_53 = VAR_54 ; } } } if ( VAR_55 -> VAR_56 == - 1 ) { METHOD_7 ( VAR_57 -> VAR_58 ) ; VAR_59 -> VAR_60 = VAR_61 ; } } }",<S2SV_ModStart> VAR_41 | VAR_42 | VAR_62,"CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }",<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
627,"CWE-476 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 = VAR_2 -> VAR_3 -> VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_1 * VAR_6 ; TYPE_2 VAR_7 = 0 ; if ( METHOD_1 ( VAR_8 ) -> VAR_9 ) { VAR_10 = METHOD_2 ( VAR_11 ) -> VAR_12 ; goto VAR_13 ; } VAR_14 = METHOD_3 ( sizeof ( struct STRUCT_OR_UNION_2 ) , VAR_15 ) ; if ( ! VAR_16 ) return - VAR_17 ; METHOD_4 ( & VAR_18 -> VAR_19 , 0 ) ; METHOD_5 ( & VAR_20 -> VAR_21 , 0 ) ; METHOD_6 ( & VAR_22 -> VAR_23 ) ; METHOD_7 ( & VAR_24 -> VAR_25 ) ; METHOD_8 ( VAR_26 ) -> VAR_27 = VAR_28 ; <S2SV_StartBug> VAR_29 : <S2SV_EndBug> VAR_30 -> VAR_31 = METHOD_9 ( VAR_32 , VAR_33 , ""f2fs_flush-%u:%u"" , METHOD_10 ( VAR_34 ) , METHOD_11 ( VAR_35 ) ) ; if ( METHOD_12 ( VAR_36 -> VAR_37 ) ) { VAR_38 = METHOD_13 ( VAR_39 -> VAR_40 ) ; METHOD_14 ( VAR_41 ) ; METHOD_15 ( VAR_42 ) -> VAR_43 = VAR_44 ; return VAR_45 ; } return VAR_46 ; }","<S2SV_ModStart> = VAR_41 ; if ( ! METHOD_16 ( VAR_42 , VAR_47 ) ) return VAR_46 ;","CWE-476 int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <S2SV_StartBug> init_thread : <S2SV_EndBug> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }","<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;"
628,"CWE-264 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { <S2SV_StartBug> TYPE_1 VAR_2 ; <S2SV_EndBug> METHOD_1 ( VAR_3 != VAR_4 -> VAR_5 ) ; METHOD_2 ( & VAR_6 -> VAR_7 ) ; <S2SV_StartBug> VAR_8 = METHOD_3 ( VAR_9 , VAR_10 ) ; <S2SV_EndBug> if ( ! VAR_11 ) { METHOD_4 ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , VAR_12 ) ; METHOD_5 ( & VAR_13 -> VAR_14 ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } METHOD_6 ( & VAR_15 -> VAR_16 ) ; METHOD_7 ( VAR_17 ) ; }","<S2SV_ModStart> VAR_17 ) { <S2SV_ModEnd> METHOD_1 ( VAR_15 <S2SV_ModStart> VAR_16 ) ; METHOD_8 <S2SV_ModEnd> ( VAR_15 , <S2SV_ModStart> VAR_15 , VAR_17 <S2SV_ModEnd> ) ; METHOD_6 <S2SV_ModStart> VAR_16 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>","CWE-264 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }","<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
629,"CWE-200 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { struct STRUCT_OR_UNION_2 * VAR_0 ; struct STRUCT_OR_UNION_3 * VAR_1 ; METHOD_1 ( ) ; VAR_2 = METHOD_2 ( STRUCT_OR_UNION_4 ) ; if ( METHOD_3 ( VAR_3 ) ) goto VAR_4 ; METHOD_4 ( ) ; while ( ! METHOD_5 ( & VAR_5 -> VAR_6 ) ) { VAR_7 = hlist_entry ( VAR_8 -> VAR_9 . VAR_10 , struct STRUCT_OR_UNION_5 , VAR_11 ) ; if ( VAR_12 -> VAR_13 . VAR_14 & VAR_15 ) { struct STRUCT_OR_UNION_6 * VAR_16 , * VAR_17 ; METHOD_6 ( VAR_18 , VAR_19 , & VAR_20 -> VAR_21 , VAR_22 ) { METHOD_7 ( & VAR_23 -> VAR_24 . VAR_25 , & VAR_26 ) ; METHOD_8 ( VAR_27 ) ; } } <S2SV_StartBug> else METHOD_9 ( VAR_28 , 0 ) ; <S2SV_EndBug> } METHOD_10 ( ) ; METHOD_11 ( VAR_29 ) ; VAR_30 : METHOD_12 ( ) ; }","<S2SV_ModStart> ( VAR_28 , VAR_31 <S2SV_ModEnd> ) ; }","CWE-200 void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","<S2SV_ModStart> ( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; }"
630,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = & VAR_3 -> VAR_4 ; if ( METHOD_1 ( VAR_5 ) <= 32 ) return 0 ; VAR_6 -> VAR_7 = 0 ; <S2SV_StartBug> VAR_8 -> VAR_9 = VAR_10 ; <S2SV_EndBug> METHOD_2 ( VAR_11 , VAR_12 ) ; METHOD_3 ( VAR_13 , 10 ) ; METHOD_4 ( VAR_14 , 2 ) ; VAR_15 -> VAR_16 = METHOD_5 ( VAR_17 , 2 ) + VAR_18 ; if ( METHOD_6 ( VAR_19 ) ) { METHOD_7 ( VAR_20 ) ; METHOD_8 ( VAR_21 ) ; VAR_22 -> VAR_23 = METHOD_9 ( VAR_24 ) ^ 1 ; } if ( VAR_25 -> VAR_26 == VAR_27 ) { if ( METHOD_10 ( VAR_28 ) ) METHOD_11 ( VAR_29 ) ; } if ( VAR_30 -> VAR_31 != VAR_32 ) { VAR_33 -> VAR_34 = METHOD_12 ( VAR_35 ) ; VAR_36 -> VAR_37 = METHOD_13 ( VAR_38 ) ; VAR_39 -> VAR_40 = METHOD_14 ( VAR_41 , 2 ) ; VAR_42 -> VAR_43 = METHOD_15 ( VAR_44 , 2 ) ; VAR_45 -> VAR_46 = METHOD_16 ( VAR_47 ) ; } if ( VAR_48 -> VAR_49 ) { METHOD_17 ( VAR_50 -> VAR_51 . VAR_52 , & VAR_53 -> VAR_54 , VAR_55 ) ; METHOD_18 ( VAR_56 -> VAR_57 . VAR_58 , & VAR_59 -> VAR_60 , VAR_61 ) ; METHOD_19 ( VAR_62 -> VAR_63 . VAR_64 , & VAR_65 -> VAR_66 , VAR_67 ) ; METHOD_20 ( VAR_68 -> VAR_69 . VAR_70 , & VAR_71 -> VAR_72 , VAR_73 ) ; } else { METHOD_21 ( VAR_74 -> VAR_75 . VAR_76 , & VAR_77 -> VAR_78 , VAR_79 ) ; METHOD_22 ( VAR_80 -> VAR_81 . VAR_82 , & VAR_83 -> VAR_84 , VAR_85 ) ; METHOD_23 ( VAR_86 -> VAR_87 . VAR_88 , & VAR_89 -> VAR_90 , VAR_91 ) ; METHOD_24 ( VAR_92 -> VAR_93 . VAR_94 , & VAR_95 -> VAR_96 , VAR_97 ) ; } METHOD_25 ( VAR_98 ) ; METHOD_26 ( VAR_99 ) ; METHOD_27 ( VAR_100 , VAR_101 , 4 ) ; return 0 ; }",<S2SV_ModStart> ; VAR_100 -> VAR_102 = 0 ; VAR_100 ->,"CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }",<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->
631,"CWE-269 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 * VAR_2 = METHOD_1 ( VAR_3 ) ; TYPE_4 VAR_4 ; <S2SV_StartBug> VAR_5 -> METHOD_2 ( VAR_6 , VAR_7 -> VAR_8 ) ; <S2SV_EndBug> if ( VAR_9 > ( VAR_10 -> VAR_11 - sizeof ( VAR_12 ) ) ) return ( TYPE_5 ) - 1 ; VAR_13 = METHOD_3 ( VAR_14 -> VAR_15 + VAR_16 ) ; return VAR_17 ; }",<S2SV_ModStart> TYPE_5 VAR_17 ; if ( VAR_16 + sizeof ( VAR_17 ) > VAR_14 -> VAR_11 ) { return ( TYPE_5 ) - 1 ; } <S2SV_ModStart> -> VAR_15 ) <S2SV_ModEnd> ; VAR_17 =,"CWE-269 uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }",<S2SV_ModStart> uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
632,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , <S2SV_EndBug> const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , unsigned TYPE_4 VAR_3 , TYPE_5 VAR_4 , unsigned TYPE_6 VAR_5 , <S2SV_StartBug> TYPE_7 * VAR_6 ) { <S2SV_EndBug> TYPE_8 VAR_7 = VAR_8 ; const TYPE_9 * VAR_9 = VAR_10 ; const TYPE_10 VAR_11 = METHOD_1 ( VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 , VAR_17 ) ; if ( VAR_18 != VAR_19 ) METHOD_2 ( VAR_20 , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame."" ) ; <S2SV_StartBug> while ( ( VAR_21 = METHOD_3 ( VAR_22 , & VAR_23 ) ) != VAR_24 ) { <S2SV_EndBug> if ( VAR_25 -> VAR_26 == VAR_27 ) { const TYPE_11 VAR_28 = ( VAR_29 -> VAR_30 . VAR_31 . VAR_32 & VAR_33 ) != 0 ; if ( ! METHOD_4 ( VAR_34 , VAR_35 -> VAR_36 . VAR_37 . VAR_38 , VAR_39 -> VAR_40 . VAR_41 . VAR_42 , VAR_43 -> VAR_44 . VAR_45 . VAR_46 ) ) METHOD_5 ( VAR_47 , ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame."" ) ; METHOD_6 ( VAR_48 ? ""K"" : ""."" ) ; METHOD_7 ( VAR_49 ) ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static TYPE_11 <S2SV_ModEnd> METHOD_0 ( TYPE_1 <S2SV_ModStart> VAR_34 ) { TYPE_11 VAR_50 = 0 ; <S2SV_ModStart> VAR_24 ) { VAR_50 = 1 ; <S2SV_ModStart> ; } } return VAR_50 ;,"CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame."" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame."" ) ; printf ( keyframe ? ""K"" : ""."" ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t <S2SV_ModStart> writer ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
633,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_EndBug> <S2SV_StartBug> TYPE_3 VAR_2 ) { <S2SV_EndBug> TYPE_4 VAR_3 ; <S2SV_StartBug> if ( VAR_4 -> VAR_5 > VAR_6 -> VAR_7 . VAR_8 ) <S2SV_EndBug> <S2SV_StartBug> VAR_9 = ( VAR_10 * VAR_11 -> VAR_12 / <S2SV_EndBug> <S2SV_StartBug> METHOD_1 ( VAR_13 -> VAR_14 ) ) ; <S2SV_EndBug> else VAR_15 = ( VAR_16 * VAR_17 -> VAR_18 . VAR_19 / METHOD_2 ( VAR_20 -> VAR_21 ) ) ; if ( VAR_22 > 0.0 ) VAR_23 += VAR_24 * ( VAR_25 * 2.0 ) ; else VAR_26 += VAR_27 * ( VAR_28 / 2.0 ) ; <S2SV_StartBug> return METHOD_3 ( VAR_29 , VAR_30 ) ; <S2SV_EndBug> }","<S2SV_ModStart> * VAR_17 , const <S2SV_ModStart> , TYPE_4 VAR_28 , TYPE_4 VAR_31 <S2SV_ModStart> TYPE_4 VAR_29 ; const TYPE_4 VAR_32 = METHOD_4 ( VAR_17 -> VAR_33 . VAR_34 [ VAR_35 ] , VAR_17 -> VAR_36 . VAR_37 ) ; const TYPE_4 VAR_38 = METHOD_3 ( ( 0.5 + ( VAR_32 * 0.015 ) ) , 1.5 ) ; TYPE_5 VAR_39 = ( VAR_17 -> VAR_40 . VAR_41 != VAR_42 ) ? VAR_17 -> VAR_43 : VAR_17 -> VAR_36 . VAR_44 ; VAR_39 = ( TYPE_5 ) METHOD_6 ( 1 , VAR_39 * METHOD_5 ( VAR_17 , VAR_20 ) ) ; <S2SV_ModEnd> VAR_29 = ( <S2SV_ModStart> VAR_29 = ( VAR_45 * VAR_39 ) <S2SV_ModEnd> / METHOD_2 ( <S2SV_ModStart> -> VAR_21 ) ; VAR_29 = VAR_29 * VAR_46 * VAR_38 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( VAR_29 , VAR_31 * VAR_38 <S2SV_ModEnd> ) ; }","CWE-119 <S2SV_StartBug> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double this_frame_mv_in_out ) { <S2SV_EndBug> double frame_boost ; <S2SV_StartBug> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <S2SV_EndBug> <S2SV_StartBug> frame_boost = ( IIFACTOR * this_frame -> intra_error / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <S2SV_EndBug> else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ; else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ; <S2SV_StartBug> return MIN ( frame_boost , GF_RMAX ) ; <S2SV_EndBug> }","<S2SV_ModStart> * cpi , const <S2SV_ModStart> , double this_frame_mv_in_out , double max_boost <S2SV_ModStart> double frame_boost ; const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <S2SV_ModEnd> frame_boost = ( <S2SV_ModStart> frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK ( <S2SV_ModStart> -> coded_error ) ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( frame_boost , max_boost * boost_q_correction <S2SV_ModEnd> ) ; }"
634,"CWE-000 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , const TYPE_2 * VAR_2 , TYPE_3 VAR_3 ) <S2SV_EndBug> { METHOD_1 ( & VAR_4 -> VAR_5 ) ; if ( VAR_6 != VAR_7 ) { METHOD_2 ( VAR_8 -> VAR_9 . VAR_10 , VAR_11 -> VAR_12 , sizeof ( VAR_13 -> VAR_14 . VAR_15 ) ) ; METHOD_3 ( VAR_16 , & VAR_17 -> VAR_18 ) ; } if ( VAR_19 != VAR_20 ) <S2SV_StartBug> METHOD_4 ( VAR_21 , VAR_22 , VAR_23 ) ; <S2SV_EndBug> METHOD_5 ( & VAR_24 -> VAR_25 ) ; METHOD_6 ( & VAR_26 -> VAR_27 -> VAR_28 ) ; <S2SV_StartBug> METHOD_7 ( VAR_29 , VAR_30 ) ; <S2SV_EndBug> METHOD_8 ( & VAR_31 -> VAR_32 -> VAR_33 ) ; }","<S2SV_ModStart> * VAR_11 , TYPE_4 VAR_34 <S2SV_ModEnd> ) { METHOD_1 <S2SV_ModStart> , VAR_22 , VAR_34 <S2SV_ModEnd> ) ; METHOD_5 <S2SV_ModStart> ( VAR_31 , VAR_34 <S2SV_ModEnd> ) ; METHOD_8","CWE-000 <S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; }","<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock"
635,"CWE-119 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * * VAR_3 , TYPE_5 * VAR_4 , TYPE_6 * VAR_5 ) { const TYPE_7 * VAR_6 ; TYPE_8 VAR_7 ; const TYPE_9 * VAR_8 , * VAR_9 , * VAR_10 ; TYPE_10 VAR_11 ; TYPE_11 VAR_12 ; TYPE_12 VAR_13 ; TYPE_13 VAR_14 ; TYPE_14 VAR_15 ; TYPE_15 VAR_16 ; TYPE_16 VAR_17 , VAR_18 , VAR_19 , VAR_20 , VAR_21 ; TYPE_17 * VAR_22 ; if ( VAR_23 > VAR_24 / 4 ) { VAR_25 = VAR_26 ; goto VAR_27 ; } VAR_28 = CAST ( const TYPE_18 * , ( const TYPE_19 * ) ( ( const TYPE_20 * ) VAR_29 -> VAR_30 + VAR_31 ) ) ; if ( METHOD_1 ( VAR_32 , VAR_33 , VAR_34 , sizeof ( * VAR_35 ) , VAR_36 ) == - 1 ) goto VAR_37 ; VAR_38 . VAR_39 = METHOD_2 ( VAR_40 -> VAR_41 ) ; METHOD_3 ( VAR_42 / 8 ) if ( VAR_43 . VAR_44 > METHOD_4 ) { VAR_45 = VAR_46 ; goto VAR_47 ; } VAR_48 . VAR_49 = METHOD_5 ( VAR_50 -> VAR_51 ) ; METHOD_6 ( VAR_52 / ( 4 * sizeof ( * VAR_53 ) ) ) if ( VAR_54 . VAR_55 > METHOD_7 ) goto VAR_56 ; METHOD_8 ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , VAR_57 . VAR_58 , VAR_59 . VAR_60 ) ) ; if ( * VAR_61 ) { if ( * VAR_62 > METHOD_9 ) goto VAR_63 ; * VAR_64 += VAR_65 . VAR_66 ; VAR_67 = CAST ( TYPE_21 * , METHOD_10 ( * VAR_68 , * VAR_69 * sizeof ( * VAR_70 ) ) ) ; } else { * VAR_71 = VAR_72 . VAR_73 ; VAR_74 = CAST ( TYPE_22 * , METHOD_11 ( * VAR_75 * sizeof ( * VAR_76 ) ) ) ; } if ( VAR_77 == VAR_78 ) goto VAR_79 ; * VAR_80 = VAR_81 ; VAR_82 += * VAR_83 ; * VAR_84 += VAR_85 . VAR_86 ; VAR_87 = CAST ( const TYPE_23 * , ( const TYPE_24 * ) ( ( const TYPE_25 * ) ( const TYPE_26 * ) VAR_88 -> VAR_89 + VAR_90 + sizeof ( VAR_91 ) ) ) ; VAR_92 = CAST ( const TYPE_27 * , ( const TYPE_28 * ) ( ( ( const TYPE_29 * ) ( const TYPE_30 * ) VAR_93 ) + VAR_94 . VAR_95 ) ) ; if ( METHOD_12 ( VAR_96 , VAR_97 , VAR_98 , 0 , VAR_99 ) == - 1 ) goto VAR_100 ; for ( VAR_101 = 0 ; VAR_102 < VAR_103 . VAR_104 ; VAR_105 ++ ) { <S2SV_StartBug> VAR_106 = ( const TYPE_31 * ) ( const TYPE_32 * ) <S2SV_EndBug> ( ( const TYPE_33 * ) ( const TYPE_34 * ) VAR_107 + <S2SV_StartBug> METHOD_13 ( VAR_108 , ( VAR_109 << 1 ) + 1 ) ) - 2 * sizeof ( TYPE_35 ) ; <S2SV_EndBug> if ( VAR_110 > VAR_111 ) { METHOD_14 ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , VAR_112 , VAR_113 ) ) ; goto VAR_114 ; } VAR_115 [ VAR_116 ] . VAR_117 = METHOD_15 ( VAR_118 , VAR_119 << 1 ) ; VAR_120 [ VAR_121 ] . VAR_122 = METHOD_16 ( VAR_123 , 0 ) ; <S2SV_StartBug> METHOD_17 ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , VAR_124 , <S2SV_EndBug> VAR_125 [ VAR_126 ] . VAR_127 , VAR_128 [ VAR_129 ] . VAR_130 , VAR_131 - VAR_132 , <S2SV_StartBug> METHOD_18 ( VAR_133 , ( VAR_134 << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( VAR_135 [ VAR_136 ] . VAR_137 & VAR_138 ) { VAR_139 = METHOD_19 ( VAR_140 , 1 ) ; VAR_141 = 2 ; } else { VAR_142 = 1 ; VAR_143 = 1 ; } VAR_144 = VAR_145 * sizeof ( TYPE_36 ) ; if ( VAR_146 [ VAR_147 ] . VAR_148 & ( VAR_149 | VAR_150 | VAR_151 ) ) goto VAR_152 ; switch ( VAR_153 [ VAR_154 ] . VAR_155 & VAR_156 ) { case VAR_157 : case VAR_158 : break ; case VAR_159 : if ( VAR_160 [ VAR_161 ] . VAR_162 & VAR_163 ) goto VAR_164 ; ( TYPE_37 ) METHOD_20 ( & VAR_165 , & VAR_166 [ VAR_167 ] , sizeof ( VAR_168 ) ) ; VAR_169 [ VAR_170 ] . VAR_171 = METHOD_21 ( VAR_172 ) ; break ; case VAR_173 : if ( VAR_174 [ VAR_175 ] . VAR_176 & VAR_177 ) goto VAR_178 ; ( TYPE_38 ) METHOD_22 ( & VAR_179 , & VAR_180 [ VAR_181 ] , sizeof ( VAR_182 ) ) ; VAR_183 [ VAR_184 ] . VAR_185 = METHOD_23 ( ( TYPE_39 ) VAR_186 ) ; break ; case VAR_187 : case VAR_188 : if ( VAR_189 [ VAR_190 ] . VAR_191 & VAR_192 ) goto VAR_193 ; ( TYPE_40 ) METHOD_24 ( & VAR_194 , & VAR_195 [ VAR_196 ] , sizeof ( VAR_197 ) ) ; VAR_198 [ VAR_199 ] . VAR_200 = METHOD_25 ( VAR_201 ) ; break ; case VAR_202 : if ( VAR_203 [ VAR_204 ] . VAR_205 & VAR_206 ) goto VAR_207 ; ( TYPE_41 ) METHOD_26 ( & VAR_208 , & VAR_209 [ VAR_210 ] , sizeof ( VAR_211 ) ) ; VAR_212 [ VAR_213 ] . VAR_214 = METHOD_27 ( ( TYPE_42 ) VAR_215 ) ; break ; case VAR_216 : if ( VAR_217 [ VAR_218 ] . VAR_219 & VAR_220 ) goto VAR_221 ; ( TYPE_43 ) METHOD_28 ( & VAR_222 , & VAR_223 [ VAR_224 ] , sizeof ( VAR_225 ) ) ; VAR_226 [ VAR_227 ] . VAR_228 = METHOD_29 ( ( TYPE_44 ) VAR_229 ) ; break ; case VAR_230 : if ( VAR_231 [ VAR_232 ] . VAR_233 & VAR_234 ) goto VAR_235 ; ( TYPE_45 ) METHOD_30 ( & VAR_236 , & VAR_237 [ VAR_238 ] , sizeof ( VAR_239 ) ) ; VAR_240 = METHOD_31 ( VAR_241 ) ; METHOD_32 ( & VAR_242 [ VAR_243 ] . VAR_244 , & VAR_245 , sizeof ( VAR_246 [ VAR_247 ] . VAR_248 ) ) ; break ; case VAR_249 : if ( VAR_250 [ VAR_251 ] . VAR_252 & VAR_253 ) goto VAR_254 ; ( TYPE_46 ) METHOD_33 ( & VAR_255 , & VAR_256 [ VAR_257 ] , sizeof ( VAR_258 ) ) ; VAR_259 = METHOD_34 ( ( TYPE_47 ) VAR_260 ) ; METHOD_35 ( & VAR_261 [ VAR_262 ] . VAR_263 , & VAR_264 , sizeof ( VAR_265 [ VAR_266 ] . VAR_267 ) ) ; break ; case VAR_268 : case VAR_269 : if ( VAR_270 > 1 ) { TYPE_48 VAR_271 = VAR_272 - * VAR_273 ; if ( * VAR_274 > METHOD_36 || VAR_275 > METHOD_37 ) goto VAR_276 ; * VAR_277 += VAR_278 ; VAR_279 = CAST ( TYPE_49 * , METHOD_38 ( * VAR_280 , * VAR_281 * sizeof ( * VAR_282 ) ) ) ; if ( VAR_283 == VAR_284 ) goto VAR_285 ; * VAR_286 = VAR_287 ; VAR_288 = * VAR_289 + VAR_290 ; } METHOD_39 ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , VAR_291 ) ) ; for ( VAR_292 = 0 ; VAR_293 < VAR_294 ; VAR_295 ++ , VAR_296 ++ ) { TYPE_50 VAR_297 = METHOD_40 ( VAR_298 , VAR_299 ) ; VAR_300 [ VAR_301 ] . VAR_302 . VAR_303 = VAR_304 ; VAR_305 [ VAR_306 ] . VAR_307 . VAR_308 = ( const TYPE_51 * ) ( const TYPE_52 * ) ( & VAR_309 [ VAR_310 + sizeof ( VAR_311 ) ] ) ; METHOD_41 ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , VAR_312 , METHOD_42 ( VAR_313 , sizeof ( VAR_314 ) ) , VAR_315 [ VAR_316 ] . VAR_317 . VAR_318 ) ) ; if ( VAR_319 & 1 ) VAR_320 ++ ; VAR_321 += VAR_322 >> 1 ; if ( VAR_323 + VAR_324 >= VAR_325 ) goto VAR_326 ; VAR_327 = VAR_328 * sizeof ( TYPE_53 ) ; } VAR_329 -- ; break ; case VAR_330 : if ( VAR_331 [ VAR_332 ] . VAR_333 & VAR_334 ) goto VAR_335 ; ( TYPE_54 ) METHOD_43 ( & VAR_336 , & VAR_337 [ VAR_338 ] , sizeof ( VAR_339 ) ) ; VAR_340 [ VAR_341 ] . VAR_342 = METHOD_44 ( ( TYPE_55 ) VAR_343 ) ; break ; case VAR_344 : if ( VAR_345 [ VAR_346 ] . VAR_347 & VAR_348 ) goto VAR_349 ; break ; default : VAR_350 : METHOD_45 ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , VAR_351 [ VAR_352 ] . VAR_353 ) ) ; break ; } } return 0 ; VAR_354 : METHOD_46 ( * VAR_355 ) ; return - 1 ; }","<S2SV_ModStart> ++ ) { TYPE_48 VAR_356 = METHOD_40 ( VAR_133 , ( VAR_352 << 1 ) + 1 ) ; <S2SV_ModStart> ) VAR_133 + VAR_356 <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( TYPE_53 ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , VAR_352 , <S2SV_ModEnd> VAR_351 [ VAR_352 <S2SV_ModStart> - VAR_133 , VAR_90 <S2SV_ModEnd> ) ) ;","CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ;   CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ;   CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;"
636,"CWE-787 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; <S2SV_StartBug> TYPE_3 VAR_2 [ VAR_3 ] ; <S2SV_EndBug> TYPE_4 VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 , VAR_9 , VAR_10 , VAR_11 ; TYPE_5 * VAR_12 ; METHOD_1 ( ""selReadStream"" ) ; if ( ! VAR_13 ) return ( TYPE_6 * ) METHOD_2 ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , VAR_14 , VAR_15 ) ; if ( METHOD_3 ( VAR_16 , ""<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n"" , & VAR_17 ) != 1 ) return ( TYPE_7 * ) METHOD_4 ( ""not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file"" , VAR_18 , VAR_19 ) ; if ( VAR_20 != VAR_21 ) return ( TYPE_8 * ) METHOD_5 ( ""invalid<S2SV_blank>sel<S2SV_blank>version"" , VAR_22 , VAR_23 ) ; <S2SV_StartBug> if ( METHOD_6 ( VAR_24 , VAR_25 , VAR_26 ) == VAR_27 ) <S2SV_EndBug> return ( TYPE_9 * ) METHOD_7 ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , VAR_28 , VAR_29 ) ; VAR_30 = METHOD_8 ( VAR_31 ) ; <S2SV_StartBug> METHOD_9 ( VAR_32 , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , VAR_33 ) ; <S2SV_EndBug> if ( METHOD_10 ( VAR_34 , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n"" , & VAR_35 , & VAR_36 , & VAR_37 , & VAR_38 ) != 4 ) { METHOD_11 ( VAR_39 ) ; return ( TYPE_10 * ) METHOD_12 ( ""dimensions<S2SV_blank>not<S2SV_blank>read"" , VAR_40 , VAR_41 ) ; } if ( ( VAR_42 = METHOD_13 ( VAR_43 , VAR_44 , VAR_45 ) ) == VAR_46 ) { METHOD_14 ( VAR_47 ) ; return ( TYPE_11 * ) METHOD_15 ( ""sel<S2SV_blank>not<S2SV_blank>made"" , VAR_48 , VAR_49 ) ; } METHOD_16 ( VAR_50 , VAR_51 , VAR_52 ) ; for ( VAR_53 = 0 ; VAR_54 < VAR_55 ; VAR_56 ++ ) { VAR_57 = METHOD_17 ( VAR_58 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( VAR_59 = 0 ; VAR_60 < VAR_61 ; VAR_62 ++ ) VAR_63 = METHOD_18 ( VAR_64 , ""%1d"" , & VAR_65 -> VAR_66 [ VAR_67 ] [ VAR_68 ] ) ; VAR_69 = METHOD_19 ( VAR_70 , ""\\n"" ) ; } VAR_71 = METHOD_20 ( VAR_72 , ""\\n"" ) ; METHOD_21 ( VAR_73 ) ; return VAR_74 ; }","<S2SV_ModStart> TYPE_3 VAR_32 [ VAR_75 <S2SV_ModEnd> ] ; TYPE_4 <S2SV_ModStart> ( VAR_32 , VAR_75 <S2SV_ModEnd> , VAR_72 ) <S2SV_ModStart> ( VAR_32 , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> , VAR_73 )","CWE-787 SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( ""selReadStream"" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file"" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( ""invalid<S2SV_blank>sel<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n"" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""dimensions<S2SV_blank>not<S2SV_blank>read"" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""sel<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , ""%1d"" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , ""\\n"" ) ; } ignore = fscanf ( fp , ""\\n"" ) ; LEPT_FREE ( selname ) ; return sel ; }","<S2SV_ModStart> char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> , selname )"
637,"CWE-20 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_1 * VAR_1 = VAR_2 -> VAR_3 ; <S2SV_EndBug> <S2SV_StartBug> if ( METHOD_1 ( VAR_4 ) ) { <S2SV_EndBug> METHOD_2 ( ) ; METHOD_3 ( VAR_5 ) ; if ( METHOD_4 ( VAR_6 ) ) <S2SV_StartBug> METHOD_5 ( VAR_7 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_6 ( ) ; <S2SV_EndBug> METHOD_7 ( VAR_8 ) ; } METHOD_8 ( & VAR_9 -> VAR_10 ) ; METHOD_9 ( VAR_11 -> VAR_12 , METHOD_10 ( & VAR_13 -> VAR_14 ) == 0 ) ; METHOD_11 ( & VAR_15 -> VAR_16 ) ; if ( VAR_17 -> VAR_18 ) METHOD_12 ( VAR_19 -> VAR_20 , VAR_21 ) ; METHOD_13 ( VAR_22 -> VAR_23 ) ; METHOD_14 ( VAR_24 ) ; METHOD_15 ( VAR_25 -> VAR_26 ) ; }",<S2SV_ModStart> VAR_25 ) { <S2SV_ModEnd> if ( METHOD_1 <S2SV_ModStart> ( METHOD_1 ( VAR_25 -> <S2SV_ModEnd> VAR_26 ) ) <S2SV_ModStart> VAR_26 ) ) METHOD_16 <S2SV_ModEnd> ( VAR_25 ) <S2SV_ModStart> VAR_25 ) ; <S2SV_ModEnd> METHOD_8 ( &,"CWE-20 void xenvif_disconnect ( struct xenvif * vif ) { <S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) ) <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }",<S2SV_ModStart> vif ) { <S2SV_ModEnd> if ( netif_carrier_ok <S2SV_ModStart> ( netif_carrier_ok ( vif -> <S2SV_ModEnd> dev ) ) <S2SV_ModStart> dev ) ) xenvif_carrier_off <S2SV_ModEnd> ( vif ) <S2SV_ModStart> vif ) ; <S2SV_ModEnd> atomic_dec ( &
638,"CWE-326 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 , <S2SV_EndBug> const struct STRUCT_OR_UNION_2 * VAR_1 , const struct STRUCT_OR_UNION_3 * VAR_2 ) { <S2SV_StartBug> TYPE_2 VAR_3 , VAR_4 ; <S2SV_EndBug> <S2SV_StartBug> VAR_5 = METHOD_1 ( VAR_6 , VAR_7 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_8 = METHOD_2 ( VAR_9 , VAR_10 ) ; <S2SV_EndBug> VAR_11 ^= METHOD_3 ( STRUCT_OR_UNION_4 ) ; VAR_12 = METHOD_4 ( VAR_13 , 1 ) ; if ( METHOD_5 ( ! VAR_14 ) ) VAR_15 = 1 << 31 ; return VAR_16 ; }","<S2SV_ModStart> STRUCT_OR_UNION_4 * STRUCT_OR_UNION_4 <S2SV_ModEnd> , const struct <S2SV_ModStart> VAR_9 ) { const struct { struct STRUCT_OR_UNION_3 VAR_6 ; struct STRUCT_OR_UNION_3 VAR_9 ; } TYPE_3 ( VAR_17 ) VAR_18 = { . VAR_6 = * VAR_6 , . VAR_9 = * VAR_9 , } ; <S2SV_ModStart> , VAR_16 ; if ( METHOD_5 ( METHOD_6 ( & STRUCT_OR_UNION_4 -> VAR_19 . VAR_20 ) ) ) METHOD_7 ( & STRUCT_OR_UNION_4 -> VAR_19 . VAR_20 , sizeof ( STRUCT_OR_UNION_4 -> VAR_19 . VAR_20 ) <S2SV_ModEnd> ) ; VAR_13 <S2SV_ModStart> ; VAR_13 = METHOD_8 ( & VAR_18 , sizeof ( VAR_18 ) , & STRUCT_OR_UNION_4 -> VAR_19 . VAR_20 <S2SV_ModEnd> ) ; VAR_16","CWE-326 <S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }","<S2SV_ModStart> net * net <S2SV_ModEnd> , const struct <S2SV_ModStart> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> ) ; hash <S2SV_ModStart> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id"
639,"CWE-284 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { TYPE_1 VAR_0 ; TYPE_2 VAR_1 ; TYPE_3 METHOD_1 ; TYPE_4 VAR_2 ; VAR_3 = METHOD_2 ( VAR_4 , VAR_5 , VAR_6 ) ; if ( VAR_7 == - 1 ) { METHOD_3 ( STRUCT_OR_UNION_2 , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>ICMP6<S2SV_blank>socket."" ) ; return - VAR_8 ; } VAR_9 = 1 ; VAR_10 = METHOD_4 ( VAR_11 , VAR_12 , VAR_13 , & VAR_14 , sizeof ( VAR_15 ) ) ; if ( VAR_16 == - 1 ) { METHOD_5 ( STRUCT_OR_UNION_3 , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVPKTINFO."" ) ; METHOD_6 = - VAR_17 ; goto VAR_18 ; } VAR_19 = 255 ; VAR_20 = METHOD_7 ( VAR_21 , VAR_22 , VAR_23 , & VAR_24 , sizeof ( VAR_25 ) ) ; if ( VAR_26 == - 1 ) { <S2SV_StartBug> METHOD_8 ( STRUCT_OR_UNION_4 , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> METHOD_9 = - VAR_27 ; goto VAR_28 ; } STRUCT_OR_UNION_5 -> VAR_29 = VAR_30 ; return 0 ; VAR_31 : METHOD_10 ( VAR_32 ) ; return METHOD_11 ; }","<S2SV_ModStart> STRUCT_OR_UNION_5 , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; METHOD_11 = - VAR_27 ; goto VAR_31 ; } VAR_25 = 1 ; VAR_26 = METHOD_7 ( VAR_32 , VAR_22 , VAR_33 , & VAR_25 , sizeof ( VAR_25 ) ) ; if ( VAR_26 == - 1 ) { METHOD_11 ( STRUCT_OR_UNION_5 , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,.""","CWE-284 static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>ICMP6<S2SV_blank>socket."" ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVPKTINFO."" ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }","<S2SV_ModStart> ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."""
640,CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { METHOD_1 ( & VAR_1 ) ; <S2SV_StartBug> METHOD_2 ( & VAR_2 -> VAR_3 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_3 ( & VAR_4 -> VAR_5 ) ; <S2SV_EndBug> METHOD_4 ( & VAR_6 ) ; METHOD_5 ( & VAR_7 -> VAR_8 . VAR_9 ) ; VAR_10 -> VAR_11 = 1 ; METHOD_6 ( & VAR_12 -> VAR_13 ) ; METHOD_7 ( & VAR_14 -> VAR_15 . VAR_16 ) ; },<S2SV_ModStart> VAR_6 ) ; METHOD_8 <S2SV_ModEnd> ( & VAR_14 <S2SV_ModStart> VAR_3 ) ; METHOD_8 <S2SV_ModEnd> ( & VAR_14,CWE-000 void pin_remove ( struct fs_pin * pin ) { spin_lock ( & pin_lock ) ; <S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> spin_unlock ( & pin_lock ) ; spin_lock_irq ( & pin -> wait . lock ) ; pin -> done = 1 ; wake_up_locked ( & pin -> wait ) ; spin_unlock_irq ( & pin -> wait . lock ) ; },<S2SV_ModStart> pin_lock ) ; hlist_del_init <S2SV_ModEnd> ( & pin <S2SV_ModStart> m_list ) ; hlist_del_init <S2SV_ModEnd> ( & pin
641,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { <S2SV_StartBug> TYPE_5 * VAR_4 = & VAR_5 -> VAR_6 ; <S2SV_EndBug> TYPE_6 * const VAR_7 = & VAR_8 -> VAR_9 ; <S2SV_StartBug> TYPE_7 VAR_10 ; <S2SV_EndBug> TYPE_8 VAR_11 = VAR_12 -> VAR_13 ; <S2SV_StartBug> TYPE_9 VAR_14 = VAR_15 ; <S2SV_EndBug> TYPE_10 VAR_16 = { 0 , 0 } ; TYPE_11 VAR_17 ; TYPE_12 * VAR_18 = & VAR_19 -> VAR_20 . VAR_21 [ 0 ] -> VAR_22 [ 0 ] . VAR_23 [ 0 ] . VAR_24 ; struct STRUCT_OR_UNION_0 VAR_25 = VAR_26 -> VAR_27 [ 0 ] . VAR_28 ; struct STRUCT_OR_UNION_1 VAR_29 = VAR_30 -> VAR_31 [ 0 ] . VAR_32 [ 0 ] ; VAR_33 . VAR_34 = VAR_35 . VAR_36 >> 3 ; VAR_37 . VAR_38 = VAR_39 . VAR_40 >> 3 ; VAR_41 -> VAR_42 [ 0 ] . VAR_43 . VAR_44 = VAR_45 ; VAR_46 -> VAR_47 [ 0 ] . VAR_48 . VAR_49 = VAR_50 ; VAR_51 -> VAR_52 [ 0 ] . VAR_53 [ 0 ] . VAR_54 = VAR_55 ; VAR_56 -> VAR_57 [ 0 ] . VAR_58 [ 0 ] . VAR_59 = VAR_60 ; <S2SV_StartBug> if ( VAR_61 -> VAR_62 < 8 ) <S2SV_EndBug> VAR_63 = VAR_64 -> VAR_65 . VAR_66 + ( ( VAR_67 -> VAR_68 > 5 ) ? 1 : 0 ) ; else VAR_69 = VAR_70 -> VAR_71 . VAR_72 + 2 ; <S2SV_StartBug> VAR_73 = METHOD_1 ( VAR_74 , ( VAR_75 -> VAR_76 . VAR_77 - 2 ) ) ; <S2SV_EndBug> METHOD_2 ( VAR_78 , & VAR_79 , VAR_80 , VAR_81 , 1 , <S2SV_StartBug> & VAR_82 -> VAR_83 [ VAR_84 ] , 0 , & VAR_85 , VAR_86 ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> TYPE_13 VAR_87 ; unsigned TYPE_14 VAR_88 ; VAR_89 = VAR_90 -> METHOD_3 ( VAR_91 , VAR_92 , & VAR_93 , VAR_94 -> VAR_95 . VAR_96 , VAR_97 -> VAR_98 , & VAR_99 -> VAR_100 [ VAR_101 ] , 0 , VAR_102 -> VAR_103 . VAR_104 , VAR_105 , VAR_106 , & VAR_107 , & VAR_108 ) ; } VAR_109 -> VAR_110 [ 0 ] . VAR_111 = VAR_112 ; VAR_113 -> VAR_114 [ 0 ] . VAR_115 [ 0 ] = VAR_116 ; return VAR_117 ; }","<S2SV_ModStart> { TYPE_5 * const VAR_109 = & VAR_102 -> VAR_118 . <S2SV_ModEnd> VAR_6 ; TYPE_6 <S2SV_ModStart> -> VAR_20 ; const TYPE_15 * const VAR_119 = & VAR_102 -> VAR_103 . VAR_120 ; <S2SV_ModStart> VAR_117 = VAR_15 ; TYPE_14 VAR_107 ; unsigned TYPE_14 VAR_108 ; TYPE_14 VAR_121 [ 5 ] <S2SV_ModStart> = VAR_60 ; VAR_80 = VAR_119 -> VAR_72 ; VAR_80 = METHOD_1 ( VAR_80 , VAR_122 <S2SV_ModEnd> - 2 ) <S2SV_ModStart> - 2 ) <S2SV_ModEnd> ; METHOD_2 ( <S2SV_ModStart> , 1 , METHOD_4 ( VAR_102 , VAR_121 ) , <S2SV_ModStart> VAR_92 ) ; VAR_117 = VAR_102 -> METHOD_3 ( VAR_109 , VAR_92 , & VAR_93 , VAR_102 -> VAR_95 . VAR_96 , VAR_109 -> VAR_98 , & VAR_102 -> VAR_100 [ VAR_101 ] , 0 , VAR_119 -> VAR_104 , METHOD_4 ( VAR_102 , VAR_121 ) , VAR_106 , VAR_106 , & VAR_107 , & VAR_108 , VAR_106 , 0 , 0 ) ; <S2SV_ModEnd> VAR_109 -> VAR_114","CWE-119 static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> int step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int distortion ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , & sse ) ; } x -> plane [ 0 ] . src = src ; xd -> plane [ 0 ] . pre [ 0 ] = pre ; return bestsme ; }","<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; MACROBLOCKD <S2SV_ModStart> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> - 2 ) <S2SV_ModStart> - 2 ) <S2SV_ModEnd> ; vp9_hex_search ( <S2SV_ModStart> , 1 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> x -> plane"
642,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 = ( struct STRUCT_OR_UNION_4 * ) STRUCT_OR_UNION_5 ; struct STRUCT_OR_UNION_6 * VAR_0 ; struct STRUCT_OR_UNION_7 * VAR_1 ; TYPE_1 VAR_2 , VAR_3 ; VAR_4 = METHOD_1 ( STRUCT_OR_UNION_8 -> STRUCT_OR_UNION_9 . VAR_5 , STRUCT_OR_UNION_10 -> STRUCT_OR_UNION_11 . VAR_6 ) ; VAR_7 = METHOD_2 ( VAR_8 , STRUCT_OR_UNION_12 -> STRUCT_OR_UNION_13 . VAR_9 ) ; if ( ! VAR_10 ) { METHOD_3 ( STRUCT_OR_UNION_14 , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; return - VAR_11 ; } <S2SV_StartBug> VAR_12 = METHOD_4 ( VAR_13 -> VAR_14 [ 0 ] . VAR_15 . VAR_16 ) ; <S2SV_EndBug> VAR_17 = METHOD_5 ( STRUCT_OR_UNION_15 , VAR_18 , VAR_19 ) ; if ( VAR_20 < 0 ) return VAR_21 ; VAR_22 = STRUCT_OR_UNION_16 -> VAR_23 -> METHOD_6 ( STRUCT_OR_UNION_17 ) ; if ( VAR_24 < 0 ) goto VAR_25 ; VAR_26 = METHOD_7 ( STRUCT_OR_UNION_18 , VAR_27 , 1 ) ; VAR_28 : if ( VAR_29 < 0 ) METHOD_8 ( STRUCT_OR_UNION_19 , VAR_30 , ""Starting<S2SV_blank>stream<S2SV_blank>failed\\n"" ) ; else METHOD_9 ( STRUCT_OR_UNION_20 , VAR_31 , ""Started<S2SV_blank>streaming\\n"" ) ; return ( VAR_32 < 0 ) ? VAR_33 : 0 ; }",<S2SV_ModStart> VAR_11 ; } if ( VAR_13 -> VAR_15 . VAR_34 < 1 ) return - VAR_35 ;,"CWE-476 static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; return - EIO ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , ""Starting<S2SV_blank>stream<S2SV_blank>failed\\n"" ) ; else gspca_dbg ( gspca_dev , D_STREAM , ""Started<S2SV_blank>streaming\\n"" ) ; return ( err < 0 ) ? err : 0 ; }",<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
643,"CWE-264 static struct STRUCT_OR_UNION_0 * METHOD_0 ( struct STRUCT_OR_UNION_1 * VAR_0 , struct STRUCT_OR_UNION_2 * VAR_1 ) { TYPE_0 VAR_2 = - VAR_3 , VAR_4 ; struct STRUCT_OR_UNION_3 * VAR_5 ; VAR_6 = METHOD_1 ( ) ; <S2SV_StartBug> VAR_7 = METHOD_2 ( VAR_8 , VAR_9 -> VAR_10 ) ; <S2SV_EndBug> if ( VAR_11 ) { METHOD_3 ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)"" , VAR_12 -> VAR_13 ) ; METHOD_4 ( VAR_14 ) ; METHOD_5 ( & VAR_15 -> VAR_16 ) ; VAR_17 = METHOD_6 ( VAR_18 , VAR_19 ) ; if ( VAR_20 ) { METHOD_7 ( & VAR_21 -> VAR_22 ) ; METHOD_8 ( VAR_23 ) ; METHOD_9 ( VAR_24 ) ; return METHOD_10 ( VAR_25 ) ; } if ( VAR_26 -> VAR_27 ) { METHOD_11 ( 1 , ""Session<S2SV_blank>needs<S2SV_blank>reconnect"" ) ; VAR_28 = METHOD_12 ( VAR_29 , VAR_30 , VAR_31 -> VAR_32 ) ; if ( VAR_33 ) { METHOD_13 ( & VAR_34 -> VAR_35 ) ; METHOD_14 ( VAR_36 ) ; METHOD_15 ( VAR_37 ) ; return METHOD_16 ( VAR_38 ) ; } } METHOD_17 ( & VAR_39 -> VAR_40 ) ; METHOD_18 ( VAR_41 ) ; return VAR_42 ; } METHOD_19 ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found"" ) ; VAR_43 = METHOD_20 ( ) ; if ( VAR_44 == VAR_45 ) goto VAR_46 ; VAR_47 -> VAR_48 = VAR_49 ; if ( VAR_50 -> VAR_51 . VAR_52 . VAR_53 == VAR_54 ) METHOD_21 ( VAR_55 -> VAR_56 , ""%pI6"" , & VAR_57 -> VAR_58 . VAR_59 . VAR_60 ) ; else METHOD_22 ( VAR_61 -> VAR_62 , ""%pI4"" , & VAR_63 -> VAR_64 . VAR_65 . VAR_66 . VAR_67 ) ; if ( VAR_68 -> VAR_69 ) METHOD_23 ( VAR_70 -> VAR_71 , VAR_72 -> VAR_73 , VAR_74 ) ; if ( VAR_75 -> VAR_76 ) { VAR_77 -> VAR_78 = METHOD_24 ( VAR_79 -> VAR_80 , VAR_81 ) ; if ( ! VAR_82 -> VAR_83 ) goto VAR_84 ; } if ( VAR_85 -> VAR_86 ) { TYPE_1 VAR_87 = METHOD_25 ( VAR_88 -> VAR_89 ) ; VAR_90 -> VAR_91 = METHOD_26 ( VAR_92 + 1 , VAR_93 ) ; if ( VAR_94 -> VAR_95 ) METHOD_27 ( VAR_96 -> VAR_97 , VAR_98 -> VAR_99 ) ; } VAR_100 -> VAR_101 = VAR_102 -> VAR_103 ; VAR_104 -> VAR_105 = VAR_106 -> VAR_107 ; METHOD_28 ( & VAR_108 -> VAR_109 ) ; VAR_110 = METHOD_29 ( VAR_111 , VAR_112 ) ; if ( ! VAR_113 ) VAR_114 = METHOD_30 ( VAR_115 , VAR_116 , VAR_117 -> VAR_118 ) ; METHOD_31 ( & VAR_119 -> VAR_120 ) ; if ( VAR_121 ) goto VAR_122 ; METHOD_32 ( & VAR_123 ) ; METHOD_33 ( & VAR_124 -> VAR_125 , & VAR_126 -> VAR_127 ) ; METHOD_34 ( & VAR_128 ) ; METHOD_35 ( VAR_129 ) ; return VAR_130 ; VAR_131 : METHOD_36 ( VAR_132 ) ; METHOD_37 ( VAR_133 ) ; return METHOD_38 ( VAR_134 ) ; }","<S2SV_ModStart> VAR_126 , VAR_117 <S2SV_ModEnd> ) ; if","CWE-264 static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)"" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , ""Session<S2SV_blank>needs<S2SV_blank>reconnect"" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found"" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , ""%pI6"" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , ""%pI4"" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }","<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if"
644,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { if ( VAR_4 ) { TYPE_5 VAR_5 = ( VAR_6 + 15 ) & ~ 15 ; TYPE_6 VAR_7 = ( VAR_8 + 15 ) & ~ 15 ; TYPE_7 VAR_9 = ( ( VAR_10 + 2 * VAR_11 ) + 31 ) & ~ 31 ; TYPE_8 VAR_12 = ( VAR_13 + 2 * VAR_14 ) * VAR_15 ; TYPE_9 VAR_16 = VAR_17 >> 1 ; TYPE_10 VAR_18 = VAR_19 >> 1 ; TYPE_11 VAR_20 = VAR_21 >> 1 ; TYPE_12 VAR_22 = ( VAR_23 + VAR_24 ) * VAR_25 ; const TYPE_13 VAR_26 = VAR_27 + 2 * VAR_28 ; if ( ! VAR_29 -> VAR_30 ) { VAR_31 -> VAR_32 = ( TYPE_14 * ) METHOD_1 ( 32 , VAR_33 ) ; VAR_34 -> VAR_35 = VAR_36 ; } if ( ! VAR_37 -> VAR_38 || VAR_39 -> VAR_40 < VAR_41 ) return - 1 ; if ( VAR_42 & 0x1f ) return - 3 ; VAR_43 -> VAR_44 = VAR_45 ; VAR_46 -> VAR_47 = VAR_48 ; VAR_49 -> VAR_50 = VAR_51 ; VAR_52 -> VAR_53 = VAR_54 ; VAR_55 -> VAR_56 = VAR_57 ; <S2SV_StartBug> VAR_58 -> VAR_59 = VAR_60 ; <S2SV_EndBug> VAR_61 -> VAR_62 = VAR_63 ; VAR_64 -> VAR_65 = VAR_66 ; VAR_67 -> VAR_68 = 0 ; VAR_69 -> VAR_70 = 0 ; VAR_71 -> VAR_72 = 0 ; VAR_73 -> VAR_74 = VAR_75 ; VAR_76 -> VAR_77 = VAR_78 ; VAR_79 -> VAR_80 = VAR_81 -> VAR_82 + ( VAR_83 * VAR_84 ) + VAR_85 ; VAR_86 -> VAR_87 = VAR_88 -> VAR_89 + VAR_90 + ( VAR_91 / 2 * VAR_92 ) + VAR_93 / 2 ; VAR_94 -> VAR_95 = VAR_96 -> VAR_97 + VAR_98 + VAR_99 + ( VAR_100 / 2 * VAR_101 ) + VAR_102 / 2 ; VAR_103 -> VAR_104 = VAR_105 ; VAR_106 -> VAR_107 = 0 ; return 0 ; } return - 2 ; }",<S2SV_ModStart> ; VAR_106 -> VAR_108 = ( VAR_45 + 1 ) / 2 ; VAR_106 -> VAR_109 = ( VAR_48 + 1 ) / 2 ; VAR_106 ->,"CWE-119 int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + ( border * y_stride ) + border ; ybf -> u_buffer = ybf -> buffer_alloc + yplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> v_buffer = ybf -> buffer_alloc + yplane_size + uvplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> alpha_buffer = NULL ; ybf -> corrupted = 0 ; return 0 ; } return - 2 ; }",<S2SV_ModStart> ; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->
645,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = METHOD_1 ( VAR_2 ) ; TYPE_1 VAR_3 ; METHOD_2 ( VAR_4 ) ; METHOD_3 ( & VAR_5 -> VAR_6 ) ; if ( METHOD_4 ( VAR_7 , VAR_8 ) || ! METHOD_5 ( VAR_9 , VAR_10 ) ) { struct STRUCT_OR_UNION_2 VAR_11 = { . VAR_12 = VAR_13 , } ; METHOD_6 ( VAR_14 , & VAR_15 ) ; } <S2SV_StartBug> METHOD_7 ( VAR_16 ) ; <S2SV_EndBug> if ( METHOD_8 ( VAR_17 ) && ! VAR_18 -> VAR_19 ) { struct STRUCT_OR_UNION_3 VAR_20 = { . VAR_21 = VAR_22 | VAR_23 , } ; METHOD_9 ( VAR_24 , & VAR_25 ) ; } METHOD_10 ( VAR_26 ) ; METHOD_11 ( VAR_27 , VAR_28 ) ; METHOD_12 ( VAR_29 ) ; METHOD_13 ( & VAR_30 -> VAR_31 ) ; METHOD_14 ( VAR_32 ) ; METHOD_15 ( VAR_33 -> VAR_34 ) ; METHOD_16 ( VAR_35 -> VAR_36 ) ; METHOD_17 ( VAR_37 ) ; METHOD_18 ( VAR_38 ) ; METHOD_19 ( VAR_39 -> VAR_40 ) ; METHOD_20 ( VAR_41 ) ; VAR_42 -> VAR_43 = VAR_44 ; if ( VAR_45 -> VAR_46 ) METHOD_21 ( VAR_47 -> VAR_48 ) ; METHOD_22 ( VAR_49 -> VAR_50 ) ; METHOD_23 ( VAR_51 ) ; METHOD_24 ( VAR_52 -> VAR_53 ) ; TYPE_2 TYPE_3 for ( VAR_54 = 0 ; VAR_55 < VAR_56 ; VAR_57 ++ ) METHOD_25 ( VAR_58 -> VAR_59 [ VAR_60 ] ) ; METHOD_26 ( VAR_61 ) ; for ( VAR_62 = 0 ; VAR_63 < VAR_64 ; VAR_65 ++ ) METHOD_27 ( VAR_66 -> VAR_67 [ VAR_68 ] ) ; METHOD_28 ( VAR_69 ) ; }","<S2SV_ModStart> METHOD_7 ( VAR_69 , VAR_28","CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ;  ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ;   destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true"
646,"CWE-347 TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , unsigned TYPE_2 VAR_2 , TYPE_3 * * VAR_3 , TYPE_4 VAR_4 , const TYPE_5 * VAR_5 , TYPE_6 VAR_6 ) { unsigned TYPE_7 VAR_7 ; { TYPE_8 VAR_8 ; TYPE_9 VAR_9 ; METHOD_1 ( & VAR_10 , VAR_11 , VAR_12 ) ; VAR_13 . METHOD_2 ( & VAR_14 , & VAR_15 , & VAR_16 -> VAR_17 , & VAR_18 -> VAR_19 ) ; VAR_20 = METHOD_3 ( & VAR_21 , VAR_22 ) ; if ( VAR_23 < VAR_24 ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } METHOD_4 ( VAR_25 , VAR_26 . VAR_27 , VAR_28 ) ; METHOD_5 ( VAR_29 . VAR_30 ) ; METHOD_6 ( & VAR_31 ) ; } VAR_32 = VAR_33 - 3 - VAR_34 ; METHOD_7 ( VAR_35 , METHOD_8 ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , VAR_36 , VAR_37 ) ) ; METHOD_9 ( VAR_38 , METHOD_10 ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , VAR_39 , ( TYPE_10 ) VAR_40 ) ) ; if ( VAR_41 [ 0 ] != 0x00 || VAR_42 [ 1 ] != 0x01 || VAR_43 [ VAR_44 + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } <S2SV_StartBug> VAR_45 += VAR_46 + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * VAR_47 ) = VAR_48 ; <S2SV_EndBug> return VAR_49 ; }","<S2SV_ModStart> ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } ( * VAR_47 ) = VAR_48 + <S2SV_ModEnd> VAR_46 + 3 <S2SV_ModStart> + 3 ; { const TYPE_5 * VAR_50 ; TYPE_6 VAR_51 = 0 ; for ( VAR_50 = VAR_48 + 2 ; VAR_50 < VAR_48 + VAR_46 + 2 ; VAR_50 ++ ) if ( * VAR_50 == 0xFF ) VAR_51 ++ ; if ( VAR_51 != VAR_46 ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> return VAR_49 ;","CWE-347 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }","<S2SV_ModStart> ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> return NULL ;"
647,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { TYPE_6 VAR_5 , VAR_6 , VAR_7 ; TYPE_7 VAR_8 = VAR_9 -> VAR_10 , VAR_11 ; TYPE_8 VAR_12 ; if ( VAR_13 < 0x280 ) { METHOD_1 ( VAR_14 -> VAR_15 , VAR_16 , ""buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>640).\\n"" , VAR_17 ) ; return VAR_18 ; } VAR_19 = METHOD_2 ( VAR_20 ) ; if ( VAR_21 == 0 ) { METHOD_3 ( VAR_22 -> VAR_23 , VAR_24 , ""unknown<S2SV_blank>header<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X\\n"" , VAR_25 [ 0 ] , VAR_26 [ 1 ] , VAR_27 [ 2 ] , VAR_28 [ 3 ] , VAR_29 [ 4 ] ) ; return VAR_30 ; } if ( VAR_31 [ 5 ] & 2 ) { VAR_32 -> VAR_33 = VAR_34 [ 5 ] & 1 ; VAR_35 -> VAR_36 = 1 ; VAR_37 -> VAR_38 = VAR_39 ^ VAR_40 -> VAR_41 ; METHOD_4 ( VAR_42 -> VAR_43 , VAR_44 , ""interlaced<S2SV_blank>%d,<S2SV_blank>cur<S2SV_blank>field<S2SV_blank>%d\\n"" , VAR_45 [ 5 ] & 3 , VAR_46 -> VAR_47 ) ; } else { VAR_48 -> VAR_49 = 0 ; } VAR_50 -> VAR_51 = ( VAR_52 [ 0x6 ] >> 5 ) & 1 ; VAR_53 -> VAR_54 = METHOD_5 ( VAR_55 + 0x18 ) ; VAR_56 -> VAR_57 = METHOD_6 ( VAR_58 + 0x1a ) ; switch ( VAR_59 [ 0x21 ] >> 5 ) { case 1 : VAR_60 = 8 ; break ; case 2 : VAR_61 = 10 ; break ; case 3 : VAR_62 = 12 ; break ; default : METHOD_7 ( VAR_63 -> VAR_64 , VAR_65 , ""Unknown<S2SV_blank>bitdepth<S2SV_blank>indicator<S2SV_blank>(%d)\\n"" , VAR_66 [ 0x21 ] >> 5 ) ; return VAR_67 ; } VAR_68 = METHOD_8 ( VAR_69 + 0x28 ) ; VAR_70 -> VAR_71 -> VAR_72 = METHOD_9 ( VAR_73 ) ; if ( ( VAR_74 = METHOD_10 ( VAR_75 , VAR_76 , VAR_77 ) ) < 0 ) return VAR_78 ; if ( VAR_79 -> VAR_80 && VAR_81 -> VAR_82 -> VAR_83 != 1260 ) METHOD_11 ( VAR_84 -> VAR_85 , VAR_86 , ""Adaptive<S2SV_blank>MB<S2SV_blank>interlace<S2SV_blank>flag<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n"" ) ; VAR_87 -> VAR_88 = VAR_89 [ 0x2C ] & 7 ; if ( VAR_90 -> VAR_91 && VAR_92 -> VAR_93 -> VAR_94 != 1256 && VAR_95 -> VAR_96 -> VAR_97 != 1270 ) METHOD_12 ( VAR_98 -> VAR_99 , VAR_100 , ""Adaptive<S2SV_blank>color<S2SV_blank>transform<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n"" ) ; VAR_101 -> VAR_102 = ( VAR_103 [ 0x2C ] >> 6 ) & 1 ; if ( VAR_104 -> VAR_105 ) { if ( VAR_106 == 8 ) { METHOD_13 ( VAR_107 -> VAR_108 , ""4:4:4<S2SV_blank>8<S2SV_blank>bits"" ) ; return VAR_109 ; } else if ( VAR_110 == 10 ) { VAR_111 -> VAR_112 = VAR_113 ; VAR_114 -> VAR_115 = VAR_116 -> VAR_117 ? VAR_118 : VAR_119 ; } else { VAR_120 -> VAR_121 = VAR_122 ; VAR_123 -> VAR_124 = VAR_125 -> VAR_126 ? VAR_127 : VAR_128 ; } } else if ( VAR_129 == 12 ) { VAR_130 -> VAR_131 = VAR_132 ; VAR_133 -> VAR_134 = VAR_135 ; } else if ( VAR_136 == 10 ) { if ( VAR_137 -> VAR_138 -> VAR_139 == VAR_140 ) VAR_141 -> VAR_142 = VAR_143 ; else VAR_144 -> VAR_145 = VAR_146 ; VAR_147 -> VAR_148 = VAR_149 ; } else { VAR_150 -> VAR_151 = VAR_152 ; VAR_153 -> VAR_154 = VAR_155 ; } VAR_156 -> VAR_157 -> VAR_158 = VAR_159 -> VAR_160 = VAR_161 ; if ( VAR_162 -> VAR_163 != VAR_164 ) { METHOD_14 ( & VAR_165 -> VAR_166 , VAR_167 -> VAR_168 ) ; METHOD_15 ( & VAR_169 -> VAR_170 , VAR_171 -> VAR_172 ) ; METHOD_16 ( VAR_173 -> VAR_174 . VAR_175 , & VAR_176 -> VAR_177 , VAR_178 ) ; } if ( VAR_179 -> VAR_180 != VAR_181 -> VAR_182 -> VAR_183 && VAR_184 -> VAR_185 -> VAR_186 != VAR_187 ) { METHOD_17 ( & VAR_188 -> VAR_189 -> VAR_190 . VAR_191 , & VAR_192 -> VAR_193 -> VAR_194 . VAR_195 , VAR_196 -> VAR_197 , VAR_198 -> VAR_199 -> VAR_200 , 255 ) ; VAR_201 -> VAR_202 = VAR_203 -> VAR_204 -> VAR_205 ; } if ( VAR_206 < VAR_207 -> VAR_208 -> VAR_209 ) { METHOD_18 ( VAR_210 -> VAR_211 , VAR_212 , ""incorrect<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%u).\\n"" , VAR_213 , VAR_214 -> VAR_215 -> VAR_216 ) ; return VAR_217 ; } VAR_218 -> VAR_219 = ( VAR_220 -> VAR_221 + 15 ) >> 4 ; VAR_222 -> VAR_223 = METHOD_19 ( VAR_224 + 0x16c ) ; if ( ( VAR_225 -> VAR_226 + 15 ) >> 4 == VAR_227 -> VAR_228 && VAR_229 -> VAR_230 ) VAR_231 -> VAR_232 <<= 1 ; METHOD_20 ( VAR_233 -> VAR_234 , VAR_235 , ""%dx%d,<S2SV_blank>4:%s<S2SV_blank>%d<S2SV_blank>bits,<S2SV_blank>MBAFF=%d<S2SV_blank>ACT=%d\\n"" , VAR_236 -> VAR_237 , VAR_238 -> VAR_239 , VAR_240 -> VAR_241 ? ""4:4"" : ""2:2"" , VAR_242 -> VAR_243 , VAR_244 -> VAR_245 , VAR_246 -> VAR_247 ) ; if ( VAR_248 -> VAR_249 > 68 && METHOD_21 ( VAR_250 ) ) { VAR_251 -> VAR_252 = 0x170 + ( VAR_253 -> VAR_254 << 2 ) ; } else { <S2SV_StartBug> if ( VAR_255 -> VAR_256 > 68 || <S2SV_EndBug> ( VAR_257 -> VAR_258 << VAR_259 -> VAR_260 ) > ( VAR_261 -> VAR_262 + 15 ) >> 4 ) { METHOD_22 ( VAR_263 -> VAR_264 , VAR_265 , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , VAR_266 -> VAR_267 ) ; return VAR_268 ; } <S2SV_StartBug> VAR_269 -> VAR_270 = 0x280 ; <S2SV_EndBug> } if ( VAR_271 < VAR_272 -> VAR_273 ) { METHOD_23 ( VAR_274 -> VAR_275 , VAR_276 , ""buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%d).\\n"" , VAR_277 , VAR_278 -> VAR_279 ) ; return VAR_280 ; } if ( VAR_281 -> VAR_282 > METHOD_24 ( VAR_283 -> VAR_284 ) ) { METHOD_25 ( VAR_285 -> VAR_286 , VAR_287 , ""mb_height<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%"" SIZE_SPECIFIER "").\\n"" , VAR_288 -> VAR_289 , METHOD_26 ( VAR_290 -> VAR_291 ) ) ; return VAR_292 ; } for ( VAR_293 = 0 ; VAR_294 < VAR_295 -> VAR_296 ; VAR_297 ++ ) { VAR_298 -> VAR_299 [ VAR_300 ] = METHOD_27 ( VAR_301 + 0x170 + ( VAR_302 << 2 ) ) ; ff_dlog ( VAR_303 -> VAR_304 , ""mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>%d,<S2SV_blank>pos<S2SV_blank>%d:<S2SV_blank>%"" PRIu32 ""\\n"" , VAR_305 , 0x170 + ( VAR_306 << 2 ) , VAR_307 -> VAR_308 [ VAR_309 ] ) ; if ( VAR_310 - VAR_311 -> VAR_312 < VAR_313 -> VAR_314 [ VAR_315 ] ) { METHOD_28 ( VAR_316 -> VAR_317 , VAR_318 , ""invalid<S2SV_blank>mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>(%"" PRIu32 ""<S2SV_blank>vs<S2SV_blank>%u).\\n"" , VAR_319 -> VAR_320 [ VAR_321 ] , VAR_322 - VAR_323 -> VAR_324 ) ; return VAR_325 ; } } return 0 ; }","<S2SV_ModStart> VAR_296 > 68 ) { METHOD_28 ( VAR_323 -> VAR_317 , VAR_318 , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , VAR_323 -> VAR_296 ) ; return VAR_325 ; } VAR_323 -> VAR_324 = 0x280 ; } if ( <S2SV_ModEnd> ( VAR_323 -> <S2SV_ModStart> VAR_325 ; } <S2SV_ModEnd> if ( VAR_322","CWE-125 static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , const uint8_t * buf , int buf_size , int first_field ) { int i , cid , ret ; int old_bit_depth = ctx -> bit_depth , bitdepth ; uint64_t header_prefix ; if ( buf_size < 0x280 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>640).\\n"" , buf_size ) ; return AVERROR_INVALIDDATA ; } header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; if ( header_prefix == 0 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""unknown<S2SV_blank>header<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X\\n"" , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; return AVERROR_INVALIDDATA ; } if ( buf [ 5 ] & 2 ) { ctx -> cur_field = buf [ 5 ] & 1 ; frame -> interlaced_frame = 1 ; frame -> top_field_first = first_field ^ ctx -> cur_field ; av_log ( ctx -> avctx , AV_LOG_DEBUG , ""interlaced<S2SV_blank>%d,<S2SV_blank>cur<S2SV_blank>field<S2SV_blank>%d\\n"" , buf [ 5 ] & 3 , ctx -> cur_field ) ; } else { ctx -> cur_field = 0 ; } ctx -> mbaff = ( buf [ 0x6 ] >> 5 ) & 1 ; ctx -> height = AV_RB16 ( buf + 0x18 ) ; ctx -> width = AV_RB16 ( buf + 0x1a ) ; switch ( buf [ 0x21 ] >> 5 ) { case 1 : bitdepth = 8 ; break ; case 2 : bitdepth = 10 ; break ; case 3 : bitdepth = 12 ; break ; default : av_log ( ctx -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>bitdepth<S2SV_blank>indicator<S2SV_blank>(%d)\\n"" , buf [ 0x21 ] >> 5 ) ; return AVERROR_INVALIDDATA ; } cid = AV_RB32 ( buf + 0x28 ) ; ctx -> avctx -> profile = dnxhd_get_profile ( cid ) ; if ( ( ret = dnxhd_init_vlc ( ctx , cid , bitdepth ) ) < 0 ) return ret ; if ( ctx -> mbaff && ctx -> cid_table -> cid != 1260 ) av_log ( ctx -> avctx , AV_LOG_WARNING , ""Adaptive<S2SV_blank>MB<S2SV_blank>interlace<S2SV_blank>flag<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n"" ) ; ctx -> act = buf [ 0x2C ] & 7 ; if ( ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270 ) av_log ( ctx -> avctx , AV_LOG_WARNING , ""Adaptive<S2SV_blank>color<S2SV_blank>transform<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n"" ) ; ctx -> is_444 = ( buf [ 0x2C ] >> 6 ) & 1 ; if ( ctx -> is_444 ) { if ( bitdepth == 8 ) { avpriv_request_sample ( ctx -> avctx , ""4:4:4<S2SV_blank>8<S2SV_blank>bits"" ) ; return AVERROR_INVALIDDATA ; } else if ( bitdepth == 10 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_12_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12 ; } } else if ( bitdepth == 12 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_12 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P12 ; } else if ( bitdepth == 10 ) { if ( ctx -> avctx -> profile == FF_PROFILE_DNXHR_HQX ) ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; else ctx -> decode_dct_block = dnxhd_decode_dct_block_10 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_8 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P ; } ctx -> avctx -> bits_per_raw_sample = ctx -> bit_depth = bitdepth ; if ( ctx -> bit_depth != old_bit_depth ) { ff_blockdsp_init ( & ctx -> bdsp , ctx -> avctx ) ; ff_idctdsp_init ( & ctx -> idsp , ctx -> avctx ) ; ff_init_scantable ( ctx -> idsp . idct_permutation , & ctx -> scantable , ff_zigzag_direct ) ; } if ( ctx -> width != ctx -> cid_table -> width && ctx -> cid_table -> width != DNXHD_VARIABLE ) { av_reduce ( & ctx -> avctx -> sample_aspect_ratio . num , & ctx -> avctx -> sample_aspect_ratio . den , ctx -> width , ctx -> cid_table -> width , 255 ) ; ctx -> width = ctx -> cid_table -> width ; } if ( buf_size < ctx -> cid_table -> coding_unit_size ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""incorrect<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%u).\\n"" , buf_size , ctx -> cid_table -> coding_unit_size ) ; return AVERROR_INVALIDDATA ; } ctx -> mb_width = ( ctx -> width + 15 ) >> 4 ; ctx -> mb_height = AV_RB16 ( buf + 0x16c ) ; if ( ( ctx -> height + 15 ) >> 4 == ctx -> mb_height && frame -> interlaced_frame ) ctx -> height <<= 1 ; av_log ( ctx -> avctx , AV_LOG_VERBOSE , ""%dx%d,<S2SV_blank>4:%s<S2SV_blank>%d<S2SV_blank>bits,<S2SV_blank>MBAFF=%d<S2SV_blank>ACT=%d\\n"" , ctx -> width , ctx -> height , ctx -> is_444 ? ""4:4"" : ""2:2"" , ctx -> bit_depth , ctx -> mbaff , ctx -> act ) ; if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) { ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ; } else { <S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> } if ( buf_size < ctx -> data_offset ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%d).\\n"" , buf_size , ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } if ( ctx -> mb_height > FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb_height<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%"" SIZE_SPECIFIER "").\\n"" , ctx -> mb_height , FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < ctx -> mb_height ; i ++ ) { ctx -> mb_scan_index [ i ] = AV_RB32 ( buf + 0x170 + ( i << 2 ) ) ; ff_dlog ( ctx -> avctx , ""mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>%d,<S2SV_blank>pos<S2SV_blank>%d:<S2SV_blank>%"" PRIu32 ""\\n"" , i , 0x170 + ( i << 2 ) , ctx -> mb_scan_index [ i ] ) ; if ( buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ] ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>(%"" PRIu32 ""<S2SV_blank>vs<S2SV_blank>%u).\\n"" , ctx -> mb_scan_index [ i ] , buf_size - ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }","<S2SV_ModStart> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> AVERROR_INVALIDDATA ; } <S2SV_ModEnd> if ( buf_size"
648,"CWE-476 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 ) { struct STRUCT_OR_UNION_0 * VAR_2 ; struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 ; unsigned TYPE_3 VAR_3 ; unsigned TYPE_4 VAR_4 , VAR_5 ; unsigned TYPE_5 VAR_6 ; unsigned TYPE_6 VAR_7 ; TYPE_7 VAR_8 ; TYPE_8 VAR_9 = 1 ; METHOD_1 ( & VAR_10 , VAR_11 ) ; VAR_12 = METHOD_2 ( ) ; if ( METHOD_3 ( ~ VAR_13 & VAR_14 ) ) { METHOD_4 ( & VAR_15 , VAR_16 ) ; if ( VAR_17 ) METHOD_5 ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , VAR_18 ) ; VAR_19 = 0 ; goto VAR_20 ; } VAR_21 = METHOD_6 ( ) ; if ( VAR_22 && ( VAR_23 & VAR_24 ) ) { static unsigned TYPE_9 VAR_25 ; static unsigned TYPE_10 VAR_26 ; VAR_27 = 0 ; if ( VAR_28 & VAR_29 ) { METHOD_7 ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , VAR_30 , VAR_31 ) ; switch ( VAR_32 ) { default : if ( METHOD_8 ( VAR_33 , VAR_34 + VAR_35 / 10 ) ) { VAR_36 = VAR_37 ; break ; } case 0xfc : case 0xfd : case 0xfe : VAR_38 = VAR_39 ; VAR_40 = 0xfe ; break ; case 0xff : VAR_41 = VAR_42 ; VAR_43 = 0xfe ; break ; } } VAR_44 = VAR_45 + ( ( VAR_46 >> 6 ) & 3 ) ; VAR_47 = VAR_48 ; VAR_49 = VAR_50 ; } else { VAR_51 = ( ( VAR_52 & VAR_53 ) ? VAR_54 : 0 ) | ( ( VAR_55 & VAR_56 && ! VAR_57 ) ? VAR_58 : 0 ) ; VAR_59 = ( VAR_60 & VAR_61 ) ? VAR_62 : VAR_63 ; } VAR_64 = & VAR_65 [ VAR_66 ] ; STRUCT_OR_UNION_3 = VAR_67 -> VAR_68 ? VAR_69 -> STRUCT_OR_UNION_4 : VAR_70 ; METHOD_9 ( VAR_71 -> VAR_72 , VAR_73 , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , VAR_74 , VAR_75 , VAR_76 & VAR_77 ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , VAR_78 & VAR_79 ? "",<S2SV_blank>timeout"" : """" ) ; VAR_80 = METHOD_10 ( VAR_81 , VAR_82 , STRUCT_OR_UNION_5 ) ; METHOD_11 ( & VAR_83 , VAR_84 ) ; <S2SV_StartBug> if ( METHOD_12 ( VAR_85 -> VAR_86 && ! VAR_87 ) ) <S2SV_EndBug> METHOD_13 ( STRUCT_OR_UNION_6 , VAR_88 , VAR_89 ) ; VAR_90 : return METHOD_14 ( VAR_91 ) ; }",<S2SV_ModStart> ( METHOD_12 ( STRUCT_OR_UNION_6 <S2SV_ModEnd> && ! VAR_87,"CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }",<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
649,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , TYPE_7 * VAR_6 ) { TYPE_8 VAR_7 , VAR_8 ; TYPE_9 VAR_9 , VAR_10 , VAR_11 = 0 , VAR_12 , VAR_13 , VAR_14 ; TYPE_10 VAR_15 ; if ( VAR_16 -> VAR_17 <= 0 ) { METHOD_1 ( VAR_18 , VAR_19 , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , VAR_20 -> VAR_21 ) ; return VAR_22 ; } if ( VAR_23 = METHOD_2 ( & VAR_24 -> VAR_25 , VAR_26 -> VAR_27 , VAR_28 -> VAR_29 - 1 , VAR_30 -> VAR_31 ) ) return VAR_32 ; VAR_33 = ( VAR_34 -> VAR_35 [ 0 ] [ 1 ] - VAR_36 -> VAR_37 [ 0 ] [ 0 ] ) * ( VAR_38 -> VAR_39 [ 1 ] [ 1 ] - VAR_40 -> VAR_41 [ 1 ] [ 0 ] ) ; if ( VAR_42 -> VAR_43 == VAR_44 ) { VAR_45 -> VAR_46 = VAR_47 ; VAR_48 -> VAR_49 = METHOD_3 ( VAR_50 , sizeof ( * VAR_51 -> VAR_52 ) ) ; if ( ! VAR_53 -> VAR_54 ) return METHOD_4 ( VAR_55 ) ; } else { VAR_56 -> VAR_57 = VAR_58 ; VAR_59 -> VAR_60 = METHOD_5 ( VAR_61 , sizeof ( * VAR_62 -> VAR_63 ) ) ; if ( ! VAR_64 -> VAR_65 ) return METHOD_6 ( VAR_66 ) ; } VAR_67 -> VAR_68 = METHOD_7 ( VAR_69 -> VAR_70 , sizeof ( * VAR_71 -> VAR_72 ) ) ; if ( ! VAR_73 -> VAR_74 ) return METHOD_8 ( VAR_75 ) ; for ( VAR_76 = 0 ; VAR_77 < VAR_78 -> VAR_79 ; VAR_80 ++ ) { TYPE_11 VAR_81 = VAR_82 -> VAR_83 - VAR_84 ; TYPE_12 * VAR_85 = VAR_86 -> VAR_87 + VAR_88 ; for ( VAR_89 = 0 ; VAR_90 < 2 ; VAR_91 ++ ) for ( VAR_92 = 0 ; VAR_93 < 2 ; VAR_94 ++ ) VAR_95 -> VAR_96 [ VAR_97 ] [ VAR_98 ] = METHOD_9 ( VAR_99 -> VAR_100 [ VAR_101 ] [ VAR_102 ] , VAR_103 - 1 ) ; VAR_104 -> VAR_105 = VAR_106 -> VAR_107 [ VAR_108 ] ; VAR_109 -> VAR_110 = VAR_111 -> VAR_112 [ VAR_113 ] ; if ( VAR_114 == 0 ) VAR_115 -> VAR_116 = 1 ; else VAR_117 -> VAR_118 = 3 ; if ( VAR_119 -> VAR_120 [ 0 ] [ 1 ] == VAR_121 -> VAR_122 [ 0 ] [ 0 ] ) VAR_123 -> VAR_124 = 0 ; else VAR_125 -> VAR_126 = METHOD_10 ( VAR_127 -> VAR_128 [ 0 ] [ 1 ] , VAR_129 -> VAR_130 ) - ( VAR_131 -> VAR_132 [ 0 ] [ 0 ] >> VAR_133 -> VAR_134 ) ; if ( VAR_135 -> VAR_136 [ 1 ] [ 1 ] == VAR_137 -> VAR_138 [ 1 ] [ 0 ] ) VAR_139 -> VAR_140 = 0 ; else VAR_141 -> VAR_142 = METHOD_11 ( VAR_143 -> VAR_144 [ 1 ] [ 1 ] , VAR_145 -> VAR_146 ) - ( VAR_147 -> VAR_148 [ 1 ] [ 0 ] >> VAR_149 -> VAR_150 ) ; <S2SV_StartBug> VAR_151 -> VAR_152 = METHOD_12 ( VAR_153 -> VAR_154 , sizeof ( * VAR_155 -> VAR_156 ) ) ; <S2SV_EndBug> if ( ! VAR_157 -> VAR_158 ) return METHOD_13 ( VAR_159 ) ; for ( VAR_160 = 0 ; VAR_161 < VAR_162 -> VAR_163 ; VAR_164 ++ , VAR_165 ++ ) { TYPE_13 * VAR_166 = VAR_167 -> VAR_168 + VAR_169 ; TYPE_14 VAR_170 , VAR_171 ; TYPE_15 VAR_172 ; switch ( VAR_173 -> VAR_174 ) { TYPE_16 VAR_175 ; TYPE_17 VAR_176 ; case VAR_177 : VAR_178 -> VAR_179 = 1 ; break ; case VAR_180 : VAR_181 = VAR_182 + VAR_183 [ VAR_184 -> VAR_185 == VAR_186 ] [ VAR_187 + ( VAR_188 > 0 ) ] ; VAR_189 -> VAR_190 = METHOD_14 ( 2048 + VAR_191 -> VAR_192 [ VAR_193 ] , 2 + VAR_194 - VAR_195 -> VAR_196 [ VAR_197 ] ) ; break ; case VAR_198 : VAR_199 = VAR_200 ; VAR_201 -> VAR_202 = METHOD_15 ( 2.0 , VAR_203 - VAR_204 -> VAR_205 [ VAR_206 ] ) ; VAR_207 -> VAR_208 *= VAR_209 -> VAR_210 [ VAR_211 ] / 2048.0 + 1.0 ; break ; default : VAR_212 -> VAR_213 = 0 ; METHOD_16 ( VAR_214 , VAR_215 , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! METHOD_17 ( VAR_216 -> VAR_217 ) ) VAR_218 -> VAR_219 *= 0.5 ; VAR_220 -> VAR_221 = VAR_222 -> VAR_223 * ( 1 << 15 ) ; if ( VAR_224 == 0 ) { for ( VAR_225 = 0 ; VAR_226 < 2 ; VAR_227 ++ ) for ( VAR_228 = 0 ; VAR_229 < 2 ; VAR_230 ++ ) VAR_231 -> VAR_232 [ VAR_233 ] [ VAR_234 ] = METHOD_18 ( VAR_235 -> VAR_236 [ VAR_237 ] [ VAR_238 ] - VAR_239 -> VAR_240 [ VAR_241 ] [ 0 ] , VAR_242 - 1 ) ; VAR_243 = VAR_244 -> VAR_245 ; VAR_246 = VAR_247 -> VAR_248 ; VAR_249 -> VAR_250 = METHOD_19 ( VAR_251 -> VAR_252 , VAR_253 -> VAR_254 ) ; VAR_255 -> VAR_256 = METHOD_20 ( VAR_257 -> VAR_258 , VAR_259 -> VAR_260 ) ; } else { for ( VAR_261 = 0 ; VAR_262 < 2 ; VAR_263 ++ ) for ( VAR_264 = 0 ; VAR_265 < 2 ; VAR_266 ++ ) VAR_267 -> VAR_268 [ VAR_269 ] [ VAR_270 ] = METHOD_21 ( VAR_271 -> VAR_272 [ VAR_273 ] [ VAR_274 ] - VAR_275 -> VAR_276 [ VAR_277 ] [ 0 ] - ( ( ( VAR_278 + 1 >> VAR_279 ) & 1 ) << VAR_280 - 1 ) , VAR_281 ) ; VAR_282 -> VAR_283 = METHOD_22 ( VAR_284 -> VAR_285 , VAR_286 -> VAR_287 - 1 ) ; VAR_288 -> VAR_289 = METHOD_23 ( VAR_290 -> VAR_291 , VAR_292 -> VAR_293 - 1 ) ; VAR_294 = VAR_295 -> VAR_296 - 1 ; VAR_297 = VAR_298 -> VAR_299 - 1 ; } for ( VAR_300 = 0 ; VAR_301 < 2 ; VAR_302 ++ ) VAR_303 -> VAR_304 [ 0 ] [ VAR_305 ] = METHOD_24 ( VAR_306 -> VAR_307 [ 0 ] [ VAR_308 ] , VAR_309 ) ; for ( VAR_310 = 0 ; VAR_311 < 2 ; VAR_312 ++ ) VAR_313 -> VAR_314 [ 1 ] [ VAR_315 ] = METHOD_25 ( VAR_316 -> VAR_317 [ 1 ] [ VAR_318 ] , VAR_319 ) ; <S2SV_StartBug> VAR_320 -> VAR_321 = METHOD_26 ( VAR_322 -> VAR_323 * <S2SV_EndBug> ( TYPE_18 ) VAR_324 -> VAR_325 , sizeof ( * VAR_326 -> VAR_327 ) ) ; if ( ! VAR_328 -> VAR_329 ) return METHOD_27 ( VAR_330 ) ; VAR_331 = VAR_332 -> VAR_333 * VAR_334 -> VAR_335 ; for ( VAR_336 = 0 ; VAR_337 < VAR_338 ; VAR_339 ++ ) { TYPE_19 * VAR_340 = VAR_341 -> VAR_342 + VAR_343 ; VAR_344 -> VAR_345 [ 0 ] [ 0 ] = ( VAR_346 % VAR_347 -> VAR_348 ) * ( 1 << VAR_349 ) ; VAR_350 -> VAR_351 [ 0 ] [ 0 ] = METHOD_28 ( VAR_352 -> VAR_353 [ 0 ] [ 0 ] , VAR_354 -> VAR_355 [ 0 ] [ 0 ] ) ; VAR_356 -> VAR_357 [ 1 ] [ 0 ] = ( VAR_358 / VAR_359 -> VAR_360 ) * ( 1 << VAR_361 ) ; VAR_362 -> VAR_363 [ 1 ] [ 0 ] = METHOD_29 ( VAR_364 -> VAR_365 [ 1 ] [ 0 ] , VAR_366 -> VAR_367 [ 1 ] [ 0 ] ) ; VAR_368 -> VAR_369 [ 0 ] [ 1 ] = VAR_370 -> VAR_371 [ 0 ] [ 0 ] + ( 1 << VAR_372 ) ; VAR_373 -> VAR_374 [ 0 ] [ 1 ] = METHOD_30 ( VAR_375 -> VAR_376 [ 0 ] [ 1 ] , VAR_377 -> VAR_378 [ 0 ] [ 1 ] ) ; VAR_379 -> VAR_380 [ 1 ] [ 1 ] = VAR_381 -> VAR_382 [ 1 ] [ 0 ] + ( 1 << VAR_383 ) ; VAR_384 -> VAR_385 [ 1 ] [ 1 ] = METHOD_31 ( VAR_386 -> VAR_387 [ 1 ] [ 1 ] , VAR_388 -> VAR_389 [ 1 ] [ 1 ] ) ; VAR_390 -> VAR_391 = METHOD_32 ( VAR_392 -> VAR_393 [ 0 ] [ 1 ] - VAR_394 -> VAR_395 [ 0 ] [ 0 ] , VAR_396 -> VAR_397 ) ; VAR_398 -> VAR_399 = METHOD_33 ( VAR_400 -> VAR_401 [ 1 ] [ 1 ] - VAR_402 -> VAR_403 [ 1 ] [ 0 ] , VAR_404 -> VAR_405 ) ; VAR_406 -> VAR_407 = METHOD_34 ( VAR_408 -> VAR_409 , VAR_410 -> VAR_411 ) ; if ( ! VAR_412 -> VAR_413 ) return METHOD_35 ( VAR_414 ) ; VAR_415 -> VAR_416 = METHOD_36 ( VAR_417 -> VAR_418 , VAR_419 -> VAR_420 ) ; if ( ! VAR_421 -> VAR_422 ) return METHOD_37 ( VAR_423 ) ; VAR_424 -> VAR_425 = METHOD_38 ( VAR_426 -> VAR_427 * ( TYPE_20 ) VAR_428 -> VAR_429 , sizeof ( * VAR_430 -> VAR_431 ) ) ; if ( ! VAR_432 -> VAR_433 ) return METHOD_39 ( VAR_434 ) ; for ( VAR_435 = 0 ; VAR_436 < VAR_437 -> VAR_438 * VAR_439 -> VAR_440 ; VAR_441 ++ ) { TYPE_21 * VAR_442 = VAR_443 -> VAR_444 + VAR_445 ; TYPE_22 VAR_446 , VAR_447 ; VAR_448 = ( VAR_449 -> VAR_450 [ 0 ] [ 0 ] >> VAR_451 -> VAR_452 ) << VAR_453 -> VAR_454 ; VAR_455 = VAR_456 + ( ( VAR_457 % VAR_458 -> VAR_459 ) << VAR_460 -> VAR_461 ) ; VAR_462 -> VAR_463 [ 0 ] [ 0 ] = METHOD_40 ( VAR_464 , VAR_465 -> VAR_466 [ 0 ] [ 0 ] ) ; VAR_467 = ( VAR_468 -> VAR_469 [ 1 ] [ 0 ] >> VAR_470 -> VAR_471 ) << VAR_472 -> VAR_473 ; VAR_474 = VAR_475 + ( ( VAR_476 / VAR_477 -> VAR_478 ) << VAR_479 -> VAR_480 ) ; VAR_481 -> VAR_482 [ 1 ] [ 0 ] = METHOD_41 ( VAR_483 , VAR_484 -> VAR_485 [ 1 ] [ 0 ] ) ; VAR_486 -> VAR_487 [ 0 ] [ 1 ] = METHOD_42 ( VAR_488 + ( 1 << VAR_489 -> VAR_490 ) , VAR_491 -> VAR_492 [ 0 ] [ 1 ] ) ; VAR_493 -> VAR_494 [ 1 ] [ 1 ] = METHOD_43 ( VAR_495 + ( 1 << VAR_496 -> VAR_497 ) , VAR_498 -> VAR_499 [ 1 ] [ 1 ] ) ; if ( ( VAR_500 + ! ! VAR_501 ) & 1 ) { VAR_502 -> VAR_503 [ 0 ] [ 0 ] += VAR_504 -> VAR_505 [ VAR_506 - 1 ] . VAR_507 [ 0 ] [ 1 ] - VAR_508 -> VAR_509 [ VAR_510 - 1 ] . VAR_511 [ 0 ] [ 0 ] ; VAR_512 -> VAR_513 [ 0 ] [ 1 ] += VAR_514 -> VAR_515 [ VAR_516 - 1 ] . VAR_517 [ 0 ] [ 1 ] - VAR_518 -> VAR_519 [ VAR_520 - 1 ] . VAR_521 [ 0 ] [ 0 ] ; } if ( ( VAR_522 + ! ! VAR_523 ) & 2 ) { VAR_524 -> VAR_525 [ 1 ] [ 0 ] += VAR_526 -> VAR_527 [ VAR_528 - 1 ] . VAR_529 [ 1 ] [ 1 ] - VAR_530 -> VAR_531 [ VAR_532 - 1 ] . VAR_533 [ 1 ] [ 0 ] ; VAR_534 -> VAR_535 [ 1 ] [ 1 ] += VAR_536 -> VAR_537 [ VAR_538 - 1 ] . VAR_539 [ 1 ] [ 1 ] - VAR_540 -> VAR_541 [ VAR_542 - 1 ] . VAR_543 [ 1 ] [ 0 ] ; } VAR_544 -> VAR_545 = 0 ; VAR_546 -> VAR_547 = 3 ; VAR_548 -> VAR_549 = 0 ; VAR_550 -> VAR_551 = 0 ; VAR_552 -> VAR_553 = 0 ; } } } } return 0 ; }",<S2SV_ModStart> -> VAR_496 = METHOD_44 <S2SV_ModEnd> ( VAR_541 -> <S2SV_ModStart> -> VAR_498 = METHOD_44 <S2SV_ModEnd> ( VAR_541 ->,"CWE-000 int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }",<S2SV_ModStart> -> band = av_calloc <S2SV_ModEnd> ( reslevel -> <S2SV_ModStart> -> prec = av_calloc <S2SV_ModEnd> ( reslevel ->
650,"CWE-000 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 ; struct STRUCT_OR_UNION_3 * VAR_3 ; struct STRUCT_OR_UNION_4 * VAR_4 ; struct STRUCT_OR_UNION_5 * VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 ; TYPE_1 VAR_7 ; const TYPE_2 * VAR_8 ; struct STRUCT_OR_UNION_7 * VAR_9 = METHOD_1 ( VAR_10 -> VAR_11 . VAR_12 ) ; if ( ! VAR_13 -> VAR_14 ) { VAR_15 -> VAR_16 = 1 ; METHOD_2 ( & VAR_17 -> VAR_18 ) ; } VAR_19 = VAR_20 -> VAR_21 . VAR_22 -> VAR_23 ; VAR_24 = ( struct STRUCT_OR_UNION_8 * ) VAR_25 -> STRUCT_OR_UNION_9 ; if ( ! VAR_26 ) { METHOD_3 ( & VAR_27 -> VAR_28 , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , VAR_29 ) ; return - VAR_30 ; } VAR_31 = METHOD_4 ( VAR_32 ) ; VAR_33 = VAR_34 -> VAR_35 ; VAR_36 = - VAR_37 ; VAR_38 = METHOD_5 ( sizeof ( * VAR_39 ) ) ; if ( ! VAR_40 ) goto VAR_41 ; METHOD_6 ( VAR_42 , & VAR_43 -> VAR_44 ) ; VAR_45 = METHOD_7 ( VAR_46 ) ; VAR_47 -> VAR_48 = VAR_49 ; VAR_50 -> VAR_51 = VAR_52 ; VAR_53 -> STRUCT_OR_UNION_10 = VAR_54 ; VAR_55 -> VAR_56 = VAR_57 ; VAR_58 -> VAR_59 = METHOD_8 ( VAR_60 , VAR_61 | VAR_62 | VAR_63 ) ; METHOD_9 ( & VAR_64 -> VAR_65 ) ; METHOD_10 ( & VAR_66 -> VAR_67 ) ; METHOD_11 ( & VAR_68 -> VAR_69 ) ; METHOD_12 ( & VAR_70 -> VAR_71 ) ; METHOD_13 ( & VAR_72 -> VAR_73 ) ; VAR_74 -> VAR_75 . VAR_76 = VAR_77 ; VAR_78 -> VAR_79 . VAR_80 = ( unsigned TYPE_3 ) VAR_81 ; METHOD_14 ( & VAR_82 -> VAR_83 , VAR_84 ) ; METHOD_15 ( & VAR_85 -> VAR_86 ) ; VAR_87 -> VAR_88 . VAR_89 = VAR_90 ; VAR_91 -> VAR_92 . VAR_93 = ( unsigned TYPE_4 ) VAR_94 ; METHOD_16 ( & VAR_95 -> VAR_96 ) ; METHOD_17 ( & VAR_97 -> VAR_98 ) ; METHOD_18 ( & VAR_99 -> VAR_100 ) ; VAR_101 -> VAR_102 = 0 ; VAR_103 -> VAR_104 = VAR_105 ; METHOD_19 ( VAR_106 -> VAR_107 , ""usb%d"" ) ; METHOD_20 ( VAR_108 -> VAR_109 , VAR_110 , sizeof VAR_111 ) ; VAR_112 -> VAR_113 = VAR_114 -> VAR_115 + VAR_116 -> VAR_117 ; VAR_118 -> VAR_119 = & VAR_120 ; VAR_121 -> VAR_122 = VAR_123 ; VAR_124 -> VAR_125 = & VAR_126 ; if ( VAR_127 -> METHOD_21 ) { VAR_128 = VAR_129 -> METHOD_22 ( VAR_130 , VAR_131 ) ; if ( VAR_132 < 0 ) goto VAR_133 ; if ( ( VAR_134 -> STRUCT_OR_UNION_11 -> VAR_135 & VAR_136 ) != 0 && ( ( VAR_137 -> STRUCT_OR_UNION_12 -> VAR_138 & VAR_139 ) == 0 || ( VAR_140 -> VAR_141 [ 0 ] & 0x02 ) == 0 ) ) METHOD_23 ( VAR_142 -> VAR_143 , ""eth%d"" ) ; if ( ( VAR_144 -> STRUCT_OR_UNION_13 -> VAR_145 & VAR_146 ) != 0 ) METHOD_24 ( VAR_147 -> VAR_148 , ""wlan%d"" ) ; if ( ( VAR_149 -> STRUCT_OR_UNION_14 -> VAR_150 & VAR_151 ) != 0 ) METHOD_25 ( VAR_152 -> VAR_153 , ""wwan%d"" ) ; if ( ( VAR_154 -> STRUCT_OR_UNION_15 -> VAR_155 & VAR_156 ) != 0 ) VAR_157 -> VAR_158 |= VAR_159 ; if ( VAR_160 -> VAR_161 > ( VAR_162 -> VAR_163 - VAR_164 -> VAR_165 ) ) VAR_166 -> VAR_167 = VAR_168 -> VAR_169 - VAR_170 -> VAR_171 ; } else if ( ! VAR_172 -> VAR_173 || ! VAR_174 -> VAR_175 ) VAR_176 = METHOD_26 ( VAR_177 , VAR_178 ) ; else { VAR_179 -> VAR_180 = METHOD_27 ( VAR_181 , VAR_182 -> VAR_183 ) ; VAR_184 -> VAR_185 = METHOD_28 ( VAR_186 , VAR_187 -> VAR_188 ) ; if ( ! ( VAR_189 -> VAR_190 & VAR_191 ) ) VAR_192 = METHOD_29 ( VAR_193 , VAR_194 -> VAR_195 . VAR_196 , VAR_197 -> VAR_198 . VAR_199 ) ; else VAR_200 = 0 ; } if ( VAR_201 >= 0 && VAR_202 -> VAR_203 ) VAR_204 = METHOD_30 ( VAR_205 , VAR_206 ) ; if ( VAR_207 < 0 ) goto VAR_208 ; if ( ! VAR_209 -> VAR_210 ) VAR_211 -> VAR_212 = VAR_213 -> VAR_214 ; VAR_215 -> VAR_216 = METHOD_31 ( VAR_217 -> VAR_218 , VAR_219 -> VAR_220 , 1 ) ; if ( METHOD_32 ( VAR_221 -> VAR_222 , VAR_223 ) ) VAR_224 -> VAR_225 = VAR_226 ; if ( ( VAR_227 -> STRUCT_OR_UNION_16 -> VAR_228 & VAR_229 ) != 0 ) METHOD_33 ( VAR_230 , & VAR_231 ) ; if ( ( VAR_232 -> STRUCT_OR_UNION_17 -> VAR_233 & VAR_234 ) != 0 ) METHOD_34 ( VAR_235 , & VAR_236 ) ; METHOD_35 ( VAR_237 ) ; if ( VAR_238 -> VAR_239 && ! ( VAR_240 -> VAR_241 & VAR_242 ) && ! ( VAR_243 -> VAR_244 & VAR_245 ) ) { VAR_246 -> VAR_247 = METHOD_36 ( 1 , VAR_248 ) ; if ( ! VAR_249 -> VAR_250 ) { VAR_251 = - VAR_252 ; goto VAR_253 ; } } VAR_254 = METHOD_37 ( VAR_255 ) ; if ( VAR_256 ) goto VAR_257 ; METHOD_38 ( VAR_258 , VAR_259 , VAR_260 -> VAR_261 , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , VAR_262 -> VAR_263 . VAR_264 -> VAR_265 , VAR_266 -> VAR_267 -> VAR_268 , VAR_269 -> VAR_270 , VAR_271 -> STRUCT_OR_UNION_18 -> VAR_272 , VAR_273 -> VAR_274 ) ; METHOD_39 ( VAR_275 , VAR_276 ) ; METHOD_40 ( VAR_277 ) ; if ( VAR_278 -> STRUCT_OR_UNION_19 -> VAR_279 & VAR_280 ) METHOD_41 ( VAR_281 , 0 , 0 ) ; return 0 ; VAR_282 : METHOD_42 ( VAR_283 -> VAR_284 ) ; VAR_285 : METHOD_43 ( VAR_286 -> VAR_287 ) ; VAR_288 : if ( VAR_289 -> METHOD_44 ) VAR_290 -> METHOD_45 ( VAR_291 , VAR_292 ) ; VAR_293 : <S2SV_StartBug> METHOD_46 ( VAR_294 ) ; <S2SV_EndBug> VAR_295 : return VAR_296 ; }",<S2SV_ModStart> ; VAR_293 : METHOD_47 ( & VAR_291 -> VAR_83 ) ; METHOD_48 ( & VAR_291 -> VAR_96 ) ;,"CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , ""usb%d"" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , ""eth%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , ""wlan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , ""wwan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }",<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
651,CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> VAR_1 -> VAR_2 . VAR_3 = VAR_4 ; <S2SV_EndBug> VAR_5 -> VAR_6 . VAR_7 . VAR_8 = & VAR_9 -> VAR_10 ; <S2SV_StartBug> VAR_11 -> VAR_12 . VAR_13 = VAR_14 -> VAR_15 ; <S2SV_EndBug> return METHOD_1 ( VAR_16 ) ; },"<S2SV_ModStart> VAR_16 ) { TYPE_0 VAR_17 ; unsigned TYPE_1 TYPE_2 ; VAR_17 = emulate_pop ( VAR_16 , & TYPE_2 , <S2SV_ModEnd> VAR_16 -> VAR_15 <S2SV_ModStart> VAR_16 -> VAR_15 ) ; if ( VAR_17 != X86EMUL_CONTINUE ) return VAR_17 ; return assign_eip_near ( VAR_16 , TYPE_2 <S2SV_ModEnd> ) ; }",CWE-264 static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; },"<S2SV_ModStart> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }"
652,"CWE-000 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 ) { struct STRUCT_OR_UNION_1 * VAR_2 = VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 = VAR_5 -> VAR_6 ; struct STRUCT_OR_UNION_3 * VAR_7 = METHOD_1 ( VAR_8 -> VAR_9 ) ; if ( METHOD_2 ( VAR_10 ) ) return ; switch ( VAR_11 -> VAR_12 ) { case 0 : METHOD_3 ( VAR_13 , & VAR_14 -> VAR_15 . VAR_16 , 0 ) ; METHOD_4 ( VAR_17 , VAR_18 -> VAR_19 ) ; break ; case - VAR_20 : case - VAR_21 : case - VAR_22 : case - VAR_23 : <S2SV_StartBug> if ( VAR_24 -> VAR_25 . VAR_26 == 0 ) <S2SV_EndBug> break ; default : if ( METHOD_5 ( VAR_27 , VAR_28 , VAR_29 ) == - VAR_30 ) { METHOD_6 ( VAR_31 ) ; return ; } } METHOD_7 ( VAR_32 -> VAR_33 , VAR_34 -> VAR_35 . VAR_36 ) ; }",<S2SV_ModStart> -> VAR_25 . VAR_37 <S2SV_ModEnd> == 0 ),"CWE-000 static void nfs4_close_done ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; struct nfs_server * server = NFS_SERVER ( calldata -> inode ) ; if ( RPC_ASSASSINATED ( task ) ) return ; switch ( task -> tk_status ) { case 0 : nfs_set_open_stateid ( state , & calldata -> res . stateid , 0 ) ; renew_lease ( server , calldata -> timestamp ) ; break ; case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : <S2SV_StartBug> if ( calldata -> arg . open_flags == 0 ) <S2SV_EndBug> break ; default : if ( nfs4_async_handle_error ( task , server , state ) == - EAGAIN ) { rpc_restart_call ( task ) ; return ; } } nfs_refresh_inode ( calldata -> inode , calldata -> res . fattr ) ; }",<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> == 0 )
653,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { struct STRUCT_OR_UNION_3 * VAR_1 = METHOD_1 ( STRUCT_OR_UNION_4 -> VAR_2 ) ; struct STRUCT_OR_UNION_5 * VAR_3 = METHOD_2 ( STRUCT_OR_UNION_6 -> VAR_4 ) ; VAR_5 -> VAR_6 = VAR_7 ; VAR_8 -> VAR_9 = METHOD_3 ( VAR_10 ) ; if ( VAR_11 ) { METHOD_4 ( & VAR_12 -> VAR_13 ) ; <S2SV_StartBug> if ( VAR_14 -> VAR_15 >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> VAR_16 -> VAR_17 = VAR_18 -> VAR_19 ; <S2SV_EndBug> <S2SV_StartBug> VAR_20 -> VAR_21 = VAR_22 -> VAR_23 = VAR_24 -> VAR_25 ; <S2SV_EndBug> VAR_26 -> VAR_27 = VAR_28 -> VAR_29 ; VAR_30 -> VAR_31 = VAR_32 -> VAR_33 ; } METHOD_5 ( & VAR_34 -> VAR_35 ) ; } VAR_36 -> VAR_37 = VAR_38 ; return 0 ; }",<S2SV_ModStart> ( VAR_34 -> VAR_39 ) { TYPE_1 VAR_40 ; METHOD_4 ( & VAR_34 -> VAR_39 -> VAR_41 ) ; <S2SV_ModEnd> VAR_36 -> VAR_17 <S2SV_ModStart> = VAR_34 -> VAR_39 -> VAR_42 ; VAR_40 = VAR_34 -> VAR_39 -> VAR_42 - VAR_34 -> VAR_39 -> VAR_43 <S2SV_ModEnd> ; VAR_36 -> <S2SV_ModStart> -> VAR_23 = VAR_40 ; METHOD_5 ( & VAR_34 -> VAR_39 -> VAR_41 ) <S2SV_ModEnd> ; VAR_36 ->,"CWE-399 static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }",<S2SV_ModStart> ( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> buf -> f_blocks <S2SV_ModStart> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> ; buf ->
654,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = METHOD_1 ( VAR_3 ) ; TYPE_4 VAR_4 = 0 ; TYPE_5 * VAR_5 = VAR_6 ; TYPE_6 * VAR_7 ; TYPE_7 VAR_8 = 0 ; TYPE_8 VAR_9 = 0 ; if ( ! VAR_10 ) { return VAR_11 ; } while ( VAR_12 ) { TYPE_9 * VAR_13 = METHOD_2 ( VAR_14 , ',' ) ; if ( VAR_15 ) { * VAR_16 ++ = 0 ; } while ( VAR_17 [ 0 ] == '<S2SV_blank>' ) { VAR_18 ++ ; } if ( VAR_19 >= VAR_20 ) { METHOD_3 ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return VAR_21 ; } VAR_22 -> VAR_23 [ VAR_24 ] . VAR_25 = VAR_26 ; VAR_27 -> VAR_28 [ VAR_29 ] . VAR_30 = VAR_31 ; VAR_32 -> VAR_33 [ VAR_34 ] . VAR_35 = VAR_36 ; while ( VAR_37 [ 0 ] == '<S2SV_blank>' || VAR_38 [ 0 ] == '[' || VAR_39 [ 0 ] == ']' ) { VAR_40 ++ ; } if ( ! METHOD_4 ( VAR_41 , ""lsl"" , 3 ) ) { VAR_42 -> VAR_43 [ VAR_44 ] . VAR_45 = VAR_46 ; } else if ( ! METHOD_5 ( VAR_47 , ""lsr"" , 3 ) ) { VAR_48 -> VAR_49 [ VAR_50 ] . VAR_51 = VAR_52 ; } else if ( ! METHOD_6 ( VAR_53 , ""asr"" , 3 ) ) { VAR_54 -> VAR_55 [ VAR_56 ] . VAR_57 = VAR_58 ; } <S2SV_StartBug> if ( VAR_59 -> VAR_60 [ VAR_61 ] . VAR_62 != VAR_63 ) { <S2SV_EndBug> VAR_64 -> VAR_65 ++ ; VAR_66 -> VAR_67 [ VAR_68 ] . VAR_69 = METHOD_7 ( VAR_70 , VAR_71 + 4 ) ; if ( VAR_72 -> VAR_73 [ VAR_74 ] . VAR_75 > 63 ) { return VAR_76 ; } VAR_77 ++ ; VAR_78 = VAR_79 ; continue ; } switch ( VAR_80 [ 0 ] ) { case 'x' : VAR_81 = METHOD_8 ( VAR_82 , ',' ) ; if ( VAR_83 ) { VAR_84 [ 0 ] = '\\0' ; } VAR_85 -> VAR_86 ++ ; VAR_87 -> VAR_88 [ VAR_89 ] . VAR_90 = VAR_91 ; VAR_92 -> VAR_93 [ VAR_94 ] . VAR_95 = VAR_96 ; VAR_97 -> VAR_98 [ VAR_99 ] . VAR_100 = METHOD_9 ( VAR_101 , VAR_102 + 1 ) ; if ( VAR_103 -> VAR_104 [ VAR_105 ] . VAR_106 > 31 ) { return VAR_107 ; } break ; case 'w' : VAR_108 -> VAR_109 ++ ; VAR_110 -> VAR_111 [ VAR_112 ] . VAR_113 = VAR_114 ; VAR_115 -> VAR_116 [ VAR_117 ] . VAR_118 = VAR_119 ; VAR_120 -> VAR_121 [ VAR_122 ] . VAR_123 = METHOD_10 ( VAR_124 , VAR_125 + 1 ) ; if ( VAR_126 -> VAR_127 [ VAR_128 ] . VAR_129 > 31 ) { return VAR_130 ; } break ; case 'v' : VAR_131 -> VAR_132 ++ ; VAR_133 -> VAR_134 [ VAR_135 ] . VAR_136 = VAR_137 ; VAR_138 -> VAR_139 [ VAR_140 ] . VAR_141 = METHOD_11 ( VAR_142 , VAR_143 + 1 ) ; break ; case 's' : case 'S' : if ( VAR_144 [ 1 ] == 'P' || VAR_145 [ 1 ] == 'p' ) { TYPE_10 VAR_146 ; for ( VAR_147 = 0 ; VAR_148 [ VAR_149 ] . VAR_150 ; VAR_151 ++ ) { if ( ! METHOD_12 ( VAR_152 , VAR_153 [ VAR_154 ] . VAR_155 , METHOD_13 ( VAR_156 [ VAR_157 ] . VAR_158 ) ) ) { VAR_159 -> VAR_160 [ VAR_161 ] . VAR_162 = VAR_163 [ VAR_164 ] . VAR_165 ; break ; } } VAR_166 -> VAR_167 ++ ; VAR_168 -> VAR_169 [ VAR_170 ] . VAR_171 = VAR_172 ; VAR_173 -> VAR_174 [ VAR_175 ] . VAR_176 = VAR_177 | VAR_178 ; VAR_179 -> VAR_180 [ VAR_181 ] . VAR_182 = 31 ; break ; } VAR_183 = METHOD_14 ( VAR_184 ) ; if ( VAR_185 != - 1 ) { VAR_186 -> VAR_187 ++ ; VAR_188 -> VAR_189 [ VAR_190 ] . VAR_191 = VAR_192 ; VAR_193 -> VAR_194 [ VAR_195 ] . VAR_196 = VAR_197 ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : VAR_198 = METHOD_15 ( VAR_199 ) ; if ( VAR_200 != - 1 ) { VAR_201 -> VAR_202 ++ ; VAR_203 -> VAR_204 [ VAR_205 ] . VAR_206 = VAR_207 ; VAR_208 -> VAR_209 [ VAR_210 ] . VAR_211 = VAR_212 ; } break ; case '-' : VAR_213 -> VAR_214 [ VAR_215 ] . VAR_216 = - 1 ; default : VAR_217 -> VAR_218 ++ ; VAR_219 -> VAR_220 [ VAR_221 ] . VAR_222 = VAR_223 ; VAR_224 -> VAR_225 [ VAR_226 ] . VAR_227 = METHOD_16 ( VAR_228 , VAR_229 ) ; VAR_230 ++ ; break ; } VAR_231 = VAR_232 ; VAR_233 ++ ; if ( VAR_234 > VAR_235 ) { METHOD_17 ( VAR_236 ) ; return VAR_237 ; } } METHOD_18 ( VAR_238 ) ; return VAR_239 ; }",<S2SV_ModStart> } if ( METHOD_13 ( VAR_231 ) > 4 &&,"CWE-125 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }",<S2SV_ModStart> } if ( strlen ( token ) > 4 &&
655,"CWE-20 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 * VAR_3 = VAR_4 -> VAR_5 ; VAR_6 * VAR_7 ; VAR_8 * VAR_9 ; TYPE_5 * VAR_10 = VAR_11 -> VAR_12 ; TYPE_6 VAR_13 ; TYPE_7 VAR_14 [ 2 ] ; TYPE_8 VAR_15 = 0 ; TYPE_9 VAR_16 , VAR_17 ; TYPE_10 VAR_18 , VAR_19 = 0 , VAR_20 ; TYPE_11 VAR_21 = 0 ; TYPE_12 VAR_22 , VAR_23 ; TYPE_13 VAR_24 ; TYPE_14 * VAR_25 = VAR_26 -> VAR_27 ; TYPE_15 * VAR_28 = & VAR_29 -> VAR_30 ; TYPE_16 VAR_31 ; TYPE_17 VAR_32 , VAR_33 ; TYPE_18 VAR_34 , VAR_35 ; TYPE_19 VAR_36 ; TYPE_20 * VAR_37 ; TYPE_21 VAR_38 ; TYPE_22 VAR_39 ; TYPE_23 VAR_40 = 0 ; VAR_41 -> VAR_42 -> VAR_43 = 0 ; VAR_44 = METHOD_1 ( VAR_45 , VAR_46 ) ; if ( VAR_47 > ( VAR_48 -> VAR_49 * VAR_50 -> VAR_51 ) ) { return VAR_52 ; } if ( ( ( VAR_53 << VAR_54 -> VAR_55 ) <= VAR_56 -> VAR_57 ) && ( VAR_58 -> VAR_59 != 0 ) && ( VAR_60 -> VAR_61 != 0 ) ) { return VAR_62 ; } METHOD_2 ( ""SH:<S2SV_blank>first_mb_in_slice"" , VAR_63 ) ; VAR_64 = METHOD_3 ( VAR_65 , VAR_66 ) ; if ( VAR_67 > 9 ) return VAR_68 ; VAR_69 = VAR_70 ; METHOD_4 ( ""SH:<S2SV_blank>slice_type"" , ( VAR_71 ) ) ; VAR_72 -> VAR_73 = 0 ; if ( VAR_74 > 4 ) { VAR_75 -= 5 ; VAR_76 -> VAR_77 = 1 ; } { TYPE_24 VAR_78 ; if ( ( VAR_79 -> VAR_80 == VAR_81 ) || ( VAR_82 -> VAR_83 == VAR_84 ) ) { TYPE_25 VAR_85 = 0 ; if ( VAR_86 -> VAR_87 == VAR_88 ) { VAR_89 = 0 ; VAR_90 -> VAR_91 = VAR_92 ; } else if ( ( VAR_93 == VAR_94 ) && ( 1 >= VAR_95 -> VAR_96 -> VAR_97 ) ) { VAR_98 = 0 ; VAR_99 -> VAR_100 = VAR_101 ; } else { VAR_102 = 1 ; } if ( ( 0 == VAR_103 ) && ( 1 == VAR_104 -> VAR_105 ) ) { VAR_106 = 0 ; } if ( VAR_107 ) { VAR_108 -> VAR_109 = 1 ; VAR_110 -> VAR_111 = VAR_112 ; return 0 ; } else { if ( 1 == VAR_113 -> VAR_114 ) { VAR_115 -> VAR_116 = 1 ; return 0 ; } } } } VAR_117 = METHOD_5 ( VAR_118 , VAR_119 ) ; if ( VAR_120 & VAR_121 ) return VAR_122 ; METHOD_6 ( ""SH:<S2SV_blank>pic_parameter_set_id"" , VAR_123 ) ; VAR_124 = & VAR_125 -> VAR_126 [ VAR_127 ] ; if ( VAR_128 == VAR_129 -> VAR_130 ) { return VAR_131 ; } VAR_132 = VAR_133 -> VAR_134 ; if ( ! VAR_135 ) return VAR_136 ; if ( VAR_137 == VAR_138 -> VAR_139 ) return VAR_140 ; VAR_141 = METHOD_7 ( VAR_142 , VAR_143 -> VAR_144 ) ; METHOD_8 ( ""SH:<S2SV_blank>frame_num"" , VAR_145 ) ; if ( ! VAR_146 -> VAR_147 ) { VAR_148 = METHOD_9 ( VAR_149 ) ; METHOD_10 ( ""SH:<S2SV_blank>field_pic_flag"" , VAR_150 ) ; VAR_151 = 0 ; if ( VAR_152 ) { VAR_153 -> VAR_154 = ( TYPE_26 * ) VAR_155 ; VAR_156 = METHOD_11 ( VAR_157 ) ; METHOD_12 ( ""SH:<S2SV_blank>bottom_field_flag"" , VAR_158 ) ; } else { VAR_159 -> VAR_160 = ( TYPE_27 * ) VAR_161 ; } } else { VAR_162 = 0 ; VAR_163 = 0 ; VAR_164 -> VAR_165 = ( TYPE_28 * ) VAR_166 ; } VAR_167 = VAR_168 ; if ( VAR_169 ) { if ( 0 == VAR_170 ) { VAR_171 -> VAR_172 = VAR_173 | VAR_174 ; } VAR_175 = VAR_176 ; VAR_177 = METHOD_13 ( VAR_178 , VAR_179 ) ; if ( VAR_180 > 65535 ) return VAR_181 ; METHOD_14 ( ""SH:<S2SV_blank><S2SV_blank>"" , VAR_182 ) ; } VAR_183 [ 0 ] = VAR_184 [ 1 ] = 0 ; VAR_185 . VAR_186 = 0 ; VAR_187 . VAR_188 = 0 ; VAR_189 = VAR_190 -> VAR_191 ; if ( VAR_192 == 0 ) { VAR_193 = METHOD_15 ( VAR_194 , VAR_195 -> VAR_196 ) ; if ( VAR_197 < 0 || VAR_198 >= VAR_199 -> VAR_200 ) return VAR_201 ; VAR_202 . VAR_203 = VAR_204 ; METHOD_16 ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , VAR_205 . VAR_206 ) ; if ( ( VAR_207 -> VAR_208 == 1 ) && ( ! VAR_209 ) ) { VAR_210 . VAR_211 = METHOD_17 ( VAR_212 , VAR_213 ) ; METHOD_18 ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , VAR_214 . VAR_215 ) ; } } VAR_216 . VAR_217 [ 0 ] = 0 ; VAR_218 . VAR_219 [ 1 ] = 0 ; if ( VAR_220 == 1 && ( ! VAR_221 -> VAR_222 ) ) { VAR_223 . VAR_224 [ 0 ] = METHOD_19 ( VAR_225 , VAR_226 ) ; METHOD_20 ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , VAR_227 . VAR_228 [ 0 ] ) ; if ( VAR_229 -> VAR_230 && ! VAR_231 ) { VAR_232 . VAR_233 [ 1 ] = METHOD_21 ( VAR_234 , VAR_235 ) ; METHOD_22 ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , VAR_236 . VAR_237 [ 1 ] ) ; } } if ( VAR_238 -> VAR_239 ) { VAR_240 = METHOD_23 ( VAR_241 , VAR_242 ) ; if ( VAR_243 > VAR_244 ) return VAR_245 ; VAR_246 = VAR_247 ; METHOD_24 ( ""SH:<S2SV_blank>redundant_pic_cnt"" , VAR_248 ) ; } VAR_249 = 0 ; if ( ! VAR_250 -> VAR_251 ) { VAR_252 = METHOD_25 ( VAR_253 , VAR_254 , & VAR_255 , & VAR_256 -> VAR_257 , VAR_258 , VAR_259 , VAR_260 , VAR_261 , VAR_262 , VAR_263 ) ; if ( ( VAR_264 -> VAR_265 == 2 ) && ( VAR_266 == 0 ) ) { VAR_267 -> VAR_268 -> VAR_269 |= VAR_270 ; VAR_271 = 1 ; } else { VAR_272 -> VAR_273 -> VAR_274 &= VAR_275 ; } } VAR_276 = VAR_277 -> VAR_278 && ( ! VAR_279 ) ; VAR_280 = 0 ; if ( VAR_281 || VAR_282 -> VAR_283 ) { if ( VAR_284 != VAR_285 -> VAR_286 && VAR_287 -> VAR_288 != 0 && VAR_289 -> VAR_290 != ( VAR_291 | VAR_292 ) ) { VAR_293 -> VAR_294 = 1 ; if ( VAR_295 -> VAR_296 ) { VAR_297 = 1 ; } else { VAR_298 = 2 ; } if ( VAR_299 -> VAR_300 == VAR_301 ) VAR_302 -> VAR_303 = 1 ; else VAR_304 -> VAR_305 = 0 ; VAR_306 = ( VAR_307 -> VAR_308 * VAR_309 -> VAR_310 ) - VAR_311 -> VAR_312 ; VAR_313 = & VAR_314 -> VAR_315 ; VAR_316 = VAR_317 -> VAR_318 == VAR_319 ; } else if ( VAR_320 -> VAR_321 == 2 ) { if ( VAR_322 > 0 ) { VAR_323 = 1 ; VAR_324 = VAR_325 << VAR_326 ; VAR_327 = & VAR_328 ; VAR_329 -> VAR_330 = VAR_331 ; VAR_332 -> VAR_333 = VAR_334 ; VAR_335 -> VAR_336 = VAR_337 ; VAR_338 -> VAR_339 = VAR_340 . VAR_341 ; VAR_342 -> VAR_343 = VAR_344 ; VAR_345 -> VAR_346 = VAR_347 ; VAR_348 -> VAR_349 = VAR_350 ; VAR_351 -> VAR_352 = VAR_353 ; } } else { if ( VAR_354 -> VAR_355 ) { VAR_356 = 1 ; VAR_357 = VAR_358 << VAR_359 ; } else { VAR_360 = 2 ; VAR_361 = ( VAR_362 -> VAR_363 * VAR_364 -> VAR_365 ) - VAR_366 -> VAR_367 ; } VAR_368 = & VAR_369 ; } } else { if ( ( VAR_370 << VAR_371 ) > VAR_372 -> VAR_373 ) { VAR_374 = 2 ; VAR_375 = ( VAR_376 << VAR_377 ) - VAR_378 -> VAR_379 ; VAR_380 = & VAR_381 ; } else if ( ( VAR_382 << VAR_383 ) < VAR_384 -> VAR_385 ) { return VAR_386 ; } } if ( VAR_387 ) { VAR_388 = METHOD_26 ( VAR_389 , VAR_390 , VAR_391 , VAR_392 , VAR_393 , VAR_394 ) ; if ( VAR_395 -> VAR_396 == 1 ) { VAR_397 -> VAR_398 = 1 - VAR_399 -> VAR_400 ; VAR_401 -> VAR_402 = VAR_403 ; VAR_404 -> VAR_405 = VAR_406 ; VAR_407 -> VAR_408 = 0 ; return VAR_409 ; } if ( VAR_410 == 2 ) { VAR_411 -> VAR_412 = 0 ; return VAR_413 ; } if ( VAR_414 -> VAR_415 >= VAR_416 -> VAR_417 * VAR_418 -> VAR_419 ) { VAR_420 -> VAR_421 = 0 ; return VAR_422 ; } if ( VAR_423 -> VAR_424 -> VAR_425 & VAR_426 ) { METHOD_27 ( VAR_427 ) ; return VAR_428 ; } if ( VAR_429 != VAR_430 ) return VAR_431 ; VAR_432 = 0 ; } if ( VAR_433 -> VAR_434 == 0 ) VAR_435 -> VAR_436 ++ ; VAR_437 -> VAR_438 = 0 ; if ( ! VAR_439 -> VAR_440 ) { TYPE_29 VAR_441 = 0 ; if ( VAR_442 -> VAR_443 == ( VAR_444 -> VAR_445 -> VAR_446 + 1 ) ) { if ( VAR_447 -> VAR_448 == 0 ) VAR_449 = 1 ; } if ( VAR_450 || VAR_451 ) { if ( 1 == VAR_452 -> VAR_453 ) { VAR_454 = METHOD_28 ( VAR_455 ) ; if ( VAR_456 != VAR_457 ) return VAR_458 ; VAR_459 = METHOD_29 ( VAR_460 , VAR_461 , VAR_462 ) ; if ( VAR_463 != VAR_464 ) return VAR_465 ; if VAR_466 METHOD_30 ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; return VAR_467 ; } else { VAR_468 = METHOD_31 ( VAR_469 , VAR_470 , VAR_471 ) ; if ( VAR_472 != VAR_473 ) return VAR_474 ; } } } if ( VAR_475 ) { VAR_476 -> VAR_477 = VAR_478 ; } if ( VAR_479 -> VAR_480 ) { TYPE_30 VAR_481 ; TYPE_31 VAR_482 , VAR_483 ; if ( ! VAR_484 -> VAR_485 ) { VAR_486 = VAR_487 -> VAR_488 -> VAR_489 ; VAR_490 = VAR_491 -> VAR_492 -> VAR_493 ; VAR_494 = METHOD_32 ( VAR_495 , VAR_496 ) ; } else if ( ! VAR_497 -> VAR_498 ) VAR_499 = VAR_500 -> VAR_501 -> VAR_502 ; else VAR_503 = VAR_504 -> VAR_505 -> VAR_506 ; VAR_507 -> VAR_508 -> VAR_509 = VAR_510 - VAR_511 -> VAR_512 -> VAR_513 ; VAR_514 -> VAR_515 -> VAR_516 = VAR_517 - VAR_518 -> VAR_519 -> VAR_520 ; VAR_521 -> VAR_522 -> VAR_523 = VAR_524 ; VAR_525 -> VAR_526 -> VAR_527 = VAR_528 ; } if ( VAR_529 -> VAR_530 == 2 ) { VAR_531 = METHOD_33 ( VAR_532 , VAR_533 , & VAR_534 -> VAR_535 , & VAR_536 , VAR_537 , VAR_538 , VAR_539 , VAR_540 , VAR_541 , & VAR_542 ) ; if ( VAR_543 != VAR_544 ) return VAR_545 ; if ( VAR_546 >= VAR_547 -> VAR_548 ) VAR_549 -> VAR_550 = VAR_551 ; if ( VAR_552 == 0 ) { VAR_553 -> VAR_554 = VAR_555 -> VAR_556 + VAR_557 -> VAR_558 + VAR_559 -> VAR_560 + 1 ; VAR_561 -> VAR_562 = 0 ; } } VAR_563 -> VAR_564 [ 0 ] = VAR_565 [ 0 ] ; VAR_566 -> VAR_567 [ 1 ] = VAR_568 [ 1 ] ; VAR_569 -> VAR_570 = VAR_571 ; VAR_572 -> VAR_573 = VAR_574 ; VAR_575 -> VAR_576 = VAR_577 ; VAR_578 -> VAR_579 = VAR_580 ; VAR_581 -> VAR_582 = VAR_583 ; VAR_584 -> VAR_585 = VAR_586 . VAR_587 ; VAR_588 -> VAR_589 = VAR_590 ; VAR_591 -> VAR_592 = VAR_593 ; VAR_594 -> VAR_595 = VAR_596 ; VAR_597 -> VAR_598 = VAR_599 ; if ( VAR_600 -> VAR_601 ) VAR_602 -> VAR_603 = VAR_604 -> VAR_605 ; else VAR_606 -> VAR_607 = 1 ; if ( VAR_608 == VAR_609 ) { VAR_610 -> VAR_611 = METHOD_34 ( VAR_612 ) ; METHOD_35 ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , VAR_613 -> VAR_614 ) ; if ( VAR_615 -> VAR_616 ) VAR_617 -> VAR_618 = VAR_619 ; else VAR_620 -> VAR_621 = VAR_622 ; if ( ! ( ( VAR_623 -> VAR_624 -> VAR_625 ) && ( ! VAR_626 ) ) ) VAR_627 -> VAR_628 = VAR_629 ; } else { if ( ! ( ( VAR_630 -> VAR_631 -> VAR_632 ) && ( ! VAR_633 ) ) ) VAR_634 -> VAR_635 = VAR_636 ; } if ( VAR_637 -> VAR_638 == 2 ) { if ( VAR_639 == 0 ) { VAR_640 = METHOD_36 ( VAR_641 , VAR_642 , & VAR_643 , VAR_644 , VAR_645 ) ; if ( VAR_646 != VAR_647 ) return VAR_648 ; } VAR_649 -> VAR_650 = 0 ; { METHOD_37 ( VAR_651 , VAR_652 -> VAR_653 , & ( VAR_654 -> VAR_655 ) ) ; if ( 0 != VAR_656 -> VAR_657 . VAR_658 ) { VAR_659 -> VAR_660 = VAR_661 -> VAR_662 . VAR_663 ; } else VAR_664 -> VAR_665 = 1 ; } if ( VAR_666 -> VAR_667 == 1 ) { if ( VAR_668 -> VAR_669 == 0 ) { METHOD_38 ( VAR_670 -> VAR_671 , VAR_672 , ( TYPE_32 * ) VAR_673 , ( TYPE_33 * ) VAR_674 ) ; VAR_675 -> VAR_676 = 1 ; } if ( ( VAR_677 -> VAR_678 == 3 ) && ( ( VAR_679 -> VAR_680 == 0 ) || VAR_681 -> VAR_682 ) && ( VAR_683 -> VAR_684 == 0 ) ) { VAR_685 -> VAR_686 = 0 ; METHOD_39 ( VAR_687 -> VAR_688 , VAR_689 , ( TYPE_34 * ) VAR_690 , ( TYPE_35 * ) VAR_691 ) ; VAR_692 -> VAR_693 = 1 ; } } } { TYPE_36 VAR_694 ; VAR_695 = ( ( VAR_696 -> VAR_697 -> VAR_698 == 0 ) && ( VAR_699 -> VAR_700 -> VAR_701 == 0 ) && ( VAR_702 != VAR_703 ) && ( VAR_704 -> VAR_705 -> VAR_706 == 0 ) ) ; if ( VAR_707 ) { VAR_708 -> VAR_709 = VAR_710 ; VAR_711 -> VAR_712 = VAR_713 ; } else { VAR_714 -> VAR_715 = VAR_716 ; VAR_717 -> VAR_718 = VAR_719 ; } } { TYPE_37 * VAR_720 = VAR_721 -> VAR_722 ; if ( VAR_723 -> VAR_724 == VAR_725 ) { VAR_726 -> VAR_727 = VAR_728 ; VAR_729 -> VAR_730 = VAR_731 ; } VAR_732 -> VAR_733 = VAR_734 ; } { TYPE_38 VAR_735 , VAR_736 ; VAR_737 = ( VAR_738 -> VAR_739 & VAR_740 ) && ( VAR_741 == VAR_742 ) && ( 0 == VAR_743 ) ; VAR_744 = ( VAR_745 -> VAR_746 & VAR_747 ) && ( VAR_748 == VAR_749 ) && ( 0 == VAR_750 ) ; if ( VAR_751 ) { VAR_752 -> VAR_753 -> VAR_754 |= VAR_755 ; VAR_756 -> VAR_757 = 1 ; return VAR_758 ; } if ( VAR_759 ) { VAR_760 -> VAR_761 -> VAR_762 |= VAR_763 ; VAR_764 -> VAR_765 = 1 ; return VAR_766 ; } } { TYPE_39 VAR_767 , VAR_768 ; VAR_769 -> VAR_770 = ( ( VAR_771 << VAR_772 -> VAR_773 ) * VAR_774 ) - VAR_775 ; if ( VAR_776 ) { TYPE_40 VAR_777 ; TYPE_41 VAR_778 ; TYPE_42 VAR_779 ; VAR_780 = VAR_781 -> VAR_782 ; VAR_783 = VAR_784 -> VAR_785 ; VAR_786 = VAR_787 -> VAR_788 ; { TYPE_43 VAR_789 ; TYPE_44 VAR_790 ; TYPE_45 VAR_791 ; VAR_792 * VAR_793 ; if ( VAR_794 -> VAR_795 ) { VAR_796 = & VAR_797 -> VAR_798 ; } else { VAR_799 = & VAR_800 -> VAR_801 ; } VAR_802 = METHOD_40 ( VAR_803 , VAR_804 ) ; VAR_805 = METHOD_41 ( VAR_806 , VAR_807 ) ; VAR_808 <<= VAR_809 ; if ( ( VAR_810 > VAR_811 - 1 ) || ( VAR_812 > VAR_813 -> VAR_814 - 1 ) ) { return VAR_815 ; } VAR_816 = VAR_817 -> VAR_818 << VAR_819 ; VAR_820 = VAR_821 << 4 ; VAR_822 = ( VAR_823 * VAR_824 ) << 4 ; VAR_825 -> VAR_826 = VAR_827 -> VAR_828 . VAR_829 + VAR_830 + VAR_831 ; VAR_832 = VAR_833 -> VAR_834 << VAR_835 ; VAR_836 >>= 1 ; VAR_837 = ( VAR_838 * VAR_839 ) << 3 ; VAR_840 *= VAR_841 ; VAR_842 -> VAR_843 = VAR_844 -> VAR_845 . VAR_846 + VAR_847 + VAR_848 ; VAR_849 -> VAR_850 = VAR_851 -> VAR_852 . VAR_853 + VAR_854 + VAR_855 ; VAR_856 -> VAR_857 = VAR_858 -> VAR_859 ; VAR_860 -> VAR_861 = VAR_862 -> VAR_863 ; VAR_864 -> VAR_865 = VAR_866 -> VAR_867 ; if ( VAR_868 -> VAR_869 == 1 ) { VAR_870 -> VAR_871 = VAR_872 -> VAR_873 + ( VAR_874 << VAR_875 ) ; } else { VAR_876 -> VAR_877 = VAR_878 -> VAR_879 + ( VAR_880 << VAR_881 ) ; } VAR_882 -> VAR_883 = ( VAR_884 << VAR_885 ) ; VAR_886 -> VAR_887 = VAR_888 -> VAR_889 . VAR_890 + ( ( VAR_891 << VAR_892 ) << 4 ) ; } } else { VAR_893 * VAR_894 ; if ( VAR_895 -> VAR_896 ) { VAR_897 = & VAR_898 -> VAR_899 ; } else { VAR_900 = & VAR_901 -> VAR_902 ; } VAR_903 = 0xffff ; VAR_904 = 0 ; VAR_905 -> VAR_906 = 0 ; VAR_907 -> VAR_908 = VAR_909 -> VAR_910 ; VAR_911 -> VAR_912 = VAR_913 -> VAR_914 . VAR_915 ; VAR_916 -> VAR_917 = VAR_918 -> VAR_919 . VAR_920 ; VAR_921 -> VAR_922 = VAR_923 -> VAR_924 . VAR_925 ; VAR_926 -> VAR_927 = VAR_928 -> VAR_929 . VAR_930 ; VAR_931 -> VAR_932 = VAR_933 -> VAR_934 ; VAR_935 -> VAR_936 = VAR_937 -> VAR_938 ; VAR_939 -> VAR_940 = VAR_941 -> VAR_942 ; } VAR_943 -> VAR_944 = VAR_945 -> VAR_946 ; VAR_947 -> VAR_948 = ( METHOD_42 ( VAR_949 - 1 , VAR_950 -> VAR_951 ) ) ; VAR_952 -> VAR_953 = ( METHOD_43 ( VAR_954 - 1 , VAR_955 -> VAR_956 ) ) ; VAR_957 -> VAR_958 <<= VAR_959 -> VAR_960 ; VAR_961 -> VAR_962 = VAR_963 -> VAR_964 ; VAR_965 -> VAR_966 = VAR_967 -> VAR_968 ; } VAR_969 -> VAR_970 += VAR_971 -> VAR_972 -> VAR_973 ; VAR_974 -> VAR_975 = ( VAR_976 == VAR_977 ) ; VAR_978 -> VAR_979 = 0 ; VAR_980 -> VAR_981 -> VAR_982 = VAR_983 -> VAR_984 -> VAR_985 ; VAR_986 -> VAR_987 -> VAR_988 = VAR_989 -> VAR_990 -> VAR_991 ; VAR_992 -> VAR_993 = 1 ; { TYPE_46 VAR_994 ; TYPE_47 VAR_995 ; TYPE_48 * VAR_996 ; VAR_997 = VAR_998 ; if ( ( 1 >= VAR_999 -> VAR_1000 -> VAR_1001 ) && ( 0 == VAR_1002 -> VAR_1003 ) ) { VAR_1004 = 1 ; } VAR_1005 = ( ( 2 * VAR_1006 ) + 1 ) ; if ( VAR_1007 != VAR_1008 -> VAR_1009 -> VAR_1010 ) { VAR_1011 *= 2 ; } VAR_1012 = VAR_1013 * sizeof ( TYPE_49 * ) ; VAR_1014 += VAR_1015 * sizeof ( TYPE_50 * ) ; VAR_1016 = ( TYPE_51 * ) VAR_1017 -> VAR_1018 ; VAR_1019 += VAR_1020 * VAR_1021 -> VAR_1022 ; VAR_1023 -> VAR_1024 -> VAR_1025 = ( TYPE_52 * ) VAR_1026 ; } if ( VAR_1027 -> VAR_1028 ) { VAR_1029 -> VAR_1030 -> VAR_1031 = VAR_1032 -> VAR_1033 ; } else { VAR_1034 -> VAR_1035 = VAR_1036 -> VAR_1037 ; } <S2SV_StartBug> VAR_1038 -> VAR_1039 = VAR_1040 -> VAR_1041 ; <S2SV_EndBug> if ( VAR_1042 == VAR_1043 ) { VAR_1044 -> VAR_1045 -> VAR_1046 |= VAR_1047 ; VAR_1048 = METHOD_44 ( VAR_1049 , VAR_1050 ) ; if ( VAR_1051 -> VAR_1052 != VAR_1053 && VAR_1054 -> VAR_1055 != VAR_1056 ) VAR_1057 -> VAR_1058 = VAR_1059 ; } else if ( VAR_1060 == VAR_1061 ) { VAR_1062 -> VAR_1063 -> VAR_1064 |= VAR_1065 ; VAR_1066 = METHOD_45 ( VAR_1067 , VAR_1068 ) ; VAR_1069 -> VAR_1070 = VAR_1071 ; if ( VAR_1072 -> VAR_1073 != VAR_1074 ) VAR_1075 -> VAR_1076 = VAR_1077 ; } else if ( VAR_1078 == VAR_1079 ) { VAR_1080 -> VAR_1081 -> VAR_1082 |= VAR_1083 ; VAR_1084 = METHOD_46 ( VAR_1085 , VAR_1086 ) ; VAR_1087 -> VAR_1088 = VAR_1089 ; VAR_1090 -> VAR_1091 = VAR_1092 ; } else return VAR_1093 ; if ( VAR_1094 -> VAR_1095 ) { VAR_1096 -> VAR_1097 = 0 ; VAR_1098 -> VAR_1099 = 0 ; } if ( VAR_1100 != VAR_1101 ) return VAR_1102 ; VAR_1103 -> VAR_1104 ++ ; VAR_1105 -> VAR_1106 = VAR_1107 -> VAR_1108 ; VAR_1109 -> VAR_1110 = VAR_1111 -> VAR_1112 ; if ( VAR_1113 -> VAR_1114 >= ( VAR_1115 -> VAR_1116 + 1 ) ) { VAR_1117 -> VAR_1118 = 1 ; } { TYPE_53 * VAR_1119 = VAR_1120 -> VAR_1121 ; if ( ( VAR_1122 -> VAR_1123 & VAR_1124 ) && ( VAR_1125 -> VAR_1126 == VAR_1127 ) ) { VAR_1128 -> VAR_1129 = VAR_1130 ; } } PRINT_BIN_BIT_RATIO ( VAR_1131 ) return VAR_1132 ; }",<S2SV_ModStart> VAR_1037 ; } <S2SV_ModEnd> if ( VAR_1089,"CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SPS_PPS_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ;  if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ;   return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } <S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",<S2SV_ModStart> pv_parse_tu_coeff_data ; } <S2SV_ModEnd> if ( u1_slice_type
656,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 * VAR_2 = & VAR_3 -> VAR_4 ; unsigned TYPE_4 VAR_5 ; TYPE_5 VAR_6 ; TYPE_6 VAR_7 = VAR_8 -> VAR_9 ; TYPE_7 * VAR_10 = VAR_11 -> VAR_12 [ VAR_13 ] ; if ( VAR_14 ) { <S2SV_StartBug> METHOD_1 ( VAR_15 -> VAR_16 [ 0 ] + VAR_17 - 1 , 127 , VAR_18 -> VAR_19 + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_2 ( VAR_20 -> VAR_21 [ 0 ] + ( VAR_22 >> 1 ) - 1 , 127 , ( VAR_23 -> VAR_24 >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_3 ( VAR_25 -> VAR_26 [ 0 ] + ( VAR_27 >> 1 ) - 1 , 127 , ( VAR_28 -> VAR_29 >> 1 ) + 5 ) ; <S2SV_EndBug> for ( VAR_30 = 1 ; VAR_31 < VAR_32 -> VAR_33 ; VAR_34 ++ ) { <S2SV_StartBug> METHOD_4 ( VAR_35 -> VAR_36 [ VAR_37 ] + VAR_38 - 1 , ( unsigned TYPE_8 ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_5 ( VAR_39 -> VAR_40 [ VAR_41 ] + ( VAR_42 >> 1 ) - 1 , ( unsigned TYPE_9 ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_6 ( VAR_43 -> VAR_44 [ VAR_45 ] + ( VAR_46 >> 1 ) - 1 , ( unsigned TYPE_10 ) 129 , 1 ) ; <S2SV_EndBug> } for ( VAR_47 = 0 ; VAR_48 < VAR_49 -> VAR_50 ; VAR_51 ++ ) { <S2SV_StartBug> METHOD_7 ( VAR_52 -> VAR_53 [ VAR_54 ] , ( unsigned TYPE_11 ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_8 ( VAR_55 -> VAR_56 [ VAR_57 ] , ( unsigned TYPE_12 ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_9 ( VAR_58 -> VAR_59 [ VAR_60 ] , ( unsigned TYPE_13 ) 129 , 8 ) ; <S2SV_EndBug> } METHOD_10 ( VAR_61 , & VAR_62 -> VAR_63 , VAR_64 ) ; } else METHOD_11 ( VAR_65 ) ; METHOD_12 ( VAR_66 , VAR_67 , VAR_68 -> VAR_69 , VAR_70 -> VAR_71 ) ; for ( VAR_72 = 0 ; VAR_73 < VAR_74 -> VAR_75 ; VAR_76 ++ ) METHOD_13 ( & VAR_77 -> VAR_78 [ VAR_79 ] ) ; METHOD_14 ( VAR_80 , VAR_81 , 0 ) ; METHOD_15 ( & VAR_82 -> VAR_83 ) ; }",<S2SV_ModStart> VAR_64 ) { METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> 5 ) ; METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> 5 ) ; METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> ++ ) { METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> 1 ) ; METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> 1 ) ; METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> ++ ) { METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> 16 ) ; METHOD_16 <S2SV_ModEnd> ( VAR_82 -> <S2SV_ModStart> 8 ) ; METHOD_16 <S2SV_ModEnd> ( VAR_82 ->,"CWE-119 void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> } vp8_loop_filter_frame_init ( pc , & pbi -> mb , filter_level ) ; } else vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; setup_decoding_thread_data ( pbi , xd , pbi -> mb_row_di , pbi -> decoding_thread_count ) ; for ( i = 0 ; i < pbi -> decoding_thread_count ; i ++ ) sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; mt_decode_mb_rows ( pbi , xd , 0 ) ; sem_wait ( & pbi -> h_event_end_decoding ) ; }",<S2SV_ModStart> filter_level ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 16 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 8 ) ; memset <S2SV_ModEnd> ( pbi ->
657,"CWE-476 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 ; TYPE_7 VAR_6 ; TYPE_8 VAR_7 ; TYPE_9 VAR_8 ; TYPE_10 VAR_9 ; TYPE_11 VAR_10 ; <S2SV_StartBug> if ( VAR_11 == 0 && VAR_12 == 0 ) { <S2SV_EndBug> return ; } VAR_13 = 1 << VAR_14 ; VAR_15 = VAR_16 ; for ( VAR_17 = 0 ; VAR_18 < METHOD_1 ( VAR_19 ) ; ++ VAR_20 ) { for ( VAR_21 = 0 ; VAR_22 < METHOD_2 ( VAR_23 ) ; ++ VAR_24 ) { VAR_25 = METHOD_3 ( VAR_26 , VAR_27 , VAR_28 ) ; VAR_29 = METHOD_4 ( VAR_30 ) ; if ( VAR_31 >= VAR_32 ) { VAR_33 >>= VAR_34 ; VAR_35 = ( VAR_36 < 0 ) ? ( - VAR_37 ) : VAR_38 ; METHOD_5 ( VAR_39 , VAR_40 , VAR_41 , VAR_42 ) ; } else { VAR_43 <<= VAR_44 ; <S2SV_StartBug> VAR_45 = ( 1 << VAR_46 ) - 1 ; <S2SV_EndBug> if ( VAR_47 & ( ~ VAR_48 ) ) { if ( ! VAR_49 ) { METHOD_6 ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; VAR_50 = VAR_51 ; } VAR_52 &= VAR_53 ; } VAR_54 = ( VAR_55 < 0 ) ? ( - VAR_56 ) : VAR_57 ; METHOD_7 ( VAR_58 , VAR_59 , VAR_60 , VAR_61 ) ; } } } }","<S2SV_ModStart> if ( VAR_34 < 0 ) { METHOD_6 ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; VAR_34 = 0 ; } if ( VAR_34 <S2SV_ModStart> VAR_53 = ( METHOD_8 ( TYPE_11 , 1 ) <S2SV_ModEnd> << VAR_46 )","CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }","<S2SV_ModStart> if ( roishift < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )"
658,"CWE-119 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , <S2SV_EndBug> const TYPE_2 * VAR_1 , TYPE_3 VAR_2 , unsigned TYPE_4 VAR_3 , TYPE_5 VAR_4 , unsigned TYPE_6 VAR_5 , <S2SV_StartBug> TYPE_7 * VAR_6 ) { <S2SV_EndBug> TYPE_8 VAR_7 = VAR_8 ; const TYPE_9 * VAR_9 = VAR_10 ; const TYPE_10 VAR_11 = METHOD_1 ( VAR_12 , VAR_13 , VAR_14 , VAR_15 , VAR_16 , VAR_17 ) ; if ( VAR_18 != VAR_19 ) METHOD_2 ( VAR_20 , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats."" ) ; while ( ( VAR_21 = METHOD_3 ( VAR_22 , & VAR_23 ) ) != VAR_24 ) { <S2SV_StartBug> if ( VAR_25 -> VAR_26 == VAR_27 ) { <S2SV_EndBug> const TYPE_11 * const VAR_28 = VAR_29 -> VAR_30 . VAR_31 . VAR_32 ; const TYPE_12 VAR_33 = VAR_34 -> VAR_35 . VAR_36 . VAR_37 ; VAR_38 -> VAR_39 = METHOD_4 ( VAR_40 -> VAR_41 , VAR_42 -> VAR_43 + VAR_44 ) ; METHOD_5 ( ( TYPE_13 * ) VAR_45 -> VAR_46 + VAR_47 -> VAR_48 , VAR_49 , VAR_50 ) ; VAR_51 -> VAR_52 += VAR_53 ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static TYPE_6 <S2SV_ModEnd> METHOD_0 ( TYPE_1 <S2SV_ModStart> VAR_51 ) { TYPE_6 VAR_54 = 0 ; <S2SV_ModStart> VAR_24 ) { VAR_54 = 1 ; <S2SV_ModStart> ; } } return VAR_54 ;,"CWE-119 <S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats."" ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> get_frame_stats ( vpx_codec_ctx_t <S2SV_ModStart> stats ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
659,"CWE-119 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_EndBug> <S2SV_StartBug> TYPE_3 * const VAR_2 = ( TYPE_4 * ) VAR_3 ; <S2SV_EndBug> <S2SV_StartBug> ( TYPE_5 ) VAR_4 ; <S2SV_EndBug> <S2SV_StartBug> METHOD_1 ( VAR_5 -> VAR_6 , VAR_7 -> VAR_8 , & VAR_9 -> VAR_10 , <S2SV_EndBug> VAR_11 -> VAR_12 , VAR_13 -> VAR_14 , VAR_15 -> VAR_16 ) ; return 1 ; }","<S2SV_ModStart> TYPE_0 METHOD_0 ( <S2SV_ModEnd> TYPE_4 * const <S2SV_ModStart> * const VAR_15 , TYPE_5 * unused ) { <S2SV_ModEnd> ( TYPE_5 ) <S2SV_ModStart> ( TYPE_5 ) unused <S2SV_ModEnd> ; METHOD_1 ( <S2SV_ModStart> -> VAR_8 , VAR_15 -> VAR_17 <S2SV_ModEnd> , VAR_15 ->","CWE-119 <S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }","<S2SV_ModStart> int vp9_loop_filter_worker ( <S2SV_ModEnd> LFWorkerData * const <S2SV_ModStart> * const lf_data , void * unused ) { <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( void ) unused <S2SV_ModEnd> ; vp9_loop_filter_rows ( <S2SV_ModStart> -> cm , lf_data -> planes <S2SV_ModEnd> , lf_data ->"
660,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; TYPE_3 * VAR_2 ; TYPE_4 VAR_3 ; while ( ( VAR_4 = METHOD_1 ( VAR_5 , ""//"" ) ) != ( TYPE_5 * ) 0 ) { for ( VAR_6 = VAR_7 + 2 ; * VAR_8 == '/' ; ++ VAR_9 ) continue ; ( TYPE_6 ) METHOD_2 ( VAR_10 + 1 , VAR_11 ) ; } while ( METHOD_3 ( VAR_12 , ""./"" , 2 ) == 0 ) ( TYPE_7 ) METHOD_4 ( VAR_13 , VAR_14 + 2 , METHOD_5 ( VAR_15 ) - 1 ) ; while ( ( VAR_16 = METHOD_6 ( VAR_17 , ""/./"" ) ) != ( TYPE_8 * ) 0 ) <S2SV_StartBug> ( TYPE_9 ) METHOD_7 ( VAR_18 , VAR_19 + 2 , METHOD_8 ( VAR_20 ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( METHOD_9 ( VAR_21 , ""../"" , 3 ) == 0 ) ( TYPE_10 ) METHOD_10 ( VAR_22 , VAR_23 + 3 , METHOD_11 ( VAR_24 ) - 2 ) ; VAR_25 = METHOD_12 ( VAR_26 , ""/../"" ) ; if ( VAR_27 == ( TYPE_11 * ) 0 ) break ; for ( VAR_28 = VAR_29 - 1 ; VAR_30 >= VAR_31 && * VAR_32 != '/' ; -- VAR_33 ) continue ; ( TYPE_12 ) METHOD_13 ( VAR_34 + 1 , VAR_35 + 4 ) ; } while ( ( VAR_36 = METHOD_14 ( VAR_37 ) ) > 3 && METHOD_15 ( ( VAR_38 = VAR_39 + VAR_40 - 3 ) , ""/.."" ) == 0 ) { for ( VAR_41 = VAR_42 - 1 ; VAR_43 >= VAR_44 && * VAR_45 != '/' ; -- VAR_46 ) continue ; if ( VAR_47 < VAR_48 ) break ; * VAR_49 = '\\0' ; } }","<S2SV_ModStart> , METHOD_14 ( VAR_42 <S2SV_ModEnd> ) - 1","CWE-119 static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , ""//"" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) <S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( strncmp ( file , ""../"" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , ""/../"" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , ""/.."" ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\\0' ; } }","<S2SV_ModStart> , strlen ( cp <S2SV_ModEnd> ) - 1"
661,"CWE-119 static TYPE_0 METHOD_0 ( const struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , TYPE_2 * VAR_2 ) { unsigned TYPE_3 VAR_3 ; for ( VAR_4 = 0 ; VAR_5 < VAR_6 ; VAR_7 ++ ) { unsigned TYPE_4 VAR_8 = VAR_9 -> VAR_10 [ VAR_11 ] ; struct STRUCT_OR_UNION_1 * VAR_12 = ( struct STRUCT_OR_UNION_2 * ) ( VAR_13 + VAR_14 ) ; if ( ! ( VAR_15 & ( 1 << VAR_16 ) ) ) continue ; VAR_17 -> VAR_18 . VAR_19 = VAR_20 ; for ( ; ; ) { const struct STRUCT_OR_UNION_3 * VAR_21 = ( TYPE_5 * ) METHOD_1 ( VAR_22 ) ; TYPE_6 VAR_23 = VAR_24 -> VAR_25 & ( 1 << VAR_26 ) ; if ( VAR_27 -> VAR_28 & ( 1 << VAR_29 ) ) { METHOD_2 ( ""arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , VAR_30 , VAR_31 , VAR_32 -> VAR_33 ) ; return 0 ; } VAR_34 -> VAR_35 |= ( ( 1 << VAR_36 ) | ( 1 << VAR_37 ) ) ; <S2SV_StartBug> if ( ( VAR_38 -> VAR_39 == sizeof ( struct STRUCT_OR_UNION_4 ) && <S2SV_EndBug> ( METHOD_3 ( VAR_40 -> VAR_41 . VAR_42 . VAR_43 . VAR_44 , VAR_45 ) == 0 ) && <S2SV_StartBug> VAR_46 -> VAR_47 < 0 && METHOD_4 ( & VAR_48 -> VAR_49 ) ) || <S2SV_EndBug> VAR_50 ) { unsigned TYPE_7 VAR_51 , VAR_52 ; if ( ( METHOD_5 ( VAR_53 -> VAR_54 . VAR_55 . VAR_56 . VAR_57 , VAR_58 ) == 0 ) && VAR_59 -> VAR_60 < - VAR_61 - 1 ) { METHOD_6 ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , VAR_62 -> VAR_63 ) ; return 0 ; } do { VAR_64 -> VAR_65 ^= ( 1 << VAR_66 ) ; VAR_67 = VAR_68 ; VAR_69 = VAR_70 -> VAR_71 . VAR_72 ; VAR_73 -> VAR_74 . VAR_75 = 0 ; if ( VAR_76 == VAR_77 ) goto VAR_78 ; VAR_79 = ( struct STRUCT_OR_UNION_5 * ) ( VAR_80 + VAR_81 ) ; } while ( VAR_82 == VAR_83 + VAR_84 -> VAR_85 ) ; VAR_86 = VAR_87 -> VAR_88 ; VAR_89 = ( struct STRUCT_OR_UNION_6 * ) ( VAR_90 + VAR_91 + VAR_92 ) ; VAR_93 -> VAR_94 . VAR_95 = VAR_96 ; VAR_97 += VAR_98 ; } else { TYPE_8 VAR_99 = VAR_100 -> VAR_101 ; if ( METHOD_7 ( VAR_102 -> VAR_103 . VAR_104 . VAR_105 . VAR_106 , VAR_107 ) == 0 && VAR_108 >= 0 ) { if ( VAR_109 > VAR_110 -> VAR_111 - sizeof ( struct STRUCT_OR_UNION_7 ) ) { METHOD_8 ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , VAR_112 ) ; return 0 ; } METHOD_9 ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , VAR_113 , VAR_114 ) ; } else { VAR_115 = VAR_116 + VAR_117 -> VAR_118 ; } VAR_119 = ( struct STRUCT_OR_UNION_8 * ) ( VAR_120 + VAR_121 ) ; VAR_122 -> VAR_123 . VAR_124 = VAR_125 ; VAR_126 = VAR_127 ; } } VAR_128 : METHOD_10 ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , VAR_129 ) ; } return 1 ; }",<S2SV_ModStart> if ( ( METHOD_4 ( VAR_122 <S2SV_ModEnd> ) && ( <S2SV_ModStart> VAR_101 < 0 <S2SV_ModEnd> ) || VAR_50,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( ""arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct arpt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }",<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
662,CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { <S2SV_StartBug> TYPE_1 VAR_1 = VAR_2 -> VAR_3 . VAR_4 ; <S2SV_EndBug> if ( VAR_5 -> VAR_6 . VAR_7 != VAR_8 ) return - VAR_9 ; if ( METHOD_1 ( VAR_10 ) ) return - VAR_11 ; switch ( VAR_12 ) { case VAR_13 : case VAR_14 : return - VAR_15 ; default : break ; } if ( VAR_16 >= VAR_17 ) return - VAR_18 ; if ( ! VAR_19 -> VAR_20 ) { TYPE_2 VAR_21 ; VAR_22 = METHOD_2 ( VAR_23 ) ; if ( VAR_24 ) return VAR_25 ; METHOD_3 ( & VAR_26 [ VAR_27 ] ) ; VAR_28 -> VAR_29 = VAR_30 ; } return 0 ; },<S2SV_ModStart> VAR_28 ) { TYPE_3 <S2SV_ModEnd> VAR_27 = VAR_28,CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; },<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event
663,"CWE-119 static TYPE_0 * METHOD_0 ( TYPE_1 ) { METHOD_1 ( & VAR_0 , VAR_1 ) ; VAR_2 = METHOD_2 ( VAR_3 ) ; if ( ! VAR_4 ) { METHOD_3 ( VAR_5 , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file."" , VAR_6 ) ; VAR_7 = METHOD_4 ( VAR_8 ) ; if ( ! VAR_9 ) { METHOD_5 ( VAR_10 , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured."" , VAR_11 ) ; VAR_12 = METHOD_6 ( ) ; if ( ! VAR_13 ) { METHOD_7 ( VAR_14 , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object."" , VAR_15 ) ; goto VAR_16 ; } } if ( METHOD_8 ( VAR_17 , VAR_18 ) ) METHOD_9 ( VAR_19 ) ; } <S2SV_StartBug> VAR_20 = METHOD_10 ( ) ; <S2SV_EndBug> if ( ! VAR_21 ) { METHOD_11 ( VAR_22 , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm."" , VAR_23 ) ; goto VAR_24 ; } return METHOD_12 ( VAR_25 ) ; VAR_26 : ; METHOD_13 ( VAR_27 ) ; METHOD_14 ( VAR_28 ) ; METHOD_15 ( & VAR_29 ) ; VAR_30 = VAR_31 ; VAR_32 = VAR_33 ; return METHOD_16 ( VAR_34 ) ; }",<S2SV_ModStart> ) ; } METHOD_17 ( ) ;,"CWE-119 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file."" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured."" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object."" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm."" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }",<S2SV_ModStart> ) ; } btif_config_devcache_cleanup ( ) ;
664,"CWE-189 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = METHOD_1 ( VAR_2 ) ; struct STRUCT_OR_UNION_2 * VAR_3 = VAR_4 ; TYPE_1 VAR_5 ; TYPE_2 VAR_6 ; <S2SV_StartBug> TYPE_3 VAR_7 = 0 ; <S2SV_EndBug> TYPE_4 VAR_8 ; TYPE_5 VAR_9 ; VAR_10 -> VAR_11 = VAR_12 -> VAR_13 -> VAR_14 ; <S2SV_StartBug> VAR_15 = 1 << VAR_16 -> VAR_17 ; <S2SV_EndBug> <S2SV_StartBug> if ( VAR_18 < 2 ) { <S2SV_EndBug> VAR_19 -> VAR_20 = 0 ; return 1 ; } VAR_21 = ( ( VAR_22 -> VAR_23 + VAR_24 - 1 ) + ( ( METHOD_2 ( VAR_25 -> VAR_26 -> VAR_27 ) + 1 ) << METHOD_3 ( VAR_28 ) ) ) / VAR_29 ; VAR_30 = VAR_31 * sizeof ( struct STRUCT_OR_UNION_3 ) ; VAR_32 -> VAR_33 = METHOD_4 ( VAR_34 , VAR_35 ) ; if ( VAR_36 -> VAR_37 == VAR_38 ) { METHOD_5 ( VAR_39 , VAR_40 , ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups"" , VAR_41 ) ; goto VAR_42 ; } for ( VAR_43 = 0 ; VAR_44 < VAR_45 -> VAR_46 ; VAR_47 ++ ) { VAR_48 = METHOD_6 ( VAR_49 , VAR_50 , VAR_51 ) ; VAR_52 = METHOD_7 ( VAR_53 , VAR_54 ) ; METHOD_8 ( METHOD_9 ( VAR_55 , VAR_56 ) , & VAR_57 -> VAR_58 [ VAR_59 ] . VAR_60 ) ; METHOD_10 ( METHOD_11 ( VAR_61 , VAR_62 ) , & VAR_63 -> VAR_64 [ VAR_65 ] . VAR_66 ) ; METHOD_12 ( METHOD_13 ( VAR_67 , VAR_68 ) , & VAR_69 -> VAR_70 [ VAR_71 ] . VAR_72 ) ; } return 1 ; VAR_73 : return 0 ; }",<S2SV_ModStart> TYPE_2 VAR_71 ; unsigned <S2SV_ModStart> -> VAR_20 ; if ( VAR_69 -> VAR_20 < 1 || VAR_69 -> VAR_20 > 31 ) { VAR_69 -> VAR_20 = 0 ; return 1 ; } <S2SV_ModStart> -> VAR_20 ; <S2SV_ModEnd> VAR_41 = (,"CWE-189 static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups"" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }",<S2SV_ModStart> ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
665,"CWE-125 static TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 ; TYPE_6 VAR_5 = VAR_6 ; <S2SV_StartBug> for ( VAR_7 = VAR_8 + 2 ; VAR_9 < VAR_10 + 2 + VAR_11 [ VAR_12 + 1 ] ; VAR_13 ++ ) <S2SV_EndBug> if ( VAR_14 -> VAR_15 [ VAR_16 ] == VAR_17 || VAR_18 [ VAR_19 ] != VAR_20 -> VAR_21 [ VAR_22 ++ ] ) return 0 ; return 1 ; }",<S2SV_ModStart> + 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( VAR_22 < VAR_20 -> VAR_23 ) ),"CWE-125 static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }",<S2SV_ModStart> + 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( kk < input -> length ) )
666,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 ; struct STRUCT_OR_UNION_3 * VAR_4 , * VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 , * VAR_7 ; TYPE_1 VAR_8 ; VAR_9 = METHOD_1 ( VAR_10 ) ; VAR_11 = VAR_12 -> VAR_13 ; VAR_14 = METHOD_2 ( VAR_15 ) ; VAR_16 = METHOD_3 ( VAR_17 -> VAR_18 ) ; VAR_19 = METHOD_4 ( VAR_20 -> VAR_21 ) ; if ( ! ( VAR_22 -> VAR_23 & VAR_24 ) ) goto VAR_25 ; if ( VAR_26 -> VAR_27 & VAR_28 ) VAR_29 -> VAR_30 = VAR_31 -> VAR_32 ; VAR_33 = VAR_34 -> VAR_35 + VAR_36 ; if ( METHOD_5 ( VAR_37 , VAR_38 ) != VAR_39 ) goto VAR_40 ; VAR_41 -> VAR_42 += VAR_43 ; VAR_44 -> VAR_45 ++ ; VAR_46 -> VAR_47 += VAR_48 ; VAR_49 -> VAR_50 ++ ; return VAR_51 ; VAR_52 : METHOD_6 ( VAR_53 ) ; VAR_54 -> VAR_55 ++ ; return VAR_56 ; VAR_57 : <S2SV_StartBug> METHOD_7 ( VAR_58 ) ; <S2SV_EndBug> VAR_59 -> VAR_60 ++ ; return VAR_61 ; }",<S2SV_ModStart> ; VAR_57 : <S2SV_ModEnd> VAR_59 -> VAR_60,"CWE-399 static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }",<S2SV_ModStart> ; rx_drop : <S2SV_ModEnd> rcv_stats -> rx_dropped
667,"CWE-119 static TYPE_0 METHOD_0 ( unsigned TYPE_1 * VAR_0 , const unsigned TYPE_2 * VAR_1 , unsigned TYPE_3 * VAR_2 ) { <S2SV_StartBug> TYPE_4 VAR_3 ; <S2SV_EndBug> unsigned TYPE_5 VAR_4 [ 8 ] ; <S2SV_StartBug> struct STRUCT_OR_UNION_0 * VAR_5 ; <S2SV_EndBug> struct STRUCT_OR_UNION_1 VAR_6 , VAR_7 ; struct STRUCT_OR_UNION_2 * VAR_8 ; METHOD_1 ( VAR_9 , VAR_10 ) ; <S2SV_StartBug> VAR_11 = METHOD_2 ( ""ecb(des)"" , 0 , VAR_12 ) ; <S2SV_EndBug> if ( METHOD_3 ( VAR_13 ) ) { <S2SV_StartBug> VAR_14 = METHOD_4 ( VAR_15 ) ; <S2SV_EndBug> METHOD_5 ( VAR_16 , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; <S2SV_StartBug> goto VAR_17 ; <S2SV_EndBug> } VAR_18 = METHOD_6 ( VAR_19 , VAR_20 ) ; if ( ! VAR_21 ) { VAR_22 = - VAR_23 ; METHOD_7 ( VAR_24 , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; goto VAR_25 ; } METHOD_8 ( VAR_26 , VAR_27 , 8 ) ; <S2SV_StartBug> METHOD_9 ( & VAR_28 , VAR_29 , 8 ) ; <S2SV_EndBug> METHOD_10 ( & VAR_30 , VAR_31 , 8 ) ; METHOD_11 ( VAR_32 , 0 , VAR_33 , VAR_34 ) ; METHOD_12 ( VAR_35 , & VAR_36 , & VAR_37 , 8 , VAR_38 ) ; VAR_39 = METHOD_13 ( VAR_40 ) ; if ( VAR_41 ) METHOD_14 ( VAR_42 , ""could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n"" , VAR_43 ) ; METHOD_15 ( VAR_44 ) ; VAR_45 : METHOD_16 ( VAR_46 ) ; <S2SV_StartBug> VAR_47 : <S2SV_EndBug> return VAR_48 ; }","<S2SV_ModStart> VAR_9 ) { <S2SV_ModEnd> unsigned TYPE_5 VAR_27 <S2SV_ModStart> ] ; struct crypto_cipher * VAR_46 <S2SV_ModEnd> ; METHOD_1 ( <S2SV_ModStart> ; VAR_46 = METHOD_17 ( ""des"" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> METHOD_14 ( VAR_42 <S2SV_ModStart> ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; return METHOD_4 ( VAR_46 ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( VAR_46 , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( VAR_46 , VAR_31 , VAR_29 ) ; crypto_free_cipher <S2SV_ModEnd> ( VAR_46 ) <S2SV_ModStart> VAR_46 ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>","CWE-119 static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <S2SV_StartBug> int rc ; <S2SV_EndBug> unsigned char key2 [ 8 ] ; <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> if ( IS_ERR ( tfm_des ) ) { <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n"" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <S2SV_StartBug> smbhash_err : <S2SV_EndBug> return rc ; }","<S2SV_ModStart> key ) { <S2SV_ModEnd> unsigned char key2 <S2SV_ModStart> ] ; struct crypto_cipher * tfm_des <S2SV_ModEnd> ; str_to_key ( <S2SV_ModStart> ; tfm_des = crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> cifs_dbg ( VFS <S2SV_ModStart> ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( tfm_des , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> ( tfm_des ) <S2SV_ModStart> tfm_des ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>"
668,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { TYPE_3 VAR_2 , VAR_3 , VAR_4 ; for ( VAR_5 = 0 ; VAR_6 -> VAR_7 && VAR_8 < VAR_9 -> VAR_10 ; VAR_11 ++ ) { TYPE_4 * VAR_12 = VAR_13 -> VAR_14 + VAR_15 ; for ( VAR_16 = 0 ; VAR_17 < VAR_18 -> VAR_19 ; VAR_20 ++ ) { TYPE_5 * VAR_21 = VAR_22 -> VAR_23 + VAR_24 ; for ( VAR_25 = 0 ; VAR_26 < VAR_27 -> VAR_28 * VAR_29 -> VAR_30 ; VAR_31 ++ ) { <S2SV_StartBug> TYPE_6 * VAR_32 = VAR_33 -> VAR_34 + VAR_35 ; <S2SV_EndBug> METHOD_1 ( & VAR_36 -> VAR_37 ) ; METHOD_2 ( & VAR_38 -> VAR_39 ) ; METHOD_3 ( & VAR_40 -> VAR_41 ) ; } <S2SV_StartBug> METHOD_4 ( & VAR_42 -> VAR_43 ) ; <S2SV_EndBug> } METHOD_5 ( & VAR_44 -> VAR_45 ) ; } METHOD_6 ( & VAR_46 -> VAR_47 ) ; METHOD_7 ( & VAR_48 -> VAR_49 ) ; METHOD_8 ( & VAR_50 -> VAR_51 ) ; METHOD_9 ( & VAR_52 -> VAR_53 ) ; }",<S2SV_ModStart> ++ ) { if ( VAR_45 -> VAR_43 ) { <S2SV_ModStart> ) ; } },"CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }",<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
669,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { struct STRUCT_OR_UNION_0 VAR_1 ; struct STRUCT_OR_UNION_1 VAR_2 ; TYPE_2 VAR_3 = VAR_4 ; TYPE_3 TYPE_4 TYPE_5 TYPE_6 = 0 ; METHOD_1 ( VAR_5 -> VAR_6 , VAR_7 , VAR_8 ) ; METHOD_2 ( ""Entering<S2SV_blank>request<S2SV_blank>loop!\\n"" ) ; VAR_9 . VAR_10 = METHOD_3 ( VAR_11 ) ; VAR_12 . VAR_13 = 0 ; while ( VAR_14 ) { TYPE_7 VAR_15 [ VAR_16 ] ; TYPE_8 VAR_17 ; TYPE_9 TYPE_10 TYPE_11 ++ ; TYPE_12 ( ""%d:<S2SV_blank>"" , TYPE_13 ) ; METHOD_4 ( VAR_18 -> VAR_19 , & VAR_20 , sizeof ( VAR_21 ) ) ; VAR_22 . VAR_23 = METHOD_5 ( VAR_24 . VAR_25 ) ; VAR_26 . VAR_27 = METHOD_6 ( VAR_28 . VAR_29 ) ; if ( VAR_30 . VAR_31 == VAR_32 ) { METHOD_7 ( VAR_33 , ""Disconnect<S2SV_blank>request<S2SV_blank>received."" ) ; if ( VAR_34 -> VAR_35 -> VAR_36 & VAR_37 ) { if ( VAR_38 -> VAR_39 ) METHOD_8 ( VAR_40 -> VAR_41 ) ; METHOD_9 ( VAR_42 -> VAR_43 ) ; METHOD_10 ( VAR_44 -> VAR_45 ) ; METHOD_11 ( VAR_46 -> VAR_47 ) ; } VAR_48 = VAR_49 ; continue ; } VAR_50 = METHOD_12 ( VAR_51 . VAR_52 ) ; if ( VAR_53 . VAR_54 != METHOD_13 ( VAR_55 ) ) METHOD_14 ( ""Not<S2SV_blank>enough<S2SV_blank>magic."" ) ; <S2SV_StartBug> if ( VAR_56 > VAR_57 + sizeof ( struct STRUCT_OR_UNION_2 ) ) <S2SV_EndBug> METHOD_15 ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ; TYPE_14 TYPE_15 TYPE_16 ( ""%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>"" , VAR_58 . VAR_59 ? ""WRITE"" : ""READ"" , ( unsigned TYPE_17 TYPE_18 ) VAR_60 . VAR_61 , ( unsigned TYPE_19 TYPE_20 ) VAR_62 . VAR_63 / 512 , VAR_64 ) ; METHOD_16 ( VAR_65 . VAR_66 , VAR_67 . VAR_68 , sizeof ( VAR_69 . VAR_70 ) ) ; if ( ( VAR_71 . VAR_72 + VAR_73 ) > ( VAR_74 ) ) { METHOD_17 ( ""[Number<S2SV_blank>too<S2SV_blank>large!]"" ) ; METHOD_18 ( VAR_75 , VAR_76 , VAR_77 ) ; continue ; } if ( ( ( TYPE_21 ) ( ( TYPE_22 ) VAR_78 . VAR_79 + VAR_80 ) > VAR_81 -> VAR_82 ) ) { METHOD_19 ( ""[RANGE!]"" ) ; METHOD_20 ( VAR_83 , VAR_84 , VAR_85 ) ; continue ; } if ( VAR_86 . VAR_87 == VAR_88 ) { METHOD_21 ( ""wr:<S2SV_blank>net->buf,<S2SV_blank>"" ) ; METHOD_22 ( VAR_89 -> VAR_90 , VAR_91 , VAR_92 ) ; METHOD_23 ( ""buf->exp,<S2SV_blank>"" ) ; if ( ( VAR_93 -> VAR_94 -> VAR_95 & VAR_96 ) || ( VAR_97 -> VAR_98 -> VAR_99 & VAR_100 ) ) { METHOD_24 ( ""[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]"" ) ; METHOD_25 ( VAR_101 , VAR_102 , VAR_103 ) ; continue ; } if ( METHOD_26 ( VAR_104 . VAR_105 , VAR_106 , VAR_107 , VAR_108 ) ) { METHOD_27 ( ""Write<S2SV_blank>failed:<S2SV_blank>%m"" ) ; METHOD_28 ( VAR_109 , VAR_110 , VAR_111 ) ; continue ; } METHOD_29 ( VAR_112 -> VAR_113 , VAR_114 ) ; METHOD_30 ( ""OK!\\n"" ) ; continue ; } METHOD_31 ( ""exp->buf,<S2SV_blank>"" ) ; if ( METHOD_32 ( VAR_115 . VAR_116 , VAR_117 + sizeof ( struct STRUCT_OR_UNION_3 ) , VAR_118 , VAR_119 ) ) { METHOD_33 ( ""Read<S2SV_blank>failed:<S2SV_blank>%m"" ) ; METHOD_34 ( VAR_120 , VAR_121 , VAR_122 ) ; continue ; } METHOD_35 ( ""buf->net,<S2SV_blank>"" ) ; METHOD_36 ( VAR_123 , & VAR_124 , sizeof ( struct STRUCT_OR_UNION_4 ) ) ; METHOD_37 ( VAR_125 -> VAR_126 , VAR_127 , VAR_128 + sizeof ( struct STRUCT_OR_UNION_5 ) ) ; METHOD_38 ( ""OK!\\n"" ) ; } return 0 ; }",<S2SV_ModStart> VAR_128 > VAR_57 - <S2SV_ModEnd> sizeof ( struct,"CWE-119 int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ;  ifdef DODBG int i = 0 ;   negotiate ( client -> net , client , NULL ) ; DEBUG ( ""Entering<S2SV_blank>request<S2SV_blank>loop!\\n"" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ;  ifdef DODBG i ++ ; printf ( ""%d:<S2SV_blank>"" , i ) ;   readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , ""Disconnect<S2SV_blank>request<S2SV_blank>received."" ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( ""Not<S2SV_blank>enough<S2SV_blank>magic."" ) ; <S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;  ifdef DODBG printf ( ""%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>"" , request . type ? ""WRITE"" : ""READ"" , ( unsigned long long ) request . from , ( unsigned long long ) request . from / 512 , len ) ;   memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; if ( ( request . from + len ) > ( OFFT_MAX ) ) { DEBUG ( ""[Number<S2SV_blank>too<S2SV_blank>large!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { DEBUG ( ""[RANGE!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( request . type == NBD_CMD_WRITE ) { DEBUG ( ""wr:<S2SV_blank>net->buf,<S2SV_blank>"" ) ; readit ( client -> net , buf , len ) ; DEBUG ( ""buf->exp,<S2SV_blank>"" ) ; if ( ( client -> server -> flags & F_READONLY ) || ( client -> server -> flags & F_AUTOREADONLY ) ) { DEBUG ( ""[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]"" ) ; ERROR ( client , reply , EPERM ) ; continue ; } if ( expwrite ( request . from , buf , len , client ) ) { DEBUG ( ""Write<S2SV_blank>failed:<S2SV_blank>%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } SEND ( client -> net , reply ) ; DEBUG ( ""OK!\\n"" ) ; continue ; } DEBUG ( ""exp->buf,<S2SV_blank>"" ) ; if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { DEBUG ( ""Read<S2SV_blank>failed:<S2SV_blank>%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } DEBUG ( ""buf->net,<S2SV_blank>"" ) ; memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; DEBUG ( ""OK!\\n"" ) ; } return 0 ; }",<S2SV_ModStart> len > BUFSIZE - <S2SV_ModEnd> sizeof ( struct
670,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 ; TYPE_2 VAR_4 , VAR_5 , VAR_6 ; TYPE_3 VAR_7 ; struct STRUCT_OR_UNION_3 * VAR_8 = METHOD_1 ( VAR_9 ) ; struct STRUCT_OR_UNION_4 * VAR_10 ; TYPE_4 VAR_11 ; struct STRUCT_OR_UNION_5 * VAR_12 ; <S2SV_StartBug> TYPE_5 VAR_13 = 0 ; <S2SV_EndBug> VAR_14 = METHOD_2 ( VAR_15 , VAR_16 , VAR_17 , & VAR_18 ) ; if ( ! VAR_19 ) return 1 ; METHOD_3 ( VAR_20 != VAR_21 ) ; <S2SV_StartBug> VAR_22 = ( struct STRUCT_OR_UNION_6 * ) VAR_23 -> VAR_24 ; <S2SV_EndBug> VAR_25 = METHOD_4 ( VAR_26 , METHOD_5 ( VAR_27 -> VAR_28 ) ) ; if ( VAR_29 ) goto VAR_30 ; for ( VAR_31 = 0 , VAR_32 = 0 ; <S2SV_StartBug> VAR_33 < VAR_34 -> VAR_35 && VAR_36 < METHOD_6 ( VAR_37 -> VAR_38 ) ; <S2SV_EndBug> VAR_39 ++ , VAR_40 += VAR_41 -> VAR_42 ) { struct STRUCT_OR_UNION_7 * VAR_43 = & VAR_44 -> VAR_45 [ VAR_46 ] ; VAR_47 = ( struct STRUCT_OR_UNION_8 * ) & ( VAR_48 -> VAR_49 [ VAR_50 ] ) ; VAR_51 = VAR_52 -> VAR_53 ; if ( VAR_54 == 1 ) { struct STRUCT_OR_UNION_9 * VAR_55 = ( struct STRUCT_OR_UNION_10 * ) VAR_56 ; VAR_57 -> VAR_58 = VAR_59 ; VAR_60 -> VAR_61 = METHOD_7 ( VAR_62 -> VAR_63 ) ; VAR_64 -> VAR_65 = METHOD_8 ( VAR_66 -> VAR_67 ) ; VAR_68 -> VAR_69 = VAR_70 ; } else if ( VAR_71 == 2 ) { struct STRUCT_OR_UNION_11 * VAR_72 = ( struct STRUCT_OR_UNION_12 * ) VAR_73 ; if ( ! METHOD_9 ( VAR_74 -> VAR_75 . VAR_76 , VAR_77 , METHOD_10 ( VAR_78 ) ) ) { TYPE_6 VAR_79 = METHOD_11 ( ( ( TYPE_7 * ) VAR_80 -> VAR_81 . VAR_82 ) [ 0 ] ) ; if ( VAR_83 < 0x0200 ) { VAR_84 -> VAR_85 = VAR_86 ; VAR_87 -> VAR_88 = VAR_89 ; } else { VAR_90 -> VAR_91 = VAR_92 ; VAR_93 -> VAR_94 = VAR_95 ; } } else if ( ! METHOD_12 ( VAR_96 -> VAR_97 . VAR_98 , VAR_99 , METHOD_13 ( VAR_100 ) ) ) { TYPE_8 VAR_101 ; struct STRUCT_OR_UNION_13 * VAR_102 ; struct STRUCT_OR_UNION_14 * VAR_103 = ( struct STRUCT_OR_UNION_15 * ) VAR_104 ; VAR_105 -> VAR_106 = VAR_107 ; VAR_108 -> VAR_109 . VAR_110 . VAR_111 = METHOD_14 ( VAR_112 -> VAR_113 ) ; for ( VAR_114 = 0 ; VAR_115 < VAR_116 -> VAR_117 ; VAR_118 ++ ) { struct STRUCT_OR_UNION_16 * VAR_119 ; VAR_120 = METHOD_15 ( VAR_121 -> VAR_122 [ VAR_123 ] ) ; VAR_124 = METHOD_16 ( VAR_125 , VAR_126 , VAR_127 , & VAR_128 ) ; VAR_129 -> VAR_130 . VAR_131 . VAR_132 [ VAR_133 ] = VAR_134 ; if ( VAR_135 == VAR_136 ) continue ; VAR_137 = ( struct STRUCT_OR_UNION_17 * ) VAR_138 -> VAR_139 ; if ( VAR_140 != 0 || METHOD_17 ( VAR_141 -> VAR_142 . VAR_143 , VAR_144 , METHOD_18 ( VAR_145 ) ) ) { METHOD_19 ( VAR_146 ) ; VAR_147 -> VAR_148 . VAR_149 . VAR_150 [ VAR_151 ] = VAR_152 ; } } VAR_153 -> VAR_154 = VAR_155 ; } else if ( ! METHOD_20 ( VAR_156 -> VAR_157 . VAR_158 , VAR_159 , METHOD_21 ( VAR_160 ) ) ) { struct STRUCT_OR_UNION_18 * VAR_161 = & VAR_162 -> VAR_163 . VAR_164 ; struct STRUCT_OR_UNION_19 * VAR_165 = ( struct STRUCT_OR_UNION_20 * ) & ( VAR_166 -> VAR_167 [ VAR_168 ] ) ; METHOD_22 ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , VAR_169 , VAR_170 , VAR_171 ) ; VAR_172 -> VAR_173 = VAR_174 ; VAR_175 -> VAR_176 = VAR_177 ; VAR_178 -> VAR_179 = METHOD_23 ( VAR_180 -> VAR_181 ) ; VAR_182 -> VAR_183 = METHOD_24 ( VAR_184 -> VAR_185 ) ; VAR_186 -> VAR_187 = METHOD_25 ( VAR_188 -> VAR_189 ) ; VAR_190 -> VAR_191 = METHOD_26 ( VAR_192 -> VAR_193 ) ; VAR_194 -> VAR_195 = METHOD_27 ( VAR_196 -> VAR_197 ) ; if ( VAR_198 -> VAR_199 & 0x01 ) VAR_200 -> VAR_201 |= VAR_202 ; METHOD_28 ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , METHOD_29 ( * ( TYPE_9 * ) VAR_203 -> VAR_204 . VAR_205 ) ) ; METHOD_30 ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , METHOD_31 ( VAR_206 -> VAR_207 ) ) ; METHOD_32 ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , METHOD_33 ( VAR_208 -> VAR_209 ) ) ; METHOD_34 ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , METHOD_35 ( VAR_210 -> VAR_211 ) ) ; METHOD_36 ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , METHOD_37 ( VAR_212 -> VAR_213 ) ) ; METHOD_38 ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , METHOD_39 ( VAR_214 -> VAR_215 ) ) ; METHOD_40 ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , VAR_216 -> VAR_217 , VAR_218 -> VAR_219 ) ; } else { METHOD_41 ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , VAR_220 -> VAR_221 . VAR_222 ) ; continue ; } VAR_223 -> VAR_224 = METHOD_42 ( VAR_225 -> VAR_226 ) ; VAR_227 -> VAR_228 = METHOD_43 ( VAR_229 -> VAR_230 ) ; } METHOD_44 ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , VAR_231 , VAR_232 -> VAR_233 , VAR_234 , VAR_235 -> VAR_236 ) ; } if ( VAR_237 ) { struct STRUCT_OR_UNION_21 * VAR_238 = ( struct STRUCT_OR_UNION_22 * ) & ( VAR_239 -> VAR_240 [ 0 ] ) ; * VAR_241 = METHOD_45 ( VAR_242 -> VAR_243 ) ; METHOD_46 ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , VAR_244 -> VAR_245 , VAR_246 -> VAR_247 ) ; } if ( VAR_248 -> VAR_249 . VAR_250 ) METHOD_47 ( VAR_251 , METHOD_48 ( VAR_252 -> VAR_253 ) ) ; VAR_254 : METHOD_49 ( VAR_255 ) ; return VAR_256 ; }","<S2SV_ModStart> * VAR_255 ; unsigned TYPE_5 VAR_257 ; <S2SV_ModStart> -> VAR_139 ; VAR_257 = METHOD_39 ( VAR_252 -> VAR_38 ) ; if ( sizeof ( * VAR_252 ) + VAR_257 > VAR_251 -> VAR_258 ) { METHOD_50 ( VAR_251 , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , VAR_257 , VAR_251 -> VAR_258 - sizeof ( * VAR_252 ) ) ; goto VAR_254 ; } <S2SV_ModStart> && VAR_168 < VAR_257 <S2SV_ModEnd> ; VAR_231 ++","CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }","<S2SV_ModStart> * bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++"
671,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { const unsigned TYPE_2 * VAR_1 = VAR_2 -> VAR_3 ; TYPE_3 VAR_4 = VAR_5 -> VAR_6 ; TYPE_4 VAR_7 = VAR_8 -> VAR_9 ; <S2SV_StartBug> TYPE_5 VAR_10 = VAR_11 - 8 - ( VAR_12 + 8 ) ; <S2SV_EndBug> TYPE_6 VAR_13 = VAR_14 -> VAR_15 - VAR_16 ; TYPE_7 VAR_17 = VAR_18 * VAR_19 ; TYPE_8 VAR_20 = ( TYPE_9 ) ( VAR_21 + VAR_22 - VAR_23 ) ; TYPE_10 VAR_24 = 0 ; unsigned TYPE_11 VAR_25 [ sizeof ( TYPE_12 ) + 1 ] ; if ( VAR_26 -> METHOD_1 ) { <S2SV_StartBug> TYPE_13 VAR_27 = VAR_28 > sizeof ( VAR_29 ) ? sizeof ( VAR_30 ) : VAR_31 ; <S2SV_EndBug> VAR_32 -> METHOD_2 ( VAR_33 -> VAR_34 , VAR_35 , VAR_36 , ( TYPE_14 ) VAR_37 ) ; VAR_38 = VAR_39 ; } if ( VAR_40 >= 0 ) { VAR_41 += VAR_42 ; VAR_43 = VAR_44 ; } if ( VAR_45 < 0 || VAR_46 ) { while ( VAR_47 >= VAR_48 ) { VAR_49 += VAR_50 ; VAR_51 |= ( TYPE_15 ) * VAR_52 << VAR_53 ; ++ VAR_54 ; ++ VAR_55 -> VAR_56 ; VAR_57 -= VAR_58 ; } } VAR_59 -> VAR_60 = VAR_61 ; VAR_62 -> VAR_63 = VAR_64 ; }","<S2SV_ModStart> = VAR_11 - VAR_58 <S2SV_ModEnd> - ( VAR_64 <S2SV_ModStart> ( VAR_64 + VAR_58 <S2SV_ModEnd> ) ; TYPE_13 <S2SV_ModStart> TYPE_13 VAR_37 = METHOD_3 ( sizeof ( VAR_39 ) , VAR_31 ) <S2SV_ModEnd> ; VAR_62 ->","CWE-119 void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }","<S2SV_ModStart> = VP8_BD_VALUE_SIZE - CHAR_BIT <S2SV_ModEnd> - ( count <S2SV_ModStart> ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br ->"
672,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { TYPE_1 VAR_2 ; struct STRUCT_OR_UNION_2 * VAR_3 ; struct STRUCT_OR_UNION_3 * VAR_4 , * VAR_5 ; struct STRUCT_OR_UNION_4 * VAR_6 , * VAR_7 ; struct STRUCT_OR_UNION_5 * VAR_8 , * VAR_9 ; struct STRUCT_OR_UNION_6 * VAR_10 ; for ( VAR_11 = 0 ; VAR_12 < VAR_13 -> VAR_14 ; VAR_15 ++ ) { unsigned VAR_16 ; VAR_17 = VAR_18 = VAR_19 ; VAR_20 = VAR_21 = VAR_22 ; VAR_23 = VAR_24 = VAR_25 ; VAR_26 = VAR_27 -> VAR_28 + VAR_29 ; if ( VAR_30 >= 0 && VAR_31 != VAR_32 -> VAR_33 . VAR_34 ) continue ; for ( VAR_35 = 0 ; VAR_36 < VAR_37 -> VAR_38 . VAR_39 ; VAR_40 ++ ) { struct STRUCT_OR_UNION_7 * VAR_41 ; TYPE_2 VAR_42 ; VAR_43 = VAR_44 -> VAR_45 + VAR_46 ; VAR_47 = METHOD_1 ( & VAR_48 -> VAR_49 ) ; switch ( METHOD_2 ( & VAR_50 -> VAR_51 ) ) { case VAR_52 : METHOD_3 ( VAR_53 , & VAR_54 , & VAR_55 , VAR_56 ) ; continue ; case VAR_57 : if ( VAR_58 -> VAR_59 -> VAR_60 ) METHOD_4 ( VAR_61 , & VAR_62 , & VAR_63 , VAR_64 ) ; continue ; case VAR_65 : if ( VAR_66 -> VAR_67 -> VAR_68 ) METHOD_5 ( VAR_69 , & VAR_70 , & VAR_71 , VAR_72 ) ; default : continue ; } } if ( ( VAR_73 && VAR_74 ) || VAR_75 || VAR_76 || VAR_77 || VAR_78 ) goto VAR_79 ; } return - VAR_80 ; VAR_81 : VAR_82 = METHOD_6 ( VAR_83 ) ; VAR_84 -> VAR_85 -> VAR_86 = VAR_87 -> VAR_88 . VAR_89 ; if ( VAR_90 -> VAR_91 . VAR_92 != 0 ) { VAR_93 = METHOD_7 ( VAR_94 , VAR_95 -> VAR_96 . VAR_97 , VAR_98 -> VAR_99 . VAR_100 ) ; if ( VAR_101 < 0 ) return VAR_102 ; } <S2SV_StartBug> if ( VAR_103 ) { <S2SV_EndBug> VAR_104 -> VAR_105 = METHOD_8 ( VAR_106 , VAR_107 -> VAR_108 . VAR_109 & VAR_110 ) ; <S2SV_StartBug> VAR_111 -> VAR_112 = METHOD_9 ( VAR_113 , <S2SV_EndBug> VAR_114 -> VAR_115 . VAR_116 & VAR_117 ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( VAR_118 ) { VAR_119 -> VAR_120 = & VAR_121 -> VAR_122 ; VAR_123 -> VAR_124 = METHOD_10 ( VAR_125 , VAR_126 -> VAR_127 . VAR_128 & VAR_129 ) ; } if ( VAR_130 ) { VAR_131 -> VAR_132 = & VAR_133 -> VAR_134 ; VAR_135 -> VAR_136 = METHOD_11 ( VAR_137 , VAR_138 -> VAR_139 . VAR_140 & VAR_141 ) ; } if ( VAR_142 ) { VAR_143 -> VAR_144 = & VAR_145 -> VAR_146 ; VAR_147 -> VAR_148 = METHOD_12 ( VAR_149 , VAR_150 -> VAR_151 . VAR_152 & VAR_153 ) ; } if ( VAR_154 ) { VAR_155 -> VAR_156 = & VAR_157 -> VAR_158 ; VAR_159 -> VAR_160 = METHOD_13 ( VAR_161 , VAR_162 -> VAR_163 . VAR_164 & VAR_165 ) ; } return 0 ; }",<S2SV_ModStart> ( VAR_107 ) <S2SV_ModEnd> VAR_159 -> VAR_105 <S2SV_ModStart> VAR_165 ) ; if ( VAR_114 ) <S2SV_ModStart> VAR_165 ) ; <S2SV_ModEnd> if ( VAR_126,"CWE-476 static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; } <S2SV_StartBug> if ( in ) { <S2SV_EndBug> dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }",<S2SV_ModStart> ( in ) <S2SV_ModEnd> dev -> in_pipe <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in
673,"CWE-787 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 ) { TYPE_5 * VAR_4 = VAR_5 ; TYPE_6 VAR_6 , VAR_7 ; TYPE_7 VAR_8 = 0 ; TYPE_8 VAR_9 ; for ( ; ; ) { VAR_10 = METHOD_1 ( & VAR_11 -> VAR_12 ) ; if ( VAR_13 <= 0 ) { if ( VAR_14 -> VAR_15 == VAR_16 && VAR_17 -> VAR_18 == VAR_19 ) { METHOD_2 ( VAR_20 , VAR_21 ) ; return 0 ; } if ( VAR_22 && VAR_23 -> VAR_24 == VAR_25 && VAR_26 == 0 ) { if ( ! ( VAR_27 -> VAR_28 & VAR_29 ) ) return 0 ; else goto VAR_30 ; } METHOD_3 ( VAR_31 , VAR_32 , ""%d<S2SV_blank>bytes<S2SV_blank>left\\n"" , VAR_33 ) ; if ( VAR_34 -> VAR_35 & VAR_36 && VAR_37 -> VAR_38 <= VAR_39 ) goto VAR_40 ; VAR_41 = VAR_42 ; goto VAR_43 ; } VAR_44 = METHOD_4 ( & VAR_45 -> VAR_46 ) ; if ( VAR_47 > 0x7fffffff || VAR_48 > METHOD_5 ( & VAR_49 -> VAR_50 ) ) { METHOD_6 ( VAR_51 , VAR_52 , ""chunk<S2SV_blank>too<S2SV_blank>big\\n"" ) ; VAR_53 = VAR_54 ; goto VAR_55 ; } VAR_56 = METHOD_7 ( & VAR_57 -> VAR_58 ) ; if ( VAR_59 -> VAR_60 & VAR_61 ) METHOD_8 ( VAR_62 , VAR_63 , ""png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n"" , ( VAR_64 & 0xff ) , ( ( VAR_65 >> 8 ) & 0xff ) , ( ( VAR_66 >> 16 ) & 0xff ) , ( ( VAR_67 >> 24 ) & 0xff ) , VAR_68 ) ; if ( VAR_69 -> VAR_70 == VAR_71 && VAR_72 -> VAR_73 == VAR_74 ) { switch ( VAR_75 ) { case METHOD_9 ( 'I' , 'H' , 'D' , 'R' ) : case METHOD_10 ( 'p' , 'H' , 'Y' , 's' ) : case METHOD_11 ( 't' , 'E' , 'X' , 't' ) : case METHOD_12 ( 'I' , 'D' , 'A' , 'T' ) : case METHOD_13 ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto VAR_76 ; } } switch ( VAR_77 ) { case METHOD_14 ( 'I' , 'H' , 'D' , 'R' ) : if ( ( VAR_78 = METHOD_15 ( VAR_79 , VAR_80 , VAR_81 ) ) < 0 ) goto VAR_82 ; break ; case METHOD_16 ( 'p' , 'H' , 'Y' , 's' ) : if ( ( VAR_83 = METHOD_17 ( VAR_84 , VAR_85 ) ) < 0 ) goto VAR_86 ; break ; case METHOD_18 ( 'f' , 'c' , 'T' , 'L' ) : if ( ! VAR_87 || VAR_88 -> VAR_89 != VAR_90 ) goto VAR_91 ; if ( ( VAR_92 = METHOD_19 ( VAR_93 , VAR_94 , VAR_95 ) ) < 0 ) goto VAR_96 ; VAR_97 = 1 ; break ; case METHOD_20 ( 'f' , 'd' , 'A' , 'T' ) : if ( ! VAR_98 || VAR_99 -> VAR_100 != VAR_101 ) goto VAR_102 ; if ( ! VAR_103 ) { VAR_104 = VAR_105 ; goto VAR_106 ; } METHOD_21 ( & VAR_107 -> VAR_108 ) ; VAR_109 -= 4 ; case METHOD_22 ( 'I' , 'D' , 'A' , 'T' ) : if ( VAR_110 && VAR_111 -> VAR_112 == VAR_113 && ! VAR_114 ) goto VAR_115 ; if ( ( VAR_116 = METHOD_23 ( VAR_117 , VAR_118 , VAR_119 , VAR_120 ) ) < 0 ) goto VAR_121 ; break ; case METHOD_24 ( 'P' , 'L' , 'T' , 'E' ) : if ( METHOD_25 ( VAR_122 , VAR_123 , VAR_124 ) < 0 ) goto VAR_125 ; break ; case METHOD_26 ( 't' , 'R' , 'N' , 'S' ) : if ( METHOD_27 ( VAR_126 , VAR_127 , VAR_128 ) < 0 ) goto VAR_129 ; break ; case METHOD_28 ( 't' , 'E' , 'X' , 't' ) : if ( METHOD_29 ( VAR_130 , VAR_131 , 0 , & VAR_132 ) < 0 ) METHOD_30 ( VAR_133 , VAR_134 , ""Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n"" ) ; METHOD_31 ( & VAR_135 -> VAR_136 , VAR_137 + 4 ) ; break ; case METHOD_32 ( 'z' , 'T' , 'X' , 't' ) : if ( METHOD_33 ( VAR_138 , VAR_139 , 1 , & VAR_140 ) < 0 ) METHOD_34 ( VAR_141 , VAR_142 , ""Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n"" ) ; METHOD_35 ( & VAR_143 -> VAR_144 , VAR_145 + 4 ) ; break ; case METHOD_36 ( 's' , 'T' , 'E' , 'R' ) : { TYPE_9 VAR_146 = METHOD_37 ( & VAR_147 -> VAR_148 ) ; TYPE_10 * VAR_149 = METHOD_38 ( VAR_150 ) ; if ( ! VAR_151 ) goto VAR_152 ; if ( VAR_153 == 0 || VAR_154 == 1 ) { VAR_155 -> VAR_156 = VAR_157 ; VAR_158 -> VAR_159 = VAR_160 ? 0 : VAR_161 ; } else { METHOD_39 ( VAR_162 , VAR_163 , ""Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n"" , VAR_164 ) ; } METHOD_40 ( & VAR_165 -> VAR_166 , 4 ) ; break ; } case METHOD_41 ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( VAR_167 -> VAR_168 & VAR_169 ) ) METHOD_42 ( VAR_170 , VAR_171 , ""IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n"" ) ; if ( ! ( VAR_172 -> VAR_173 & ( VAR_174 | VAR_175 ) ) ) { VAR_176 = VAR_177 ; goto VAR_178 ; } METHOD_43 ( & VAR_179 -> VAR_180 , 4 ) ; goto VAR_181 ; default : VAR_182 : METHOD_44 ( & VAR_183 -> VAR_184 , VAR_185 + 4 ) ; break ; } } VAR_186 : if ( VAR_187 -> VAR_188 == VAR_189 && VAR_190 -> VAR_191 == VAR_192 ) { METHOD_45 ( VAR_193 , VAR_194 ) ; return 0 ; } if ( VAR_195 -> VAR_196 <= 4 ) METHOD_46 ( VAR_197 , VAR_198 ) ; if ( VAR_199 -> VAR_200 && VAR_201 -> VAR_202 != VAR_203 ) { TYPE_11 VAR_204 = VAR_205 -> VAR_206 > 8 ? 2 : 1 ; TYPE_12 VAR_207 = VAR_208 -> VAR_209 - VAR_210 ; unsigned VAR_211 , VAR_212 ; <S2SV_StartBug> for ( VAR_213 = 0 ; VAR_214 < VAR_215 -> VAR_216 ; ++ VAR_217 ) { <S2SV_EndBug> TYPE_13 * VAR_218 = & VAR_219 -> VAR_220 [ VAR_221 -> VAR_222 * VAR_223 ] ; for ( VAR_224 = VAR_225 -> VAR_226 ; VAR_227 > 0 ; -- VAR_228 ) { TYPE_14 * VAR_229 = & VAR_230 [ VAR_231 -> VAR_232 * ( VAR_233 - 1 ) ] ; METHOD_47 ( VAR_234 , & VAR_235 [ VAR_236 * ( VAR_237 - 1 ) ] , VAR_238 ) ; if ( ! METHOD_48 ( VAR_239 , VAR_240 -> VAR_241 , VAR_242 ) ) { METHOD_49 ( & VAR_243 [ VAR_244 ] , 0 , VAR_245 ) ; } else { METHOD_50 ( & VAR_246 [ VAR_247 ] , 0xff , VAR_248 ) ; } } } } if ( VAR_249 -> VAR_250 . VAR_251 -> VAR_252 [ 0 ] ) { if ( ! ( VAR_253 -> VAR_254 & VAR_255 ) && VAR_256 -> VAR_257 != METHOD_51 ( ""MPNG"" ) && VAR_258 -> VAR_259 . VAR_260 -> VAR_261 == VAR_262 -> VAR_263 && VAR_264 -> VAR_265 . VAR_266 -> VAR_267 == VAR_268 -> VAR_269 && VAR_270 -> VAR_271 . VAR_272 -> VAR_273 == VAR_274 -> VAR_275 ) { if ( VAR_276 && VAR_277 -> VAR_278 != VAR_279 ) METHOD_52 ( VAR_280 , VAR_281 ) ; else if ( VAR_282 && VAR_283 -> VAR_284 == VAR_285 && ( VAR_286 = METHOD_53 ( VAR_287 , VAR_288 , VAR_289 ) ) < 0 ) goto VAR_290 ; } } METHOD_54 ( & VAR_291 -> VAR_292 , VAR_293 , 0 ) ; METHOD_55 ( & VAR_294 -> VAR_295 , VAR_296 , 0 ) ; METHOD_56 ( VAR_297 , VAR_298 ) ; VAR_299 = VAR_300 ; return 0 ; VAR_301 : METHOD_57 ( & VAR_302 ) ; METHOD_58 ( & VAR_303 -> VAR_304 , VAR_305 , 0 ) ; METHOD_59 ( & VAR_306 -> VAR_307 , VAR_308 , 0 ) ; return VAR_309 ; }","<S2SV_ModStart> , VAR_223 ; METHOD_60 ( VAR_306 -> VAR_206 > 1 ) ;","CWE-787 static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , ""%d<S2SV_blank>bytes<S2SV_blank>left\\n"" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , ""chunk<S2SV_blank>too<S2SV_blank>big\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , ""png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n"" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ; if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : case MKTAG ( 't' , 'E' , 'X' , 't' ) : case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : case MKTAG ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto skip_tag ; } } switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) goto fail ; break ; case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) goto fail ; break ; case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) goto fail ; decode_next_dat = 1 ; break ; case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ! decode_next_dat ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_get_be32 ( & s -> gb ) ; length -= 4 ; case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) goto skip_tag ; if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) goto fail ; break ; case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : if ( decode_plte_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'R' , 'N' , 'S' ) : if ( decode_trns_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'E' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 'z' , 'T' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { int mode = bytestream2_get_byte ( & s -> gb ) ; AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; if ( ! stereo3d ) goto fail ; if ( mode == 0 || mode == 1 ) { stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; } else { av_log ( avctx , AV_LOG_WARNING , ""Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n"" , mode ) ; } bytestream2_skip ( & s -> gb , 4 ) ; break ; } case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) av_log ( avctx , AV_LOG_ERROR , ""IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n"" ) ; if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_skip ( & s -> gb , 4 ) ; goto exit_loop ; default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ; break ; } } exit_loop : if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( s -> bits_per_pixel <= 4 ) handle_small_bpp ( s , p ) ; if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; size_t raw_bpp = s -> bpp - byte_depth ; unsigned x , y ; <S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; for ( x = s -> width ; x > 0 ; -- x ) { uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; } else { memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; } } } } if ( s -> last_picture . f -> data [ 0 ] ) { if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( ""MPNG"" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format ) { if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) handle_p_frame_png ( s , p ) ; else if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) goto fail ; } } ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; av_frame_set_metadata ( p , metadata ) ; metadata = NULL ; return 0 ; fail : av_dict_free ( & metadata ) ; ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; return ret ; }","<S2SV_ModStart> , y ; av_assert0 ( s -> bit_depth > 1 ) ;"
674,"CWE-000 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , TYPE_1 VAR_0 ) <S2SV_EndBug> { struct STRUCT_OR_UNION_2 * VAR_1 ; METHOD_1 ( ) ; VAR_2 = METHOD_2 ( METHOD_3 ( STRUCT_OR_UNION_3 ) -> VAR_3 ) ; <S2SV_StartBug> if ( VAR_4 == VAR_5 || ( VAR_6 -> VAR_7 & VAR_8 ) == VAR_9 ) { <S2SV_EndBug> METHOD_4 ( ) ; return ; } METHOD_5 ( ) ; METHOD_6 ( STRUCT_OR_UNION_4 ) ; }","<S2SV_ModStart> * STRUCT_OR_UNION_4 , TYPE_2 VAR_10 <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> VAR_7 & VAR_10 ) == VAR_10 <S2SV_ModEnd> ) { METHOD_5","CWE-000 <S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }","<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock"
675,"CWE-787 <S2SV_StartBug> TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { <S2SV_EndBug> if ( VAR_3 > 32 && VAR_4 < 128 ) { METHOD_1 ( VAR_5 >= 4 ) ; VAR_6 [ 0 ] = '\\'' ; VAR_7 [ 1 ] = ( TYPE_4 ) VAR_8 ; VAR_9 [ 2 ] = '\\'' ; VAR_10 [ 3 ] = 0 ; return ; } switch ( VAR_11 ) { <S2SV_StartBug> case VAR_12 : METHOD_2 ( VAR_13 , ""EOF"" , VAR_14 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_15 : METHOD_3 ( VAR_16 , ""ID"" , VAR_17 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_18 : METHOD_4 ( VAR_19 , ""INT"" , VAR_20 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_21 : METHOD_5 ( VAR_22 , ""FLOAT"" , VAR_23 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_24 : METHOD_6 ( VAR_25 , ""STRING"" , VAR_26 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_27 : METHOD_7 ( VAR_28 , ""UNFINISHED<S2SV_blank>STRING"" , VAR_29 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_30 : METHOD_8 ( VAR_31 , ""TEMPLATE<S2SV_blank>LITERAL"" , VAR_32 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_33 : METHOD_9 ( VAR_34 , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , VAR_35 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_36 : METHOD_10 ( VAR_37 , ""REGEX"" , VAR_38 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_39 : METHOD_11 ( VAR_40 , ""UNFINISHED<S2SV_blank>REGEX"" , VAR_41 ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case VAR_42 : METHOD_12 ( VAR_43 , ""UNFINISHED<S2SV_blank>COMMENT"" , VAR_44 ) ; return ; <S2SV_EndBug> } if ( VAR_45 >= VAR_46 && VAR_47 < VAR_48 ) { const TYPE_5 VAR_49 [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned TYPE_6 VAR_50 = 0 ; TYPE_7 VAR_51 = VAR_52 - VAR_53 ; while ( VAR_54 > 0 && VAR_55 < sizeof ( VAR_56 ) ) { while ( VAR_57 [ VAR_58 ] && VAR_59 < sizeof ( VAR_60 ) ) VAR_61 ++ ; VAR_62 ++ ; VAR_63 -- ; } METHOD_13 ( VAR_64 == 0 ) ; <S2SV_StartBug> METHOD_14 ( VAR_65 , & VAR_66 [ VAR_67 ] , VAR_68 ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> METHOD_15 ( VAR_69 >= 10 ) ; <S2SV_EndBug> METHOD_16 ( VAR_70 , VAR_71 , ""?[%d]"" , VAR_72 ) ; }","<S2SV_ModStart> VAR_71 ) { METHOD_15 ( VAR_71 > 28 ) ; <S2SV_ModStart> case VAR_12 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_15 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_18 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_21 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_24 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_27 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""UNFINISHED<S2SV_blank>STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_30 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_33 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_36 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_39 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""UNFINISHED<S2SV_blank>REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case VAR_42 : METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> VAR_70 , ""UNFINISHED<S2SV_blank>COMMENT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; METHOD_17 <S2SV_ModEnd> ( VAR_70 , <S2SV_ModStart> [ VAR_67 ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> METHOD_16 ( VAR_70","CWE-787 <S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }","<S2SV_ModStart> len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>COMMENT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str"
676,CWE-476 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; <S2SV_StartBug> if ( ! VAR_2 ) <S2SV_EndBug> return VAR_3 ; VAR_4 = ( TYPE_3 * ) ~ ( ( TYPE_4 ) VAR_5 -> VAR_6 ) ; return VAR_7 ; },<S2SV_ModStart> ( ! VAR_5 || ! METHOD_1 ( VAR_5 ),CWE-476 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; },<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
677,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_4 * VAR_4 = STRUCT_OR_UNION_5 -> VAR_5 ; struct STRUCT_OR_UNION_6 * VAR_6 = ( struct STRUCT_OR_UNION_7 * ) VAR_7 -> VAR_8 ; TYPE_3 VAR_9 ; struct STRUCT_OR_UNION_8 * VAR_10 ; TYPE_4 VAR_11 ; METHOD_1 ( VAR_12 ) ; if ( VAR_13 -> VAR_14 != VAR_15 ) { METHOD_2 ( VAR_16 ) ; return - VAR_17 ; } if ( ( VAR_18 = METHOD_3 ( VAR_19 , VAR_20 & ~ VAR_21 , VAR_22 & VAR_23 , & VAR_24 ) ) == VAR_25 ) { METHOD_4 ( VAR_26 ) ; return VAR_27 ; } METHOD_5 ( VAR_28 ) ; VAR_29 = VAR_30 -> VAR_31 ; if ( VAR_32 > VAR_33 ) { VAR_34 = VAR_35 ; VAR_36 -> VAR_37 |= VAR_38 ; } VAR_39 = METHOD_6 ( VAR_40 , 0 , VAR_41 -> VAR_42 , VAR_43 ) ; if ( VAR_44 < 0 ) { METHOD_7 ( VAR_45 , VAR_46 ) ; METHOD_8 ( VAR_47 ) ; return VAR_48 ; } if ( VAR_49 != VAR_50 ) { <S2SV_StartBug> VAR_51 -> VAR_52 = VAR_53 ; <S2SV_EndBug> METHOD_9 ( VAR_54 , 7 , VAR_55 -> VAR_56 . VAR_57 , VAR_58 ) ; } VAR_59 -> VAR_60 = sizeof ( * VAR_61 ) ; METHOD_10 ( VAR_62 , VAR_63 ) ; METHOD_11 ( VAR_64 ) ; return VAR_65 ; }","<S2SV_ModStart> VAR_50 ) { METHOD_12 ( VAR_61 , 0 , sizeof ( VAR_61 ) ) ;","CWE-200 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }","<S2SV_ModStart> NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;"
678,"CWE-190 <S2SV_StartBug> static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) <S2SV_EndBug> { TYPE_4 VAR_3 ; TYPE_5 VAR_4 ; for ( VAR_5 = VAR_6 ; VAR_7 > 0 ; -- VAR_8 ) { VAR_9 = ( VAR_10 >> ( 8 * ( VAR_11 - 1 ) ) ) & 0xff ; if ( METHOD_1 ( VAR_12 , VAR_13 ) == VAR_14 ) return - 1 ; } return 0 ; }","<S2SV_ModStart> TYPE_5 VAR_6 , TYPE_6 <S2SV_ModEnd> VAR_10 ) {","CWE-190 <S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }","<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {"
679,"CWE-362 TYPE_0 METHOD_0 ( TYPE_1 TYPE_2 * VAR_0 , TYPE_3 TYPE_4 VAR_1 , TYPE_5 TYPE_6 TYPE_7 * VAR_2 , TYPE_8 TYPE_9 TYPE_10 * VAR_3 ) { VAR_4 * VAR_5 ; TYPE_11 VAR_6 = VAR_7 ; if ( ( VAR_8 = METHOD_1 ( 1 , sizeof ( VAR_9 ) ) ) == VAR_10 ) { VAR_11 = VAR_12 ; goto VAR_13 ; } VAR_14 -> VAR_15 = VAR_16 ; * VAR_17 = VAR_18 ; if ( ! VAR_19 || ( METHOD_2 ( VAR_20 , ""localhost"" ) == 0 ) ) { if ( METHOD_3 ( VAR_21 , VAR_22 ) == VAR_23 ) { VAR_24 = VAR_25 ; goto VAR_26 ; } if ( METHOD_4 ( VAR_27 , VAR_28 ) == VAR_29 ) { VAR_30 = VAR_31 ; goto VAR_32 ; } if ( METHOD_5 ( VAR_33 , VAR_34 ) == VAR_35 ) { VAR_36 = VAR_37 ; goto VAR_38 ; } } <S2SV_StartBug> return VAR_39 ; <S2SV_EndBug> VAR_40 : if ( VAR_41 ) { METHOD_6 ( VAR_42 ) ; VAR_43 = VAR_44 ; } return VAR_45 ; }",<S2SV_ModStart> ; } } VAR_40 : <S2SV_ModEnd> return VAR_45 ;,"CWE-362 fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , ""localhost"" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <S2SV_StartBug> return res ; <S2SV_EndBug> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }",<S2SV_ModStart> ; } } cleanup : <S2SV_ModEnd> return res ;
680,CWE-787 static TYPE_0 METHOD_0 ( unsigned TYPE_1 VAR_0 ) { <S2SV_StartBug> METHOD_1 ( ) ; <S2SV_EndBug> if ( METHOD_2 ( ) == ( VAR_1 & VAR_2 ) ) METHOD_3 ( VAR_3 ) ; <S2SV_StartBug> METHOD_4 ( VAR_4 ) ; <S2SV_EndBug> },"<S2SV_ModStart> { METHOD_1 ( ) ; if ( METHOD_5 ( ) == VAR_4 ) METHOD_7 ( VAR_5 , METHOD_6 ( ) <S2SV_ModStart> VAR_3 ) ; METHOD_8 <S2SV_ModEnd> ( VAR_4 )",CWE-787 static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> },"<S2SV_ModStart> { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt )"
681,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 , struct STRUCT_OR_UNION_3 * VAR_3 ) { METHOD_1 ( VAR_4 ) ; <S2SV_StartBug> struct STRUCT_OR_UNION_4 * VAR_5 , * VAR_6 ; <S2SV_EndBug> struct STRUCT_OR_UNION_5 * VAR_7 ; TYPE_1 VAR_8 ; <S2SV_StartBug> if ( METHOD_2 ( VAR_9 ) ) { <S2SV_EndBug> VAR_10 = METHOD_3 ( VAR_11 , VAR_12 ) ; if ( VAR_13 ) goto VAR_14 ; <S2SV_StartBug> VAR_15 = METHOD_4 ( VAR_16 , VAR_17 , VAR_18 , & VAR_19 ) ; <S2SV_EndBug> METHOD_5 ( ) ; if ( VAR_20 ) goto VAR_21 ; for ( VAR_22 = VAR_23 ; VAR_24 ; VAR_25 = METHOD_6 ( VAR_26 , VAR_27 ) ) METHOD_7 ( VAR_28 ) ; } else { METHOD_8 ( ) ; } if ( VAR_29 ) { METHOD_9 ( VAR_30 , VAR_31 ) ; METHOD_10 ( VAR_32 , VAR_33 , VAR_34 ) ; METHOD_11 ( VAR_35 -> VAR_36 ) ; } else { METHOD_12 ( VAR_37 , VAR_38 , VAR_39 ) ; METHOD_13 ( VAR_40 , VAR_41 ) ; } METHOD_14 ( VAR_42 , VAR_43 , & VAR_44 , VAR_45 ) { struct STRUCT_OR_UNION_6 * VAR_46 ; METHOD_15 ( & VAR_47 -> VAR_48 ) ; VAR_49 = METHOD_16 ( & VAR_50 -> VAR_51 -> VAR_52 , VAR_53 -> VAR_54 ) ; METHOD_17 ( VAR_55 , VAR_56 ) ; } METHOD_18 ( ) ; return 0 ; VAR_57 : while ( ! METHOD_19 ( & VAR_58 ) ) { VAR_59 = hlist_entry ( VAR_60 . VAR_61 , struct STRUCT_OR_UNION_7 , VAR_62 ) ; <S2SV_StartBug> METHOD_20 ( VAR_63 , VAR_64 ) ; <S2SV_EndBug> } METHOD_21 ( ) ; METHOD_22 ( VAR_65 , VAR_66 ) ; VAR_67 : <S2SV_StartBug> return VAR_68 ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; struct STRUCT_OR_UNION_8 * VAR_69 = VAR_37 -> VAR_36 ; struct <S2SV_ModStart> ; if ( ! VAR_31 ) { VAR_68 = METHOD_23 ( VAR_69 , VAR_65 <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto VAR_67 ; } if ( METHOD_2 ( VAR_37 ) ) { VAR_68 = METHOD_3 ( VAR_65 , VAR_12 ) ; if ( VAR_68 ) goto VAR_67 ; <S2SV_ModStart> VAR_62 ) ; VAR_63 -> VAR_51 -> VAR_36 -> VAR_70 = 0 ; <S2SV_ModStart> ; VAR_67 : VAR_69 -> VAR_70 = 0 ;","CWE-400 static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> struct hlist_node * n ; int err ; <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out : <S2SV_StartBug> return err ; <S2SV_EndBug> }","<S2SV_ModStart> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ; out : ns -> pending_mounts = 0 ;"
682,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 ) { struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 -> VAR_4 ; if ( ! METHOD_1 ( VAR_5 , VAR_6 ) ) return ; if ( METHOD_2 ( METHOD_3 ( & VAR_7 -> VAR_8 ) ) ) { * METHOD_4 ( VAR_9 ) = * VAR_10 ; <S2SV_StartBug> METHOD_5 ( VAR_11 , VAR_12 , VAR_13 ) ; <S2SV_EndBug> METHOD_6 ( VAR_14 ) ; } }","<S2SV_ModStart> VAR_14 , VAR_13 , VAR_6","CWE-125 void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }","<S2SV_ModStart> sk , SCM_TSTAMP_SND , false"
683,"CWE-000 <S2SV_StartBug> static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * STRUCT_OR_UNION_2 , struct STRUCT_OR_UNION_3 * VAR_1 ) <S2SV_EndBug> { struct STRUCT_OR_UNION_4 * VAR_2 ; TYPE_1 VAR_3 ; <S2SV_StartBug> if ( VAR_4 -> VAR_5 . VAR_6 . VAR_7 & VAR_8 ) { <S2SV_EndBug> VAR_9 = METHOD_1 ( VAR_10 -> VAR_11 , VAR_12 -> VAR_13 -> VAR_14 , VAR_15 -> VAR_16 . VAR_17 . VAR_18 ) ; if ( VAR_19 < 0 ) goto VAR_20 ; } VAR_21 = METHOD_2 ( VAR_22 , STRUCT_OR_UNION_5 -> VAR_23 , VAR_24 ) ; if ( ! METHOD_3 ( VAR_25 ) ) { struct STRUCT_OR_UNION_6 * VAR_26 ; VAR_27 = METHOD_4 ( VAR_28 ) ; VAR_29 -> VAR_30 = VAR_31 ; return 0 ; } VAR_32 = METHOD_5 ( VAR_33 ) ; VAR_34 : <S2SV_StartBug> METHOD_6 ( STRUCT_OR_UNION_7 , VAR_35 , VAR_36 -> VAR_37 . VAR_38 . VAR_39 ) ; <S2SV_EndBug> return VAR_40 ; }","<S2SV_ModStart> STRUCT_OR_UNION_3 * VAR_35 , TYPE_2 VAR_41 <S2SV_ModStart> ; if ( VAR_41 <S2SV_ModEnd> & VAR_8 ) <S2SV_ModStart> , VAR_35 , VAR_41 & ( VAR_42 | VAR_43 ) <S2SV_ModEnd> ) ; return","CWE-000 <S2SV_StartBug> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <S2SV_EndBug> { struct file * filp ; int ret ; <S2SV_StartBug> if ( nd -> intent . open . flags & FMODE_EXEC ) { <S2SV_EndBug> ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : <S2SV_StartBug> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <S2SV_EndBug> return ret ; }","<S2SV_ModStart> nfs4_state * state , fmode_t fmode <S2SV_ModStart> ; if ( fmode <S2SV_ModEnd> & FMODE_EXEC ) <S2SV_ModStart> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> ) ; return"
684,"CWE-000 struct STRUCT_OR_UNION_0 * METHOD_0 ( TYPE_0 VAR_0 ) { struct STRUCT_OR_UNION_1 VAR_1 = METHOD_1 ( VAR_2 ) ; struct STRUCT_OR_UNION_2 * VAR_3 ; VAR_4 = METHOD_2 ( VAR_5 ) ; if ( METHOD_3 ( VAR_6 ) ) return VAR_7 ; <S2SV_StartBug> METHOD_4 ( VAR_8 , VAR_9 ) ; <S2SV_EndBug> METHOD_5 ( VAR_10 ) ; return VAR_11 ; }",<S2SV_ModStart> return VAR_11 ; VAR_11 =,"CWE-000 struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }",<S2SV_ModStart> return map ; map =
685,"CWE-20 static VAR_0 TYPE_0 METHOD_0 ( TYPE_1 * VAR_1 ) { <S2SV_StartBug> VAR_2 -> VAR_3 = METHOD_1 ( 1.0f , METHOD_2 ( 0.0f , VAR_4 -> VAR_5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_6 -> VAR_7 = METHOD_3 ( 1.0f , METHOD_4 ( 0.0f , VAR_8 -> VAR_9 ) ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_10 -> VAR_11 = METHOD_5 ( 1.0f , METHOD_6 ( 0.0f , VAR_12 -> VAR_13 ) ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_14 -> VAR_15 = METHOD_7 ( 1.0f , METHOD_8 ( 0.0f , VAR_16 -> VAR_17 ) ) ; <S2SV_EndBug> }","<S2SV_ModStart> -> VAR_5 = METHOD_9 <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , METHOD_10 <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> VAR_9 = METHOD_9 <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , METHOD_10 <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> VAR_13 = METHOD_9 <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , METHOD_10 <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> VAR_17 = METHOD_9 <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , METHOD_10 <S2SV_ModEnd> ( 0.0f ,","CWE-20 static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> w = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,"
686,"CWE-125 static TYPE_0 * METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 , TYPE_3 * VAR_3 , TYPE_4 * VAR_4 ) { VAR_5 * VAR_6 ; TYPE_5 * VAR_7 ; TYPE_6 VAR_8 = 0 ; <S2SV_StartBug> TYPE_7 VAR_9 , VAR_10 ; <S2SV_EndBug> if ( ( VAR_11 = METHOD_1 ( VAR_12 , VAR_13 ) ) == VAR_14 ) { VAR_15 -> VAR_16 = VAR_17 ; METHOD_2 ( VAR_18 ) ; return VAR_19 ; } TYPE_8 TYPE_9 if ( * VAR_20 & VAR_21 ) <S2SV_StartBug> VAR_22 -> VAR_23 |= VAR_24 ; <S2SV_EndBug> for ( ; ; ) { TYPE_10 * VAR_25 , * VAR_26 ; TYPE_11 VAR_27 ; TYPE_12 VAR_28 ; TYPE_13 * VAR_29 ; VAR_30 = - 1 ; TYPE_14 VAR_31 ; const TYPE_15 * VAR_32 ; VAR_33 = METHOD_3 ( VAR_34 , & VAR_35 , & VAR_36 ) ; if ( VAR_37 == VAR_38 ) { VAR_39 -> VAR_40 = VAR_41 -> VAR_42 ; break ; } if ( VAR_43 == VAR_44 && VAR_45 ) { VAR_46 = VAR_47 ; VAR_48 = 0 ; if ( VAR_49 -> VAR_50 && ! ( * VAR_51 & VAR_52 ) ) { VAR_53 -> VAR_54 = - VAR_55 -> VAR_56 ; VAR_57 -> VAR_58 = 0 ; } } else VAR_59 = 1 ; VAR_60 = ( VAR_61 != VAR_62 && VAR_63 != VAR_64 ) ? VAR_65 - VAR_66 : 0 ; VAR_67 = ( TYPE_16 * ) METHOD_4 ( VAR_68 + 1 ) ; if ( VAR_69 == VAR_70 ) { VAR_71 -> VAR_72 = VAR_73 ; break ; } if ( VAR_74 > 0 ) METHOD_5 ( VAR_75 , VAR_76 , VAR_77 ) ; VAR_78 [ VAR_79 ] = '\\0' ; TYPE_17 TYPE_18 if ( VAR_80 == VAR_81 ) { if ( ! ( VAR_82 -> VAR_83 & VAR_84 ) && METHOD_6 ( VAR_85 , ""!="" ) ) { METHOD_7 ( VAR_86 ) ; VAR_87 -> VAR_88 = VAR_89 ; break ; } else if ( ( VAR_90 -> VAR_91 & VAR_92 ) && METHOD_8 ( VAR_93 , ""<>"" ) ) { METHOD_9 ( VAR_94 ) ; VAR_95 -> VAR_96 = VAR_97 ; VAR_98 -> VAR_99 = VAR_100 ; break ; } } VAR_101 = VAR_102 == VAR_103 ? VAR_104 -> VAR_105 : VAR_106 -> VAR_107 ; VAR_108 = VAR_109 == VAR_110 ? VAR_111 -> VAR_112 : VAR_113 -> VAR_114 ; if ( VAR_115 != VAR_116 && VAR_117 >= VAR_118 ) { VAR_119 = Py_SAFE_DOWNCAST ( VAR_120 - VAR_121 , VAR_122 , TYPE_19 ) ; } else { VAR_123 = - 1 ; } if ( VAR_124 != VAR_125 && VAR_126 >= VAR_127 -> VAR_128 ) { VAR_129 = Py_SAFE_DOWNCAST ( VAR_130 - VAR_131 -> VAR_132 , VAR_133 , TYPE_20 ) ; } else { VAR_134 = - 1 ; } <S2SV_StartBug> if ( ( VAR_135 -> VAR_136 = <S2SV_EndBug> METHOD_10 ( VAR_137 , ( TYPE_21 ) VAR_138 , VAR_139 , VAR_140 , VAR_141 , VAR_142 -> VAR_143 , VAR_144 , & ( VAR_145 -> VAR_146 ) ) ) != VAR_147 ) { if ( VAR_148 -> VAR_149 != VAR_150 ) { METHOD_11 ( VAR_151 ) ; VAR_152 -> VAR_153 = VAR_154 ; } break ; } } if ( VAR_155 -> VAR_156 == VAR_157 ) { VAR_158 = VAR_159 -> VAR_160 ; <S2SV_StartBug> VAR_161 -> VAR_162 = VAR_163 ; <S2SV_EndBug> TYPE_22 TYPE_23 if ( VAR_164 == single_input ) { TYPE_24 * VAR_165 = VAR_166 -> VAR_167 ; TYPE_25 VAR_168 = * VAR_169 -> VAR_170 ; for ( ; ; ) { while ( VAR_171 == '<S2SV_blank>' || VAR_172 == '\\t' || VAR_173 == '\\n' || VAR_174 == '\\014' ) VAR_175 = * ++ VAR_176 ; if ( ! VAR_177 ) break ; if ( VAR_178 != '' ) { VAR_179 -> VAR_180 = VAR_181 ; METHOD_12 ( VAR_182 ) ; VAR_183 = VAR_184 ; break ; } while ( VAR_185 && VAR_186 != '\\n' ) VAR_187 = * ++ VAR_188 ; } } } else VAR_189 = VAR_190 ; TYPE_26 TYPE_27 * VAR_191 = VAR_192 -> VAR_193 ; METHOD_13 ( VAR_194 ) ; if ( VAR_195 == VAR_196 ) { if ( VAR_197 -> VAR_198 == VAR_199 ) VAR_200 -> VAR_201 = VAR_202 ; VAR_203 -> VAR_204 = VAR_205 -> VAR_206 ; if ( VAR_207 -> VAR_208 != VAR_209 ) { TYPE_28 VAR_210 ; METHOD_14 ( VAR_211 -> VAR_212 - VAR_213 -> VAR_214 < VAR_215 ) ; VAR_216 -> VAR_217 = VAR_218 != - 1 ? VAR_219 + 1 : ( ( TYPE_29 ) ( VAR_220 -> VAR_221 - VAR_222 -> VAR_223 ) ) ; VAR_224 = VAR_225 -> VAR_226 - VAR_227 -> VAR_228 ; VAR_229 -> VAR_230 = ( TYPE_30 * ) METHOD_15 ( VAR_231 + 1 ) ; if ( VAR_232 -> VAR_233 != VAR_234 ) { if ( VAR_235 > 0 ) METHOD_16 ( VAR_236 -> VAR_237 , VAR_238 -> VAR_239 , VAR_240 ) ; VAR_241 -> VAR_242 [ VAR_243 ] = '\\0' ; } } } else if ( VAR_244 -> VAR_245 != VAR_246 ) { TYPE_31 * VAR_247 = METHOD_17 ( VAR_248 ) ; if ( VAR_249 ) VAR_250 -> VAR_251 = METHOD_18 ( METHOD_19 ( VAR_252 -> VAR_253 ) + 1 ) ; if ( ! VAR_254 || ! VAR_255 -> VAR_256 ) { VAR_257 -> VAR_258 = VAR_259 ; if ( VAR_260 ) METHOD_20 ( VAR_261 ) ; VAR_262 = VAR_263 ; goto VAR_264 ; } METHOD_21 ( VAR_265 -> VAR_266 , VAR_267 -> VAR_268 ) ; METHOD_22 ( VAR_269 -> VAR_270 ) ; VAR_271 -> VAR_272 = VAR_273 ; VAR_274 -> VAR_275 = 1 ; VAR_276 -> VAR_277 = VAR_278 ; VAR_279 = VAR_280 ; } VAR_281 : METHOD_23 ( VAR_282 ) ; if ( VAR_283 != VAR_284 ) { METHOD_24 ( VAR_285 ) ; } return VAR_286 ; }","<S2SV_ModStart> , VAR_144 ; TYPE_32 VAR_287 ; if ( ! METHOD_25 ( & VAR_287 , 10 ) ) { VAR_257 -> VAR_258 = VAR_259 ; METHOD_23 ( VAR_282 ) ; return VAR_284 ; } <S2SV_ModStart> VAR_193 |= VAR_92 ; if ( * VAR_191 & VAR_288 ) VAR_194 -> VAR_193 |= VAR_289 <S2SV_ModStart> } if ( VAR_154 == VAR_290 ) { if ( ! METHOD_26 ( & VAR_287 , VAR_282 -> VAR_206 ) ) { VAR_257 -> VAR_258 = VAR_259 ; break ; } continue ; } if ( <S2SV_ModStart> VAR_162 = VAR_284 ; if ( VAR_286 -> VAR_291 == VAR_292 ) { TYPE_29 VAR_293 ; TYPE_31 * VAR_294 ; TYPE_28 VAR_295 ; VAR_293 = METHOD_27 ( VAR_286 ) ; VAR_294 = METHOD_28 ( VAR_286 , VAR_293 - 1 ) ; METHOD_29 ( VAR_294 , VAR_44 ) ; for ( VAR_295 = 0 ; VAR_295 < VAR_287 . VAR_296 ; VAR_295 ++ ) { METHOD_30 ( VAR_294 , VAR_290 , VAR_284 , VAR_287 . VAR_297 [ VAR_295 ] , 0 , VAR_287 . VAR_297 [ VAR_295 ] , 0 ) ; } } METHOD_31 ( & VAR_287 )","CWE-125 static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; }  ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug>   for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ;  ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""!="" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) { PyObject_FREE ( str ) ; err_ret -> expected = NOTEQUAL ; err_ret -> error = E_SYNTAX ; break ; } }   lineno = type == STRING ? tok -> first_lineno : tok -> lineno ; line_start = type == STRING ? tok -> multi_line_start : tok -> line_start ; if ( a != NULL && a >= line_start ) { col_offset = Py_SAFE_DOWNCAST ( a - line_start , intptr_t , int ) ; } else { col_offset = - 1 ; } if ( b != NULL && b >= tok -> line_start ) { end_col_offset = Py_SAFE_DOWNCAST ( b - tok -> line_start , intptr_t , int ) ; } else { end_col_offset = - 1 ; } <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug>  ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '' ) { err_ret -> error = E_BADSINGLE ; PyNode_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } }   } else n = NULL ;  ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ;   PyParser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = col_offset != - 1 ? col_offset + 1 : ( ( int ) ( tok -> cur - tok -> buf ) ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = PyNode_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : PyTokenizer_Free ( tok ) ; if ( n != NULL ) { _PyNode_FinalizeEndPos ( n ) ; } return n ; }","<S2SV_ModStart> , end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )"
687,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , unsigned TYPE_2 * VAR_1 ) { <S2SV_StartBug> METHOD_1 ( VAR_2 -> VAR_3 , VAR_4 , ( VAR_5 -> VAR_6 . VAR_7 * VAR_8 -> VAR_9 . VAR_10 ) ) ; <S2SV_EndBug> VAR_11 -> VAR_12 . VAR_13 . VAR_14 = 1 ; VAR_15 -> VAR_16 . VAR_17 . VAR_18 = 1 ; }",<S2SV_ModStart> VAR_4 ) { METHOD_2 <S2SV_ModEnd> ( VAR_15 ->,"CWE-119 static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; }",<S2SV_ModStart> segmentation_map ) { memcpy <S2SV_ModEnd> ( cpi ->
688,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { METHOD_1 ( VAR_1 , 0 ) ; <S2SV_StartBug> VAR_2 -> VAR_3 . VAR_4 = VAR_5 -> VAR_6 . VAR_7 ; <S2SV_EndBug> VAR_8 -> VAR_9 . VAR_10 ++ ; VAR_11 -> VAR_12 . VAR_13 -- ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> ; VAR_11 -> <S2SV_ModEnd> VAR_12 . VAR_10 <S2SV_ModStart> VAR_13 -- ; VAR_11 -> VAR_12 . VAR_14 = 0 ; VAR_11 -> VAR_12 . VAR_15 = 0 ;,"CWE-119 void vp9_rc_postencode_update_drop_frame ( VP9_COMP * cpi ) { update_buffer_level ( cpi , 0 ) ; <S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> cpi -> rc . frames_since_key ++ ; cpi -> rc . frames_to_key -- ; <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_ModStart> ; cpi -> <S2SV_ModEnd> rc . frames_since_key <S2SV_ModStart> frames_to_key -- ; cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ;
689,"CWE-125 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { VAR_2 1 VAR_3 0 VAR_4 2 VAR_5 1 VAR_6 2 VAR_7 3 typedef struct STRUCT_OR_UNION_0 { unsigned TYPE_3 VAR_8 , VAR_9 , VAR_10 , VAR_11 , VAR_12 , VAR_13 , VAR_14 , VAR_15 ; } TYPE_4 ; TYPE_5 * VAR_16 ; TYPE_6 VAR_17 ; TYPE_7 VAR_18 ; TYPE_8 VAR_19 ; register TYPE_9 * VAR_20 ; register TYPE_10 VAR_21 , VAR_22 ; register unsigned TYPE_11 * VAR_23 ; TYPE_12 VAR_24 , VAR_25 , VAR_26 , VAR_27 ; TYPE_13 VAR_28 , VAR_29 ; TYPE_14 VAR_30 ; unsigned TYPE_15 * VAR_31 , * VAR_32 ; METHOD_1 ( VAR_33 != ( const TYPE_16 * ) VAR_34 ) ; METHOD_2 ( VAR_35 -> VAR_36 == VAR_37 ) ; if ( VAR_38 -> VAR_39 != VAR_40 ) ( TYPE_17 ) METHOD_3 ( VAR_41 , METHOD_4 ( ) , ""%s"" , VAR_42 -> VAR_43 ) ; METHOD_5 ( VAR_44 != ( TYPE_18 * ) VAR_45 ) ; METHOD_6 ( VAR_46 -> VAR_47 == VAR_48 ) ; VAR_49 = METHOD_7 ( VAR_50 , VAR_51 ) ; VAR_52 = METHOD_8 ( VAR_53 , VAR_54 , VAR_55 , VAR_56 ) ; if ( VAR_57 == VAR_58 ) { VAR_59 = METHOD_9 ( VAR_60 ) ; return ( ( TYPE_19 * ) VAR_61 ) ; } ( TYPE_20 ) METHOD_10 ( & VAR_62 , 0 , sizeof ( VAR_63 ) ) ; VAR_64 . VAR_65 = METHOD_11 ( VAR_66 ) ; do { if ( VAR_67 . VAR_68 != 0x59a66a95 ) METHOD_12 ( VAR_69 , ""ImproperImageHeader"" ) ; VAR_70 . VAR_71 = METHOD_13 ( VAR_72 ) ; VAR_73 . VAR_74 = METHOD_14 ( VAR_75 ) ; VAR_76 . VAR_77 = METHOD_15 ( VAR_78 ) ; VAR_79 . VAR_80 = METHOD_16 ( VAR_81 ) ; VAR_82 . VAR_83 = METHOD_17 ( VAR_84 ) ; VAR_85 . VAR_86 = METHOD_18 ( VAR_87 ) ; VAR_88 . VAR_89 = METHOD_19 ( VAR_90 ) ; VAR_91 = VAR_92 . VAR_93 * VAR_94 . VAR_95 ; if ( ( VAR_96 . VAR_97 != 0 ) && ( VAR_98 . VAR_99 != VAR_100 / VAR_101 . VAR_102 ) ) METHOD_20 ( VAR_103 , ""ImproperImageHeader"" ) ; if ( ( VAR_104 . VAR_105 != VAR_106 ) && ( VAR_107 . VAR_108 != VAR_109 ) && ( VAR_110 . VAR_111 != VAR_112 ) ) METHOD_21 ( VAR_113 , ""ImproperImageHeader"" ) ; if ( ( VAR_114 . VAR_115 == VAR_116 ) && ( VAR_117 . VAR_118 != 0 ) ) METHOD_22 ( VAR_119 , ""ImproperImageHeader"" ) ; if ( ( VAR_120 . VAR_121 == 0 ) || ( VAR_122 . VAR_123 > 32 ) ) METHOD_23 ( VAR_124 , ""ImproperImageHeader"" ) ; if ( ( VAR_125 . VAR_126 != VAR_127 ) && ( VAR_128 . VAR_129 != VAR_130 ) && ( VAR_131 . VAR_132 != VAR_133 ) ) METHOD_24 ( VAR_134 , ""ColormapTypeNotSupported"" ) ; VAR_135 -> VAR_136 = VAR_137 . VAR_138 ; VAR_139 -> VAR_140 = VAR_141 . VAR_142 ; VAR_143 -> VAR_144 = VAR_145 . VAR_146 <= 8 ? VAR_147 . VAR_148 : VAR_149 ; if ( VAR_150 . VAR_151 < 24 ) { TYPE_21 VAR_152 ; VAR_153 -> VAR_154 = VAR_155 . VAR_156 ; VAR_157 = 1 ; if ( VAR_158 . VAR_159 == VAR_160 ) VAR_161 -> VAR_162 = VAR_163 << VAR_164 . VAR_165 ; if ( VAR_166 . VAR_167 == VAR_168 ) VAR_169 -> VAR_170 = VAR_171 . VAR_172 / 3 ; if ( METHOD_25 ( VAR_173 , VAR_174 -> VAR_175 , VAR_176 ) == VAR_177 ) METHOD_26 ( VAR_178 , ""MemoryAllocationFailed"" ) ; } switch ( VAR_179 . VAR_180 ) { case VAR_181 : break ; case VAR_182 : { unsigned TYPE_22 * VAR_183 ; VAR_184 = ( unsigned TYPE_23 * ) METHOD_27 ( VAR_185 -> VAR_186 , sizeof ( * VAR_187 ) ) ; if ( VAR_188 == ( unsigned TYPE_24 * ) VAR_189 ) METHOD_28 ( VAR_190 , ""MemoryAllocationFailed"" ) ; VAR_191 = METHOD_29 ( VAR_192 , VAR_193 -> VAR_194 , VAR_195 ) ; if ( VAR_196 != ( TYPE_25 ) VAR_197 -> VAR_198 ) METHOD_30 ( VAR_199 , ""UnexpectedEndOfFile"" ) ; for ( VAR_200 = 0 ; VAR_201 < ( TYPE_26 ) VAR_202 -> VAR_203 ; VAR_204 ++ ) VAR_205 -> VAR_206 [ VAR_207 ] . VAR_208 = ( TYPE_27 ) METHOD_31 ( VAR_209 [ VAR_210 ] ) ; VAR_211 = METHOD_32 ( VAR_212 , VAR_213 -> VAR_214 , VAR_215 ) ; if ( VAR_216 != ( TYPE_28 ) VAR_217 -> VAR_218 ) METHOD_33 ( VAR_219 , ""UnexpectedEndOfFile"" ) ; for ( VAR_220 = 0 ; VAR_221 < ( TYPE_29 ) VAR_222 -> VAR_223 ; VAR_224 ++ ) VAR_225 -> VAR_226 [ VAR_227 ] . VAR_228 = ( TYPE_30 ) METHOD_34 ( VAR_229 [ VAR_230 ] ) ; VAR_231 = METHOD_35 ( VAR_232 , VAR_233 -> VAR_234 , VAR_235 ) ; if ( VAR_236 != ( TYPE_31 ) VAR_237 -> VAR_238 ) METHOD_36 ( VAR_239 , ""UnexpectedEndOfFile"" ) ; for ( VAR_240 = 0 ; VAR_241 < ( TYPE_32 ) VAR_242 -> VAR_243 ; VAR_244 ++ ) VAR_245 -> VAR_246 [ VAR_247 ] . VAR_248 = ( TYPE_33 ) METHOD_37 ( VAR_249 [ VAR_250 ] ) ; VAR_251 = ( unsigned TYPE_34 * ) METHOD_38 ( VAR_252 ) ; break ; } case VAR_253 : { unsigned TYPE_35 * VAR_254 ; VAR_255 = ( unsigned TYPE_36 * ) METHOD_39 ( VAR_256 . VAR_257 , sizeof ( * VAR_258 ) ) ; if ( VAR_259 == ( unsigned TYPE_37 * ) VAR_260 ) METHOD_40 ( VAR_261 , ""MemoryAllocationFailed"" ) ; VAR_262 = METHOD_41 ( VAR_263 , VAR_264 . VAR_265 , VAR_266 ) ; if ( VAR_267 != ( TYPE_38 ) VAR_268 . VAR_269 ) METHOD_42 ( VAR_270 , ""UnexpectedEndOfFile"" ) ; VAR_271 = ( unsigned TYPE_39 * ) METHOD_43 ( VAR_272 ) ; break ; } default : METHOD_44 ( VAR_273 , ""ColormapTypeNotSupported"" ) ; } VAR_274 -> VAR_275 = VAR_276 . VAR_277 == 32 ? VAR_278 : VAR_279 ; VAR_280 -> VAR_281 = VAR_282 . VAR_283 ; VAR_284 -> VAR_285 = VAR_286 . VAR_287 ; if ( VAR_288 -> VAR_289 != VAR_290 ) { ( TYPE_40 ) METHOD_45 ( VAR_291 ) ; return ( METHOD_46 ( VAR_292 ) ) ; } VAR_293 = METHOD_47 ( VAR_294 , VAR_295 -> VAR_296 , VAR_297 -> VAR_298 , VAR_299 ) ; if ( VAR_300 == VAR_301 ) return ( METHOD_48 ( VAR_302 ) ) ; if ( ( VAR_303 . VAR_304 * sizeof ( * VAR_305 ) ) / sizeof ( * VAR_306 ) != VAR_307 . VAR_308 || ! VAR_309 . VAR_310 ) <S2SV_StartBug> METHOD_49 ( VAR_311 , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> VAR_312 = ( TYPE_41 ) VAR_313 -> VAR_314 * VAR_315 -> VAR_316 ; if ( ( VAR_317 . VAR_318 != VAR_319 ) && ( ( VAR_320 * VAR_321 . VAR_322 ) > ( 8 * VAR_323 . VAR_324 ) ) ) METHOD_50 ( VAR_325 , ""ImproperImageHeader"" ) ; VAR_326 = VAR_327 . VAR_328 * VAR_329 . VAR_330 ; VAR_331 = ( unsigned TYPE_42 * ) METHOD_51 ( ( TYPE_43 ) METHOD_52 ( VAR_332 . VAR_333 , VAR_334 * VAR_335 . VAR_336 ) , sizeof ( * VAR_337 ) ) ; if ( VAR_338 == ( unsigned TYPE_44 * ) VAR_339 ) METHOD_53 ( VAR_340 , ""MemoryAllocationFailed"" ) ; VAR_341 = ( TYPE_45 ) METHOD_54 ( VAR_342 , VAR_343 . VAR_344 , VAR_345 ) ; if ( VAR_346 != ( TYPE_46 ) VAR_347 . VAR_348 ) METHOD_55 ( VAR_349 , ""UnableToReadImageData"" ) ; VAR_350 = VAR_351 . VAR_352 ; if ( ( VAR_353 == 0 ) || ( VAR_354 . VAR_355 == 0 ) || ( VAR_356 . VAR_357 == 0 ) || ( ( VAR_358 / VAR_359 . VAR_360 ) != VAR_361 . VAR_362 ) ) <S2SV_StartBug> METHOD_56 ( VAR_363 , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> VAR_364 += 15 ; VAR_365 <<= 1 ; if ( ( VAR_366 >> 1 ) != ( VAR_367 . VAR_368 * VAR_369 . VAR_370 + 15 ) ) <S2SV_StartBug> METHOD_57 ( VAR_371 , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> VAR_372 >>= 4 ; VAR_373 = ( unsigned TYPE_47 * ) METHOD_58 ( VAR_374 , VAR_375 * sizeof ( * VAR_376 ) ) ; if ( VAR_377 == ( unsigned TYPE_48 * ) VAR_378 ) METHOD_59 ( VAR_379 , ""MemoryAllocationFailed"" ) ; if ( VAR_380 . VAR_381 == VAR_382 ) ( TYPE_49 ) METHOD_60 ( VAR_383 , VAR_384 . VAR_385 , VAR_386 , VAR_387 * <S2SV_StartBug> VAR_388 ) ; <S2SV_EndBug> VAR_389 = ( unsigned TYPE_50 * ) METHOD_61 ( VAR_390 ) ; VAR_391 = VAR_392 ; if ( VAR_393 . VAR_394 == 1 ) for ( VAR_395 = 0 ; VAR_396 < ( TYPE_51 ) VAR_397 -> VAR_398 ; VAR_399 ++ ) { VAR_400 = METHOD_62 ( VAR_401 , 0 , VAR_402 , VAR_403 -> VAR_404 , 1 , VAR_405 ) ; if ( VAR_406 == ( TYPE_52 * ) VAR_407 ) break ; for ( VAR_408 = 0 ; VAR_409 < ( ( TYPE_53 ) VAR_410 -> VAR_411 - 7 ) ; VAR_412 += 8 ) { for ( VAR_413 = 7 ; VAR_414 >= 0 ; VAR_415 -- ) { METHOD_63 ( VAR_416 , ( TYPE_54 ) ( ( * VAR_417 ) & ( 0x01 << VAR_418 ) ? 0x00 : 0x01 ) , VAR_419 ) ; VAR_420 += METHOD_64 ( VAR_421 ) ; } VAR_422 ++ ; } if ( ( VAR_423 -> VAR_424 % 8 ) != 0 ) { for ( VAR_425 = 7 ; VAR_426 >= ( TYPE_55 ) ( 8 - ( VAR_427 -> VAR_428 % 8 ) ) ; VAR_429 -- ) { METHOD_65 ( VAR_430 , ( TYPE_56 ) ( ( * VAR_431 ) & ( 0x01 << VAR_432 ) ? 0x00 : 0x01 ) , VAR_433 ) ; VAR_434 += METHOD_66 ( VAR_435 ) ; } VAR_436 ++ ; } if ( ( ( ( VAR_437 -> VAR_438 / 8 ) + ( VAR_439 -> VAR_440 % 8 ? 1 : 0 ) ) % 2 ) != 0 ) VAR_441 ++ ; if ( METHOD_67 ( VAR_442 , VAR_443 ) == VAR_444 ) break ; if ( VAR_445 -> VAR_446 == ( TYPE_57 * ) VAR_447 ) { VAR_448 = METHOD_68 ( VAR_449 , VAR_450 , ( TYPE_58 ) VAR_451 , VAR_452 -> VAR_453 ) ; if ( VAR_454 == VAR_455 ) break ; } } else if ( VAR_456 -> VAR_457 == VAR_458 ) { if ( VAR_459 == 0 ) VAR_460 = VAR_461 -> VAR_462 ; VAR_463 = VAR_464 -> VAR_465 * ( VAR_466 -> VAR_467 + VAR_468 -> VAR_469 % 2 ) ; if ( ( ( VAR_470 . VAR_471 == VAR_472 ) && ( VAR_473 > ( VAR_474 * VAR_475 -> VAR_476 ) ) ) || ( ( VAR_477 . VAR_478 != VAR_479 ) && ( VAR_480 > VAR_481 . VAR_482 ) ) ) METHOD_69 ( VAR_483 , ""UnableToReadImageData"" ) ; for ( VAR_484 = 0 ; VAR_485 < ( TYPE_59 ) VAR_486 -> VAR_487 ; VAR_488 ++ ) { VAR_489 = METHOD_70 ( VAR_490 , 0 , VAR_491 , VAR_492 -> VAR_493 , 1 , VAR_494 ) ; if ( VAR_495 == ( TYPE_60 * ) VAR_496 ) break ; for ( VAR_497 = 0 ; VAR_498 < ( TYPE_61 ) VAR_499 -> VAR_500 ; VAR_501 ++ ) { METHOD_71 ( VAR_502 , * VAR_503 ++ , VAR_504 ) ; VAR_505 += METHOD_72 ( VAR_506 ) ; } if ( ( VAR_507 -> VAR_508 % 2 ) != 0 ) VAR_509 ++ ; if ( METHOD_73 ( VAR_510 , VAR_511 ) == VAR_512 ) break ; if ( VAR_513 -> VAR_514 == ( TYPE_62 * ) VAR_515 ) { VAR_516 = METHOD_74 ( VAR_517 , VAR_518 , ( TYPE_63 ) VAR_519 , VAR_520 -> VAR_521 ) ; if ( VAR_522 == VAR_523 ) break ; } } } else { TYPE_64 VAR_524 ; VAR_525 = 3 ; if ( VAR_526 -> VAR_527 != VAR_528 ) VAR_529 ++ ; if ( VAR_530 == 0 ) VAR_531 = VAR_532 * VAR_533 -> VAR_534 ; VAR_535 = VAR_536 -> VAR_537 * ( VAR_538 + VAR_539 % 2 ) ; if ( ( ( VAR_540 . VAR_541 == VAR_542 ) && ( VAR_543 > ( VAR_544 * VAR_545 -> VAR_546 ) ) ) || ( ( VAR_547 . VAR_548 != VAR_549 ) && ( VAR_550 > VAR_551 . VAR_552 ) ) ) METHOD_75 ( VAR_553 , ""UnableToReadImageData"" ) ; for ( VAR_554 = 0 ; VAR_555 < ( TYPE_65 ) VAR_556 -> VAR_557 ; VAR_558 ++ ) { VAR_559 = METHOD_76 ( VAR_560 , 0 , VAR_561 , VAR_562 -> VAR_563 , 1 , VAR_564 ) ; if ( VAR_565 == ( TYPE_66 * ) VAR_566 ) break ; for ( VAR_567 = 0 ; VAR_568 < ( TYPE_67 ) VAR_569 -> VAR_570 ; VAR_571 ++ ) { if ( VAR_572 -> VAR_573 != VAR_574 ) METHOD_77 ( VAR_575 , METHOD_78 ( * VAR_576 ++ ) , VAR_577 ) ; if ( VAR_578 . VAR_579 == VAR_580 ) { METHOD_79 ( VAR_581 , METHOD_80 ( * VAR_582 ++ ) , VAR_583 ) ; METHOD_81 ( VAR_584 , METHOD_82 ( * VAR_585 ++ ) , VAR_586 ) ; METHOD_83 ( VAR_587 , METHOD_84 ( * VAR_588 ++ ) , VAR_589 ) ; } else { METHOD_85 ( VAR_590 , METHOD_86 ( * VAR_591 ++ ) , VAR_592 ) ; METHOD_87 ( VAR_593 , METHOD_88 ( * VAR_594 ++ ) , VAR_595 ) ; METHOD_89 ( VAR_596 , METHOD_90 ( * VAR_597 ++ ) , VAR_598 ) ; } if ( VAR_599 -> VAR_600 != 0 ) { METHOD_91 ( VAR_601 , METHOD_92 ( VAR_602 -> VAR_603 [ ( TYPE_68 ) METHOD_93 ( VAR_604 , VAR_605 ) ] . VAR_606 ) , VAR_607 ) ; METHOD_94 ( VAR_608 , METHOD_95 ( VAR_609 -> VAR_610 [ ( TYPE_69 ) METHOD_96 ( VAR_611 , VAR_612 ) ] . VAR_613 ) , VAR_614 ) ; METHOD_97 ( VAR_615 , METHOD_98 ( VAR_616 -> VAR_617 [ ( TYPE_70 ) METHOD_99 ( VAR_618 , VAR_619 ) ] . VAR_620 ) , VAR_621 ) ; } VAR_622 += METHOD_100 ( VAR_623 ) ; } if ( ( ( VAR_624 * VAR_625 -> VAR_626 ) % 2 ) != 0 ) VAR_627 ++ ; if ( METHOD_101 ( VAR_628 , VAR_629 ) == VAR_630 ) break ; if ( VAR_631 -> VAR_632 == ( TYPE_71 * ) VAR_633 ) { VAR_634 = METHOD_102 ( VAR_635 , VAR_636 , ( TYPE_72 ) VAR_637 , VAR_638 -> VAR_639 ) ; if ( VAR_640 == VAR_641 ) break ; } } } if ( VAR_642 -> VAR_643 == VAR_644 ) ( TYPE_73 ) METHOD_103 ( VAR_645 , VAR_646 ) ; VAR_647 = ( unsigned TYPE_74 * ) METHOD_104 ( VAR_648 ) ; if ( METHOD_105 ( VAR_649 ) != VAR_650 ) { METHOD_106 ( VAR_651 , VAR_652 , ""UnexpectedEndOfFile"" , VAR_653 -> VAR_654 ) ; break ; } if ( VAR_655 -> VAR_656 != 0 ) if ( VAR_657 -> VAR_658 >= ( VAR_659 -> VAR_660 + VAR_661 -> VAR_662 - 1 ) ) break ; VAR_663 . VAR_664 = METHOD_107 ( VAR_665 ) ; if ( VAR_666 . VAR_667 == 0x59a66a95 ) { METHOD_108 ( VAR_668 , VAR_669 , VAR_670 ) ; if ( METHOD_109 ( VAR_671 ) == ( TYPE_75 * ) VAR_672 ) { VAR_673 = METHOD_110 ( VAR_674 ) ; return ( ( TYPE_76 * ) VAR_675 ) ; } VAR_676 = METHOD_111 ( VAR_677 ) ; VAR_678 = METHOD_112 ( VAR_679 , VAR_680 , METHOD_113 ( VAR_681 ) , METHOD_114 ( VAR_682 ) ) ; if ( VAR_683 == VAR_684 ) break ; } } while ( VAR_685 . VAR_686 == 0x59a66a95 ) ; ( TYPE_77 ) METHOD_115 ( VAR_687 ) ; return ( METHOD_116 ( VAR_688 ) ) ; }","<S2SV_ModStart> ( VAR_379 , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; VAR_320 <S2SV_ModStart> ( VAR_379 , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; VAR_544 <S2SV_ModStart> ( VAR_379 , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; VAR_544 <S2SV_ModStart> VAR_388 ) ; else { if ( VAR_685 . VAR_552 > ( VAR_388 * VAR_544 ) ) METHOD_75 ( VAR_379 , ""ImproperImageHeader"" ) ; ( TYPE_77 ) METHOD_117 ( VAR_648 , VAR_390 , VAR_685 . VAR_552 ) ; }","CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {   RMT_EQUAL_RGB 1   RMT_NONE 0   RMT_RAW 2   RT_STANDARD 1   RT_ENCODED 2   RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }"
690,"CWE-17 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const struct STRUCT_OR_UNION_1 * VAR_1 , unsigned TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { struct STRUCT_OR_UNION_2 * VAR_4 = VAR_5 -> VAR_6 ; struct STRUCT_OR_UNION_3 * VAR_7 = VAR_8 -> VAR_9 ; TYPE_3 VAR_10 ; TYPE_4 VAR_11 ; struct STRUCT_OR_UNION_4 * VAR_12 = ( struct STRUCT_OR_UNION_5 * ) VAR_13 ; TYPE_5 VAR_14 ; <S2SV_StartBug> VAR_15 = METHOD_1 ( VAR_16 , VAR_17 ) ; <S2SV_EndBug> if ( METHOD_2 ( VAR_18 == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> VAR_19 = 0 ; VAR_20 = 0 ; METHOD_3 ( VAR_21 ) ; for ( ; ; ) { TYPE_6 VAR_22 = VAR_23 -> VAR_24 ; if ( VAR_25 ) { TYPE_7 VAR_26 = VAR_27 -> VAR_28 ; struct STRUCT_OR_UNION_6 * VAR_29 = VAR_30 -> VAR_31 + VAR_32 ; const struct STRUCT_OR_UNION_7 * VAR_33 = VAR_34 -> VAR_35 ; <S2SV_StartBug> TYPE_8 * VAR_36 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_9 VAR_37 = VAR_38 -> VAR_39 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_10 VAR_40 , VAR_41 ; <S2SV_EndBug> if ( VAR_42 > VAR_43 ) VAR_44 = VAR_45 ; VAR_46 = VAR_47 -> METHOD_4 ( VAR_48 , VAR_49 ) ; if ( VAR_50 ) { if ( ! VAR_51 ) VAR_52 = VAR_53 ; break ; } <S2SV_StartBug> VAR_54 = ! METHOD_5 ( VAR_55 , VAR_56 ) ; <S2SV_EndBug> VAR_57 : if ( VAR_58 ) VAR_59 = METHOD_6 ( VAR_60 -> VAR_61 ) ; else VAR_62 = METHOD_7 ( VAR_63 -> VAR_64 ) ; VAR_65 = METHOD_8 ( VAR_66 , VAR_67 + VAR_68 -> VAR_69 , VAR_70 , VAR_71 ) ; if ( VAR_72 ) METHOD_9 ( VAR_73 ) ; else METHOD_10 ( VAR_74 -> VAR_75 ) ; if ( METHOD_11 ( VAR_76 ) ) { if ( VAR_77 ) { VAR_78 = 0 ; goto VAR_79 ; } if ( ! VAR_80 ) VAR_81 = VAR_82 ; break ; } VAR_83 += VAR_84 ; VAR_85 -> VAR_86 += VAR_87 ; VAR_88 -> VAR_89 -= VAR_90 ; if ( VAR_91 -> VAR_92 & VAR_93 ) { VAR_94 = VAR_95 ; VAR_96 -> VAR_97 = 0 ; } if ( ! VAR_98 -> VAR_99 ) { VAR_100 -> VAR_101 = VAR_102 ; VAR_103 -> METHOD_12 ( VAR_104 , VAR_105 ) ; VAR_106 = ( VAR_107 + 1 ) & ( VAR_108 -> VAR_109 - 1 ) ; VAR_110 -> VAR_111 = VAR_112 ; VAR_113 -> VAR_114 = -- VAR_115 ; VAR_116 = 1 ; } VAR_117 -= VAR_118 ; if ( ! VAR_119 ) break ; } if ( VAR_120 ) continue ; if ( ! VAR_121 -> VAR_122 ) break ; if ( ! VAR_123 -> VAR_124 ) { if ( VAR_125 ) break ; if ( VAR_126 -> VAR_127 & VAR_128 ) { VAR_129 = - VAR_130 ; break ; } } if ( METHOD_13 ( VAR_131 ) ) { if ( ! VAR_132 ) VAR_133 = - VAR_134 ; break ; } if ( VAR_135 ) { METHOD_14 ( & VAR_136 -> VAR_137 , VAR_138 | VAR_139 ) ; METHOD_15 ( & VAR_140 -> VAR_141 , VAR_142 , VAR_143 ) ; } METHOD_16 ( VAR_144 ) ; } METHOD_17 ( VAR_145 ) ; if ( VAR_146 ) { METHOD_18 ( & VAR_147 -> VAR_148 , VAR_149 | VAR_150 ) ; METHOD_19 ( & VAR_151 -> VAR_152 , VAR_153 , VAR_154 ) ; } if ( VAR_155 > 0 ) METHOD_20 ( VAR_156 ) ; return VAR_157 ; }","<S2SV_ModStart> TYPE_9 VAR_119 ; struct STRUCT_OR_UNION_8 VAR_158 ; <S2SV_ModStart> ) return 0 ; METHOD_21 ( & VAR_158 , VAR_66 , VAR_17 , VAR_119 , 0 ) <S2SV_ModStart> -> VAR_103 ; <S2SV_ModEnd> TYPE_9 VAR_118 = <S2SV_ModStart> VAR_105 -> VAR_99 ; TYPE_9 VAR_159 <S2SV_ModStart> ; TYPE_10 VAR_82 <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } VAR_159 = METHOD_22 ( VAR_105 -> VAR_75 , VAR_105 -> VAR_86 , VAR_118 , & VAR_158 ) ; if ( METHOD_11 ( VAR_159 < VAR_118 ) ) { if ( ! VAR_157 ) VAR_157 = - VAR_160 <S2SV_ModEnd> ; break ;","CWE-17 static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }","<S2SV_ModStart> size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> -> ops ; <S2SV_ModEnd> size_t chars = <S2SV_ModStart> buf -> len ; size_t written <S2SV_ModStart> ; int error <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ;"
691,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , unsigned TYPE_1 VAR_1 , TYPE_2 * VAR_2 , TYPE_3 VAR_3 , unsigned TYPE_4 VAR_4 , TYPE_5 VAR_5 ) { struct STRUCT_OR_UNION_1 * VAR_6 = VAR_7 -> VAR_8 ; struct STRUCT_OR_UNION_2 * VAR_9 = VAR_10 -> STRUCT_OR_UNION_3 ; VAR_11 * VAR_12 ; TYPE_6 VAR_13 ; if ( VAR_14 [ 0 ] != VAR_15 ) return - VAR_16 ; VAR_17 = METHOD_1 ( VAR_18 , VAR_19 ) ; if ( ! VAR_20 ) return - VAR_21 ; <S2SV_StartBug> if ( VAR_22 < VAR_23 - 2 ) <S2SV_EndBug> VAR_24 = VAR_25 - 2 ; VAR_26 [ 0 ] = VAR_27 ; VAR_28 [ 1 ] = VAR_29 -> VAR_30 ; METHOD_2 ( VAR_31 + 2 , VAR_32 , VAR_33 ) ; VAR_34 = METHOD_3 ( VAR_35 -> VAR_36 , VAR_37 [ 0 ] , VAR_38 , VAR_39 , VAR_40 , VAR_41 ) ; METHOD_4 ( VAR_42 ) ; return VAR_43 ; }",<S2SV_ModStart> if ( VAR_33 > <S2SV_ModEnd> VAR_39 - 2,"CWE-119 static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }",<S2SV_ModStart> if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2
692,"CWE-400 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 ; struct STRUCT_OR_UNION_1 * VAR_2 = & METHOD_1 ( STRUCT_OR_UNION_2 ) ; struct STRUCT_OR_UNION_3 * VAR_3 ; unsigned TYPE_2 VAR_4 ; TYPE_3 VAR_5 = 0 ; TYPE_4 VAR_6 ; VAR_7 = METHOD_2 ( VAR_8 ) ; if ( VAR_9 ) METHOD_3 ( ) ; else METHOD_4 ( ) ; for ( VAR_10 = 0 ; VAR_11 < VAR_12 -> VAR_13 ; ++ VAR_14 ) { VAR_15 = VAR_16 -> VAR_17 [ VAR_18 ] ; VAR_19 = METHOD_5 ( VAR_20 ) ; if ( ( TYPE_5 ) VAR_21 < 0 ) { if ( VAR_22 ) { VAR_23 = 1 ; <S2SV_StartBug> METHOD_6 ( VAR_24 , VAR_25 , VAR_26 , VAR_27 ) ; <S2SV_EndBug> } else { METHOD_7 ( VAR_28 , 0 ) ; } } } METHOD_8 ( METHOD_9 ( ) | VAR_29 ) ; METHOD_10 ( VAR_30 , VAR_31 | VAR_32 ) ; METHOD_11 ( ) ; if ( VAR_33 ) METHOD_12 ( ) ; else METHOD_13 ( ) ; }","<S2SV_ModStart> VAR_25 , VAR_26 <S2SV_ModEnd> ) ; }","CWE-400 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }"
693,"CWE-362 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 VAR_3 ; TYPE_3 VAR_4 ; TYPE_4 VAR_5 ; TYPE_5 VAR_6 = VAR_7 -> VAR_8 ; if ( VAR_9 > VAR_10 ) VAR_11 = VAR_12 ; if ( VAR_13 -> VAR_14 >= VAR_15 ) return - VAR_16 ; METHOD_1 ( VAR_17 ) ; METHOD_2 ( & VAR_18 -> VAR_19 ) ; VAR_20 -> VAR_21 = VAR_22 ; METHOD_3 ( ) ; METHOD_4 ( & VAR_23 -> VAR_24 ) ; <S2SV_StartBug> VAR_25 = METHOD_5 ( & VAR_26 -> VAR_27 , VAR_28 , <S2SV_EndBug> ( VAR_29 < 0 ) ? 0 : METHOD_6 ( VAR_30 ) , 0 , VAR_31 ) ; METHOD_7 ( ) ; if ( VAR_32 < 0 ) { METHOD_8 ( & VAR_33 -> VAR_34 ) ; METHOD_9 ( ) ; return VAR_35 ; } VAR_36 -> VAR_37 ++ ; <S2SV_StartBug> METHOD_10 ( & VAR_38 , & VAR_39 ) ; <S2SV_EndBug> VAR_40 -> VAR_41 = VAR_42 -> VAR_43 = VAR_44 ; VAR_45 -> VAR_46 = VAR_47 -> VAR_48 = VAR_49 ; if ( VAR_50 < 0 ) { VAR_51 -> VAR_52 = VAR_53 -> VAR_54 ++ ; if ( VAR_55 -> VAR_56 > VAR_57 ) VAR_58 -> VAR_59 = 0 ; } else { VAR_60 -> VAR_61 = METHOD_11 ( VAR_62 ) ; VAR_63 -> VAR_64 = - 1 ; } VAR_65 -> VAR_66 = METHOD_12 ( VAR_67 , VAR_68 -> VAR_69 ) ; return VAR_70 ; }","<S2SV_ModStart> VAR_34 ) ; METHOD_10 ( & VAR_44 , & VAR_49 ) ; VAR_68 -> VAR_41 = VAR_68 -> VAR_43 = VAR_44 ; VAR_68 -> VAR_46 = VAR_68 -> VAR_48 = VAR_49 ; <S2SV_ModStart> VAR_37 ++ ; <S2SV_ModEnd> if ( VAR_64","CWE-362 int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }","<S2SV_ModStart> lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart> in_use ++ ; <S2SV_ModEnd> if ( next_id"
694,"CWE-000 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 * VAR_2 , * VAR_3 ; TYPE_4 VAR_4 ; unsigned TYPE_5 VAR_5 ; switch ( VAR_6 -> VAR_7 ) { case VAR_8 : VAR_9 = VAR_10 = * VAR_11 ; while ( VAR_12 ) { VAR_13 = VAR_14 -> VAR_15 ; METHOD_1 ( VAR_16 -> VAR_17 ) ; METHOD_2 ( VAR_18 ) ; VAR_19 = VAR_20 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case VAR_21 : VAR_22 = * VAR_23 ; while ( 1 ) { VAR_24 = ( VAR_25 != VAR_26 ) ; if ( ! METHOD_3 ( VAR_27 , & VAR_28 ) ) return VAR_29 ; if ( VAR_30 == VAR_31 ) break ; if ( ! METHOD_4 ( VAR_32 , & VAR_33 -> VAR_34 ) ) return VAR_35 ; VAR_36 = VAR_37 -> VAR_38 ; if ( ! METHOD_5 ( VAR_39 , ( TYPE_6 * * ) & VAR_40 -> VAR_41 , & VAR_42 , ~ 0 ) ) return VAR_43 ; VAR_44 = VAR_45 -> VAR_46 ; } break ; case VAR_47 : VAR_48 = VAR_49 ; while ( 1 ) { if ( ! METHOD_6 ( VAR_50 , & VAR_51 ) ) return VAR_52 ; if ( VAR_53 == VAR_54 ) break ; VAR_55 = ( TYPE_7 * ) METHOD_7 ( sizeof ( TYPE_8 ) ) ; if ( VAR_56 == VAR_57 ) return VAR_58 ; METHOD_8 ( VAR_59 , 0 , sizeof ( TYPE_9 ) ) ; if ( ! METHOD_9 ( VAR_60 , & VAR_61 -> VAR_62 ) ) return VAR_63 ; if ( ! METHOD_10 ( VAR_64 , ( TYPE_10 * * ) & VAR_65 -> VAR_66 , & VAR_67 , ~ 0 ) ) return VAR_68 ; VAR_69 -> VAR_70 = VAR_71 ; VAR_72 -> VAR_73 = VAR_74 ; VAR_75 = VAR_76 ; } * VAR_77 = VAR_78 ; break ; } return VAR_79 ; }",<S2SV_ModStart> VAR_76 ; } * VAR_77 = VAR_57 ;,"CWE-000 bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl2 -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl2 -> tl_data_length = len ; tl2 -> tl_data_next = tl ; tl = tl2 ; } * tl_data_head = tl ; break ; } return TRUE ; }",<S2SV_ModStart> tl2 ; } * tl_data_head = NULL ;
695,"CWE-119 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 ) { struct STRUCT_OR_UNION_2 * VAR_0 = STRUCT_OR_UNION_3 -> VAR_1 ; TYPE_1 VAR_2 = STRUCT_OR_UNION_4 -> VAR_3 ; <S2SV_StartBug> METHOD_1 ( & VAR_4 -> VAR_5 ) ; <S2SV_EndBug> METHOD_2 ( VAR_6 , & VAR_7 -> VAR_8 ) ; if ( VAR_9 ) { switch ( VAR_10 ) { case - VAR_11 : METHOD_3 ( & VAR_12 -> VAR_13 -> VAR_14 , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT"" ) ; goto VAR_15 ; case - VAR_16 : METHOD_4 ( & VAR_17 -> VAR_18 -> VAR_19 , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET"" ) ; goto VAR_20 ; case - VAR_21 : METHOD_5 ( & VAR_22 -> VAR_23 -> VAR_24 , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN"" ) ; goto VAR_25 ; case - VAR_26 : METHOD_6 ( & VAR_27 -> VAR_28 -> VAR_29 , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n"" ) ; break ; default : METHOD_7 ( & VAR_30 -> VAR_31 -> VAR_32 , ""Unexpected<S2SV_blank>error<S2SV_blank>%d\\n"" , VAR_33 ) ; break ; } } VAR_34 -> VAR_35 = VAR_36 ; <S2SV_StartBug> VAR_37 -> VAR_38 = STRUCT_OR_UNION_5 -> VAR_39 ; <S2SV_EndBug> <S2SV_StartBug> METHOD_8 ( VAR_40 -> VAR_41 + VAR_42 -> VAR_43 , VAR_44 -> VAR_45 , VAR_46 -> VAR_47 ) ; <S2SV_EndBug> VAR_48 -> VAR_49 += VAR_50 -> VAR_51 ; VAR_52 : METHOD_9 ( & VAR_53 -> VAR_54 ) ; METHOD_10 ( VAR_55 , & VAR_56 -> VAR_57 ) ; METHOD_11 ( & VAR_58 -> VAR_59 ) ; }","<S2SV_ModStart> -> VAR_36 ; TYPE_1 VAR_49 = STRUCT_OR_UNION_5 -> VAR_39 ; <S2SV_ModStart> = VAR_36 ; if ( VAR_49 + VAR_58 -> VAR_49 > VAR_58 -> VAR_60 ) { METHOD_10 ( VAR_61 , & VAR_58 -> VAR_57 ) ; } else { if ( ! METHOD_12 ( VAR_61 , & VAR_58 -> VAR_57 ) ) { <S2SV_ModEnd> METHOD_8 ( VAR_58 <S2SV_ModStart> -> VAR_45 , VAR_49 ) ; VAR_58 -> VAR_49 += VAR_49 ; <S2SV_ModStart> VAR_58 -> VAR_51 = VAR_49 ; } } <S2SV_ModEnd> VAR_52 : METHOD_9","CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT"" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET"" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN"" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n"" ) ; break ; default : dev_err ( & desc -> intf -> dev , ""Unexpected<S2SV_blank>error<S2SV_blank>%d\\n"" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }","<S2SV_ModStart> -> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up"
696,"CWE-284 static TYPE_0 METHOD_0 ( TYPE_1 TYPE_2 * VAR_0 ) { METHOD_1 ( & VAR_1 ) ; if ( METHOD_2 ( VAR_2 ) ) { METHOD_3 ( ""%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>commands<S2SV_blank>pending<S2SV_blank>response"" , VAR_3 ) ; } else { TYPE_3 * VAR_4 = METHOD_4 ( VAR_5 ) ; METHOD_5 ( & VAR_6 ) ; METHOD_6 ( ""%s<S2SV_blank>hci<S2SV_blank>layer<S2SV_blank>timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>to<S2SV_blank>a<S2SV_blank>command.<S2SV_blank>opcode:<S2SV_blank>0x%x"" , VAR_7 , VAR_8 -> VAR_9 ) ; } METHOD_7 ( ""%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process."" , VAR_10 ) ; <S2SV_StartBug> METHOD_8 ( 10000 ) ; <S2SV_EndBug> METHOD_9 ( METHOD_10 ( ) , VAR_11 ) ; }",<S2SV_ModStart> VAR_10 ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> METHOD_8 ( 10000 ),"CWE-284 static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( ""%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>commands<S2SV_blank>pending<S2SV_blank>response"" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( ""%s<S2SV_blank>hci<S2SV_blank>layer<S2SV_blank>timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>to<S2SV_blank>a<S2SV_blank>command.<S2SV_blank>opcode:<S2SV_blank>0x%x"" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( ""%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process."" , __func__ ) ; <S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; }",<S2SV_ModStart> __func__ ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 10000 )
697,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_3 * VAR_1 = STRUCT_OR_UNION_4 -> VAR_2 . VAR_3 [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct STRUCT_OR_UNION_5 * VAR_4 ; <S2SV_EndBug> struct STRUCT_OR_UNION_6 * VAR_5 ; TYPE_1 VAR_6 = VAR_7 -> VAR_8 ; TYPE_2 * VAR_9 ; TYPE_3 VAR_10 = 0 ; if ( ! VAR_11 -> VAR_12 ) return - VAR_13 ; if ( VAR_14 <= 0 || VAR_15 > 32767 || ! VAR_16 -> VAR_17 ) return - VAR_18 ; VAR_19 = METHOD_1 ( VAR_20 + 1 , VAR_21 ) ; if ( ! VAR_22 ) return - VAR_23 ; VAR_24 = METHOD_2 ( ) ; if ( ! VAR_25 ) { VAR_26 = - VAR_27 ; goto VAR_28 ; } VAR_29 = METHOD_3 ( STRUCT_OR_UNION_7 ) ; if ( ! VAR_30 ) { VAR_31 = - VAR_32 ; goto VAR_33 ; } METHOD_4 ( VAR_34 , VAR_35 -> VAR_36 , VAR_37 ) ; VAR_38 [ VAR_39 ] = '\\0' ; VAR_40 = METHOD_5 ( VAR_41 , VAR_42 , VAR_43 ) ; if ( VAR_44 != VAR_45 ) { VAR_46 = - VAR_47 ; METHOD_6 ( VAR_48 ) ; goto VAR_49 ; } if ( ! VAR_50 -> VAR_51 ) { VAR_52 = - VAR_53 ; METHOD_7 ( VAR_54 ) ; goto VAR_55 ; } VAR_56 -> VAR_57 = VAR_58 -> VAR_59 ; VAR_60 -> VAR_61 = VAR_62 -> VAR_63 ; METHOD_8 ( VAR_64 -> STRUCT_OR_UNION_8 , VAR_65 -> STRUCT_OR_UNION_9 , VAR_66 -> VAR_67 ) ; METHOD_9 ( VAR_68 ) ; METHOD_10 ( VAR_69 ) ; VAR_70 = METHOD_11 ( VAR_71 , VAR_72 ) ; if ( VAR_73 < 0 ) { METHOD_12 ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , VAR_74 ) ; METHOD_13 ( VAR_75 ) ; goto VAR_76 ; } if ( VAR_77 -> METHOD_14 ) { VAR_78 = METHOD_15 ( VAR_79 -> METHOD_16 ) ; if ( VAR_80 < 0 ) { METHOD_17 ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , VAR_81 ) ; METHOD_18 ( VAR_82 ) ; goto VAR_83 ; } } METHOD_19 ( STRUCT_OR_UNION_10 , VAR_84 ) ; METHOD_20 ( & VAR_85 -> VAR_86 , VAR_87 ) ; VAR_88 : METHOD_21 ( VAR_89 ) ; METHOD_22 ( VAR_90 ) ; return VAR_91 ; }","<S2SV_ModStart> struct STRUCT_OR_UNION_5 * VAR_85 ; struct STRUCT_OR_UNION_5 * VAR_84 ; struct STRUCT_OR_UNION_6 * VAR_90 ; TYPE_1 VAR_39 = VAR_35 -> VAR_39 ; TYPE_2 * VAR_89 ; TYPE_3 VAR_91 = 0 ; if ( METHOD_23 ( VAR_92 , & STRUCT_OR_UNION_10 -> VAR_93 ) ) return - VAR_94 ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !","CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }","<S2SV_ModStart> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !"
698,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * * VAR_1 ) { TYPE_3 VAR_2 ; if ( VAR_3 -> VAR_4 == VAR_5 ) { if ( * VAR_6 == VAR_7 ) VAR_8 = 0 ; else VAR_9 = METHOD_1 ( * VAR_10 ) + 1 ; } if ( ! METHOD_2 ( VAR_11 , & VAR_12 ) ) { return VAR_13 ; } switch ( VAR_14 -> VAR_15 ) { case VAR_16 : if ( VAR_17 == 0 ) { * VAR_18 = VAR_19 ; return VAR_20 ; } else if ( * VAR_21 == VAR_22 ) { * VAR_23 = ( TYPE_4 * ) METHOD_3 ( VAR_24 ) ; if ( * VAR_25 == VAR_26 ) { VAR_27 = VAR_28 ; return VAR_29 ; } } <S2SV_StartBug> return ( METHOD_4 ( VAR_30 , * VAR_31 , VAR_32 ) ) ; <S2SV_EndBug> case VAR_33 : if ( VAR_34 != 0 ) return ( METHOD_5 ( VAR_35 , * VAR_36 , VAR_37 ) ) ; return VAR_38 ; case VAR_39 : if ( * VAR_40 != VAR_41 ) METHOD_6 ( * VAR_42 , VAR_43 ) ; * VAR_44 = VAR_45 ; return VAR_46 ; } return VAR_47 ; }","<S2SV_ModStart> ; } } if ( ! <S2SV_ModEnd> METHOD_5 ( VAR_35 <S2SV_ModStart> VAR_43 ) ) return VAR_47 ; if ( ( * VAR_44 ) [ VAR_43 - 1 ] != '\\0' ) return VAR_47 ; if ( METHOD_7 ( * VAR_44 , '\\0' , VAR_43 - 1 ) != VAR_45 ) return VAR_47 ; return VAR_46","CWE-119 bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }","<S2SV_ModStart> ; } } if ( ! <S2SV_ModEnd> xdr_opaque ( xdrs <S2SV_ModStart> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE"
699,"CWE-416 TYPE_0 * METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { unsigned VAR_2 = METHOD_1 ( VAR_3 -> VAR_4 . VAR_5 ) ; unsigned VAR_6 = METHOD_2 ( VAR_7 -> VAR_8 . VAR_9 ) ; METHOD_3 ( VAR_10 -> VAR_11 . VAR_12 , VAR_13 ) ; METHOD_4 ( VAR_14 -> VAR_15 . VAR_16 , VAR_17 ) ; METHOD_5 ( VAR_18 -> VAR_19 . VAR_20 , VAR_21 -> VAR_22 . VAR_23 ) ; <S2SV_StartBug> METHOD_6 ( ( TYPE_3 * ) & VAR_24 ) ; <S2SV_EndBug> return VAR_25 ; }",<S2SV_ModStart> TYPE_3 * ) <S2SV_ModEnd> VAR_24 ) ;,"CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }",<S2SV_ModStart> ParseCommon * ) <S2SV_ModEnd> append ) ;
700,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , const TYPE_1 * VAR_1 , TYPE_2 VAR_2 , const TYPE_3 * VAR_3 , ... ) { TYPE_4 VAR_4 ; <S2SV_StartBug> struct STRUCT_OR_UNION_1 VAR_5 ; <S2SV_EndBug> TYPE_5 VAR_6 [ 32 ] ; METHOD_1 ( VAR_7 , 0 , sizeof ( VAR_8 ) ) ; METHOD_2 ( VAR_9 , VAR_10 , sizeof ( VAR_11 ) - 1 ) ; METHOD_3 ( VAR_12 , VAR_13 ) ; VAR_14 . VAR_15 = VAR_16 ; VAR_17 . VAR_18 = & VAR_19 ; if ( ! ( VAR_20 & VAR_21 ) ) goto VAR_22 ; if ( METHOD_4 ( VAR_23 ) && METHOD_5 ( VAR_24 -> VAR_25 ) ) METHOD_6 ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , METHOD_7 ( & VAR_26 -> VAR_27 -> VAR_28 ) , <S2SV_StartBug> VAR_29 , VAR_30 , VAR_31 -> VAR_32 , & VAR_33 ) ; <S2SV_EndBug> else <S2SV_StartBug> METHOD_8 ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , VAR_34 , VAR_35 , & VAR_36 ) ; <S2SV_EndBug> VAR_37 : METHOD_9 ( VAR_38 ) ; }","<S2SV_ModStart> struct STRUCT_OR_UNION_1 VAR_36 <S2SV_ModEnd> ; METHOD_3 ( <S2SV_ModStart> VAR_28 ) , VAR_10 <S2SV_ModEnd> , VAR_35 , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , VAR_10 <S2SV_ModEnd> , VAR_35 ,","CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,"
701,"CWE-834 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 * VAR_2 = VAR_3 -> VAR_4 ; TYPE_4 * VAR_5 = VAR_6 -> VAR_7 ; TYPE_5 VAR_8 , VAR_9 , VAR_10 , VAR_11 ; TYPE_6 VAR_12 [ 1024 ] ; METHOD_1 ( VAR_13 ) ; METHOD_2 ( VAR_14 ) ; VAR_15 = METHOD_3 ( VAR_16 ) ; METHOD_4 ( VAR_17 ) ; VAR_18 = METHOD_5 ( VAR_19 ) ; <S2SV_StartBug> for ( VAR_20 = 0 ; VAR_21 < VAR_22 ; VAR_23 ++ ) <S2SV_EndBug> METHOD_6 ( VAR_24 ) ; for ( VAR_25 = 0 ; VAR_26 < VAR_27 ; VAR_28 ++ ) { TYPE_7 VAR_29 ; <S2SV_StartBug> TYPE_8 VAR_30 ; <S2SV_EndBug> METHOD_7 ( VAR_31 ) ; VAR_32 = METHOD_8 ( VAR_33 ) ; VAR_34 -= VAR_35 -> VAR_36 . VAR_37 * 10000 ; METHOD_9 ( VAR_38 ) ; METHOD_10 ( VAR_39 ) ; METHOD_11 ( VAR_40 ) ; VAR_41 = METHOD_12 ( VAR_42 ) ; if ( ( VAR_43 = METHOD_13 ( VAR_44 , VAR_45 * 2 , VAR_46 , sizeof ( VAR_47 ) ) ) < VAR_48 ) METHOD_14 ( VAR_49 , VAR_50 - VAR_51 ) ; METHOD_15 ( VAR_52 , VAR_53 , ( TYPE_9 ) { 1 , 10000000 } , VAR_54 , VAR_55 , VAR_56 ) ; } return 0 ; }","<S2SV_ModStart> VAR_49 ) ; METHOD_14 ( VAR_49 , VAR_50 <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; TYPE_8 VAR_50 ; if ( METHOD_16 ( VAR_49 ) ) return VAR_57","CWE-834 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <S2SV_StartBug> int name_len ; <S2SV_EndBug> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }","<S2SV_ModStart> pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA"
702,"CWE-89 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 = & VAR_2 -> VAR_3 . VAR_4 ; struct STRUCT_OR_UNION_2 * VAR_5 = VAR_6 -> VAR_7 ; const TYPE_1 * VAR_8 = VAR_9 -> VAR_10 . VAR_11 ; <S2SV_StartBug> TYPE_2 VAR_12 ; <S2SV_EndBug> if ( ! * VAR_13 ) VAR_14 = ""INBOX"" ; <S2SV_StartBug> VAR_15 -> VAR_16 = METHOD_1 ( VAR_17 , VAR_18 , 0 , & VAR_19 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VAR_20 -> VAR_21 ) <S2SV_EndBug> return VAR_22 ; return VAR_23 ; }","<S2SV_ModStart> . VAR_18 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = ""INBOX"" ; return METHOD_2 <S2SV_ModEnd> ( VAR_17 , <S2SV_ModStart> 0 , & <S2SV_ModEnd> VAR_20 -> VAR_21 <S2SV_ModStart> VAR_20 -> VAR_21 , VAR_24 , VAR_25 ) <S2SV_ModEnd> ; } <S2SV_null>","CWE-89 static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = ""INBOX"" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }","<S2SV_ModStart> . path ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = ""INBOX"" ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> 0 , & <S2SV_ModEnd> imapc -> mailbox <S2SV_ModStart> imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>"
703,"CWE-399 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 , TYPE_1 VAR_1 ) { TYPE_2 VAR_2 ; TYPE_3 VAR_3 ; unsigned TYPE_4 VAR_4 ; unsigned TYPE_5 VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; struct STRUCT_OR_UNION_4 VAR_7 , VAR_8 ; struct STRUCT_OR_UNION_5 * VAR_9 , * VAR_10 ; VAR_11 = METHOD_1 ( VAR_12 ) ; if ( VAR_13 ) goto VAR_14 ; VAR_15 = - VAR_16 ; if ( VAR_17 -> VAR_18 & ( VAR_19 - 1 ) ) goto VAR_20 ; if ( VAR_21 -> VAR_22 & ( VAR_23 - 1 ) ) goto VAR_24 ; if ( VAR_25 && ( ( VAR_26 -> VAR_27 & ( VAR_28 - 1 ) ) || ! METHOD_2 ( VAR_29 , ( TYPE_6 TYPE_7 * ) ( unsigned TYPE_8 ) VAR_30 -> VAR_31 , VAR_32 -> VAR_33 ) ) ) goto VAR_34 ; if ( VAR_35 -> VAR_36 >= VAR_37 ) goto VAR_38 ; if ( VAR_39 -> VAR_40 + VAR_41 -> VAR_42 < VAR_43 -> VAR_44 ) goto VAR_45 ; VAR_46 = METHOD_3 ( STRUCT_OR_UNION_6 -> VAR_47 , VAR_48 -> VAR_49 ) ; VAR_50 = VAR_51 -> VAR_52 >> VAR_53 ; VAR_54 = VAR_55 -> VAR_56 >> VAR_57 ; VAR_58 = - VAR_59 ; if ( VAR_60 > VAR_61 ) goto VAR_62 ; if ( ! VAR_63 ) VAR_64 -> VAR_65 &= ~ VAR_66 ; VAR_67 = VAR_68 = * VAR_69 ; VAR_70 . VAR_71 = VAR_72 -> VAR_73 ; VAR_74 . VAR_75 = VAR_76 ; VAR_77 . VAR_78 = VAR_79 ; VAR_80 . VAR_81 = VAR_82 -> VAR_83 ; VAR_84 = - VAR_85 ; if ( VAR_86 && VAR_87 . VAR_88 && VAR_89 != VAR_90 . VAR_91 ) goto VAR_92 ; VAR_93 = - VAR_94 ; for ( VAR_95 = 0 ; VAR_96 < VAR_97 ; ++ VAR_98 ) { struct STRUCT_OR_UNION_7 * VAR_99 = & STRUCT_OR_UNION_8 -> VAR_100 -> VAR_101 [ VAR_102 ] ; if ( VAR_103 == VAR_104 || ! VAR_105 -> VAR_106 ) continue ; if ( ! ( ( VAR_107 + VAR_108 <= VAR_109 -> VAR_110 ) || ( VAR_111 >= VAR_112 -> VAR_113 + VAR_114 -> VAR_115 ) ) ) goto VAR_116 ; } if ( ! ( VAR_117 . VAR_118 & VAR_119 ) ) VAR_120 . VAR_121 = VAR_122 ; VAR_123 = - VAR_124 ; if ( VAR_125 && ! VAR_126 . VAR_127 ) { VAR_128 . VAR_129 = VAR_130 ; VAR_131 . VAR_132 = VAR_133 -> VAR_134 ; if ( METHOD_4 ( & VAR_135 , VAR_136 ) ) goto VAR_137 ; } if ( ( VAR_138 . VAR_139 & VAR_140 ) && ! VAR_141 . VAR_142 ) { if ( METHOD_5 ( & VAR_143 ) < 0 ) goto VAR_144 ; } <S2SV_StartBug> if ( ! VAR_145 ) { <S2SV_EndBug> struct STRUCT_OR_UNION_9 * VAR_146 ; VAR_147 = - VAR_148 ; VAR_149 = METHOD_6 ( STRUCT_OR_UNION_10 -> VAR_150 , sizeof ( struct STRUCT_OR_UNION_11 ) , VAR_151 ) ; if ( ! VAR_152 ) goto VAR_153 ; VAR_154 = METHOD_7 ( VAR_155 , VAR_156 -> VAR_157 ) ; VAR_158 -> VAR_159 |= VAR_160 ; METHOD_8 ( VAR_161 , VAR_162 ) ; VAR_163 = STRUCT_OR_UNION_12 -> VAR_164 ; METHOD_9 ( STRUCT_OR_UNION_13 -> VAR_165 , VAR_166 ) ; METHOD_10 ( & STRUCT_OR_UNION_14 -> VAR_167 ) ; METHOD_11 ( STRUCT_OR_UNION_15 , VAR_168 ) ; METHOD_12 ( VAR_169 ) ; } VAR_170 = METHOD_13 ( STRUCT_OR_UNION_16 , & VAR_171 , VAR_172 , VAR_173 , VAR_174 ) ; if ( VAR_175 ) goto VAR_176 ; if ( VAR_177 ) { VAR_178 = METHOD_14 ( STRUCT_OR_UNION_17 , & VAR_179 ) ; if ( VAR_180 ) goto VAR_181 ; } else METHOD_15 ( STRUCT_OR_UNION_18 , & VAR_182 ) ; VAR_183 = - VAR_184 ; VAR_185 = METHOD_16 ( STRUCT_OR_UNION_19 -> VAR_186 , sizeof ( struct STRUCT_OR_UNION_20 ) , VAR_187 ) ; if ( ! VAR_188 ) goto VAR_189 ; if ( ! VAR_190 ) { VAR_191 . VAR_192 = VAR_193 ; METHOD_17 ( & VAR_194 . VAR_195 , 0 , sizeof ( VAR_196 . VAR_197 ) ) ; } METHOD_18 ( VAR_198 , & VAR_199 ) ; VAR_200 = STRUCT_OR_UNION_21 -> VAR_201 ; METHOD_19 ( STRUCT_OR_UNION_22 -> VAR_202 , VAR_203 ) ; METHOD_20 ( & STRUCT_OR_UNION_23 -> VAR_204 ) ; METHOD_21 ( STRUCT_OR_UNION_24 , VAR_205 , VAR_206 , VAR_207 ) ; if ( VAR_208 && VAR_209 . VAR_210 != VAR_211 -> VAR_212 >> VAR_213 ) METHOD_22 ( STRUCT_OR_UNION_25 ) ; METHOD_23 ( & VAR_214 , & VAR_215 ) ; METHOD_24 ( VAR_216 ) ; return 0 ; VAR_217 : METHOD_25 ( & VAR_218 , & VAR_219 ) ; VAR_220 : return VAR_221 ; }",<S2SV_ModStart> ( ! VAR_208 || VAR_210 != VAR_219 . VAR_210,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }",<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn
704,"CWE-476 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 ; VAR_2 * VAR_3 ; if ( VAR_4 -> VAR_5 == VAR_6 ) VAR_7 -> VAR_8 = METHOD_1 ( VAR_9 -> VAR_10 ) ; if ( VAR_11 -> VAR_12 == VAR_13 ) VAR_14 -> VAR_15 = VAR_16 -> VAR_17 ; VAR_18 -> VAR_19 = VAR_20 ; VAR_21 -> VAR_22 -> VAR_23 = VAR_24 -> VAR_25 -> VAR_26 ; if ( METHOD_2 ( VAR_27 -> VAR_28 , VAR_29 -> VAR_30 -> VAR_31 , VAR_32 -> VAR_33 -> VAR_34 ) != VAR_35 ) return VAR_36 ; if ( VAR_37 -> VAR_38 -> VAR_39 != VAR_40 ) return VAR_41 ; VAR_42 = VAR_43 -> VAR_44 ; VAR_45 = ( TYPE_3 * ) VAR_46 -> VAR_47 ; if ( VAR_48 -> VAR_49 == VAR_50 ) VAR_51 -> VAR_52 = METHOD_3 ( VAR_53 , VAR_54 , VAR_55 ) ; if ( METHOD_4 ( VAR_56 -> VAR_57 ) < 0 ) { METHOD_5 ( VAR_58 , ""client<S2SV_blank>authentication<S2SV_blank>failure\\n"" ) ; METHOD_6 ( VAR_59 -> VAR_60 ) ; <S2SV_StartBug> return VAR_61 ; <S2SV_EndBug> } return VAR_62 ; }",<S2SV_ModStart> VAR_60 ) ; VAR_59 -> VAR_60 = VAR_50 ;,"CWE-476 BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , ""client<S2SV_blank>authentication<S2SV_blank>failure\\n"" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }",<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
705,"CWE-119 static VAR_0 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_1 , struct STRUCT_OR_UNION_1 * VAR_2 , const unsigned TYPE_1 * VAR_3 , const unsigned TYPE_2 * VAR_4 , const unsigned TYPE_3 * VAR_5 , const unsigned TYPE_4 * VAR_6 , unsigned TYPE_5 VAR_7 ) { unsigned TYPE_6 VAR_8 ; TYPE_7 VAR_9 ; if ( ( unsigned TYPE_8 ) VAR_10 % VAR_11 ( struct STRUCT_OR_UNION_2 ) != 0 || <S2SV_StartBug> ( unsigned TYPE_9 * ) VAR_12 + sizeof ( struct STRUCT_OR_UNION_3 ) >= VAR_13 ) { <S2SV_EndBug> METHOD_1 ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , VAR_14 ) ; return - VAR_15 ; } if ( VAR_16 -> VAR_17 < sizeof ( struct STRUCT_OR_UNION_4 ) + sizeof ( struct STRUCT_OR_UNION_5 ) ) { METHOD_2 ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , VAR_18 , VAR_19 -> VAR_20 ) ; return - VAR_21 ; } VAR_22 = METHOD_3 ( VAR_23 ) ; if ( VAR_24 ) return VAR_25 ; for ( VAR_26 = 0 ; VAR_27 < VAR_28 ; VAR_29 ++ ) { if ( ! ( VAR_30 & ( 1 << VAR_31 ) ) ) continue ; if ( ( unsigned TYPE_10 * ) VAR_32 - VAR_33 == VAR_34 [ VAR_35 ] ) VAR_36 -> VAR_37 [ VAR_38 ] = VAR_39 [ VAR_40 ] ; if ( ( unsigned TYPE_11 * ) VAR_41 - VAR_42 == VAR_43 [ VAR_44 ] ) { if ( ! METHOD_4 ( VAR_45 ) ) { METHOD_5 ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - VAR_46 ; } VAR_47 -> VAR_48 [ VAR_49 ] = VAR_50 [ VAR_51 ] ; } } VAR_52 -> VAR_53 = ( ( struct STRUCT_OR_UNION_6 ) { 0 , 0 } ) ; VAR_54 -> VAR_55 = 0 ; return 0 ; }",<S2SV_ModStart> STRUCT_OR_UNION_4 ) >= VAR_13 || ( unsigned TYPE_11 * ) VAR_54 + VAR_54 -> VAR_20 >,"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
706,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 ) { METHOD_1 ( VAR_0 != VAR_1 ) ; METHOD_2 ( VAR_2 != VAR_3 ) ; METHOD_3 ( VAR_4 ) ; <S2SV_StartBug> METHOD_4 ( & VAR_5 ) ; <S2SV_EndBug> METHOD_5 ( VAR_6 , VAR_7 ) ; METHOD_6 ( & VAR_8 ) ; }",<S2SV_ModStart> VAR_4 ) ; METHOD_7 ( <S2SV_ModEnd> ) ; },"CWE-119 void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }",<S2SV_ModStart> alarm_timer ) ; btif_config_write ( <S2SV_ModEnd> ) ; }
707,"CWE-362 METHOD_0 ( TYPE_0 , struct STRUCT_OR_UNION_0 TYPE_1 * , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 , TYPE_8 , unsigned TYPE_9 , TYPE_10 ) { struct STRUCT_OR_UNION_1 * VAR_0 = VAR_1 , * VAR_2 = VAR_3 ; struct STRUCT_OR_UNION_2 * VAR_4 , * VAR_5 ; struct STRUCT_OR_UNION_3 VAR_6 ; struct STRUCT_OR_UNION_4 * VAR_7 , * VAR_8 ( TYPE_11 ) ; struct STRUCT_OR_UNION_5 * VAR_9 = VAR_10 ; struct STRUCT_OR_UNION_6 VAR_11 = { VAR_12 , 0 } ; struct STRUCT_OR_UNION_7 * VAR_13 = VAR_14 ; struct STRUCT_OR_UNION_8 * STRUCT_OR_UNION_9 ; TYPE_12 VAR_15 ; TYPE_13 TYPE_14 = 0 ; TYPE_15 VAR_16 ; TYPE_16 VAR_17 = VAR_18 ; TYPE_17 VAR_19 = - 1 ; if ( TYPE_18 & ~ VAR_20 ) return - VAR_21 ; VAR_22 = METHOD_1 ( TYPE_19 , & VAR_23 ) ; if ( VAR_24 ) return VAR_25 ; if ( ! VAR_26 . VAR_27 ) { if ( METHOD_2 ( ) && ! METHOD_3 ( VAR_28 ) ) return - VAR_29 ; } if ( VAR_30 . VAR_31 ) { if ( VAR_32 . VAR_33 > VAR_34 ) return - VAR_35 ; } else { if ( VAR_36 . VAR_37 & ( 1ULL << 63 ) ) return - VAR_38 ; } if ( ! VAR_39 . VAR_40 ) VAR_41 . VAR_42 = VAR_43 ; if ( ( TYPE_20 & VAR_44 ) && ( TYPE_21 == - 1 || TYPE_22 == - 1 ) ) return - VAR_45 ; if ( TYPE_23 & VAR_46 ) VAR_47 |= VAR_48 ; VAR_49 = METHOD_4 ( VAR_50 ) ; if ( VAR_51 < 0 ) return VAR_52 ; if ( TYPE_24 != - 1 ) { VAR_53 = METHOD_5 ( TYPE_25 , & VAR_54 ) ; if ( VAR_55 ) goto VAR_56 ; VAR_57 = VAR_58 . STRUCT_OR_UNION_10 -> VAR_59 ; if ( TYPE_26 & VAR_60 ) VAR_61 = VAR_62 ; if ( TYPE_27 & VAR_63 ) VAR_64 = VAR_65 ; } if ( TYPE_28 != - 1 && ! ( TYPE_29 & VAR_66 ) ) { VAR_67 = METHOD_6 ( TYPE_30 ) ; if ( METHOD_7 ( VAR_68 ) ) { VAR_69 = METHOD_8 ( VAR_70 ) ; goto VAR_71 ; } } if ( VAR_72 && VAR_73 && VAR_74 -> VAR_75 . VAR_76 != VAR_77 . VAR_78 ) { VAR_79 = - VAR_80 ; goto VAR_81 ; } METHOD_9 ( ) ; if ( VAR_82 ) { VAR_83 = METHOD_10 ( & VAR_84 -> VAR_85 -> VAR_86 ) ; if ( VAR_87 ) goto VAR_88 ; VAR_89 = - VAR_90 ; if ( ! METHOD_11 ( VAR_91 , VAR_92 ) ) goto VAR_93 ; } if ( TYPE_31 & VAR_94 ) VAR_95 = TYPE_32 ; VAR_96 = METHOD_12 ( & VAR_97 , TYPE_33 , VAR_98 , VAR_99 , VAR_100 , VAR_101 , VAR_102 , VAR_103 ) ; if ( METHOD_13 ( VAR_104 ) ) { VAR_105 = METHOD_14 ( VAR_106 ) ; goto VAR_107 ; } if ( METHOD_15 ( VAR_108 ) ) { if ( VAR_109 -> STRUCT_OR_UNION_11 -> VAR_110 & VAR_111 ) { VAR_112 = - VAR_113 ; goto VAR_114 ; } } STRUCT_OR_UNION_12 = VAR_115 -> STRUCT_OR_UNION_13 ; if ( VAR_116 . VAR_117 ) { VAR_118 = METHOD_16 ( VAR_119 , VAR_120 . VAR_121 ) ; if ( VAR_122 ) goto VAR_123 ; } if ( STRUCT_OR_UNION_14 -> VAR_124 == VAR_125 ) VAR_126 -> VAR_127 |= VAR_128 ; if ( VAR_129 && ( METHOD_17 ( VAR_130 ) != METHOD_18 ( VAR_131 ) ) ) { if ( METHOD_19 ( VAR_132 ) ) { STRUCT_OR_UNION_15 = VAR_133 -> STRUCT_OR_UNION_16 ; } else if ( METHOD_20 ( VAR_134 ) && ( VAR_135 -> VAR_136 & VAR_137 ) ) { TYPE_34 = 1 ; } } VAR_138 = METHOD_21 ( STRUCT_OR_UNION_17 , VAR_139 , VAR_140 ) ; if ( METHOD_22 ( VAR_141 ) ) { VAR_142 = METHOD_23 ( VAR_143 ) ; goto VAR_144 ; } if ( ( STRUCT_OR_UNION_18 -> VAR_145 & VAR_146 ) && VAR_147 ) { VAR_148 = - VAR_149 ; goto VAR_150 ; } if ( VAR_151 ) { VAR_152 = - VAR_153 ; if ( VAR_154 -> VAR_155 != VAR_156 ) goto VAR_157 ; if ( VAR_158 -> VAR_159 != VAR_160 -> VAR_161 ) goto VAR_162 ; if ( TYPE_35 ) { if ( VAR_163 -> VAR_164 -> VAR_165 != VAR_166 -> VAR_167 ) goto VAR_168 ; if ( VAR_169 -> TYPE_36 != VAR_170 -> TYPE_37 ) goto VAR_171 ; } else { if ( VAR_172 -> VAR_173 != VAR_174 ) goto VAR_175 ; } if ( VAR_176 . VAR_177 || VAR_178 . VAR_179 ) goto VAR_180 ; } if ( VAR_181 ) { VAR_182 = METHOD_24 ( VAR_183 , VAR_184 ) ; if ( VAR_185 ) goto VAR_186 ; } VAR_187 = METHOD_25 ( ""[perf_event]"" , & VAR_188 , VAR_189 , VAR_190 ) ; if ( METHOD_26 ( VAR_191 ) ) { VAR_192 = METHOD_27 ( VAR_193 ) ; VAR_194 = VAR_195 ; goto VAR_196 ; } if ( TYPE_38 ) { <S2SV_StartBug> TYPE_39 = VAR_197 -> VAR_198 ; <S2SV_EndBug> METHOD_28 ( & TYPE_40 -> VAR_199 , & VAR_200 -> VAR_201 ) ; if ( TYPE_41 -> VAR_202 == VAR_203 ) { VAR_204 = - VAR_205 ; goto VAR_206 ; } <S2SV_StartBug> } else { <S2SV_EndBug> METHOD_29 ( & VAR_207 -> VAR_208 ) ; } if ( VAR_209 -> VAR_210 == VAR_211 ) { VAR_212 = - VAR_213 ; goto VAR_214 ; } if ( ! METHOD_30 ( VAR_215 ) ) { VAR_216 = - VAR_217 ; goto VAR_218 ; } if ( ! METHOD_31 ( VAR_219 , VAR_220 ) ) { METHOD_32 ( TYPE_42 ) ; VAR_221 = - VAR_222 ; goto VAR_223 ; } METHOD_33 ( VAR_224 -> VAR_225 ) ; if ( TYPE_43 ) { METHOD_34 ( VAR_226 , 0 ) ; METHOD_35 ( VAR_227 , & VAR_228 -> VAR_229 , VAR_230 ) { METHOD_36 ( VAR_231 , 0 ) ; METHOD_37 ( TYPE_44 ) ; } METHOD_38 ( ) ; METHOD_39 ( VAR_232 , & VAR_233 -> VAR_234 , VAR_235 ) { METHOD_40 ( VAR_236 ) ; METHOD_41 ( VAR_237 , VAR_238 , VAR_239 -> TYPE_45 ) ; METHOD_42 ( VAR_240 ) ; } METHOD_43 ( VAR_241 ) ; METHOD_44 ( VAR_242 , VAR_243 , VAR_244 -> TYPE_46 ) ; METHOD_45 ( VAR_245 ) ; METHOD_46 ( TYPE_47 ) ; } METHOD_47 ( VAR_246 ) ; METHOD_48 ( VAR_247 ) ; VAR_248 -> VAR_249 = VAR_250 ; METHOD_49 ( VAR_251 , VAR_252 , VAR_253 -> TYPE_48 ) ; METHOD_50 ( VAR_254 ) ; if ( TYPE_49 ) <S2SV_StartBug> METHOD_51 ( & TYPE_50 -> VAR_255 ) ; <S2SV_EndBug> METHOD_52 ( & VAR_256 -> VAR_257 ) ; if ( VAR_258 ) { METHOD_53 ( & VAR_259 -> VAR_260 -> VAR_261 ) ; METHOD_54 ( VAR_262 ) ; } METHOD_55 ( ) ; METHOD_56 ( & VAR_263 -> VAR_264 ) ; METHOD_57 ( & VAR_265 -> VAR_266 , & VAR_267 -> VAR_268 ) ; METHOD_58 ( & VAR_269 -> VAR_270 ) ; METHOD_59 ( VAR_271 ) ; METHOD_60 ( VAR_272 , VAR_273 ) ; return VAR_274 ; VAR_275 : if ( TYPE_51 ) <S2SV_StartBug> METHOD_61 ( & TYPE_52 -> VAR_276 ) ; <S2SV_EndBug> METHOD_62 ( & VAR_277 -> VAR_278 ) ; METHOD_63 ( VAR_279 ) ; VAR_280 : METHOD_64 ( VAR_281 ) ; METHOD_65 ( VAR_282 ) ; VAR_283 : if ( ! VAR_284 ) METHOD_66 ( VAR_285 ) ; VAR_286 : if ( VAR_287 ) METHOD_67 ( & VAR_288 -> VAR_289 -> VAR_290 ) ; VAR_291 : METHOD_68 ( ) ; VAR_292 : if ( VAR_293 ) METHOD_69 ( VAR_294 ) ; VAR_295 : METHOD_70 ( VAR_296 ) ; VAR_297 : METHOD_71 ( VAR_298 ) ; return VAR_299 ; }","<S2SV_ModStart> { TYPE_52 = METHOD_72 ( VAR_244 , VAR_282 <S2SV_ModEnd> ) ; if <S2SV_ModStart> VAR_275 ; } if ( ! ( VAR_244 -> VAR_136 & VAR_137 ) ) { if ( TYPE_52 != VAR_282 ) { VAR_299 = - VAR_153 ; goto VAR_275 ; } else { METHOD_73 ( VAR_244 , TYPE_52 ) ; TYPE_51 = 0 ; } } <S2SV_ModStart> ( TYPE_51 ) METHOD_73 ( VAR_244 , TYPE_52 <S2SV_ModEnd> ) ; METHOD_67 <S2SV_ModStart> ( TYPE_51 ) METHOD_73 ( VAR_244 , TYPE_52 <S2SV_ModEnd> ) ; METHOD_67","CWE-362 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; if ( task ) { err = mutex_lock_interruptible ( & task -> signal -> cred_guard_mutex ) ; if ( err ) goto err_cpus ; err = - EACCES ; if ( ! ptrace_may_access ( task , PTRACE_MODE_READ_REALCREDS ) ) goto err_cred ; } if ( flags & PERF_FLAG_PID_CGROUP ) cgroup_fd = pid ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL , cgroup_fd ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cred ; } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - EOPNOTSUPP ; goto err_alloc ; } } pmu = event -> pmu ; if ( attr . use_clockid ) { err = perf_event_set_clock ( event , attr . clockid ) ; if ( err ) goto err_alloc ; } if ( pmu -> task_ctx_nr == perf_sw_context ) event -> event_caps |= PERF_EV_CAP_SOFTWARE ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( ( pmu -> capabilities & PERF_PMU_CAP_EXCLUSIVE ) && group_leader ) { err = - EBUSY ; goto err_context ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( group_leader -> clock != event -> clock ) goto err_context ; if ( move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu ) goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; event_file = NULL ; goto err_context ; } if ( move_group ) { <S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; if ( gctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } <S2SV_StartBug> } else { <S2SV_EndBug> mutex_lock ( & ctx -> mutex ) ; } if ( ctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } if ( ! perf_event_validate_size ( event ) ) { err = - E2BIG ; goto err_locked ; } if ( ! exclusive_event_installable ( event , ctx ) ) { WARN_ON_ONCE ( move_group ) ; err = - EBUSY ; goto err_locked ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { perf_remove_from_context ( group_leader , 0 ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , 0 ) ; put_ctx ( gctx ) ; } synchronize_rcu ( ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_event__state_init ( sibling ) ; perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } perf_event__state_init ( group_leader ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; put_ctx ( gctx ) ; } perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; event -> owner = current ; perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; if ( task ) { mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; put_task_struct ( task ) ; } put_online_cpus ( ) ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_locked : if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; fput ( event_file ) ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : if ( ! event_file ) free_event ( event ) ; err_cred : if ( task ) mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }","<S2SV_ModStart> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if <S2SV_ModStart> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock"
708,"CWE-310 TYPE_0 METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 , TYPE_4 * VAR_3 , TYPE_5 * VAR_4 ) { TYPE_6 VAR_5 ; unsigned TYPE_7 * VAR_6 = VAR_7 ; TYPE_8 VAR_8 = - 1 , VAR_9 ; TYPE_9 VAR_10 , VAR_11 ; if ( ! VAR_12 ) { METHOD_1 ( VAR_13 , VAR_14 ) ; return - 1 ; } <S2SV_StartBug> METHOD_2 ( & VAR_15 ) ; <S2SV_EndBug> if ( ! METHOD_3 ( METHOD_4 ( VAR_16 -> VAR_17 ) , & VAR_18 , & VAR_19 ) ) { METHOD_5 ( VAR_20 , VAR_21 ) ; goto VAR_22 ; } if ( VAR_23 == VAR_24 ) { if ( ! VAR_25 -> VAR_26 || ! VAR_27 -> VAR_28 -> METHOD_6 ) { METHOD_7 ( VAR_29 , VAR_30 ) ; goto VAR_31 ; } VAR_32 = VAR_33 -> VAR_34 -> METHOD_8 ( & VAR_35 , VAR_36 , VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; if ( VAR_41 != 2 ) goto VAR_42 ; VAR_43 = - 1 ; } else { const TYPE_10 * VAR_44 ; VAR_45 = METHOD_9 ( VAR_46 ) ; if ( VAR_47 == VAR_48 ) { METHOD_10 ( VAR_49 , VAR_50 ) ; goto VAR_51 ; } if ( METHOD_11 ( VAR_52 ) != VAR_53 -> VAR_54 -> VAR_55 ) { METHOD_12 ( VAR_56 , VAR_57 ) ; goto VAR_58 ; } if ( ! METHOD_13 ( & VAR_59 , VAR_60 , VAR_61 , VAR_62 , VAR_63 ) ) { METHOD_14 ( VAR_64 , VAR_65 ) ; VAR_66 = 0 ; goto VAR_67 ; } } VAR_68 = METHOD_15 ( VAR_69 , & VAR_70 , VAR_71 ) ; if ( VAR_72 == VAR_73 ) { METHOD_16 ( VAR_74 , VAR_75 ) ; goto VAR_76 ; } VAR_77 = METHOD_17 ( & VAR_78 , VAR_79 , VAR_80 ) ; METHOD_18 ( VAR_81 , ( unsigned TYPE_11 ) VAR_82 ) ; METHOD_19 ( VAR_83 ) ; if ( ! VAR_84 ) { METHOD_20 ( VAR_85 , VAR_86 ) ; goto VAR_87 ; } VAR_88 = - 1 ; if ( METHOD_21 ( & VAR_89 , VAR_90 -> VAR_91 , ( TYPE_12 ) VAR_92 -> VAR_93 ) <= 0 ) { METHOD_22 ( VAR_94 , VAR_95 ) ; VAR_96 = 0 ; goto VAR_97 ; } VAR_98 = 1 ; VAR_99 : METHOD_23 ( & VAR_100 ) ; return ( VAR_101 ) ; }","<S2SV_ModStart> 1 ; } if ( VAR_92 -> VAR_61 == VAR_102 && VAR_92 -> VAR_103 & 0x7 ) { METHOD_22 ( VAR_104 , VAR_105 ) ; return - 1 ; }","CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }","<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }"
709,"CWE-399 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { TYPE_1 VAR_1 , VAR_2 ; unsigned TYPE_2 VAR_3 ; struct STRUCT_OR_UNION_1 VAR_4 ; <S2SV_StartBug> METHOD_1 ( VAR_5 , METHOD_2 ( ) & ~ VAR_6 ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_3 ( VAR_7 , METHOD_4 ( ) ) ; <S2SV_EndBug> METHOD_5 ( VAR_8 , METHOD_6 ( ) ) ; TYPE_3 ( VAR_9 , VAR_10 ) ; TYPE_4 TYPE_5 TYPE_6 ( TYPE_7 , 0 ) ; TYPE_8 ( VAR_11 , 0 ) ; else TYPE_9 ( TYPE_10 , TYPE_11 ) ; TYPE_12 ( VAR_12 , TYPE_13 ) ; TYPE_14 ( VAR_13 , TYPE_15 ) ; TYPE_16 ( VAR_14 , VAR_15 * 8 ) ; METHOD_7 ( & VAR_16 ) ; METHOD_8 ( VAR_17 , VAR_18 . VAR_19 ) ; VAR_20 -> VAR_21 = VAR_22 . VAR_23 ; METHOD_9 ( VAR_24 , VAR_25 ) ; METHOD_10 ( VAR_26 , VAR_27 , VAR_28 ) ; METHOD_11 ( VAR_29 , VAR_30 ) ; METHOD_12 ( VAR_31 , VAR_32 ) ; METHOD_13 ( VAR_33 , VAR_34 ) ; if ( VAR_35 . VAR_36 & VAR_37 ) { METHOD_14 ( VAR_38 , VAR_39 , VAR_40 ) ; METHOD_15 ( VAR_41 , VAR_42 | ( ( TYPE_17 ) VAR_43 << 32 ) ) ; } }","<S2SV_ModStart> STRUCT_OR_UNION_1 VAR_22 ; unsigned TYPE_2 VAR_44 ; <S2SV_ModStart> ; METHOD_13 ( VAR_8 , METHOD_6 ( ) ) ; VAR_44 = METHOD_4 ( ) ; METHOD_13 ( VAR_7 , VAR_44 ) ; VAR_20 -> VAR_45 . VAR_46 = VAR_44 <S2SV_ModEnd> ; TYPE_16 (","CWE-399 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ;  ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ;  else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ;   vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }","<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 ("
710,"CWE-476 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * STRUCT_OR_UNION_3 , struct STRUCT_OR_UNION_4 * VAR_0 ) { struct STRUCT_OR_UNION_5 * VAR_1 ; struct STRUCT_OR_UNION_6 * VAR_2 = STRUCT_OR_UNION_7 -> VAR_3 ; struct STRUCT_OR_UNION_8 * VAR_4 ; TYPE_1 VAR_5 ; if ( VAR_6 -> VAR_7 ) return - VAR_8 ; VAR_9 = METHOD_1 ( STRUCT_OR_UNION_9 , VAR_10 -> VAR_11 ) ; if ( VAR_12 ) { if ( VAR_13 -> VAR_14 & VAR_15 ) return - VAR_16 ; if ( ( VAR_17 -> VAR_18 & VAR_19 ) && VAR_20 -> VAR_21 == & VAR_22 ) VAR_23 = METHOD_2 ( VAR_24 ) ; else if ( ( VAR_25 -> VAR_26 & VAR_27 ) && VAR_28 -> VAR_29 == & VAR_30 ) VAR_31 = METHOD_3 ( VAR_32 ) ; else return - VAR_33 ; if ( ! ! ( VAR_34 -> VAR_35 & VAR_36 ) != ! ! ( VAR_37 -> VAR_38 & VAR_39 ) ) return - VAR_40 ; if ( METHOD_4 ( VAR_41 ) ) return - VAR_42 ; VAR_43 = METHOD_5 ( VAR_44 -> VAR_45 ) ; if ( VAR_46 < 0 ) return VAR_47 ; VAR_48 = METHOD_6 ( VAR_49 , STRUCT_OR_UNION_10 , VAR_50 -> VAR_51 & VAR_52 ) ; if ( VAR_53 < 0 ) return VAR_54 ; if ( VAR_55 -> VAR_56 & VAR_57 && ( VAR_58 -> VAR_59 + VAR_60 -> VAR_61 > 1 ) ) { return 0 ; } } else { TYPE_2 * VAR_62 ; unsigned TYPE_3 VAR_63 = 0 ; TYPE_4 VAR_64 = VAR_65 -> VAR_66 & VAR_67 ? VAR_68 : 1 ; if ( ! METHOD_7 ( STRUCT_OR_UNION_11 -> VAR_69 , VAR_70 ) ) return - VAR_71 ; VAR_72 = METHOD_8 ( ) ; if ( VAR_73 < 0 ) return VAR_74 ; if ( VAR_75 -> VAR_76 & VAR_77 ) { VAR_78 |= VAR_79 ; VAR_80 = ""tun%d"" ; } else if ( VAR_81 -> VAR_82 & VAR_83 ) { VAR_84 |= VAR_85 ; VAR_86 = ""tap%d"" ; } else return - VAR_87 ; if ( * VAR_88 -> VAR_89 ) VAR_90 = VAR_91 -> VAR_92 ; VAR_93 = METHOD_9 ( sizeof ( struct STRUCT_OR_UNION_12 ) , VAR_94 , VAR_95 , VAR_96 , VAR_97 , VAR_98 ) ; if ( ! VAR_99 ) return - VAR_100 ; <S2SV_StartBug> METHOD_10 ( VAR_101 , STRUCT_OR_UNION_13 ) ; <S2SV_EndBug> VAR_102 -> VAR_103 = & VAR_104 ; VAR_105 -> VAR_106 = VAR_107 -> VAR_108 ; VAR_109 -> VAR_110 [ 0 ] = & VAR_111 ; VAR_112 = METHOD_11 ( VAR_113 ) ; VAR_114 -> VAR_115 = VAR_116 ; VAR_117 -> VAR_118 = VAR_119 ; VAR_120 -> VAR_121 . VAR_122 = 0 ; VAR_123 -> VAR_124 = sizeof ( struct STRUCT_OR_UNION_14 ) ; VAR_125 -> VAR_126 = VAR_127 ; VAR_128 -> VAR_129 = VAR_130 ; VAR_131 -> VAR_132 = VAR_133 -> VAR_134 . VAR_135 -> VAR_136 ; VAR_137 -> VAR_138 = 0 ; VAR_139 -> VAR_140 = netdev_alloc_pcpu_stats ( struct STRUCT_OR_UNION_15 ) ; if ( ! VAR_141 -> VAR_142 ) { VAR_143 = - VAR_144 ; goto VAR_145 ; } METHOD_12 ( & VAR_146 -> VAR_147 ) ; VAR_148 = METHOD_13 ( & VAR_149 -> VAR_150 ) ; if ( VAR_151 < 0 ) goto VAR_152 ; METHOD_14 ( VAR_153 ) ; METHOD_15 ( VAR_154 ) ; VAR_155 -> VAR_156 = VAR_157 | VAR_158 | VAR_159 | VAR_160 | VAR_161 ; VAR_162 -> VAR_163 = VAR_164 -> VAR_165 | VAR_166 ; VAR_167 -> VAR_168 = VAR_169 -> VAR_170 & ~ ( VAR_171 | VAR_172 ) ; METHOD_16 ( & VAR_173 -> VAR_174 ) ; VAR_175 = METHOD_17 ( VAR_176 , STRUCT_OR_UNION_16 , VAR_177 ) ; if ( VAR_178 < 0 ) goto VAR_179 ; VAR_180 = METHOD_18 ( VAR_181 -> VAR_182 ) ; if ( VAR_183 < 0 ) goto VAR_184 ; } METHOD_19 ( VAR_185 -> VAR_186 ) ; METHOD_20 ( VAR_187 , VAR_188 , ""tun_set_iff\\n"" ) ; VAR_189 -> VAR_190 = ( VAR_191 -> VAR_192 & ~ VAR_193 ) | ( VAR_194 -> VAR_195 & VAR_196 ) ; if ( METHOD_21 ( VAR_197 -> VAR_198 ) ) METHOD_22 ( VAR_199 -> VAR_200 ) ; METHOD_23 ( VAR_201 -> VAR_202 , VAR_203 -> VAR_204 -> VAR_205 ) ; return 0 ; VAR_206 : METHOD_24 ( VAR_207 ) ; goto VAR_208 ; VAR_209 : METHOD_25 ( VAR_210 ) ; METHOD_26 ( VAR_211 -> VAR_212 ) ; VAR_213 : METHOD_27 ( VAR_214 -> VAR_215 ) ; VAR_216 : METHOD_28 ( VAR_217 ) ; return VAR_218 ; }","<S2SV_ModStart> - VAR_144 ; VAR_218 = METHOD_29 ( STRUCT_OR_UNION_13 , VAR_217 , VAR_205 ) ; if ( VAR_218 ) goto VAR_216 ;","CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = ""tun%d"" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = ""tap%d"" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , ""tun_set_iff\\n"" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }","<S2SV_ModStart> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;"
711,"CWE-125 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , const TYPE_3 * VAR_2 , TYPE_4 VAR_3 ) { if ( ( VAR_4 & 0xff00 ) == 0x7e00 ) { METHOD_1 ( VAR_5 , VAR_6 - 1 , VAR_7 ) ; return ; } switch ( VAR_8 ) { case VAR_9 : case VAR_10 : case VAR_11 : case VAR_12 : case VAR_13 : case VAR_14 : case VAR_15 : METHOD_2 ( VAR_16 , VAR_17 , VAR_18 , VAR_19 ) ; break ; case VAR_20 : METHOD_3 ( VAR_21 , VAR_22 , VAR_23 ) ; break ; case VAR_24 : METHOD_4 ( VAR_25 , VAR_26 , VAR_27 ) ; break ; case VAR_28 : METHOD_5 ( VAR_29 , VAR_30 , VAR_31 ) ; break ; case VAR_32 : METHOD_6 ( VAR_33 , VAR_34 , VAR_35 ) ; break ; case VAR_36 : case VAR_37 : case VAR_38 : METHOD_7 ( VAR_39 , VAR_40 , VAR_41 ) ; break ; case VAR_42 : case VAR_43 : METHOD_8 ( VAR_44 , VAR_45 , VAR_46 ) ; break ; case VAR_47 : case VAR_48 : METHOD_9 ( VAR_49 , VAR_50 , VAR_51 ) ; break ; case VAR_52 : <S2SV_StartBug> METHOD_10 ( VAR_53 , VAR_54 , VAR_55 , VAR_56 ) ; <S2SV_EndBug> break ; case VAR_57 : case VAR_58 : METHOD_11 ( VAR_59 , VAR_60 , VAR_61 ) ; break ; case VAR_62 : METHOD_12 ( ( VAR_63 , ""compressed<S2SV_blank>PPP<S2SV_blank>data"" ) ) ; break ; default : METHOD_13 ( ( VAR_64 , ""%s<S2SV_blank>"" , METHOD_14 ( VAR_65 , ""unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , VAR_66 ) ) ) ; METHOD_15 ( VAR_67 , VAR_68 , ""\\n\\t"" , VAR_69 ) ; break ; } }","<S2SV_ModStart> VAR_68 , VAR_69 <S2SV_ModEnd> ) ; break","CWE-125 static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , ""compressed<S2SV_blank>PPP<S2SV_blank>data"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( ppptype2str , ""unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; break ; } }","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break"
712,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 * VAR_2 = ( TYPE_4 * ) VAR_3 ; TYPE_5 * VAR_4 = METHOD_1 ( TYPE_6 , VAR_5 , VAR_6 -> VAR_7 . VAR_8 ) ; TYPE_7 VAR_9 ; if ( VAR_10 -> VAR_11 . VAR_12 != VAR_13 ) { VAR_14 -> VAR_15 . VAR_16 = VAR_17 ; METHOD_2 ( VAR_18 -> VAR_19 , & VAR_20 -> VAR_21 ) ; } if ( VAR_22 ) { if ( METHOD_3 ( VAR_23 , - VAR_24 , VAR_25 ) ) { return ; } } <S2SV_StartBug> METHOD_4 ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , VAR_26 -> VAR_27 . VAR_28 , VAR_29 -> VAR_30 . VAR_31 ) ; <S2SV_EndBug> <S2SV_StartBug> VAR_32 = VAR_33 -> VAR_34 . VAR_35 / 512 ; <S2SV_EndBug> VAR_36 -> VAR_37 += VAR_38 ; VAR_39 -> VAR_40 -= VAR_41 ; <S2SV_StartBug> METHOD_5 ( & VAR_42 -> VAR_43 , VAR_44 -> VAR_45 . VAR_46 ) ; <S2SV_EndBug> }","<S2SV_ModStart> , VAR_44 -> VAR_47 . VAR_48 <S2SV_ModEnd> ) ; VAR_41 <S2SV_ModStart> = VAR_44 -> VAR_47 . VAR_48 <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , VAR_44 -> VAR_47 . VAR_48 <S2SV_ModEnd> ) ; }","CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }","<S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; n <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; }"
713,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * const VAR_1 = & VAR_2 -> VAR_3 ; TYPE_3 * const VAR_4 = & VAR_5 -> VAR_6 ; TYPE_4 VAR_7 ; if ( ( VAR_8 -> VAR_9 == 0 || <S2SV_StartBug> ( VAR_10 -> VAR_11 & VAR_12 ) || <S2SV_EndBug> VAR_13 -> VAR_14 == 0 || <S2SV_StartBug> ( VAR_15 -> VAR_16 . VAR_17 && METHOD_1 ( VAR_18 ) ) ) ) { <S2SV_EndBug> VAR_19 -> VAR_20 = VAR_21 ; VAR_22 -> VAR_23 = VAR_24 -> VAR_25 != 0 && VAR_26 -> VAR_27 == 0 ; <S2SV_StartBug> VAR_28 -> VAR_29 = VAR_30 -> VAR_31 ; <S2SV_EndBug> VAR_32 -> VAR_33 = VAR_34 ; <S2SV_StartBug> VAR_35 -> VAR_36 = 0 ; <S2SV_EndBug> VAR_37 = METHOD_2 ( VAR_38 ) ; } else { VAR_39 -> VAR_40 = VAR_41 ; <S2SV_StartBug> VAR_42 = METHOD_3 ( VAR_43 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> METHOD_4 ( VAR_44 , VAR_45 ) ; <S2SV_StartBug> VAR_46 -> VAR_47 = VAR_48 ; <S2SV_EndBug> VAR_49 -> VAR_50 = VAR_51 ; }",<S2SV_ModStart> 0 || ( VAR_44 <S2SV_ModEnd> -> VAR_11 & <S2SV_ModStart> . VAR_17 && 0 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> = VAR_44 -> VAR_16 . VAR_52 <S2SV_ModEnd> ; VAR_49 -> <S2SV_ModStart> VAR_36 = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> = VAR_41 ; } if ( VAR_49 -> VAR_47 == 0 ) { if ( VAR_44 -> VAR_16 . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( VAR_44 ) ; else VAR_49 -> VAR_50 = ( VAR_49 -> min_gf_interval + VAR_49 -> max_gf_interval ) / 2 ; VAR_49 -> VAR_47 = VAR_49 -> VAR_50 ; if ( VAR_49 -> VAR_47 > VAR_49 -> VAR_29 ) VAR_49 -> VAR_47 = VAR_49 -> VAR_29 ; VAR_44 -> refresh_golden_frame = 1 ; VAR_49 -> gfu_boost = DEFAULT_GF_BOOST ; } if ( VAR_44 -> VAR_16 . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( VAR_44 ) ; if ( VAR_39 -> VAR_40 == VAR_21 ) VAR_45 = METHOD_2 ( VAR_44 ) ; else VAR_45 = <S2SV_ModEnd> METHOD_3 ( VAR_44 <S2SV_ModStart> VAR_44 ) ; <S2SV_ModEnd> METHOD_4 ( VAR_44 <S2SV_ModStart> VAR_45 ) ; if ( VAR_44 -> VAR_16 . VAR_53 == VAR_54 ) VAR_44 -> VAR_55 = METHOD_5 ( VAR_44 ) ; else VAR_44 -> VAR_55 = 0 <S2SV_ModEnd> ; } <S2SV_null>,"CWE-119 void vp9_rc_get_one_pass_cbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ( cm -> current_video_frame == 0 || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> rc -> frames_to_key == 0 || <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> rc -> kf_boost = DEFAULT_KF_BOOST ; <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } else { cm -> frame_type = INTER_FRAME ; <S2SV_StartBug> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> vp9_rc_set_frame_target ( cpi , target ) ; <S2SV_StartBug> rc -> frames_till_gf_update_due = INT_MAX ; <S2SV_EndBug> rc -> baseline_gf_interval = INT_MAX ; }",<S2SV_ModStart> 0 || ( cpi <S2SV_ModEnd> -> frame_flags & <S2SV_ModStart> . auto_key && 0 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> = cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc -> <S2SV_ModStart> source_alt_ref_active = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <S2SV_ModEnd> calc_pframe_target_size_one_pass_cbr ( cpi <S2SV_ModStart> cpi ) ; <S2SV_ModEnd> vp9_rc_set_frame_target ( cpi <S2SV_ModStart> target ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> ; } <S2SV_null>
714,"CWE-476 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 ) { TYPE_2 * VAR_1 = METHOD_1 ( VAR_2 ) ; VAR_3 * VAR_4 , * VAR_5 ; TYPE_3 VAR_6 ; <S2SV_StartBug> TYPE_4 * VAR_7 , * VAR_8 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_5 VAR_9 , VAR_10 ; <S2SV_EndBug> TYPE_6 VAR_11 = VAR_12 ; if ( VAR_13 -> VAR_14 ) return VAR_15 -> VAR_16 ; if ( ! VAR_17 -> VAR_18 . VAR_19 ) METHOD_2 ( VAR_20 , VAR_21 ) ; if ( VAR_22 -> VAR_23 && ! VAR_24 -> VAR_25 ) return VAR_26 ; VAR_27 = METHOD_3 ( VAR_28 -> VAR_29 ) ; if ( ! VAR_30 ) { if ( METHOD_4 ( VAR_31 -> VAR_32 ) ) { if ( ! VAR_33 -> VAR_34 ) { if ( VAR_35 -> VAR_36 ) METHOD_5 ( VAR_37 -> VAR_38 ) ; if ( VAR_39 -> VAR_40 ) METHOD_6 ( VAR_41 -> VAR_42 ) ; VAR_43 -> VAR_44 = VAR_45 ; return VAR_46 ; } } else { return VAR_47 ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> VAR_48 = ( TYPE_7 * ) METHOD_7 ( VAR_49 , & VAR_50 ) ; <S2SV_EndBug> if ( VAR_51 -> VAR_52 && VAR_53 ) { VAR_54 = METHOD_8 ( VAR_55 ) ; } VAR_56 = VAR_57 -> VAR_58 ; if ( VAR_59 && ! VAR_60 -> VAR_61 ) { if ( VAR_62 -> VAR_63 + VAR_64 > VAR_65 -> VAR_66 ) { VAR_67 -> VAR_68 = VAR_69 -> VAR_70 + VAR_71 ; VAR_72 -> VAR_73 = METHOD_9 ( VAR_74 -> VAR_75 , VAR_76 -> VAR_77 ) ; } METHOD_10 ( VAR_78 -> VAR_79 + VAR_80 -> VAR_81 , VAR_82 , VAR_83 ) ; VAR_84 -> VAR_85 += VAR_86 ; } if ( ! VAR_87 -> VAR_88 ) VAR_89 -> VAR_90 = METHOD_11 ( VAR_91 -> VAR_92 , VAR_93 -> VAR_94 , VAR_95 ) ; else METHOD_12 ( VAR_96 -> VAR_97 , VAR_98 -> VAR_99 , VAR_100 -> VAR_101 ) ; if ( VAR_102 -> VAR_103 ) { METHOD_13 ( VAR_104 -> VAR_105 , VAR_106 -> VAR_107 - 1 ) ; VAR_108 -> VAR_109 = 0 ; } if ( VAR_110 == VAR_111 ) VAR_112 = 0 ; while ( 1 ) { VAR_113 = ( TYPE_8 ) METHOD_14 ( VAR_114 -> VAR_115 ) ; TYPE_9 VAR_116 [ 4096 ] ; TYPE_10 VAR_117 = 4096 ; if ( ! METHOD_15 ( VAR_118 -> VAR_119 , & VAR_120 -> VAR_121 , & VAR_122 , VAR_123 , VAR_124 ) ) break ; if ( VAR_125 -> VAR_126 ) { TYPE_11 VAR_127 = ( TYPE_12 ) ( VAR_128 -> VAR_129 * VAR_130 [ VAR_131 -> VAR_132 ] ) ; if ( VAR_133 -> VAR_134 + VAR_135 -> VAR_136 >= VAR_137 ) { VAR_138 -> VAR_139 = VAR_140 ; } } METHOD_16 ( VAR_141 , VAR_142 ) ; if ( ! VAR_143 -> VAR_144 ) { VAR_145 -> VAR_146 = VAR_147 + 1 ; return VAR_148 ; } if ( ! VAR_149 -> VAR_150 ) { TYPE_13 VAR_151 = VAR_152 ; VAR_153 = METHOD_17 ( VAR_154 -> VAR_155 , VAR_156 , & VAR_157 ) ; if ( VAR_158 -> VAR_159 ) METHOD_18 ( VAR_160 -> VAR_161 , VAR_162 ) ; METHOD_19 ( VAR_163 , VAR_164 , VAR_165 ) ; METHOD_20 ( VAR_166 , VAR_167 -> VAR_168 ) ; METHOD_21 ( VAR_169 , VAR_170 -> VAR_171 ) ; METHOD_22 ( VAR_172 , VAR_173 , VAR_174 ) ; if ( VAR_175 -> VAR_176 . VAR_177 == VAR_178 ) { if ( VAR_179 && ( VAR_180 [ 0 ] & 0x80 ) && ! VAR_181 -> VAR_182 ) { VAR_183 = VAR_184 ; VAR_185 -> VAR_186 = VAR_187 ; } else { VAR_188 = VAR_189 ; VAR_190 -> VAR_191 = VAR_192 ; } } METHOD_23 ( VAR_193 , VAR_194 ) ; METHOD_24 ( VAR_195 ) ; } METHOD_25 ( VAR_196 ) ; if ( VAR_197 ) { VAR_198 = ( TYPE_14 ) METHOD_26 ( VAR_199 -> VAR_200 ) ; if ( VAR_201 <= VAR_202 ) { VAR_203 = 0 ; if ( VAR_204 -> VAR_205 ) METHOD_27 ( VAR_206 -> VAR_207 ) ; VAR_208 -> VAR_209 = VAR_210 ; if ( VAR_211 ) METHOD_28 ( & VAR_212 -> VAR_213 ) ; } } } if ( VAR_214 ) { VAR_215 = ( TYPE_15 ) METHOD_29 ( VAR_216 -> VAR_217 ) ; METHOD_30 ( VAR_218 -> VAR_219 >= VAR_220 ) ; METHOD_31 ( VAR_221 -> VAR_222 , VAR_223 -> VAR_224 + VAR_225 , VAR_226 -> VAR_227 - VAR_228 ) ; VAR_229 -> VAR_230 -= VAR_231 ; METHOD_32 ( VAR_232 -> VAR_233 ) ; METHOD_33 ( ! VAR_234 -> VAR_235 ) ; } else { VAR_236 -> VAR_237 = 0 ; return METHOD_34 ( VAR_238 ) ; } return VAR_239 ; }",<S2SV_ModStart> TYPE_9 * VAR_82 = VAR_124 <S2SV_ModStart> ; TYPE_15 VAR_86 = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> VAR_86 ) ; },"CWE-476 GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size , data , pck_size ) ; ctx -> latm_buffer_size += pck_size ; } if ( ! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer , ctx -> latm_buffer_size , GF_BITSTREAM_READ ) ; else gf_bs_reassign_buffer ( ctx -> bs , ctx -> latm_buffer , ctx -> latm_buffer_size ) ; if ( ctx -> resume_from ) { gf_bs_seek ( ctx -> bs , ctx -> resume_from - 1 ) ; ctx -> resume_from = 0 ; } if ( cts == GF_FILTER_NO_TS ) prev_pck_size = 0 ; while ( 1 ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; u8 latm_buffer [ 4096 ] ; u32 latm_frame_size = 4096 ; if ( ! latm_dmx_sync_frame_bs ( ctx -> bs , & ctx -> acfg , & latm_frame_size , latm_buffer , NULL ) ) break ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } latm_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = pos + 1 ; return GF_OK ; } if ( ! ctx -> in_seek ) { GF_FilterSAPType sap = GF_FILTER_SAP_1 ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , latm_frame_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , latm_buffer , latm_frame_size ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> acfg . base_object_type == GF_CODECID_USAC ) { if ( latm_frame_size && ( output [ 0 ] & 0x80 ) && ! ctx -> prev_sap ) { sap = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; } else { sap = GF_FILTER_SAP_NONE ; ctx -> prev_sap = GF_FALSE ; } } gf_filter_pck_set_sap ( dst_pck , sap ) ; gf_filter_pck_send ( dst_pck ) ; } latm_dmx_update_cts ( ctx ) ; if ( prev_pck_size ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; if ( prev_pck_size <= pos ) { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } } if ( pck ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; assert ( ctx -> latm_buffer_size >= pos ) ; memmove ( ctx -> latm_buffer , ctx -> latm_buffer + pos , ctx -> latm_buffer_size - pos ) ; ctx -> latm_buffer_size -= pos ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; assert ( ! ctx -> resume_from ) ; } else { ctx -> latm_buffer_size = 0 ; return latm_dmx_process ( filter ) ; } return GF_OK ; }",<S2SV_ModStart> u8 * data = NULL <S2SV_ModStart> ; u32 pck_size = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> pck_size ) ; }
715,"CWE-119 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 , const struct STRUCT_OR_UNION_2 * VAR_3 ) { <S2SV_StartBug> if ( VAR_4 -> VAR_5 ) <S2SV_EndBug> return - VAR_6 ; if ( VAR_7 < METHOD_1 ( & VAR_8 -> VAR_9 ) ) return - VAR_10 ; VAR_11 -> VAR_12 = VAR_13 ; VAR_14 -> VAR_15 = METHOD_2 ( & VAR_16 -> VAR_17 ) ; VAR_18 -> VAR_19 = 0 ; VAR_20 -> VAR_21 = METHOD_3 ( & VAR_22 -> VAR_23 ) ; VAR_24 -> VAR_25 = ( TYPE_2 * ) VAR_26 + sizeof ( * VAR_27 ) ; VAR_28 -> VAR_29 = 0 ; VAR_30 -> VAR_31 = & VAR_32 -> VAR_33 ; VAR_34 -> VAR_35 ++ ; VAR_36 -> VAR_37 = VAR_38 ; VAR_39 -> VAR_40 = & VAR_41 ; VAR_42 -> VAR_43 = 1 ; if ( VAR_44 -> VAR_45 & ( 1 << VAR_46 ) ) { while ( METHOD_4 ( VAR_47 -> VAR_48 ) & ( 1 << VAR_49 ) ) { VAR_50 -> VAR_51 += sizeof ( VAR_52 ) ; if ( ( unsigned TYPE_3 ) VAR_53 -> VAR_54 - <S2SV_StartBug> ( unsigned TYPE_4 ) VAR_55 -> VAR_56 > <S2SV_EndBug> ( unsigned TYPE_5 ) VAR_57 -> VAR_58 ) return - VAR_59 ; } VAR_60 -> VAR_61 += sizeof ( VAR_62 ) ; } VAR_63 -> VAR_64 = VAR_65 -> VAR_66 ; return 0 ; }",<S2SV_ModStart> { if ( VAR_7 < sizeof ( struct STRUCT_OR_UNION_1 ) ) return - VAR_59 ; if ( <S2SV_ModStart> VAR_65 -> VAR_56 + sizeof ( VAR_62 ),"CWE-119 int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }",<S2SV_ModStart> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> iterator -> _rtheader + sizeof ( uint32_t )
716,"CWE-416 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , TYPE_1 VAR_2 ) { struct STRUCT_OR_UNION_2 * VAR_3 = ( struct STRUCT_OR_UNION_3 * ) VAR_4 ; struct STRUCT_OR_UNION_4 * VAR_5 = METHOD_1 ( VAR_6 ) ; struct STRUCT_OR_UNION_5 * VAR_7 = METHOD_2 ( VAR_8 ) ; struct STRUCT_OR_UNION_6 * VAR_9 , * VAR_10 , VAR_11 ; struct STRUCT_OR_UNION_7 * VAR_12 ; struct STRUCT_OR_UNION_8 VAR_13 ; struct STRUCT_OR_UNION_9 * VAR_14 = VAR_15 ; struct STRUCT_OR_UNION_10 * VAR_16 ; TYPE_2 VAR_17 ; TYPE_3 VAR_18 ; if ( VAR_19 -> VAR_20 == VAR_21 ) { if ( METHOD_3 ( VAR_22 ) ) return - VAR_23 ; VAR_24 = METHOD_4 ( VAR_25 , VAR_26 , VAR_27 ) ; goto VAR_28 ; } if ( VAR_29 < VAR_30 ) return - VAR_31 ; if ( VAR_32 -> VAR_33 != VAR_34 ) return - VAR_35 ; METHOD_5 ( & VAR_36 , 0 , sizeof ( VAR_37 ) ) ; if ( VAR_38 -> VAR_39 ) { VAR_40 . VAR_41 = VAR_42 -> VAR_43 & VAR_44 ; if ( VAR_45 . VAR_46 & VAR_47 ) { VAR_48 = METHOD_6 ( VAR_49 , VAR_50 . VAR_51 ) ; if ( ! VAR_52 ) return - VAR_53 ; } } VAR_54 = METHOD_7 ( & VAR_55 -> VAR_56 ) ; if ( VAR_57 == VAR_58 ) { VAR_59 -> VAR_60 . VAR_61 [ 15 ] = 0x01 ; } VAR_62 = & VAR_63 -> VAR_64 ; if ( VAR_65 == VAR_66 ) { struct STRUCT_OR_UNION_11 VAR_67 ; if ( METHOD_8 ( VAR_68 ) ) { VAR_69 = - VAR_70 ; goto VAR_71 ; } VAR_72 . VAR_73 = VAR_74 ; VAR_75 . VAR_76 . VAR_77 = VAR_78 -> VAR_79 [ 3 ] ; VAR_80 . VAR_81 = VAR_82 -> VAR_83 ; VAR_84 = METHOD_9 ( VAR_85 , ( struct STRUCT_OR_UNION_12 * ) & VAR_86 , sizeof ( VAR_87 ) ) ; VAR_88 : if ( VAR_89 ) goto VAR_90 ; METHOD_10 ( VAR_91 -> VAR_92 , & VAR_93 -> VAR_94 ) ; if ( METHOD_11 ( & VAR_95 -> VAR_96 ) || METHOD_12 ( & VAR_97 -> VAR_98 ) ) METHOD_13 ( VAR_99 -> VAR_100 , & VAR_101 -> VAR_102 ) ; if ( METHOD_14 ( & VAR_103 -> VAR_104 ) || METHOD_15 ( & VAR_105 -> VAR_106 ) ) { METHOD_16 ( VAR_107 -> VAR_108 , & VAR_109 -> VAR_110 ) ; if ( VAR_111 -> VAR_112 -> METHOD_17 ) VAR_113 -> VAR_114 -> METHOD_18 ( VAR_115 ) ; } goto VAR_116 ; } if ( METHOD_19 ( VAR_117 ) ) { if ( VAR_118 >= sizeof ( struct STRUCT_OR_UNION_13 ) && VAR_119 -> VAR_120 ) { if ( VAR_121 -> VAR_122 && VAR_123 -> VAR_124 != VAR_125 -> VAR_126 ) { VAR_127 = - VAR_128 ; goto VAR_129 ; } VAR_130 -> VAR_131 = VAR_132 -> VAR_133 ; } if ( ! VAR_134 -> VAR_135 && ( VAR_136 & VAR_137 ) ) VAR_138 -> VAR_139 = VAR_140 -> VAR_141 ; if ( ! VAR_142 -> VAR_143 ) { VAR_144 = - VAR_145 ; goto VAR_146 ; } } VAR_147 -> VAR_148 = * VAR_149 ; VAR_150 -> VAR_151 = VAR_152 . VAR_153 ; VAR_154 -> VAR_155 = VAR_156 -> VAR_157 ; VAR_158 . VAR_159 = VAR_160 -> VAR_161 ; VAR_162 . VAR_163 = VAR_164 -> VAR_165 ; VAR_166 . VAR_167 = VAR_168 -> VAR_169 ; VAR_170 . VAR_171 = VAR_172 -> VAR_173 ; VAR_174 . VAR_175 = VAR_176 -> VAR_177 ; VAR_178 . VAR_179 = VAR_180 -> VAR_181 ; VAR_182 . VAR_183 = VAR_184 -> VAR_185 ; if ( ! VAR_186 . VAR_187 && ( VAR_188 & VAR_189 ) ) VAR_190 . VAR_191 = VAR_192 -> VAR_193 ; METHOD_20 ( VAR_194 , METHOD_21 ( & VAR_195 ) ) ; <S2SV_StartBug> VAR_196 = VAR_197 ? VAR_198 -> VAR_199 : VAR_200 -> VAR_201 ; <S2SV_EndBug> <S2SV_StartBug> VAR_202 = METHOD_22 ( & VAR_203 , VAR_204 , & VAR_205 ) ; <S2SV_EndBug> VAR_206 = METHOD_23 ( VAR_207 , & VAR_208 , VAR_209 ) ; VAR_210 = 0 ; if ( METHOD_24 ( VAR_211 ) ) { VAR_212 = METHOD_25 ( VAR_213 ) ; goto VAR_214 ; } if ( METHOD_26 ( & VAR_215 -> VAR_216 ) ) VAR_217 -> VAR_218 = VAR_219 . VAR_220 ; if ( METHOD_27 ( & VAR_221 -> VAR_222 ) ) { VAR_223 -> VAR_224 = VAR_225 . VAR_226 ; VAR_227 -> VAR_228 = VAR_229 ; if ( VAR_230 -> VAR_231 -> METHOD_28 ) VAR_232 -> VAR_233 -> METHOD_29 ( VAR_234 ) ; } ip6_dst_store ( VAR_235 , VAR_236 , TYPE_4 ( & VAR_237 . VAR_238 , & VAR_239 -> VAR_240 ) ? & VAR_241 -> VAR_242 : VAR_243 , VAR_244 TYPE_5 TYPE_6 ( & VAR_245 . VAR_246 , & VAR_247 -> VAR_248 ) ? & VAR_249 -> VAR_250 : VAR_251 ) ; VAR_252 -> VAR_253 = VAR_254 ; METHOD_30 ( VAR_255 ) ; VAR_256 : METHOD_31 ( VAR_257 ) ; return VAR_258 ; }","<S2SV_ModStart> ) ) ; METHOD_32 ( ) ; <S2SV_ModStart> -> VAR_204 : METHOD_33 ( <S2SV_ModStart> VAR_249 -> VAR_204 ) <S2SV_ModStart> , & VAR_205 ) ; METHOD_34 (","CWE-416 static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ; goto out ; } sin . sin_family = AF_INET ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; sin . sin_port = usin -> sin6_port ; err = __ip4_datagram_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; ipv4_connected : if ( err ) goto out ; ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; if ( ipv6_addr_any ( & np -> saddr ) || ipv6_mapped_addr_any ( & np -> saddr ) ) ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , & sk -> sk_v6_rcv_saddr ) ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } goto out ; } if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { err = - EINVAL ; goto out ; } sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) sk -> sk_bound_dev_if = np -> mcast_oif ; if ( ! sk -> sk_bound_dev_if ) { err = - EINVAL ; goto out ; } } sk -> sk_v6_daddr = * daddr ; np -> flow_label = fl6 . flowlabel ; inet -> inet_dport = usin -> sin6_port ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) fl6 . flowi6_oif = np -> mcast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; err = 0 ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( ipv6_addr_any ( & np -> saddr ) ) np -> saddr = fl6 . saddr ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { sk -> sk_v6_rcv_saddr = fl6 . saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL ,  ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr :   NULL ) ; sk -> sk_state = TCP_ESTABLISHED ; sk_set_txhash ( sk ) ; out : fl6_sock_release ( flowlabel ) ; return err ; }","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> opt : rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock ("
717,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , struct STRUCT_OR_UNION_0 * VAR_2 , TYPE_3 * VAR_3 , TYPE_4 * VAR_4 , TYPE_5 * * VAR_5 ) { <S2SV_StartBug> TYPE_6 VAR_6 ; <S2SV_EndBug> TYPE_7 VAR_7 [ VAR_8 ] ; if ( METHOD_1 ( VAR_9 -> VAR_10 , VAR_11 , VAR_12 , VAR_13 ) == - 1 ) return VAR_14 ; if ( METHOD_2 ( VAR_15 , VAR_16 , VAR_17 -> VAR_18 ) == VAR_19 ) { * VAR_20 = METHOD_3 ( VAR_21 -> VAR_22 , VAR_23 ) ; if ( * VAR_24 == 0 ) { * VAR_25 = VAR_26 ; } return VAR_27 ; } <S2SV_StartBug> VAR_28 = METHOD_4 ( VAR_29 , VAR_30 , VAR_31 , VAR_32 ) ; <S2SV_EndBug> if ( VAR_33 == - 1 ) return VAR_34 ; <S2SV_StartBug> return METHOD_5 ( VAR_35 -> VAR_36 , VAR_37 , VAR_38 , VAR_39 , VAR_40 , <S2SV_EndBug> VAR_41 ) ; }","<S2SV_ModStart> VAR_41 ) { <S2SV_ModEnd> TYPE_7 VAR_30 [ <S2SV_ModStart> VAR_34 ; } return METHOD_6 <S2SV_ModEnd> ( VAR_35 -> <S2SV_ModStart> , VAR_37 , VAR_39 , VAR_30 <S2SV_ModEnd> , VAR_40 ,","CWE-119 static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> err_info ) ; }","<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> FALSE ; } return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> , phdr , buf , line <S2SV_ModEnd> , err ,"
718,"CWE-20 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 ) { struct STRUCT_OR_UNION_1 * VAR_1 ; struct STRUCT_OR_UNION_2 * VAR_2 = VAR_3 -> VAR_4 -> VAR_5 ; struct STRUCT_OR_UNION_3 * VAR_6 ; TYPE_1 VAR_7 = VAR_8 -> VAR_9 -> VAR_10 ; TYPE_2 VAR_11 , VAR_12 = 0 ; TYPE_3 VAR_13 = 0 ; TYPE_4 VAR_14 = VAR_15 ; VAR_16 = METHOD_1 ( sizeof ( struct STRUCT_OR_UNION_4 ) , VAR_17 ) ; if ( ! VAR_18 ) return - VAR_19 ; VAR_20 -> VAR_21 = VAR_22 ; METHOD_2 ( VAR_23 , VAR_24 -> VAR_25 ) ; VAR_26 -> VAR_27 = VAR_28 ; VAR_29 = 0 ; for ( ; ; ) { struct STRUCT_OR_UNION_5 * VAR_30 ; TYPE_5 VAR_31 ; TYPE_6 VAR_32 ; if ( VAR_33 >= VAR_34 ) { METHOD_3 ( VAR_35 , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , VAR_36 , VAR_37 ) ; return - VAR_38 ; } VAR_39 = & VAR_40 [ VAR_41 ] ; VAR_42 = METHOD_4 ( VAR_43 -> VAR_44 ) ; if ( ++ VAR_45 > VAR_46 ) { METHOD_5 ( VAR_47 , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , VAR_48 ) ; return - VAR_49 ; } VAR_50 = METHOD_6 ( VAR_51 , VAR_52 ) ; if ( VAR_53 < 0 ) return VAR_54 ; if ( VAR_55 == 1 ) { if ( VAR_56 -> VAR_57 . VAR_58 ) { if ( VAR_59 ) METHOD_7 ( VAR_60 , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , VAR_61 , VAR_62 ) ; else METHOD_8 ( VAR_63 , ""%d:<S2SV_blank>safe\\n"" , VAR_64 ) ; } goto VAR_65 ; } if ( METHOD_9 ( ) ) METHOD_10 ( ) ; if ( VAR_66 -> VAR_67 . VAR_68 > 1 || ( VAR_69 -> VAR_70 . VAR_71 && VAR_72 ) ) { if ( VAR_73 -> VAR_74 . VAR_75 > 1 ) METHOD_11 ( VAR_76 , ""%d:"" , VAR_77 ) ; else METHOD_12 ( VAR_78 , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , VAR_79 , VAR_80 ) ; METHOD_13 ( VAR_81 , VAR_82 ) ; VAR_83 = VAR_84 ; } if ( VAR_85 -> VAR_86 . VAR_87 ) { METHOD_14 ( VAR_88 , ""%d:<S2SV_blank>"" , VAR_89 ) ; METHOD_15 ( METHOD_16 , VAR_90 , VAR_91 , VAR_92 -> VAR_93 ) ; } VAR_94 = METHOD_17 ( VAR_95 , VAR_96 , VAR_97 ) ; if ( VAR_98 ) return VAR_99 ; VAR_100 = METHOD_18 ( VAR_101 ) ; <S2SV_StartBug> if ( VAR_102 == VAR_103 || VAR_104 == VAR_105 ) { <S2SV_EndBug> VAR_106 = METHOD_19 ( VAR_107 , VAR_108 ) ; if ( VAR_109 ) return VAR_110 ; } else if ( VAR_111 == VAR_112 ) { enum VAR_113 * VAR_114 , VAR_115 ; VAR_116 = METHOD_20 ( VAR_117 , VAR_118 -> VAR_119 , VAR_120 ) ; if ( VAR_121 ) return VAR_122 ; VAR_123 = METHOD_21 ( VAR_124 , VAR_125 -> VAR_126 , VAR_127 ) ; if ( VAR_128 ) return VAR_129 ; VAR_130 = VAR_131 [ VAR_132 -> VAR_133 ] . VAR_134 ; VAR_135 = METHOD_22 ( VAR_136 , VAR_137 , VAR_138 -> VAR_139 , VAR_140 -> VAR_141 , METHOD_23 ( VAR_142 -> VAR_143 ) , VAR_144 , VAR_145 -> VAR_146 ) ; if ( VAR_147 ) return VAR_148 ; VAR_149 = & VAR_150 -> VAR_151 [ VAR_152 ] . VAR_153 ; if ( * VAR_154 == VAR_155 ) { * VAR_156 = VAR_157 ; } else if ( VAR_158 != * VAR_159 && ( VAR_160 == VAR_161 || * VAR_162 == VAR_163 ) ) { METHOD_24 ( VAR_164 , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - VAR_165 ; } } else if ( VAR_166 == VAR_167 ) { enum VAR_168 * VAR_169 , VAR_170 ; if ( METHOD_25 ( VAR_171 -> VAR_172 ) == VAR_173 ) { VAR_174 = METHOD_26 ( VAR_175 , VAR_176 , VAR_177 ) ; if ( VAR_178 ) return VAR_179 ; VAR_180 ++ ; continue ; } VAR_181 = METHOD_27 ( VAR_182 , VAR_183 -> VAR_184 , VAR_185 ) ; if ( VAR_186 ) return VAR_187 ; VAR_188 = METHOD_28 ( VAR_189 , VAR_190 -> VAR_191 , VAR_192 ) ; if ( VAR_193 ) return VAR_194 ; VAR_195 = VAR_196 [ VAR_197 -> VAR_198 ] . VAR_199 ; VAR_200 = METHOD_29 ( VAR_201 , VAR_202 , VAR_203 -> VAR_204 , VAR_205 -> VAR_206 , METHOD_30 ( VAR_207 -> VAR_208 ) , VAR_209 , VAR_210 -> VAR_211 ) ; if ( VAR_212 ) return VAR_213 ; VAR_214 = & VAR_215 -> VAR_216 [ VAR_217 ] . VAR_218 ; if ( * VAR_219 == VAR_220 ) { * VAR_221 = VAR_222 ; } else if ( VAR_223 != * VAR_224 && ( VAR_225 == VAR_226 || * VAR_227 == VAR_228 ) ) { METHOD_31 ( VAR_229 , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - VAR_230 ; } } else if ( VAR_231 == VAR_232 ) { if ( METHOD_32 ( VAR_233 -> VAR_234 ) != VAR_235 || VAR_236 -> VAR_237 != VAR_238 ) { METHOD_33 ( VAR_239 , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_240 ; } VAR_241 = METHOD_34 ( VAR_242 , VAR_243 -> VAR_244 , VAR_245 ) ; if ( VAR_246 ) return VAR_247 ; VAR_248 = METHOD_35 ( VAR_249 , VAR_250 , VAR_251 -> VAR_252 , VAR_253 -> VAR_254 , METHOD_36 ( VAR_255 -> VAR_256 ) , VAR_257 , - 1 ) ; if ( VAR_258 ) return VAR_259 ; } else if ( VAR_260 == VAR_261 ) { TYPE_7 VAR_262 = METHOD_37 ( VAR_263 -> VAR_264 ) ; if ( VAR_265 == VAR_266 ) { if ( METHOD_38 ( VAR_267 -> VAR_268 ) != VAR_269 || VAR_270 -> VAR_271 != 0 || VAR_272 -> VAR_273 != VAR_274 || VAR_275 -> VAR_276 != VAR_277 ) { METHOD_39 ( VAR_278 , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_279 ; } VAR_280 = METHOD_40 ( VAR_281 , VAR_282 -> VAR_283 , VAR_284 ) ; if ( VAR_285 ) return VAR_286 ; } else if ( VAR_287 == VAR_288 ) { if ( METHOD_41 ( VAR_289 -> VAR_290 ) != VAR_291 || VAR_292 -> VAR_293 != 0 || VAR_294 -> VAR_295 != VAR_296 || VAR_297 -> VAR_298 != VAR_299 ) { METHOD_42 ( VAR_300 , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_301 ; } VAR_302 += VAR_303 -> VAR_304 + 1 ; continue ; } else if ( VAR_305 == VAR_306 ) { if ( METHOD_43 ( VAR_307 -> VAR_308 ) != VAR_309 || VAR_310 -> VAR_311 != 0 || VAR_312 -> VAR_313 != VAR_314 || VAR_315 -> VAR_316 != VAR_317 ) { METHOD_44 ( VAR_318 , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - VAR_319 ; } VAR_320 = METHOD_45 ( VAR_321 , VAR_322 , VAR_323 ) ; if ( VAR_324 ) return VAR_325 ; if ( METHOD_46 ( VAR_326 , VAR_327 ) ) { METHOD_47 ( VAR_328 , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - VAR_329 ; } VAR_330 = METHOD_48 ( VAR_331 ) ; if ( VAR_332 ) return VAR_333 ; VAR_334 : VAR_335 = METHOD_49 ( VAR_336 , & VAR_337 , & VAR_338 ) ; if ( VAR_339 < 0 ) { if ( VAR_340 != - VAR_341 ) return VAR_342 ; break ; } else { VAR_343 = VAR_344 ; continue ; } } else { VAR_345 = METHOD_50 ( VAR_346 , VAR_347 , & VAR_348 ) ; if ( VAR_349 ) return VAR_350 ; } } else if ( VAR_351 == VAR_352 ) { TYPE_8 VAR_353 = METHOD_51 ( VAR_354 -> VAR_355 ) ; if ( VAR_356 == VAR_357 || VAR_358 == VAR_359 ) { VAR_360 = METHOD_52 ( VAR_361 , VAR_362 ) ; if ( VAR_363 ) return VAR_364 ; } else if ( VAR_365 == VAR_366 ) { VAR_367 = METHOD_53 ( VAR_368 , VAR_369 ) ; if ( VAR_370 ) return VAR_371 ; VAR_372 ++ ; <S2SV_StartBug> } else { <S2SV_EndBug> METHOD_54 ( VAR_373 , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - VAR_374 ; } } else { METHOD_55 ( VAR_375 , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , VAR_376 ) ; return - VAR_377 ; } VAR_378 ++ ; } METHOD_56 ( VAR_379 , ""processed<S2SV_blank>%d<S2SV_blank>insns,<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>%d\\n"" , VAR_380 , VAR_381 -> VAR_382 -> VAR_383 -> VAR_384 ) ; return 0 ; }",<S2SV_ModStart> VAR_381 ) ; VAR_381 -> VAR_216 [ VAR_378 ] . VAR_385 = VAR_344 ; <S2SV_ModStart> VAR_378 ++ ; VAR_381 -> VAR_216 [ VAR_378 ] . VAR_385 = VAR_344 ;,"CWE-20 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , insn_idx ) ; else verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( env , state ) ; do_print_state = false ; } if ( env -> log . level ) { verbose ( env , ""%d:<S2SV_blank>"" , insn_idx ) ; print_bpf_insn ( verbose , env , insn , env -> allow_ptr_leaks ) ; } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; regs = cur_regs ( env ) ; <S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn_idx , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; <S2SV_StartBug> } else { <S2SV_EndBug> verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns,<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>%d\\n"" , insn_processed , env -> prog -> aux -> stack_depth ) ; return 0 ; }",<S2SV_ModStart> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
719,"CWE-190 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { <S2SV_StartBug> TYPE_3 VAR_2 ; <S2SV_EndBug> TYPE_4 VAR_3 ; VAR_4 * VAR_5 ; <S2SV_StartBug> TYPE_5 VAR_6 ; <S2SV_EndBug> VAR_7 * VAR_8 ; if ( METHOD_1 ( VAR_9 ) > 0 && METHOD_2 ( VAR_10 ) > 0 ) { METHOD_3 ( VAR_11 -> VAR_12 ) ; VAR_13 = METHOD_4 ( VAR_14 ) ; for ( VAR_15 = VAR_16 -> VAR_17 , VAR_18 = VAR_19 -> VAR_20 [ 0 ] ; VAR_21 > 0 ; -- VAR_22 , VAR_23 += VAR_24 ) { for ( VAR_25 = VAR_26 -> VAR_27 , VAR_28 = VAR_29 ; VAR_30 > 0 ; -- VAR_31 , ++ VAR_32 ) { * VAR_33 = ( * VAR_34 >= 0 ) ? ( ( * VAR_35 ) >> VAR_36 ) : ( - ( ( - ( * VAR_37 ) ) >> VAR_38 ) ) ; } } } }",<S2SV_ModStart> VAR_38 ) { TYPE_6 VAR_22 ; TYPE_6 <S2SV_ModEnd> VAR_31 ; VAR_7 <S2SV_ModStart> * VAR_29 ; TYPE_6 <S2SV_ModEnd> VAR_24 ; VAR_7,"CWE-190 void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }",<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
720,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 , VAR_3 , VAR_4 ; TYPE_4 VAR_5 [ 65536 ] ; TYPE_5 * VAR_6 ; TYPE_6 VAR_7 ; VAR_8 = VAR_9 -> VAR_10 - VAR_11 ; VAR_12 = VAR_13 -> VAR_14 + + VAR_15 ; if ( VAR_16 <= 0 ) { return ; } METHOD_1 ( & VAR_17 , 0 , sizeof ( TYPE_7 ) ) ; VAR_18 . VAR_19 = VAR_20 . VAR_21 = VAR_22 . VAR_23 [ VAR_24 ] = & ( VAR_25 . VAR_26 [ VAR_27 . VAR_28 ++ ] ) ; VAR_29 . VAR_30 -> VAR_31 = VAR_32 ; VAR_33 . VAR_34 -> VAR_35 = 0 ; VAR_36 . VAR_37 -> VAR_38 = VAR_39 . VAR_40 -> VAR_41 = VAR_42 ; VAR_43 . VAR_44 -> VAR_45 = VAR_46 . VAR_47 -> VAR_48 = VAR_49 . VAR_50 -> VAR_51 = VAR_52 ; VAR_53 [ 0 ] = ( VAR_54 >> 8 ) ; VAR_55 [ 1 ] = VAR_56 & 0xff ; VAR_57 = 16 ; for ( VAR_58 = 0 ; VAR_59 < VAR_60 ; VAR_61 ++ ) { VAR_62 = VAR_63 [ VAR_64 ] ; <S2SV_StartBug> METHOD_2 ( & VAR_65 , VAR_66 , VAR_67 ) ; <S2SV_EndBug> METHOD_3 ( & VAR_68 , ( TYPE_8 ) VAR_69 ) ; } VAR_70 += 8 ; VAR_71 -> VAR_72 = ( VAR_73 >> 3 ) + VAR_74 ; METHOD_4 ( VAR_75 -> VAR_76 + VAR_77 , VAR_78 , ( VAR_79 >> 3 ) ) ; }","<S2SV_ModStart> VAR_69 , VAR_78 , VAR_60 << 3","CWE-119 void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }","<S2SV_ModStart> ch , seq , size << 3"
721,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 METHOD_1 { TYPE_5 VAR_4 ; TYPE_6 VAR_5 , VAR_6 , VAR_7 , VAR_8 ; TYPE_7 VAR_9 ; <S2SV_StartBug> ( TYPE_8 METHOD_2 METHOD_3 ( VAR_10 , VAR_11 , & VAR_12 METHOD_4 ; <S2SV_EndBug> if ( VAR_13 != VAR_14 && VAR_15 != 8 && VAR_16 > 1 METHOD_5 { METHOD_6 ( VAR_17 , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , METHOD_7 ( VAR_18 METHOD_8 METHOD_9 ; return ( VAR_19 METHOD_10 ; } METHOD_11 ( VAR_20 , VAR_21 , & VAR_22 METHOD_12 ; METHOD_13 ( VAR_23 , VAR_24 , & VAR_25 METHOD_14 ; if ( ! ( METHOD_15 ( VAR_26 METHOD_16 || METHOD_17 ( VAR_27 METHOD_18 METHOD_19 METHOD_20 { TYPE_9 VAR_28 = ( TYPE_10 METHOD_21 - 1L ; METHOD_22 ( VAR_29 , VAR_30 , & VAR_31 METHOD_23 ; VAR_32 = ! VAR_33 && ( VAR_34 == VAR_35 METHOD_24 ; } else { if ( VAR_36 METHOD_25 { METHOD_26 ( VAR_37 , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , METHOD_27 ( VAR_38 METHOD_28 METHOD_29 ; return ( VAR_39 METHOD_30 ; } if ( METHOD_31 ( VAR_40 METHOD_32 METHOD_33 { if ( ! METHOD_34 ( VAR_41 , VAR_42 , & VAR_43 METHOD_35 METHOD_36 VAR_44 = VAR_45 ; if ( ! METHOD_37 ( VAR_46 , VAR_47 , & VAR_48 METHOD_38 METHOD_39 VAR_49 = VAR_50 ; VAR_51 = ( VAR_52 == VAR_53 && VAR_54 == VAR_55 METHOD_40 ; } else { METHOD_41 ( VAR_56 , VAR_57 , & VAR_58 METHOD_42 ; METHOD_43 ( VAR_59 , VAR_60 , & VAR_61 METHOD_44 ; VAR_62 = ( VAR_63 == VAR_64 && VAR_65 == VAR_66 METHOD_45 ; } } TYPE_11 1 TYPE_12 0 TYPE_13 ( VAR_67 , VAR_68 , VAR_69 , VAR_70 , VAR_71 METHOD_46 ( ( TYPE_14 METHOD_47 ( ( ( VAR_72 METHOD_48 << 11 METHOD_49 | ( ( VAR_73 METHOD_50 << 3 METHOD_51 | ( ( VAR_74 METHOD_52 << 2 METHOD_53 | ( ( VAR_75 METHOD_54 << 1 METHOD_55 | ( VAR_76 METHOD_56 METHOD_57 METHOD_58 switch ( TYPE_15 ( VAR_77 , VAR_78 , METHOD_59 ( VAR_79 METHOD_60 , METHOD_61 ( VAR_80 METHOD_62 , VAR_81 METHOD_63 METHOD_64 { case TYPE_16 ( VAR_82 , VAR_83 , TYPE_17 , TYPE_18 , TYPE_19 METHOD_65 : case TYPE_20 ( VAR_84 , VAR_85 , TYPE_21 , TYPE_22 , TYPE_23 METHOD_66 : return VAR_86 ; case TYPE_24 ( VAR_87 , VAR_88 , TYPE_25 , TYPE_26 , TYPE_27 METHOD_67 : case TYPE_28 ( VAR_89 , VAR_90 , TYPE_29 , TYPE_30 , TYPE_31 METHOD_68 : return VAR_91 ; case TYPE_32 ( VAR_92 , VAR_93 , TYPE_33 , TYPE_34 , TYPE_35 METHOD_69 : case TYPE_36 ( VAR_94 , VAR_95 , TYPE_37 , TYPE_38 , TYPE_39 METHOD_70 : return VAR_96 ; case TYPE_40 ( VAR_97 , VAR_98 , TYPE_41 , TYPE_42 , TYPE_43 METHOD_71 : case TYPE_44 ( VAR_99 , VAR_100 , TYPE_45 , TYPE_46 , TYPE_47 METHOD_72 : return VAR_101 ; case TYPE_48 ( VAR_102 , VAR_103 , TYPE_49 , TYPE_50 , TYPE_51 METHOD_73 : case TYPE_52 ( VAR_104 , VAR_105 , TYPE_53 , TYPE_54 , TYPE_55 METHOD_74 : return VAR_106 ; case TYPE_56 ( VAR_107 , VAR_108 , TYPE_57 , TYPE_58 , TYPE_59 METHOD_75 : case TYPE_60 ( VAR_109 , VAR_110 , TYPE_61 , TYPE_62 , TYPE_63 METHOD_76 : return VAR_111 ; case TYPE_64 ( VAR_112 , VAR_113 , TYPE_65 , TYPE_66 , TYPE_67 METHOD_77 : case TYPE_68 ( VAR_114 , VAR_115 , TYPE_69 , TYPE_70 , TYPE_71 METHOD_78 : return VAR_116 ; case TYPE_72 ( VAR_117 , VAR_118 , TYPE_73 , TYPE_74 , TYPE_75 METHOD_79 : case TYPE_76 ( VAR_119 , VAR_120 , TYPE_77 , TYPE_78 , TYPE_79 METHOD_80 : return VAR_121 ; case TYPE_80 ( VAR_122 , VAR_123 , TYPE_81 , TYPE_82 , TYPE_83 METHOD_81 : case TYPE_84 ( VAR_124 , VAR_125 , TYPE_85 , TYPE_86 , TYPE_87 METHOD_82 : return VAR_126 ; case TYPE_88 ( VAR_127 , VAR_128 , TYPE_89 , TYPE_90 , TYPE_91 METHOD_83 : case TYPE_92 ( VAR_129 , VAR_130 , TYPE_93 , TYPE_94 , TYPE_95 METHOD_84 : return VAR_131 ; case TYPE_96 ( VAR_132 , VAR_133 , TYPE_97 , TYPE_98 , TYPE_99 METHOD_85 : case TYPE_100 ( VAR_134 , VAR_135 , TYPE_101 , TYPE_102 , TYPE_103 METHOD_86 : return VAR_136 ; case TYPE_104 ( VAR_137 , VAR_138 , TYPE_105 , TYPE_106 , TYPE_107 METHOD_87 : case TYPE_108 ( VAR_139 , VAR_140 , TYPE_109 , TYPE_110 , TYPE_111 METHOD_88 : return VAR_141 ; case TYPE_112 ( VAR_142 , VAR_143 , TYPE_113 , TYPE_114 , TYPE_115 METHOD_89 : return VAR_144 ? VAR_145 : VAR_146 ; case TYPE_116 ( VAR_147 , VAR_148 , TYPE_117 , TYPE_118 , TYPE_119 METHOD_90 : return VAR_149 ; case TYPE_120 ( VAR_150 , VAR_151 , TYPE_121 , TYPE_122 , TYPE_123 METHOD_91 : case TYPE_124 ( VAR_152 , VAR_153 , TYPE_125 , TYPE_126 , TYPE_127 METHOD_92 : return VAR_154 ; case TYPE_128 ( VAR_155 , VAR_156 , TYPE_129 , TYPE_130 , TYPE_131 METHOD_93 : case TYPE_132 ( VAR_157 , VAR_158 , TYPE_133 , TYPE_134 , TYPE_135 METHOD_94 : return VAR_159 ; case TYPE_136 ( VAR_160 , VAR_161 , TYPE_137 , TYPE_138 , TYPE_139 METHOD_95 : case TYPE_140 ( VAR_162 , VAR_163 , TYPE_141 , TYPE_142 , TYPE_143 METHOD_96 : return VAR_164 ; } TYPE_144 TYPE_145 TYPE_146 METHOD_97 ( VAR_165 , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , METHOD_98 ( VAR_166 METHOD_99 METHOD_100 ; return ( VAR_167 METHOD_101 ; }","<S2SV_ModStart> ( TYPE_8 METHOD_101 METHOD_102 <S2SV_ModEnd> ( VAR_166 ,","CWE-119 static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } }   T 1   F 0   pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; }   pack   F   T fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; }","<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,"
722,"CWE-119 static TYPE_0 * METHOD_0 ( const TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { <S2SV_StartBug> METHOD_1 ( VAR_2 , VAR_3 ) { if ( VAR_4 != ( TYPE_3 * ) VAR_5 ) VAR_6 = METHOD_2 ( VAR_7 ) ; if ( VAR_8 != ( TYPE_4 * ) VAR_9 ) VAR_10 = METHOD_3 ( VAR_11 ) ; METHOD_4 ( ( VAR_12 ) , ( VAR_13 ) ) ; } <S2SV_EndBug> TYPE_5 VAR_14 [ VAR_15 ] , VAR_16 [ 4 ] ; TYPE_6 * VAR_17 , * VAR_18 ; TYPE_7 * VAR_19 ; TYPE_8 VAR_20 , VAR_21 ; TYPE_9 VAR_22 , VAR_23 ; TYPE_10 VAR_24 ; TYPE_11 VAR_25 ; TYPE_12 VAR_26 ; register TYPE_13 * VAR_27 ; register TYPE_14 VAR_28 , VAR_29 ; TYPE_15 VAR_30 , VAR_31 ; TYPE_16 VAR_32 , VAR_33 , VAR_34 , VAR_35 , VAR_36 ; VAR_37 * VAR_38 ; METHOD_5 ( VAR_39 != ( const TYPE_17 * ) VAR_40 ) ; METHOD_6 ( VAR_41 -> VAR_42 == VAR_43 ) ; if ( VAR_44 -> VAR_45 != VAR_46 ) ( TYPE_18 ) METHOD_7 ( VAR_47 , METHOD_8 ( ) , ""%s"" , VAR_48 -> VAR_49 ) ; METHOD_9 ( VAR_50 != ( TYPE_19 * ) VAR_51 ) ; METHOD_10 ( VAR_52 -> VAR_53 == VAR_54 ) ; VAR_55 = METHOD_11 ( VAR_56 , VAR_57 ) ; VAR_58 = METHOD_12 ( VAR_59 , VAR_60 , VAR_61 , VAR_62 ) ; if ( VAR_63 == VAR_64 ) { VAR_65 = METHOD_13 ( VAR_66 ) ; return ( ( TYPE_20 * ) VAR_67 ) ; } VAR_68 = ( TYPE_21 * ) VAR_69 ; VAR_70 = ( TYPE_22 * ) VAR_71 ; VAR_72 . VAR_73 = 0 ; VAR_74 . VAR_75 = 0 ; VAR_76 [ 0 ] = METHOD_14 ( VAR_77 ) ; VAR_78 [ 1 ] = METHOD_15 ( VAR_79 ) ; VAR_80 [ 2 ] = METHOD_16 ( VAR_81 ) ; VAR_82 [ 3 ] = METHOD_17 ( VAR_83 ) ; if ( ! ( ( VAR_84 [ 0 ] == 0x50 ) && ( VAR_85 [ 1 ] == 0x49 ) && ( VAR_86 [ 2 ] == 0x43 ) && ( VAR_87 [ 3 ] == 0x54 ) ) ) for ( VAR_88 = 0 ; VAR_89 < 508 ; VAR_90 ++ ) if ( METHOD_18 ( VAR_91 ) == VAR_92 ) break ; ( TYPE_23 ) METHOD_19 ( VAR_93 ) ; if ( METHOD_20 ( VAR_94 , & VAR_95 ) == VAR_96 ) METHOD_21 ( VAR_97 , ""ImproperImageHeader"" ) ; while ( ( VAR_98 = METHOD_22 ( VAR_99 ) ) == 0 ) ; if ( VAR_100 != 0x11 ) METHOD_23 ( VAR_101 , ""ImproperImageHeader"" ) ; VAR_102 = ( TYPE_24 ) METHOD_24 ( VAR_103 ) ; if ( VAR_104 == 2 ) { VAR_105 = METHOD_25 ( VAR_106 ) ; if ( VAR_107 != 0xff ) METHOD_26 ( VAR_108 , ""ImproperImageHeader"" ) ; } else if ( VAR_109 != 1 ) METHOD_27 ( VAR_110 , ""ImproperImageHeader"" ) ; if ( ( VAR_111 . VAR_112 < 0 ) || ( VAR_113 . VAR_114 < 0 ) || ( VAR_115 . VAR_116 < 0 ) || ( VAR_117 . VAR_118 < 0 ) || ( VAR_119 . VAR_120 >= VAR_121 . VAR_122 ) || ( VAR_123 . VAR_124 >= VAR_125 . VAR_126 ) ) METHOD_28 ( VAR_127 , ""ImproperImageHeader"" ) ; VAR_128 = 0 ; VAR_129 -> VAR_130 = 8 ; VAR_131 -> VAR_132 = ( TYPE_25 ) ( VAR_133 . VAR_134 - VAR_135 . VAR_136 ) ; VAR_137 -> VAR_138 = ( TYPE_26 ) ( VAR_139 . VAR_140 - VAR_141 . VAR_142 ) ; VAR_143 -> VAR_144 . VAR_145 = VAR_146 ; VAR_147 -> VAR_148 . VAR_149 = VAR_150 ; VAR_151 -> VAR_152 = VAR_153 ; if ( ( VAR_154 -> VAR_155 != VAR_156 ) && ( VAR_157 -> VAR_158 != 0 ) ) if ( VAR_159 -> VAR_160 >= ( VAR_161 -> VAR_162 + VAR_163 -> VAR_164 - 1 ) ) { ( TYPE_27 ) METHOD_29 ( VAR_165 ) ; return ( METHOD_30 ( VAR_166 ) ) ; } VAR_167 = METHOD_31 ( VAR_168 , VAR_169 -> VAR_170 , VAR_171 -> VAR_172 , VAR_173 ) ; if ( VAR_174 != VAR_175 ) VAR_176 = METHOD_32 ( VAR_177 , VAR_178 ) ; if ( VAR_179 == VAR_180 ) return ( METHOD_33 ( VAR_181 ) ) ; VAR_182 = VAR_183 ; for ( VAR_184 = 0 ; METHOD_34 ( VAR_185 ) == VAR_186 ; ) { if ( ( VAR_187 -> VAR_188 != VAR_189 ) && ( VAR_190 -> VAR_191 != 0 ) ) if ( VAR_192 -> VAR_193 >= ( VAR_194 -> VAR_195 + VAR_196 -> VAR_197 - 1 ) ) break ; if ( ( VAR_198 == 1 ) || ( ( METHOD_35 ( VAR_199 ) % 2 ) != 0 ) ) VAR_200 = METHOD_36 ( VAR_201 ) ; if ( VAR_202 == 2 ) VAR_203 = METHOD_37 ( VAR_204 ) ; if ( VAR_205 < 0 ) break ; if ( VAR_206 == 0 ) continue ; if ( VAR_207 > 0xa1 ) { if ( VAR_208 -> VAR_209 != VAR_210 ) ( TYPE_28 ) METHOD_38 ( VAR_211 , METHOD_39 ( ) , ""%04X:"" , VAR_212 ) ; } else { if ( VAR_213 -> VAR_214 != VAR_215 ) ( TYPE_29 ) METHOD_40 ( VAR_216 , METHOD_41 ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , VAR_217 , VAR_218 [ VAR_219 ] . VAR_220 , VAR_221 [ VAR_222 ] . VAR_223 ) ; switch ( VAR_224 ) { case 0x01 : { VAR_225 = METHOD_42 ( VAR_226 ) ; <S2SV_StartBug> if ( VAR_227 != 0x000a ) <S2SV_EndBug> { for ( VAR_228 = 0 ; VAR_229 < ( TYPE_30 ) ( VAR_230 - 2 ) ; VAR_231 ++ ) if ( METHOD_43 ( VAR_232 ) == VAR_233 ) break ; break ; } if ( METHOD_44 ( VAR_234 , & VAR_235 ) == VAR_236 ) METHOD_45 ( VAR_237 , ""ImproperImageHeader"" ) ; if ( ( ( VAR_238 . VAR_239 & 0x8000 ) != 0 ) || ( ( VAR_240 . VAR_241 & 0x8000 ) != 0 ) ) break ; VAR_242 -> VAR_243 = ( TYPE_31 ) ( VAR_244 . VAR_245 - VAR_246 . VAR_247 ) ; VAR_248 -> VAR_249 = ( TYPE_32 ) ( VAR_250 . VAR_251 - VAR_252 . VAR_253 ) ; VAR_254 = METHOD_46 ( VAR_255 , VAR_256 -> VAR_257 , VAR_258 -> VAR_259 , VAR_260 ) ; if ( VAR_261 != VAR_262 ) VAR_263 = METHOD_47 ( VAR_264 , VAR_265 ) ; if ( VAR_266 == VAR_267 ) return ( METHOD_48 ( VAR_268 ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { TYPE_33 VAR_269 ; TYPE_34 VAR_270 , VAR_271 ; VAR_272 = ( TYPE_35 ) METHOD_49 ( VAR_273 ) ; for ( VAR_274 = 0 ; VAR_275 < 8 ; VAR_276 ++ ) if ( METHOD_50 ( VAR_277 ) == VAR_278 ) break ; if ( VAR_279 == 2 ) { for ( VAR_280 = 0 ; VAR_281 < 5 ; VAR_282 ++ ) if ( METHOD_51 ( VAR_283 ) == VAR_284 ) break ; break ; } if ( VAR_285 != 1 ) METHOD_52 ( VAR_286 , ""UnknownPatternType"" ) ; VAR_287 = METHOD_53 ( VAR_288 ) ; <S2SV_StartBug> if ( METHOD_54 ( VAR_289 , & VAR_290 ) == VAR_291 ) <S2SV_EndBug> METHOD_55 ( VAR_292 , ""ImproperImageHeader"" ) ; if ( METHOD_56 ( VAR_293 , & VAR_294 ) == VAR_295 ) METHOD_57 ( VAR_296 , ""ImproperImageHeader"" ) ; VAR_297 -> VAR_298 = ( TYPE_36 ) VAR_299 . VAR_300 ; VAR_301 -> VAR_302 . VAR_303 = 1.0 * VAR_304 . VAR_305 ; VAR_306 -> VAR_307 . VAR_308 = 1.0 * VAR_309 . VAR_310 ; VAR_311 -> VAR_312 = VAR_313 ; ( TYPE_37 ) METHOD_58 ( VAR_314 ) ; VAR_315 = ( TYPE_38 ) METHOD_59 ( VAR_316 ) ; <S2SV_StartBug> VAR_317 = METHOD_60 ( VAR_318 ) ; <S2SV_EndBug> for ( VAR_319 = 0 ; VAR_320 <= ( TYPE_39 ) VAR_321 ; VAR_322 ++ ) ( TYPE_40 ) METHOD_61 ( VAR_323 ) ; VAR_324 = ( TYPE_41 ) ( VAR_325 . VAR_326 - VAR_327 . VAR_328 ) ; VAR_329 = ( TYPE_42 ) ( VAR_330 . VAR_331 - VAR_332 . VAR_333 ) ; if ( VAR_334 . VAR_335 <= 8 ) VAR_336 &= 0x7fff ; if ( VAR_337 . VAR_338 == 16 ) VAR_339 <<= 1 ; if ( VAR_340 == 0 ) VAR_341 = VAR_342 ; if ( VAR_343 < 8 ) { for ( VAR_344 = 0 ; VAR_345 < ( TYPE_43 ) ( VAR_346 * VAR_347 ) ; VAR_348 ++ ) if ( METHOD_62 ( VAR_349 ) == VAR_350 ) break ; } else for ( VAR_351 = 0 ; VAR_352 < ( TYPE_44 ) VAR_353 ; VAR_354 ++ ) { if ( METHOD_63 ( VAR_355 ) != VAR_356 ) break ; if ( VAR_357 > 200 ) { for ( VAR_358 = 0 ; VAR_359 < ( TYPE_45 ) METHOD_64 ( VAR_360 ) ; VAR_361 ++ ) if ( METHOD_65 ( VAR_362 ) == VAR_363 ) break ; } else for ( VAR_364 = 0 ; VAR_365 < ( TYPE_46 ) METHOD_66 ( VAR_366 ) ; VAR_367 ++ ) if ( METHOD_67 ( VAR_368 ) == VAR_369 ) break ; } break ; } case 0x1b : { VAR_370 -> VAR_371 . VAR_372 = ( TYPE_47 ) METHOD_68 ( METHOD_69 ( VAR_373 ) ) ; VAR_374 -> VAR_375 . VAR_376 = ( TYPE_48 ) METHOD_70 ( METHOD_71 ( VAR_377 ) ) ; VAR_378 -> VAR_379 . VAR_380 = ( TYPE_49 ) METHOD_72 ( METHOD_73 ( VAR_381 ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> VAR_382 = METHOD_74 ( VAR_383 ) ; <S2SV_EndBug> for ( VAR_384 = 0 ; VAR_385 < ( TYPE_50 ) ( VAR_386 - 2 ) ; VAR_387 ++ ) if ( METHOD_75 ( VAR_388 ) == VAR_389 ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { TYPE_51 VAR_390 , VAR_391 ; register unsigned TYPE_52 * VAR_392 ; TYPE_53 VAR_393 ; TYPE_54 VAR_394 ; unsigned TYPE_55 * VAR_395 ; VAR_396 = 0 ; if ( ( VAR_397 != 0x9a ) && ( VAR_398 != 0x9b ) ) VAR_399 = ( TYPE_56 ) METHOD_76 ( VAR_400 ) ; else { ( TYPE_57 ) METHOD_77 ( VAR_401 ) ; ( TYPE_58 ) METHOD_78 ( VAR_402 ) ; ( TYPE_59 ) METHOD_79 ( VAR_403 ) ; } if ( METHOD_80 ( VAR_404 , & VAR_405 ) == VAR_406 ) METHOD_81 ( VAR_407 , ""ImproperImageHeader"" ) ; VAR_408 = METHOD_82 ( VAR_409 , ( TYPE_60 ) ( VAR_410 . VAR_411 - VAR_412 . VAR_413 ) , ( TYPE_61 ) ( VAR_414 . VAR_415 - VAR_416 . VAR_417 ) , VAR_418 , VAR_419 ) ; if ( VAR_420 == ( TYPE_62 * ) VAR_421 ) METHOD_83 ( VAR_422 , ""ImproperImageHeader"" ) ; if ( ( VAR_423 == 0x9a ) || ( VAR_424 == 0x9b ) || ( ( VAR_425 & 0x8000 ) != 0 ) ) { if ( METHOD_84 ( VAR_426 , & VAR_427 ) == VAR_428 ) METHOD_85 ( VAR_429 , ""ImproperImageHeader"" ) ; VAR_430 -> VAR_431 = ( TYPE_63 ) VAR_432 . VAR_433 ; VAR_434 -> VAR_435 = VAR_436 . VAR_437 == 4 ? VAR_438 : VAR_439 ; VAR_440 -> VAR_441 . VAR_442 = ( TYPE_64 ) VAR_443 . VAR_444 ; VAR_445 -> VAR_446 . VAR_447 = ( TYPE_65 ) VAR_448 . VAR_449 ; VAR_450 -> VAR_451 = VAR_452 ; if ( VAR_453 -> VAR_454 != VAR_455 ) ( TYPE_66 ) METHOD_86 ( VAR_456 , VAR_457 , VAR_458 ) ; } if ( ( VAR_459 != 0x9a ) && ( VAR_460 != 0x9b ) ) { VAR_461 -> VAR_462 = 2 ; if ( ( VAR_463 & 0x8000 ) != 0 ) { ( TYPE_67 ) METHOD_87 ( VAR_464 ) ; VAR_465 = ( TYPE_68 ) METHOD_88 ( VAR_466 ) ; VAR_467 -> VAR_468 = 1UL * METHOD_89 ( VAR_469 ) + 1 ; } VAR_470 = METHOD_90 ( VAR_471 , VAR_472 -> VAR_473 , VAR_474 ) ; if ( VAR_475 == VAR_476 ) METHOD_91 ( VAR_477 , ""MemoryAllocationFailed"" ) ; if ( ( VAR_478 & 0x8000 ) != 0 ) { for ( VAR_479 = 0 ; VAR_480 < ( TYPE_69 ) VAR_481 -> VAR_482 ; VAR_483 ++ ) { VAR_484 = METHOD_92 ( VAR_485 ) % VAR_486 -> VAR_487 ; if ( ( VAR_488 & 0x8000 ) != 0 ) VAR_489 = ( TYPE_70 ) VAR_490 ; VAR_491 -> VAR_492 [ VAR_493 ] . VAR_494 = ( TYPE_71 ) METHOD_93 ( METHOD_94 ( VAR_495 ) ) ; VAR_496 -> VAR_497 [ VAR_498 ] . VAR_499 = ( TYPE_72 ) METHOD_95 ( METHOD_96 ( VAR_500 ) ) ; VAR_501 -> VAR_502 [ VAR_503 ] . VAR_504 = ( TYPE_73 ) METHOD_97 ( METHOD_98 ( VAR_505 ) ) ; } } else { for ( VAR_506 = 0 ; VAR_507 < ( TYPE_74 ) VAR_508 -> VAR_509 ; VAR_510 ++ ) { VAR_511 -> VAR_512 [ VAR_513 ] . VAR_514 = ( TYPE_75 ) ( VAR_515 - VAR_516 -> VAR_517 [ VAR_518 ] . VAR_519 ) ; VAR_520 -> VAR_521 [ VAR_522 ] . VAR_523 = ( TYPE_76 ) ( VAR_524 - VAR_525 -> VAR_526 [ VAR_527 ] . VAR_528 ) ; VAR_529 -> VAR_530 [ VAR_531 ] . VAR_532 = ( TYPE_77 ) ( VAR_533 - VAR_534 -> VAR_535 [ VAR_536 ] . VAR_537 ) ; } } } if ( METHOD_99 ( VAR_538 ) != VAR_539 ) METHOD_100 ( VAR_540 , ""InsufficientImageDataInFile"" ) ; if ( METHOD_101 ( VAR_541 , & VAR_542 ) == VAR_543 ) METHOD_102 ( VAR_544 , ""ImproperImageHeader"" ) ; if ( METHOD_103 ( VAR_545 , & VAR_546 ) == VAR_547 ) METHOD_104 ( VAR_548 , ""ImproperImageHeader"" ) ; ( TYPE_78 ) METHOD_105 ( VAR_549 ) ; if ( ( VAR_550 == 0x91 ) || ( VAR_551 == 0x99 ) || ( VAR_552 == 0x9b ) ) { <S2SV_StartBug> VAR_553 = METHOD_106 ( VAR_554 ) ; <S2SV_EndBug> for ( VAR_555 = 0 ; VAR_556 < ( TYPE_79 ) ( VAR_557 - 2 ) ; VAR_558 ++ ) if ( METHOD_107 ( VAR_559 ) == VAR_560 ) break ; } if ( ( VAR_561 != 0x9a ) && ( VAR_562 != 0x9b ) && ( VAR_563 & 0x8000 ) == 0 ) VAR_564 = METHOD_108 ( VAR_565 , VAR_566 , ( TYPE_80 ) VAR_567 , 1 , & VAR_568 ) ; else VAR_569 = METHOD_109 ( VAR_570 , VAR_571 , ( TYPE_81 ) VAR_572 , ( unsigned TYPE_82 ) VAR_573 . VAR_574 , & VAR_575 ) ; if ( VAR_576 == ( unsigned TYPE_83 * ) VAR_577 ) METHOD_110 ( VAR_578 , ""UnableToUncompressImage"" ) ; VAR_579 = VAR_580 ; for ( VAR_581 = 0 ; VAR_582 < ( TYPE_84 ) VAR_583 -> VAR_584 ; VAR_585 ++ ) { if ( VAR_586 > ( VAR_587 + VAR_588 + VAR_589 -> VAR_590 ) ) { VAR_591 = ( unsigned TYPE_85 * ) METHOD_111 ( VAR_592 ) ; METHOD_112 ( VAR_593 , ""NotEnoughPixelData"" ) ; } VAR_594 = METHOD_113 ( VAR_595 , 0 , VAR_596 , VAR_597 -> VAR_598 , 1 , VAR_599 ) ; if ( VAR_600 == ( TYPE_86 * ) VAR_601 ) break ; for ( VAR_602 = 0 ; VAR_603 < ( TYPE_87 ) VAR_604 -> VAR_605 ; VAR_606 ++ ) { if ( VAR_607 -> VAR_608 == VAR_609 ) { VAR_610 = ( TYPE_88 ) METHOD_114 ( VAR_611 , ( TYPE_89 ) * VAR_612 , VAR_613 ) ; METHOD_115 ( VAR_614 , VAR_615 , VAR_616 ) ; METHOD_116 ( VAR_617 , VAR_618 -> VAR_619 [ ( TYPE_90 ) VAR_620 ] . VAR_621 , VAR_622 ) ; METHOD_117 ( VAR_623 , VAR_624 -> VAR_625 [ ( TYPE_91 ) VAR_626 ] . VAR_627 , VAR_628 ) ; METHOD_118 ( VAR_629 , VAR_630 -> VAR_631 [ ( TYPE_92 ) VAR_632 ] . VAR_633 , VAR_634 ) ; } else { if ( VAR_635 . VAR_636 == 16 ) { VAR_637 = ( TYPE_93 ) ( * VAR_638 ++ ) ; VAR_639 = ( TYPE_94 ) ( * VAR_640 ) ; METHOD_119 ( VAR_641 , METHOD_120 ( ( unsigned TYPE_95 ) ( ( VAR_642 & 0x7c ) << 1 ) ) , VAR_643 ) ; METHOD_121 ( VAR_644 , METHOD_122 ( ( unsigned TYPE_96 ) ( ( ( VAR_645 & 0x03 ) << 6 ) | ( ( VAR_646 & 0xe0 ) >> 2 ) ) ) , VAR_647 ) ; METHOD_123 ( VAR_648 , METHOD_124 ( ( unsigned TYPE_97 ) ( ( VAR_649 & 0x1f ) << 3 ) ) , VAR_650 ) ; } else if ( VAR_651 -> VAR_652 == VAR_653 ) { if ( VAR_654 > ( VAR_655 + VAR_656 + 2 * VAR_657 -> VAR_658 ) ) METHOD_125 ( VAR_659 , ""NotEnoughPixelData"" ) ; METHOD_126 ( VAR_660 , METHOD_127 ( * VAR_661 ) , VAR_662 ) ; METHOD_128 ( VAR_663 , METHOD_129 ( * ( VAR_664 + VAR_665 -> VAR_666 ) ) , VAR_667 ) ; METHOD_130 ( VAR_668 , METHOD_131 ( * ( VAR_669 + 2 * VAR_670 -> VAR_671 ) ) , VAR_672 ) ; } else { if ( VAR_673 > ( VAR_674 + VAR_675 + 3 * VAR_676 -> VAR_677 ) ) METHOD_132 ( VAR_678 , ""NotEnoughPixelData"" ) ; METHOD_133 ( VAR_679 , METHOD_134 ( * VAR_680 ) , VAR_681 ) ; METHOD_135 ( VAR_682 , METHOD_136 ( * ( VAR_683 + VAR_684 -> VAR_685 ) ) , VAR_686 ) ; METHOD_137 ( VAR_687 , METHOD_138 ( * ( VAR_688 + 2 * VAR_689 -> VAR_690 ) ) , VAR_691 ) ; METHOD_139 ( VAR_692 , METHOD_140 ( * ( VAR_693 + 3 * VAR_694 -> VAR_695 ) ) , VAR_696 ) ; } } VAR_697 ++ ; VAR_698 += METHOD_141 ( VAR_699 ) ; } if ( METHOD_142 ( VAR_700 , VAR_701 ) == VAR_702 ) break ; if ( ( VAR_703 -> VAR_704 == VAR_705 ) && ( VAR_706 . VAR_707 != 16 ) ) { VAR_708 += ( VAR_709 . VAR_710 - 1 ) * VAR_711 -> VAR_712 ; if ( VAR_713 < VAR_714 ) break ; } VAR_715 = METHOD_143 ( VAR_716 , VAR_717 , ( TYPE_98 ) VAR_718 , VAR_719 -> VAR_720 ) ; if ( VAR_721 == VAR_722 ) break ; } VAR_723 = ( unsigned TYPE_99 * ) METHOD_144 ( VAR_724 ) ; if ( ( VAR_725 == VAR_726 ) && ( METHOD_145 ( VAR_727 ) == VAR_728 ) ) if ( ( VAR_729 == 0x9a ) || ( VAR_730 == 0x9b ) || ( ( VAR_731 & 0x8000 ) != 0 ) ) ( TYPE_100 ) METHOD_146 ( VAR_732 , VAR_733 , VAR_734 , VAR_735 , ( TYPE_101 ) VAR_736 . VAR_737 , ( TYPE_102 ) VAR_738 . VAR_739 , VAR_740 ) ; VAR_741 = METHOD_147 ( VAR_742 ) ; break ; } case 0xa1 : { unsigned TYPE_103 * VAR_743 ; TYPE_104 VAR_744 ; VAR_745 = METHOD_148 ( VAR_746 ) ; VAR_747 = METHOD_149 ( VAR_748 ) ; <S2SV_StartBug> if ( VAR_749 == 0 ) <S2SV_EndBug> break ; ( TYPE_105 ) METHOD_150 ( VAR_750 ) ; VAR_751 -= METHOD_151 ( VAR_752 , 4 ) ; if ( VAR_753 == 0 ) break ; VAR_754 = ( unsigned TYPE_106 * ) METHOD_152 ( VAR_755 , sizeof ( * VAR_756 ) ) ; if ( VAR_757 == ( unsigned TYPE_107 * ) VAR_758 ) break ; VAR_759 = METHOD_153 ( VAR_760 , VAR_761 , VAR_762 ) ; if ( VAR_763 != ( TYPE_108 ) VAR_764 ) { VAR_765 = ( unsigned TYPE_109 * ) METHOD_154 ( VAR_766 ) ; METHOD_155 ( VAR_767 , ""UnableToReadImageData"" ) ; } switch ( VAR_768 ) { case 0xe0 : { VAR_769 = METHOD_156 ( ( const TYPE_110 * ) VAR_770 , VAR_771 ) ; METHOD_157 ( VAR_772 , VAR_773 ) ; VAR_774 = METHOD_158 ( VAR_775 , ""icc"" , VAR_776 , VAR_777 ) ; VAR_778 = METHOD_159 ( VAR_779 ) ; if ( VAR_780 == VAR_781 ) { VAR_782 = ( unsigned TYPE_111 * ) METHOD_160 ( VAR_783 ) ; METHOD_161 ( VAR_784 , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { VAR_785 = METHOD_162 ( ( const TYPE_112 * ) VAR_786 , VAR_787 ) ; METHOD_163 ( VAR_788 , VAR_789 ) ; VAR_790 = METHOD_164 ( VAR_791 , ""iptc"" , VAR_792 , VAR_793 ) ; if ( VAR_794 == VAR_795 ) { VAR_796 = ( unsigned TYPE_113 * ) METHOD_165 ( VAR_797 ) ; METHOD_166 ( VAR_798 , ""MemoryAllocationFailed"" ) ; } VAR_799 = METHOD_167 ( VAR_800 ) ; break ; } default : break ; } VAR_801 = ( unsigned TYPE_114 * ) METHOD_168 ( VAR_802 ) ; break ; } default : { if ( VAR_803 [ VAR_804 ] . VAR_805 == - 1 ) ( TYPE_115 ) METHOD_169 ( VAR_806 ) ; else for ( VAR_807 = 0 ; VAR_808 < ( TYPE_116 ) VAR_809 [ VAR_810 ] . VAR_811 ; VAR_812 ++ ) if ( METHOD_170 ( VAR_813 ) == VAR_814 ) break ; } } } if ( VAR_815 == 0xc00 ) { for ( VAR_816 = 0 ; VAR_817 < 24 ; VAR_818 ++ ) if ( METHOD_171 ( VAR_819 ) == VAR_820 ) break ; continue ; } if ( ( ( VAR_821 >= 0xb0 ) && ( VAR_822 <= 0xcf ) ) || ( ( VAR_823 >= 0x8000 ) && ( VAR_824 <= 0x80ff ) ) ) continue ; if ( VAR_825 == 0x8200 ) { TYPE_117 VAR_826 [ VAR_827 ] ; TYPE_118 * VAR_828 ; TYPE_119 VAR_829 ; VAR_830 = VAR_831 ; VAR_832 = METHOD_172 ( VAR_833 ) ; METHOD_173 ( VAR_834 , ( TYPE_120 * ) VAR_835 , 0 ) ; VAR_836 = ( TYPE_121 * ) VAR_837 ; VAR_838 = METHOD_174 ( VAR_839 ) ; ( TYPE_122 ) METHOD_175 ( VAR_840 -> VAR_841 , VAR_842 , ""jpeg:%s"" , VAR_843 ) ; if ( VAR_844 != - 1 ) VAR_845 = METHOD_176 ( VAR_846 , ""wb"" ) ; if ( ( VAR_847 == - 1 ) || ( VAR_848 == ( TYPE_123 * ) VAR_849 ) ) { ( TYPE_124 ) METHOD_177 ( VAR_850 -> VAR_851 ) ; ( TYPE_125 ) METHOD_178 ( VAR_852 -> VAR_853 , VAR_854 -> VAR_855 , VAR_856 ) ; METHOD_179 ( VAR_857 , ""UnableToCreateTemporaryFile"" ) ; } VAR_858 = METHOD_180 ( VAR_859 ) ; <S2SV_StartBug> if ( VAR_860 > 154 ) <S2SV_EndBug> { for ( VAR_861 = 0 ; VAR_862 < 6 ; VAR_863 ++ ) ( TYPE_126 ) METHOD_181 ( VAR_864 ) ; if ( METHOD_182 ( VAR_865 , & VAR_866 ) == VAR_867 ) { ( TYPE_127 ) METHOD_183 ( VAR_868 ) ; ( TYPE_128 ) METHOD_184 ( VAR_869 -> VAR_870 ) ; METHOD_185 ( VAR_871 , ""ImproperImageHeader"" ) ; } for ( VAR_872 = 0 ; VAR_873 < 122 ; VAR_874 ++ ) if ( METHOD_186 ( VAR_875 ) == VAR_876 ) break ; for ( VAR_877 = 0 ; VAR_878 < ( TYPE_129 ) ( VAR_879 - 154 ) ; VAR_880 ++ ) { VAR_881 = METHOD_187 ( VAR_882 ) ; if ( VAR_883 == VAR_884 ) break ; if ( METHOD_188 ( VAR_885 , VAR_886 ) != VAR_887 ) break ; } } ( TYPE_130 ) METHOD_189 ( VAR_888 ) ; ( TYPE_131 ) METHOD_190 ( VAR_889 ) ; VAR_890 = METHOD_191 ( VAR_891 , VAR_892 ) ; ( TYPE_132 ) METHOD_192 ( VAR_893 ) ; VAR_894 = METHOD_193 ( VAR_895 ) ; if ( VAR_896 == ( TYPE_133 * ) VAR_897 ) continue ; ( TYPE_134 ) METHOD_194 ( VAR_898 , VAR_899 , ""%.20gx%.20g"" , ( TYPE_135 ) METHOD_195 ( VAR_900 -> VAR_901 , VAR_902 -> VAR_903 ) , ( TYPE_136 ) METHOD_196 ( VAR_904 -> VAR_905 , VAR_906 -> VAR_907 ) ) ; ( TYPE_137 ) METHOD_197 ( VAR_908 , METHOD_198 ( VAR_909 -> VAR_910 , VAR_911 -> VAR_912 ) , METHOD_199 ( VAR_913 -> VAR_914 , VAR_915 -> VAR_916 ) , VAR_917 ) ; ( TYPE_138 ) METHOD_200 ( VAR_918 , VAR_919 -> VAR_920 , VAR_921 ) ; ( TYPE_139 ) METHOD_201 ( VAR_922 , VAR_923 , VAR_924 , VAR_925 , ( TYPE_140 ) VAR_926 . VAR_927 , ( TYPE_141 ) VAR_928 . VAR_929 , VAR_930 ) ; VAR_931 -> VAR_932 = VAR_933 -> VAR_934 ; VAR_935 = METHOD_202 ( VAR_936 ) ; continue ; } if ( ( VAR_937 == 0xff ) || ( VAR_938 == 0xffff ) ) break ; if ( ( ( VAR_939 >= 0xd0 ) && ( VAR_940 <= 0xfe ) ) || ( ( VAR_941 >= 0x8100 ) && ( VAR_942 <= 0xffff ) ) ) { VAR_943 = METHOD_203 ( VAR_944 ) ; <S2SV_StartBug> for ( VAR_945 = 0 ; VAR_946 < ( TYPE_142 ) VAR_947 ; VAR_948 ++ ) <S2SV_EndBug> if ( METHOD_204 ( VAR_949 ) == VAR_950 ) break ; continue ; } if ( ( VAR_951 >= 0x100 ) && ( VAR_952 <= 0x7fff ) ) { VAR_953 = ( TYPE_143 ) ( ( VAR_954 >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( VAR_955 = 0 ; VAR_956 < ( TYPE_144 ) VAR_957 ; VAR_958 ++ ) <S2SV_EndBug> if ( METHOD_205 ( VAR_959 ) == VAR_960 ) break ; continue ; } } ( TYPE_145 ) METHOD_206 ( VAR_961 ) ; return ( METHOD_207 ( VAR_962 ) ) ; }","<S2SV_ModStart> , VAR_13 ) \\\n{ <S2SV_ModEnd> if ( VAR_936 <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> TYPE_117 VAR_898 [ <S2SV_ModStart> if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" ) ; if ( VAR_957 <S2SV_ModStart> ; if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> METHOD_203 ( VAR_962 ) ; if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" <S2SV_ModStart> METHOD_203 ( VAR_962 ) ; if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" <S2SV_ModStart> METHOD_203 ( VAR_962 ) ; if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" ) ; if ( VAR_957 <S2SV_ModStart> ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" ) ; if ( VAR_957 > <S2SV_ModStart> VAR_962 ) ; if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> 0xff ) ; if ( VAR_957 > METHOD_208 ( VAR_962 ) ) METHOD_185 ( VAR_871 , ""InsufficientImageDataInFile"" ) ;","CWE-119 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug>   ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break ; } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;"
723,"CWE-125 TYPE_0 <S2SV_StartBug> METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 <S2SV_EndBug> VAR_4 , TYPE_6 VAR_5 , TYPE_7 * VAR_6 ) { TYPE_8 VAR_7 ; if ( ! VAR_8 ) { METHOD_1 ( VAR_9 , ""field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign"" ) ; return VAR_10 ; } VAR_11 = ( TYPE_9 ) METHOD_2 ( VAR_12 , sizeof ( * VAR_13 ) ) ; if ( ! VAR_14 ) return VAR_15 ; VAR_16 -> VAR_17 = VAR_18 ; VAR_19 -> VAR_20 . METHOD_3 . VAR_21 = VAR_22 ; VAR_23 -> VAR_24 . METHOD_4 . VAR_25 = VAR_26 ; <S2SV_StartBug> VAR_27 -> VAR_28 = VAR_29 ; <S2SV_EndBug> VAR_30 -> VAR_31 = VAR_32 ; VAR_33 -> VAR_34 = VAR_35 ; VAR_36 -> VAR_37 = VAR_38 ; return VAR_39 ; }","<S2SV_ModStart> TYPE_2 VAR_26 , TYPE_10 VAR_40 , <S2SV_ModStart> ; VAR_39 -> VAR_24 . METHOD_4 . VAR_40 = VAR_40 ; VAR_39 ->","CWE-125 stmt_ty <S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->"
724,"CWE-400 static TYPE_0 METHOD_0 ( enum VAR_0 VAR_1 , TYPE_1 VAR_2 , <S2SV_StartBug> TYPE_2 VAR_3 , TYPE_3 VAR_4 , <S2SV_EndBug> struct STRUCT_OR_UNION_0 * VAR_5 , struct STRUCT_OR_UNION_1 * VAR_6 ) { struct STRUCT_OR_UNION_2 * VAR_7 = & METHOD_1 ( STRUCT_OR_UNION_3 ) ; struct STRUCT_OR_UNION_4 * VAR_8 ; struct STRUCT_OR_UNION_5 * VAR_9 ; struct STRUCT_OR_UNION_6 * VAR_10 ; METHOD_2 ( ) ; VAR_11 = METHOD_3 ( VAR_12 , VAR_13 , VAR_14 ) ; if ( ! VAR_15 ) goto VAR_16 ; METHOD_4 ( VAR_17 , VAR_18 , VAR_19 , VAR_20 ) { if ( METHOD_5 ( VAR_21 , VAR_22 , VAR_23 , VAR_24 , VAR_25 ) ) <S2SV_StartBug> METHOD_6 ( VAR_26 , VAR_27 , VAR_28 , VAR_29 , VAR_30 ) ; <S2SV_EndBug> } VAR_31 : METHOD_7 ( ) ; }","<S2SV_ModStart> , TYPE_2 VAR_27 <S2SV_ModEnd> , struct STRUCT_OR_UNION_0 <S2SV_ModStart> , VAR_27 , <S2SV_ModEnd> VAR_29 , VAR_30","CWE-400 static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> } end : rcu_read_unlock ( ) ; }","<S2SV_ModStart> , u64 nr <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> , nr , <S2SV_ModEnd> data , regs"
725,"CWE-125 <S2SV_StartBug> TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 ) { <S2SV_EndBug> TYPE_3 VAR_3 = 0 ; TYPE_4 VAR_4 = 0 ; TYPE_5 VAR_5 = 0 ; TYPE_6 VAR_6 = 0 ; TYPE_7 VAR_7 = 0 ; TYPE_8 * VAR_8 = VAR_9 ; <S2SV_StartBug> if ( VAR_10 [ 0 ] >= 0x80 ) { <S2SV_EndBug> VAR_11 = * VAR_12 & 0xf0 ; VAR_13 = * VAR_14 ++ & 0x0f ; <S2SV_StartBug> VAR_15 ++ ; <S2SV_EndBug> } else { VAR_16 = VAR_17 & 0xf0 ; VAR_18 = VAR_19 & 0x0f ; } switch ( VAR_20 ) { case 0x80 : VAR_21 : <S2SV_StartBug> VAR_22 = * VAR_23 ++ ; <S2SV_EndBug> VAR_24 = * VAR_25 ++ ; METHOD_1 ( VAR_26 , VAR_27 , VAR_28 , VAR_29 ) ; VAR_30 += 2 ; break ; case 0x90 : if ( VAR_31 [ 1 ] == 0 ) goto VAR_32 ; <S2SV_StartBug> VAR_33 = * VAR_34 ++ ; <S2SV_EndBug> VAR_35 = * VAR_36 ++ ; METHOD_2 ( VAR_37 , VAR_38 , VAR_39 , VAR_40 ) ; VAR_41 += 2 ; break ; case 0xa0 : <S2SV_StartBug> VAR_42 = * VAR_43 ++ ; <S2SV_EndBug> VAR_44 = * VAR_45 ++ ; METHOD_3 ( VAR_46 , VAR_47 , VAR_48 , VAR_49 ) ; VAR_50 += 2 ; break ; case 0xb0 : <S2SV_StartBug> VAR_51 = * VAR_52 ++ ; <S2SV_EndBug> VAR_53 = * VAR_54 ++ ; METHOD_4 ( VAR_55 , VAR_56 , VAR_57 , VAR_58 ) ; VAR_59 += 2 ; break ; case 0xc0 : VAR_60 = * VAR_61 ++ ; METHOD_5 ( VAR_62 , VAR_63 , VAR_64 ) ; VAR_65 ++ ; break ; case 0xd0 : VAR_66 = * VAR_67 ++ ; METHOD_6 ( VAR_68 , VAR_69 , VAR_70 ) ; VAR_71 ++ ; break ; case 0xe0 : <S2SV_StartBug> VAR_72 = * VAR_73 ++ ; <S2SV_EndBug> VAR_74 = * VAR_75 ++ ; METHOD_7 ( VAR_76 , VAR_77 , ( ( VAR_78 << 7 ) | ( VAR_79 & 0x7f ) ) ) ; VAR_80 += 2 ; break ; case 0xf0 : if ( VAR_81 == 0x0f ) { TYPE_9 VAR_82 = 0 ; if ( ( VAR_83 [ 0 ] == 0x00 ) && ( VAR_84 [ 1 ] == 0x02 ) ) { <S2SV_StartBug> METHOD_8 ( VAR_85 , ( ( VAR_86 [ 2 ] << 8 ) + VAR_87 [ 3 ] ) ) ; <S2SV_EndBug> VAR_88 += 4 ; } else if ( VAR_89 [ 0 ] == 0x01 ) { VAR_90 ++ ; VAR_91 ++ ; <S2SV_StartBug> if ( * VAR_92 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_93 = ( VAR_94 << 7 ) + ( * VAR_95 & 0x7f ) ; VAR_96 ++ ; <S2SV_StartBug> VAR_97 ++ ; <S2SV_EndBug> } while ( * VAR_98 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_99 = ( VAR_100 << 7 ) + ( * VAR_101 & 0x7f ) ; VAR_102 ++ ; VAR_103 ++ ; <S2SV_StartBug> VAR_104 = METHOD_9 ( VAR_105 + 1 ) ; <S2SV_EndBug> METHOD_10 ( VAR_106 , VAR_107 , VAR_108 ) ; VAR_109 [ VAR_110 ] = '\\0' ; METHOD_11 ( VAR_111 , VAR_112 ) ; VAR_113 += VAR_114 ; } else if ( VAR_115 [ 0 ] == 0x02 ) { VAR_116 ++ ; VAR_117 ++ ; <S2SV_StartBug> if ( * VAR_118 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_119 = ( VAR_120 << 7 ) + ( * VAR_121 & 0x7f ) ; VAR_122 ++ ; <S2SV_StartBug> VAR_123 ++ ; <S2SV_EndBug> } while ( * VAR_124 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_125 = ( VAR_126 << 7 ) + ( * VAR_127 & 0x7f ) ; VAR_128 ++ ; <S2SV_StartBug> VAR_129 ++ ; <S2SV_EndBug> if ( VAR_130 -> VAR_131 . VAR_132 ) { VAR_133 -> VAR_134 . VAR_135 = METHOD_12 ( VAR_136 -> VAR_137 . VAR_138 , ( METHOD_13 ( VAR_139 -> VAR_140 . VAR_141 ) + 1 + VAR_142 + 1 ) ) ; METHOD_14 ( & VAR_143 -> VAR_144 . VAR_145 [ METHOD_15 ( VAR_146 -> VAR_147 . VAR_148 ) + 1 ] , VAR_149 , VAR_150 ) ; VAR_151 -> VAR_152 . VAR_153 [ METHOD_16 ( VAR_154 -> VAR_155 . VAR_156 ) + 1 + VAR_157 ] = '\\0' ; VAR_158 -> VAR_159 . VAR_160 [ METHOD_17 ( VAR_161 -> VAR_162 . VAR_163 ) ] = '\\n' ; } else { VAR_164 -> VAR_165 . VAR_166 = METHOD_18 ( VAR_167 + 1 ) ; METHOD_19 ( VAR_168 -> VAR_169 . VAR_170 , VAR_171 , VAR_172 ) ; VAR_173 -> VAR_174 . VAR_175 [ VAR_176 ] = '\\0' ; } VAR_177 = METHOD_20 ( VAR_178 + 1 ) ; METHOD_21 ( VAR_179 , VAR_180 , VAR_181 ) ; VAR_182 [ VAR_183 ] = '\\0' ; METHOD_22 ( VAR_184 , VAR_185 ) ; VAR_186 += VAR_187 ; } else if ( VAR_188 [ 0 ] == 0x03 ) { VAR_189 ++ ; VAR_190 ++ ; <S2SV_StartBug> if ( * VAR_191 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_192 = ( VAR_193 << 7 ) + ( * VAR_194 & 0x7f ) ; VAR_195 ++ ; <S2SV_StartBug> VAR_196 ++ ; <S2SV_EndBug> } while ( * VAR_197 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_198 = ( VAR_199 << 7 ) + ( * VAR_200 & 0x7f ) ; VAR_201 ++ ; VAR_202 ++ ; <S2SV_StartBug> VAR_203 = METHOD_23 ( VAR_204 + 1 ) ; <S2SV_EndBug> METHOD_24 ( VAR_205 , VAR_206 , VAR_207 ) ; VAR_208 [ VAR_209 ] = '\\0' ; METHOD_25 ( VAR_210 , VAR_211 ) ; VAR_212 += VAR_213 ; } else if ( VAR_214 [ 0 ] == 0x04 ) { VAR_215 ++ ; VAR_216 ++ ; <S2SV_StartBug> if ( * VAR_217 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_218 = ( VAR_219 << 7 ) + ( * VAR_220 & 0x7f ) ; VAR_221 ++ ; <S2SV_StartBug> VAR_222 ++ ; <S2SV_EndBug> } while ( * VAR_223 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_224 = ( VAR_225 << 7 ) + ( * VAR_226 & 0x7f ) ; VAR_227 ++ ; VAR_228 ++ ; <S2SV_StartBug> VAR_229 = METHOD_26 ( VAR_230 + 1 ) ; <S2SV_EndBug> METHOD_27 ( VAR_231 , VAR_232 , VAR_233 ) ; VAR_234 [ VAR_235 ] = '\\0' ; METHOD_28 ( VAR_236 , VAR_237 ) ; VAR_238 += VAR_239 ; } else if ( VAR_240 [ 0 ] == 0x05 ) { VAR_241 ++ ; VAR_242 ++ ; <S2SV_StartBug> if ( * VAR_243 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_244 = ( VAR_245 << 7 ) + ( * VAR_246 & 0x7f ) ; VAR_247 ++ ; <S2SV_StartBug> VAR_248 ++ ; <S2SV_EndBug> } while ( * VAR_249 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_250 = ( VAR_251 << 7 ) + ( * VAR_252 & 0x7f ) ; VAR_253 ++ ; VAR_254 ++ ; <S2SV_StartBug> VAR_255 = METHOD_29 ( VAR_256 + 1 ) ; <S2SV_EndBug> METHOD_30 ( VAR_257 , VAR_258 , VAR_259 ) ; VAR_260 [ VAR_261 ] = '\\0' ; METHOD_31 ( VAR_262 , VAR_263 ) ; VAR_264 += VAR_265 ; } else if ( VAR_266 [ 0 ] == 0x06 ) { VAR_267 ++ ; VAR_268 ++ ; <S2SV_StartBug> if ( * VAR_269 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_270 = ( VAR_271 << 7 ) + ( * VAR_272 & 0x7f ) ; VAR_273 ++ ; <S2SV_StartBug> VAR_274 ++ ; <S2SV_EndBug> } while ( * VAR_275 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_276 = ( VAR_277 << 7 ) + ( * VAR_278 & 0x7f ) ; VAR_279 ++ ; VAR_280 ++ ; <S2SV_StartBug> VAR_281 = METHOD_32 ( VAR_282 + 1 ) ; <S2SV_EndBug> METHOD_33 ( VAR_283 , VAR_284 , VAR_285 ) ; VAR_286 [ VAR_287 ] = '\\0' ; METHOD_34 ( VAR_288 , VAR_289 ) ; VAR_290 += VAR_291 ; } else if ( VAR_292 [ 0 ] == 0x07 ) { VAR_293 ++ ; VAR_294 ++ ; <S2SV_StartBug> if ( * VAR_295 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_296 = ( VAR_297 << 7 ) + ( * VAR_298 & 0x7f ) ; VAR_299 ++ ; <S2SV_StartBug> VAR_300 ++ ; <S2SV_EndBug> } while ( * VAR_301 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_302 = ( VAR_303 << 7 ) + ( * VAR_304 & 0x7f ) ; VAR_305 ++ ; VAR_306 ++ ; <S2SV_StartBug> VAR_307 = METHOD_35 ( VAR_308 + 1 ) ; <S2SV_EndBug> METHOD_36 ( VAR_309 , VAR_310 , VAR_311 ) ; VAR_312 [ VAR_313 ] = '\\0' ; METHOD_37 ( VAR_314 , VAR_315 ) ; VAR_316 += VAR_317 ; <S2SV_StartBug> } else if ( ( VAR_318 [ 0 ] == 0x20 ) && ( VAR_319 [ 1 ] == 0x01 ) ) { <S2SV_EndBug> METHOD_38 ( VAR_320 , VAR_321 [ 2 ] ) ; VAR_322 += 3 ; } else if ( ( VAR_323 [ 0 ] == 0x21 ) && ( VAR_324 [ 1 ] == 0x01 ) ) { <S2SV_StartBug> METHOD_39 ( VAR_325 , VAR_326 [ 2 ] ) ; <S2SV_EndBug> VAR_327 += 3 ; } else if ( ( VAR_328 [ 0 ] == 0x2F ) && ( VAR_329 [ 1 ] == 0x00 ) ) { <S2SV_StartBug> METHOD_40 ( VAR_330 ) ; <S2SV_EndBug> VAR_331 += 2 ; } else if ( ( VAR_332 [ 0 ] == 0x51 ) && ( VAR_333 [ 1 ] == 0x03 ) ) { <S2SV_StartBug> METHOD_41 ( VAR_334 , ( ( VAR_335 [ 2 ] << 16 ) + ( VAR_336 [ 3 ] << 8 ) + VAR_337 [ 4 ] ) ) ; <S2SV_EndBug> VAR_338 += 5 ; <S2SV_StartBug> } else if ( ( VAR_339 [ 0 ] == 0x54 ) && ( VAR_340 [ 1 ] == 0x05 ) ) { <S2SV_EndBug> METHOD_42 ( VAR_341 , ( ( VAR_342 [ 3 ] << 24 ) + ( VAR_343 [ 4 ] << 16 ) + ( VAR_344 [ 5 ] << 8 ) + VAR_345 [ 6 ] ) ) ; VAR_346 -> VAR_347 [ VAR_348 -> VAR_349 - 1 ] . VAR_350 . VAR_351 = VAR_352 [ 2 ] ; VAR_353 += 7 ; } else if ( ( VAR_354 [ 0 ] == 0x58 ) && ( VAR_355 [ 1 ] == 0x04 ) ) { <S2SV_StartBug> METHOD_43 ( VAR_356 , ( ( VAR_357 [ 2 ] << 24 ) + ( VAR_358 [ 3 ] << 16 ) + ( VAR_359 [ 4 ] << 8 ) + VAR_360 [ 5 ] ) ) ; <S2SV_EndBug> VAR_361 += 6 ; } else if ( ( VAR_362 [ 0 ] == 0x59 ) && ( VAR_363 [ 1 ] == 0x02 ) ) { <S2SV_StartBug> METHOD_44 ( VAR_364 , ( ( VAR_365 [ 2 ] << 8 ) + VAR_366 [ 3 ] ) ) ; <S2SV_EndBug> VAR_367 += 4 ; } else { VAR_368 ++ ; VAR_369 ++ ; <S2SV_StartBug> if ( * VAR_370 > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> VAR_371 = ( VAR_372 << 7 ) + ( * VAR_373 & 0x7f ) ; VAR_374 ++ ; <S2SV_StartBug> VAR_375 ++ ; <S2SV_EndBug> } while ( * VAR_376 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_377 = ( VAR_378 << 7 ) + ( * VAR_379 & 0x7f ) ; VAR_380 ++ ; VAR_381 += VAR_382 ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( ( VAR_383 == 0 ) || ( VAR_384 == 7 ) ) { TYPE_10 VAR_385 = 0 ; TYPE_11 * VAR_386 = VAR_387 ; if ( * VAR_388 > 0x7f ) { <S2SV_StartBug> do { <S2SV_EndBug> VAR_389 = ( VAR_390 << 7 ) + ( * VAR_391 & 0x7F ) ; VAR_392 ++ ; <S2SV_StartBug> VAR_393 ++ ; <S2SV_EndBug> } while ( * VAR_394 > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_395 = ( VAR_396 << 7 ) + ( * VAR_397 & 0x7F ) ; VAR_398 ++ ; <S2SV_StartBug> if ( ! VAR_399 ) break ; <S2SV_EndBug> VAR_400 ++ ; VAR_401 = METHOD_45 ( sizeof ( TYPE_12 ) * VAR_402 ) ; METHOD_46 ( VAR_403 , VAR_404 , VAR_405 ) ; if ( VAR_406 [ VAR_407 - 1 ] == 0xF7 ) { TYPE_13 VAR_408 [ ] = { 0x41 , 0x10 , 0x42 , 0x12 } ; if ( METHOD_47 ( VAR_409 , VAR_410 , 4 ) == 0 ) { TYPE_14 VAR_411 = 0 ; TYPE_15 VAR_412 = 4 ; do { VAR_413 += VAR_414 [ VAR_415 ] ; if ( VAR_416 > 0x7F ) { VAR_417 -= 0x80 ; } VAR_418 ++ ; } while ( VAR_419 [ VAR_420 + 1 ] != 0xf7 ) ; VAR_421 = 128 - VAR_422 ; if ( VAR_423 == VAR_424 [ VAR_425 ] ) { if ( VAR_426 [ 4 ] == 0x40 ) { if ( ( ( VAR_427 [ 5 ] & 0xf0 ) == 0x10 ) && ( VAR_428 [ 6 ] == 0x15 ) ) { TYPE_16 VAR_429 = 0x0f & VAR_430 [ 5 ] ; if ( VAR_431 == 0x00 ) { VAR_432 = 0x09 ; } else if ( VAR_433 <= 0x09 ) { VAR_434 -= 1 ; } METHOD_48 ( VAR_435 , VAR_436 , VAR_437 [ 7 ] ) ; } else if ( ( VAR_438 [ 5 ] == 0x00 ) && ( VAR_439 [ 6 ] == 0x7F ) && ( VAR_440 [ 7 ] == 0x00 ) ) { METHOD_49 ( VAR_441 ) ; } } } } else { TYPE_17 VAR_442 [ ] = { 0x7e , 0x7f , 0x09 , 0x01 , 0xf7 } ; TYPE_18 VAR_443 [ ] = { 0x43 , 0x10 , 0x4c , 0x00 , 0x00 , 0x7e , 0x00 , 0xf7 } ; if ( METHOD_50 ( VAR_444 , VAR_445 , 5 ) == 0 ) { METHOD_51 ( VAR_446 ) ; } else if ( METHOD_52 ( VAR_447 , VAR_448 , 8 ) == 0 ) { METHOD_53 ( VAR_449 ) ; } } } METHOD_54 ( VAR_450 ) ; VAR_451 = VAR_452 ; VAR_453 += VAR_454 ; } else { METHOD_55 ( VAR_455 , VAR_456 , VAR_457 , ""(unrecognized<S2SV_blank>meta<S2SV_blank>type<S2SV_blank>event)"" , 0 ) ; return 0 ; } break ; default : VAR_458 = 0 ; break ; } if ( VAR_459 == 0 ) METHOD_56 ( VAR_460 , VAR_461 , VAR_462 , ""(missing<S2SV_blank>event)"" , 0 ) ; return VAR_463 ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> * VAR_404 , TYPE_15 VAR_464 , <S2SV_ModStart> ; if ( ! VAR_464 ) goto VAR_465 ; if ( <S2SV_ModStart> ; VAR_463 ++ ; if ( -- VAR_464 == 0 ) goto VAR_465 <S2SV_ModStart> : VAR_32 : if ( VAR_464 < 2 ) goto VAR_465 ; <S2SV_ModStart> goto VAR_32 ; if ( VAR_464 < 2 ) goto VAR_465 ; <S2SV_ModStart> case 0xa0 : if ( VAR_464 < 2 ) goto VAR_465 ; <S2SV_ModStart> case 0xb0 : if ( VAR_464 < 2 ) goto VAR_465 ; <S2SV_ModStart> case 0xe0 : if ( VAR_464 < 2 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 4 ) goto VAR_465 ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> ; VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_463 ++ ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; if ( ! VAR_382 ) break ; <S2SV_ModStart> ) ) { if ( VAR_464 < 3 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 3 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 2 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 5 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 7 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 6 ) goto VAR_465 ; <S2SV_ModStart> ) ) { if ( VAR_464 < 4 ) goto VAR_465 ; <S2SV_ModStart> ; if ( -- VAR_464 && <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> += VAR_382 ; if ( -- VAR_464 < VAR_382 ) goto VAR_465 ; <S2SV_ModStart> { do { if ( ! VAR_464 ) break ; <S2SV_ModStart> VAR_404 ++ ; VAR_464 -- ; <S2SV_ModStart> ) ; } if ( ! VAR_464 ) goto VAR_465 ; <S2SV_ModStart> VAR_404 ++ ; VAR_463 ++ ; if ( -- VAR_464 < VAR_454 ) goto VAR_465 ; <S2SV_ModStart> VAR_454 ) break <S2SV_ModEnd> ; VAR_451 = <S2SV_ModStart> return VAR_463 ; VAR_465 : METHOD_56 ( VAR_460 , VAR_461 , VAR_462 , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ;","CWE-125 <S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xd0 : data_1 = * event_data ++ ; midi_setup_channel_pressure ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xe0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_pitch ( mdi , channel , ( ( data_2 << 7 ) | ( data_1 & 0x7f ) ) ) ; ret_cnt += 2 ; break ; case 0xf0 : if ( channel == 0x0f ) { uint32_t tmp_length = 0 ; if ( ( event_data [ 0 ] == 0x00 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else if ( event_data [ 0 ] == 0x01 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_text ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x02 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> if ( mdi -> extra_info . copyright ) { mdi -> extra_info . copyright = realloc ( mdi -> extra_info . copyright , ( strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length + 1 ) ) ; memcpy ( & mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 ] , event_data , tmp_length ) ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length ] = '\\0' ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) ] = '\\n' ; } else { mdi -> extra_info . copyright = malloc ( tmp_length + 1 ) ; memcpy ( mdi -> extra_info . copyright , event_data , tmp_length ) ; mdi -> extra_info . copyright [ tmp_length ] = '\\0' ; } text = malloc ( tmp_length + 1 ) ; memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_copyright ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x03 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_trackname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x04 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_instrumentname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x05 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_lyric ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x06 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_marker ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x07 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_cuepoint ( mdi , text ) ; ret_cnt += tmp_length ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ; ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x21 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x2F ) && ( event_data [ 1 ] == 0x00 ) ) { <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> ret_cnt += 2 ; } else if ( ( event_data [ 0 ] == 0x51 ) && ( event_data [ 1 ] == 0x03 ) ) { <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> ret_cnt += 5 ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ; mdi -> events [ mdi -> events_size - 1 ] . event_data . channel = event_data [ 2 ] ; ret_cnt += 7 ; } else if ( ( event_data [ 0 ] == 0x58 ) && ( event_data [ 1 ] == 0x04 ) ) { <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> ret_cnt += 6 ; } else if ( ( event_data [ 0 ] == 0x59 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; ret_cnt ++ ; ret_cnt += tmp_length ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( ( channel == 0 ) || ( channel == 7 ) ) { uint32_t sysex_len = 0 ; uint8_t * sysex_store = NULL ; if ( * event_data > 0x7f ) { <S2SV_StartBug> do { <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> ret_cnt ++ ; sysex_store = malloc ( sizeof ( uint8_t ) * sysex_len ) ; memcpy ( sysex_store , event_data , sysex_len ) ; if ( sysex_store [ sysex_len - 1 ] == 0xF7 ) { uint8_t rolandsysexid [ ] = { 0x41 , 0x10 , 0x42 , 0x12 } ; if ( memcmp ( rolandsysexid , sysex_store , 4 ) == 0 ) { uint8_t sysex_cs = 0 ; uint32_t sysex_ofs = 4 ; do { sysex_cs += sysex_store [ sysex_ofs ] ; if ( sysex_cs > 0x7F ) { sysex_cs -= 0x80 ; } sysex_ofs ++ ; } while ( sysex_store [ sysex_ofs + 1 ] != 0xf7 ) ; sysex_cs = 128 - sysex_cs ; if ( sysex_cs == sysex_store [ sysex_ofs ] ) { if ( sysex_store [ 4 ] == 0x40 ) { if ( ( ( sysex_store [ 5 ] & 0xf0 ) == 0x10 ) && ( sysex_store [ 6 ] == 0x15 ) ) { uint8_t sysex_ch = 0x0f & sysex_store [ 5 ] ; if ( sysex_ch == 0x00 ) { sysex_ch = 0x09 ; } else if ( sysex_ch <= 0x09 ) { sysex_ch -= 1 ; } midi_setup_sysex_roland_drum_track ( mdi , sysex_ch , sysex_store [ 7 ] ) ; } else if ( ( sysex_store [ 5 ] == 0x00 ) && ( sysex_store [ 6 ] == 0x7F ) && ( sysex_store [ 7 ] == 0x00 ) ) { midi_setup_sysex_roland_reset ( mdi ) ; } } } } else { uint8_t gm_reset [ ] = { 0x7e , 0x7f , 0x09 , 0x01 , 0xf7 } ; uint8_t yamaha_reset [ ] = { 0x43 , 0x10 , 0x4c , 0x00 , 0x00 , 0x7e , 0x00 , 0xf7 } ; if ( memcmp ( gm_reset , sysex_store , 5 ) == 0 ) { midi_setup_sysex_gm_reset ( mdi ) ; } else if ( memcmp ( yamaha_reset , sysex_store , 8 ) == 0 ) { midi_setup_sysex_yamaha_reset ( mdi ) ; } } } free ( sysex_store ) ; sysex_store = NULL ; ret_cnt += sysex_len ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(unrecognized<S2SV_blank>meta<S2SV_blank>type<S2SV_blank>event)"" , 0 ) ; return 0 ; } break ; default : ret_cnt = 0 ; break ; } if ( ret_cnt == 0 ) _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>event)"" , 0 ) ; return ret_cnt ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_ModStart> * event_data , uint32_t siz , <S2SV_ModStart> ; if ( ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart> sysex_len ) break <S2SV_ModEnd> ; sysex_store = <S2SV_ModStart> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ;"
726,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , TYPE_2 * VAR_1 [ ] ) { VAR_2 * VAR_3 ; TYPE_3 VAR_4 ; TYPE_4 VAR_5 ; unsigned TYPE_5 VAR_6 ; TYPE_6 * VAR_7 ; VAR_8 * VAR_9 ; VAR_10 * VAR_11 ; unsigned TYPE_7 * VAR_12 ; VAR_13 * VAR_14 , * VAR_15 ; TYPE_8 VAR_16 [ 50 ] ; TYPE_9 VAR_17 ; if ( VAR_18 != 3 ) { METHOD_1 ( ""Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n"" , VAR_19 [ 0 ] ) ; METHOD_2 ( ""Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n"" , VAR_20 [ 0 ] ) ; return 1 ; } VAR_21 = METHOD_3 ( VAR_22 [ 1 ] , ""rb"" ) ; if ( ! VAR_23 ) { METHOD_4 ( VAR_24 , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n"" , VAR_25 [ 1 ] ) ; return 1 ; } METHOD_5 ( & VAR_26 , 0 , sizeof ( TYPE_10 ) ) ; VAR_27 . VAR_28 = VAR_29 ; VAR_30 . VAR_31 = VAR_32 ; VAR_33 . VAR_34 = VAR_35 ; VAR_36 = METHOD_6 ( ) ; METHOD_7 ( ( TYPE_11 ) VAR_37 , & VAR_38 , VAR_39 ) ; METHOD_8 ( & VAR_40 , 0 , sizeof ( TYPE_12 ) ) ; VAR_41 = ( TYPE_13 * ) VAR_42 -> VAR_43 ; METHOD_9 ( VAR_44 , & VAR_45 ) ; if ( METHOD_10 ( VAR_46 , VAR_47 ) ) { return 1 ; } VAR_48 = 0 ; while ( VAR_49 -> VAR_50 [ VAR_51 ] . VAR_52 != 0 ) { VAR_53 ++ ; } VAR_54 = & VAR_55 -> VAR_56 [ VAR_57 ] ; METHOD_11 ( VAR_58 , ""Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n"" , VAR_59 -> VAR_60 ) ; for ( VAR_61 = 0 ; VAR_62 < VAR_63 -> VAR_64 ; VAR_65 ++ ) { VAR_66 = & VAR_67 -> VAR_68 [ VAR_69 ] ; VAR_70 = ( unsigned TYPE_14 * ) METHOD_12 ( VAR_71 -> VAR_72 - 8 ) ; METHOD_13 ( VAR_73 , VAR_74 -> VAR_75 + 8 , VAR_76 ) ; METHOD_14 ( VAR_77 , VAR_78 -> VAR_79 - 8 , 1 , VAR_80 ) ; <S2SV_StartBug> METHOD_15 ( VAR_81 , ""%s_%05d.j2k"" , VAR_82 [ 2 ] , VAR_83 ) ; <S2SV_EndBug> VAR_84 = METHOD_16 ( VAR_85 , ""wb"" ) ; if ( ! VAR_86 ) { METHOD_17 ( VAR_87 , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , VAR_88 ) ; return 1 ; } METHOD_18 ( VAR_89 , VAR_90 -> VAR_91 - 8 , 1 , VAR_92 ) ; METHOD_19 ( VAR_93 ) ; METHOD_20 ( VAR_94 ) ; } METHOD_21 ( VAR_95 ) ; METHOD_22 ( VAR_96 , ""%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n"" , VAR_97 ) ; if ( VAR_98 ) { METHOD_23 ( ( TYPE_15 * ) VAR_99 -> VAR_100 ) ; } return 0 ; }","<S2SV_ModStart> VAR_95 ) ; TYPE_5 VAR_101 = METHOD_24 <S2SV_ModEnd> ( VAR_88 , <S2SV_ModStart> ( VAR_88 , sizeof ( VAR_88 ) , <S2SV_ModStart> VAR_97 ) ; if ( VAR_101 >= sizeof ( VAR_88 ) ) { METHOD_22 ( VAR_87 , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; return 1 ; }","CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n"" , argv [ 0 ] ) ; printf ( ""Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n"" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , ""rb"" ) ; if ( ! file ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n"" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf ( stdout , ""Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n"" , track -> num_samples ) ; for ( snum = 0 ; snum < track -> num_samples ; snum ++ ) { sample = & track -> sample [ snum ] ; frame_codestream = ( unsigned char * ) malloc ( sample -> sample_size - 8 ) ; fseek ( file , sample -> offset + 8 , SEEK_SET ) ; fread ( frame_codestream , sample -> sample_size - 8 , 1 , file ) ; <S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> outfile = fopen ( outfilename , ""wb"" ) ; if ( ! outfile ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfilename ) ; return 1 ; } fwrite ( frame_codestream , sample -> sample_size - 8 , 1 , outfile ) ; fclose ( outfile ) ; free ( frame_codestream ) ; } fclose ( file ) ; fprintf ( stdout , ""%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n"" , snum ) ; if ( dinfo ) { mj2_destroy_decompress ( ( opj_mj2_t * ) dinfo -> mj2_handle ) ; } return 0 ; }","<S2SV_ModStart> file ) ; int num = snprintf <S2SV_ModEnd> ( outfilename , <S2SV_ModStart> ( outfilename , sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; return 1 ; }"
727,"CWE-200 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 ) { VAR_2 * VAR_3 ; TYPE_3 VAR_4 ; unsigned TYPE_4 TYPE_5 ; VAR_5 = 0 ; METHOD_1 ( VAR_6 , & VAR_7 -> VAR_8 , VAR_9 ) { if ( VAR_10 > VAR_11 ) break ; <S2SV_StartBug> METHOD_2 ( & VAR_12 [ VAR_13 ] , 0 , VAR_14 ) ; <S2SV_EndBug> VAR_15 [ VAR_16 ] . VAR_17 = VAR_18 -> VAR_19 + 1 ; VAR_20 [ VAR_21 ] . VAR_22 = VAR_23 -> VAR_24 . VAR_25 & VAR_26 -> VAR_27 . VAR_28 & VAR_29 -> VAR_30 . VAR_31 ; if ( VAR_32 -> VAR_33 ) VAR_34 [ VAR_35 ] . VAR_36 = VAR_37 -> VAR_38 . VAR_39 ; else { TYPE_6 = METHOD_3 ( VAR_40 ) ; VAR_41 [ VAR_42 ] . VAR_43 = ( TYPE_7 > VAR_44 -> VAR_45 . VAR_46 ) ? ( TYPE_8 - VAR_47 -> VAR_48 . VAR_49 ) : 0 ; } VAR_50 [ VAR_51 ] . VAR_52 = VAR_53 -> VAR_54 ; VAR_55 [ VAR_56 ] . VAR_57 = VAR_58 -> VAR_59 ; VAR_60 [ VAR_61 ] . VAR_62 = VAR_63 -> VAR_64 . VAR_65 ; VAR_66 [ VAR_67 ] . VAR_68 = VAR_69 -> VAR_70 . VAR_71 ; VAR_72 ++ ; } }",<S2SV_ModStart> ) break ; <S2SV_ModEnd> VAR_66 [ VAR_72,"CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }",<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
728,"CWE-125 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 * VAR_2 ) { TYPE_4 * VAR_3 = VAR_4 ; TYPE_5 VAR_5 ; TYPE_6 VAR_6 ; VAR_7 * VAR_8 ; TYPE_7 VAR_9 ; <S2SV_StartBug> if ( METHOD_1 ( VAR_10 , & VAR_11 ) ) { <S2SV_EndBug> TYPE_8 TYPE_9 ; VAR_12 = METHOD_2 ( VAR_13 , & VAR_14 ) ; <S2SV_StartBug> if ( VAR_15 == VAR_16 ) goto VAR_17 ; <S2SV_EndBug> TYPE_10 = METHOD_3 ( VAR_18 , & VAR_19 , VAR_20 ) ; if ( TYPE_11 != 0 ) goto VAR_21 ; METHOD_4 ( VAR_22 ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( VAR_23 , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( METHOD_5 ( VAR_24 , & VAR_25 ) ) { <S2SV_EndBug> TYPE_12 TYPE_13 ; VAR_26 = METHOD_6 ( VAR_27 , & VAR_28 ) ; <S2SV_StartBug> if ( VAR_29 == VAR_30 ) goto VAR_31 ; <S2SV_EndBug> TYPE_14 = METHOD_7 ( VAR_32 , & VAR_33 , VAR_34 ) ; if ( TYPE_15 != 0 ) goto VAR_35 ; METHOD_8 ( VAR_36 ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( VAR_37 , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } if ( METHOD_9 ( VAR_38 , & VAR_39 ) ) { TYPE_16 TYPE_17 ; TYPE_18 VAR_40 ; <S2SV_StartBug> TYPE_19 VAR_41 ; <S2SV_EndBug> VAR_42 = METHOD_10 ( VAR_43 , & VAR_44 ) ; if ( VAR_45 == VAR_46 ) goto VAR_47 ; if ( ! METHOD_11 ( VAR_48 ) ) { PyErr_Format ( VAR_49 , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , VAR_50 -> VAR_51 -> VAR_52 ) ; goto VAR_53 ; } VAR_54 = METHOD_12 ( VAR_55 ) ; VAR_56 = METHOD_13 ( VAR_57 , VAR_58 ) ; if ( VAR_59 == VAR_60 ) goto VAR_61 ; for ( VAR_62 = 0 ; VAR_63 < VAR_64 ; VAR_65 ++ ) { <S2SV_StartBug> TYPE_20 VAR_66 ; <S2SV_EndBug> <S2SV_StartBug> TYPE_21 = METHOD_14 ( METHOD_15 ( VAR_67 , VAR_68 ) , & VAR_69 , VAR_70 ) ; <S2SV_EndBug> if ( TYPE_22 != 0 ) goto VAR_71 ; if ( VAR_72 != METHOD_16 ( VAR_73 ) ) { PyErr_SetString ( VAR_74 , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto VAR_75 ; } <S2SV_StartBug> METHOD_17 ( VAR_76 , VAR_77 , VAR_78 ) ; <S2SV_EndBug> } METHOD_18 ( VAR_79 ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( VAR_80 , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( METHOD_19 ( VAR_81 , & VAR_82 ) ) { <S2SV_EndBug> TYPE_23 TYPE_24 ; VAR_83 = METHOD_20 ( VAR_84 , & VAR_85 ) ; <S2SV_StartBug> if ( VAR_86 == VAR_87 ) goto VAR_88 ; <S2SV_EndBug> TYPE_25 = METHOD_21 ( VAR_89 , & VAR_90 , VAR_91 ) ; if ( TYPE_26 != 0 ) goto VAR_92 ; <S2SV_StartBug> METHOD_22 ( VAR_93 ) ; <S2SV_EndBug> } else { PyErr_SetString ( VAR_94 , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } * VAR_95 = METHOD_23 ( VAR_96 , VAR_97 , VAR_98 , VAR_99 , VAR_100 ) ; return 0 ; VAR_101 : METHOD_24 ( VAR_102 ) ; return 1 ; }","<S2SV_ModStart> ; if ( METHOD_25 <S2SV_ModEnd> ( VAR_84 , <S2SV_ModStart> , & VAR_14 , & VAR_102 ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( VAR_102 <S2SV_ModStart> == VAR_87 ) { PyErr_SetString ( VAR_94 , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { TYPE_23 TYPE_26 <S2SV_ModEnd> ; TYPE_26 = <S2SV_ModStart> ) ; } if ( METHOD_25 <S2SV_ModEnd> ( VAR_84 , <S2SV_ModStart> , & VAR_28 , & VAR_102 ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( VAR_102 <S2SV_ModStart> == VAR_87 ) { PyErr_SetString ( VAR_94 , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { TYPE_23 TYPE_26 <S2SV_ModEnd> ; TYPE_26 = <S2SV_ModStart> ) ; } if ( METHOD_25 ( VAR_84 , & VAR_44 , & VAR_102 ) < 0 ) { return 1 ; } if ( VAR_102 == VAR_87 ) { PyErr_SetString ( VAR_94 , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { TYPE_23 TYPE_26 <S2SV_ModStart> ; TYPE_19 VAR_77 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { TYPE_20 VAR_103 <S2SV_ModEnd> ; TYPE_26 = <S2SV_ModStart> ) , & VAR_103 <S2SV_ModEnd> , VAR_100 ) <S2SV_ModStart> , VAR_77 , VAR_103 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( METHOD_25 <S2SV_ModEnd> ( VAR_84 , <S2SV_ModStart> , & VAR_85 , & VAR_102 ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( VAR_102 <S2SV_ModStart> == VAR_87 ) { PyErr_SetString ( VAR_94 , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { TYPE_23 TYPE_26 <S2SV_ModEnd> ; TYPE_26 = <S2SV_ModStart> ( VAR_102 ) <S2SV_ModEnd> ; } *","CWE-125 int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *"
729,"CWE-125 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * STRUCT_OR_UNION_1 , struct STRUCT_OR_UNION_2 * VAR_0 , struct STRUCT_OR_UNION_3 * VAR_1 , TYPE_1 ( * METHOD_1 ) ( struct STRUCT_OR_UNION_4 * , struct STRUCT_OR_UNION_5 * , struct STRUCT_OR_UNION_6 * ) ) { struct STRUCT_OR_UNION_7 * VAR_2 ; struct STRUCT_OR_UNION_8 * VAR_3 = ( struct STRUCT_OR_UNION_9 * ) METHOD_2 ( VAR_4 ) ; struct STRUCT_OR_UNION_10 * VAR_5 = VAR_6 -> VAR_7 && ! METHOD_3 ( ) ? METHOD_4 ( VAR_8 -> VAR_9 ) : VAR_10 ; struct STRUCT_OR_UNION_11 * VAR_11 ; struct STRUCT_OR_UNION_12 * VAR_12 ; unsigned TYPE_2 VAR_13 , VAR_14 , VAR_15 , VAR_16 ; TYPE_3 VAR_17 , VAR_18 ; TYPE_4 VAR_19 ; TYPE_5 VAR_20 , VAR_21 = 0 , VAR_22 = 0 ; VAR_23 * VAR_24 , VAR_25 = 0 ; <S2SV_StartBug> VAR_26 = METHOD_5 ( VAR_27 , & VAR_28 ) ; <S2SV_EndBug> VAR_29 = * VAR_30 ; VAR_31 = METHOD_6 ( VAR_32 ) ; if ( METHOD_7 ( ! VAR_33 -> VAR_34 && VAR_35 -> VAR_36 > VAR_37 ) ) goto VAR_38 ; if ( METHOD_8 ( VAR_39 ) -> VAR_40 ) { if ( METHOD_9 ( VAR_41 ) -> VAR_42 > VAR_43 ) goto VAR_44 ; VAR_45 = METHOD_10 ( VAR_46 ) -> VAR_47 ; if ( VAR_48 < VAR_49 ) VAR_50 = VAR_51 ; } if ( VAR_52 && VAR_53 -> VAR_54 < VAR_55 ) { if ( VAR_56 -> VAR_57 ) VAR_58 = VAR_59 -> VAR_60 ; } if ( VAR_61 < VAR_62 + sizeof ( struct STRUCT_OR_UNION_13 ) + 8 ) goto VAR_63 ; VAR_64 -= VAR_65 + sizeof ( struct STRUCT_OR_UNION_14 ) ; VAR_66 = METHOD_11 ( STRUCT_OR_UNION_15 , & METHOD_12 ( VAR_67 ) -> VAR_68 , & METHOD_13 ( VAR_69 ) -> VAR_70 ) ; if ( VAR_71 -> VAR_72 == VAR_73 && ( VAR_74 = METHOD_14 ( VAR_75 ) ) ) goto VAR_76 ; VAR_77 = METHOD_15 ( VAR_78 -> VAR_79 . VAR_80 ) ; if ( METHOD_16 ( VAR_81 ) ) { unsigned TYPE_6 VAR_82 = METHOD_17 ( VAR_83 ) ; struct STRUCT_OR_UNION_16 * VAR_84 ; if ( VAR_85 - VAR_86 > VAR_87 || ( ( VAR_88 - VAR_89 ) & 7 ) || METHOD_18 ( VAR_90 ) || METHOD_19 ( VAR_91 ) < ( VAR_92 + sizeof ( struct STRUCT_OR_UNION_17 ) ) ) goto VAR_93 ; METHOD_20 ( VAR_94 , VAR_95 ) { if ( VAR_96 -> VAR_97 > VAR_98 || ( ( VAR_99 -> VAR_100 & 7 ) && VAR_101 -> VAR_102 ) || METHOD_21 ( VAR_103 ) < ( VAR_104 + VAR_105 + sizeof ( struct STRUCT_OR_UNION_18 ) ) ) goto VAR_106 ; if ( METHOD_22 ( VAR_107 ) ) goto VAR_108 ; METHOD_23 ( VAR_109 -> VAR_110 ) ; if ( VAR_111 -> VAR_112 ) { VAR_113 -> VAR_114 = VAR_115 -> VAR_116 ; VAR_117 -> VAR_118 = VAR_119 ; } VAR_120 -> VAR_121 -= VAR_122 -> VAR_123 ; } VAR_124 = 0 ; VAR_125 = 0 ; * VAR_126 = VAR_127 ; VAR_128 = METHOD_24 ( METHOD_25 ( VAR_129 ) , VAR_130 , VAR_131 ) ; if ( ! VAR_132 ) { METHOD_26 ( STRUCT_OR_UNION_19 , METHOD_27 ( METHOD_28 ( VAR_133 ) ) , VAR_134 ) ; VAR_135 = - VAR_136 ; goto VAR_137 ; } VAR_138 = METHOD_29 ( VAR_139 ) -> VAR_140 ; METHOD_30 ( VAR_141 ) ; METHOD_31 ( VAR_142 , VAR_143 ) ; VAR_144 = ( struct STRUCT_OR_UNION_20 * ) METHOD_32 ( VAR_145 , sizeof ( struct STRUCT_OR_UNION_21 ) ) ; METHOD_33 ( VAR_146 , VAR_147 ) ; METHOD_34 ( VAR_148 ) ; METHOD_35 ( METHOD_36 ( VAR_149 ) , VAR_150 , VAR_151 ) ; VAR_152 -> VAR_153 = VAR_154 ; VAR_155 -> VAR_156 = 0 ; VAR_157 -> VAR_158 = METHOD_37 ( VAR_159 ) ; VAR_160 -> VAR_161 = VAR_162 ; VAR_163 = METHOD_38 ( VAR_164 ) ; VAR_165 -> VAR_166 = VAR_167 - METHOD_39 ( VAR_168 ) ; VAR_169 -> VAR_170 = VAR_171 ; METHOD_40 ( VAR_172 ) -> VAR_173 = METHOD_41 ( VAR_174 - sizeof ( struct STRUCT_OR_UNION_22 ) ) ; METHOD_42 ( & VAR_175 -> VAR_176 ) ; for ( ; ; ) { if ( VAR_177 ) { VAR_178 -> VAR_179 = VAR_180 ; METHOD_43 ( VAR_181 ) ; VAR_182 = ( struct STRUCT_OR_UNION_23 * ) METHOD_44 ( VAR_183 , sizeof ( struct STRUCT_OR_UNION_24 ) ) ; METHOD_45 ( VAR_184 , VAR_185 ) ; METHOD_46 ( VAR_186 ) ; METHOD_47 ( METHOD_48 ( VAR_187 ) , VAR_188 , VAR_189 ) ; VAR_190 += VAR_191 -> VAR_192 - VAR_193 - sizeof ( struct STRUCT_OR_UNION_25 ) ; VAR_194 -> VAR_195 = VAR_196 ; VAR_197 -> VAR_198 = 0 ; VAR_199 -> VAR_200 = METHOD_49 ( VAR_201 ) ; if ( VAR_202 -> VAR_203 ) VAR_204 -> VAR_205 |= METHOD_50 ( VAR_206 ) ; VAR_207 -> VAR_208 = VAR_209 ; METHOD_51 ( VAR_210 ) -> VAR_211 = METHOD_52 ( VAR_212 -> VAR_213 - sizeof ( struct STRUCT_OR_UNION_26 ) ) ; METHOD_53 ( VAR_214 , VAR_215 ) ; } VAR_216 = METHOD_54 ( STRUCT_OR_UNION_27 , VAR_217 , VAR_218 ) ; if ( ! VAR_219 ) METHOD_55 ( STRUCT_OR_UNION_28 , METHOD_56 ( & VAR_220 -> VAR_221 ) , VAR_222 ) ; if ( VAR_223 || ! VAR_224 ) break ; VAR_225 = VAR_226 ; VAR_227 = VAR_228 -> VAR_229 ; VAR_230 -> VAR_231 = VAR_232 ; } METHOD_57 ( VAR_233 ) ; if ( VAR_234 == 0 ) { METHOD_58 ( STRUCT_OR_UNION_29 , METHOD_59 ( & VAR_235 -> VAR_236 ) , VAR_237 ) ; METHOD_60 ( VAR_238 ) ; return 0 ; } METHOD_61 ( VAR_239 ) ; METHOD_62 ( STRUCT_OR_UNION_30 , METHOD_63 ( & VAR_240 -> VAR_241 ) , VAR_242 ) ; METHOD_64 ( VAR_243 ) ; return VAR_244 ; VAR_245 : METHOD_65 ( VAR_246 , VAR_247 ) { if ( VAR_248 == VAR_249 ) break ; VAR_250 -> VAR_251 = VAR_252 ; VAR_253 -> VAR_254 = VAR_255 ; VAR_256 -> VAR_257 += VAR_258 -> VAR_259 ; } } VAR_260 : VAR_261 = VAR_262 -> VAR_263 - VAR_264 ; VAR_265 = VAR_266 ; VAR_267 = VAR_268 -> VAR_269 . VAR_270 -> VAR_271 ; while ( VAR_272 > 0 ) { VAR_273 * VAR_274 ; VAR_275 = VAR_276 ; if ( VAR_277 > VAR_278 ) VAR_279 = VAR_280 ; if ( VAR_281 < VAR_282 ) { VAR_283 &= ~ 7 ; } VAR_284 = METHOD_66 ( VAR_285 + VAR_286 + sizeof ( struct STRUCT_OR_UNION_31 ) + VAR_287 + VAR_288 , VAR_289 ) ; if ( ! VAR_290 ) { METHOD_67 ( STRUCT_OR_UNION_32 , METHOD_68 ( METHOD_69 ( VAR_291 ) ) , VAR_292 ) ; VAR_293 = - VAR_294 ; goto VAR_295 ; } METHOD_70 ( VAR_296 , VAR_297 ) ; METHOD_71 ( VAR_298 , VAR_299 ) ; METHOD_72 ( VAR_300 , VAR_301 + VAR_302 + sizeof ( struct STRUCT_OR_UNION_33 ) ) ; METHOD_73 ( VAR_303 ) ; VAR_304 = ( struct STRUCT_OR_UNION_34 * ) ( METHOD_74 ( VAR_305 ) + VAR_306 ) ; VAR_307 -> VAR_308 = ( VAR_309 -> VAR_310 + VAR_311 + sizeof ( struct STRUCT_OR_UNION_35 ) ) ; if ( VAR_312 -> VAR_313 ) METHOD_75 ( VAR_314 , VAR_315 -> VAR_316 ) ; METHOD_76 ( VAR_317 , METHOD_77 ( VAR_318 ) , VAR_319 ) ; VAR_320 = METHOD_78 ( VAR_321 ) ; VAR_322 += VAR_323 - METHOD_79 ( VAR_324 ) ; * VAR_325 = VAR_326 ; VAR_327 -> VAR_328 = VAR_329 ; VAR_330 -> VAR_331 = 0 ; VAR_332 -> VAR_333 = VAR_334 ; METHOD_80 ( METHOD_81 ( VAR_335 , VAR_336 , METHOD_82 ( VAR_337 ) , VAR_338 ) ) ; VAR_339 -= VAR_340 ; VAR_341 -> VAR_342 = METHOD_83 ( VAR_343 ) ; if ( VAR_344 > 0 ) VAR_345 -> VAR_346 |= METHOD_84 ( VAR_347 ) ; METHOD_85 ( VAR_348 ) -> VAR_349 = METHOD_86 ( VAR_350 -> VAR_351 - sizeof ( struct STRUCT_OR_UNION_36 ) ) ; VAR_352 += VAR_353 ; VAR_354 += VAR_355 ; VAR_356 = METHOD_87 ( STRUCT_OR_UNION_37 , VAR_357 , VAR_358 ) ; if ( VAR_359 ) goto VAR_360 ; METHOD_88 ( STRUCT_OR_UNION_38 , METHOD_89 ( METHOD_90 ( VAR_361 ) ) , VAR_362 ) ; } METHOD_91 ( STRUCT_OR_UNION_39 , METHOD_92 ( METHOD_93 ( VAR_363 ) ) , VAR_364 ) ; METHOD_94 ( VAR_365 ) ; return VAR_366 ; VAR_367 : if ( VAR_368 -> VAR_369 && METHOD_95 ( METHOD_96 ( VAR_370 ) ) ) METHOD_97 ( VAR_371 -> VAR_372 , VAR_373 ) ; VAR_374 -> VAR_375 = METHOD_98 ( VAR_376 ) -> VAR_377 ; METHOD_99 ( VAR_378 , VAR_379 , 0 , VAR_380 ) ; VAR_381 = - VAR_382 ; VAR_383 : METHOD_100 ( STRUCT_OR_UNION_40 , METHOD_101 ( METHOD_102 ( VAR_384 ) ) , VAR_385 ) ; METHOD_103 ( VAR_386 ) ; return VAR_387 ; }",<S2SV_ModStart> VAR_323 ) ; if ( VAR_319 < 0 ) { VAR_387 = VAR_319 ; goto VAR_383 ; },"CWE-125 int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }",<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
730,"CWE-119 static TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , <S2SV_StartBug> const TYPE_3 * const VAR_2 , <S2SV_EndBug> TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , TYPE_7 * VAR_6 , TYPE_8 * VAR_7 ) { TYPE_9 * VAR_8 = & VAR_9 -> VAR_10 ; <S2SV_StartBug> TYPE_10 * VAR_11 = & VAR_12 -> VAR_13 ; <S2SV_EndBug> TYPE_11 * VAR_14 = & VAR_15 -> VAR_16 [ 0 ] -> VAR_17 ; <S2SV_StartBug> struct STRUCT_OR_UNION_0 VAR_18 [ VAR_19 ] = { { 0 } } ; <S2SV_EndBug> TYPE_12 VAR_20 = VAR_21 ; <S2SV_StartBug> TYPE_13 VAR_22 , VAR_23 ; <S2SV_EndBug> TYPE_14 VAR_24 = VAR_25 -> VAR_26 ; TYPE_15 VAR_27 ; TYPE_16 VAR_28 = VAR_29 -> VAR_30 [ 0 ] ; <S2SV_StartBug> TYPE_17 VAR_31 = VAR_32 -> VAR_33 [ VAR_34 ] [ 0 ] . VAR_35 ; <S2SV_EndBug> TYPE_18 VAR_36 = VAR_37 -> VAR_38 ; TYPE_19 VAR_39 = VAR_40 -> VAR_41 ; TYPE_20 VAR_42 = VAR_43 -> VAR_44 ; <S2SV_StartBug> TYPE_21 VAR_45 = VAR_46 -> VAR_47 ; <S2SV_EndBug> const TYPE_22 * VAR_48 = METHOD_1 ( VAR_49 , VAR_50 ) ; TYPE_23 VAR_51 [ 3 ] ; <S2SV_StartBug> VAR_52 [ 0 ] = VAR_53 -> VAR_54 [ VAR_55 ] [ 0 ] . VAR_56 ; <S2SV_EndBug> <S2SV_StartBug> VAR_57 [ 1 ] = VAR_58 -> VAR_59 [ VAR_60 ] [ 1 ] . VAR_61 ; <S2SV_EndBug> <S2SV_StartBug> VAR_62 [ 2 ] = VAR_63 -> VAR_64 [ VAR_65 ] . VAR_66 ; <S2SV_EndBug> if ( VAR_67 ) { TYPE_24 VAR_68 ; for ( VAR_69 = 0 ; VAR_70 < VAR_71 ; VAR_72 ++ ) VAR_73 [ VAR_74 ] = VAR_75 -> VAR_76 [ VAR_77 ] . VAR_78 [ 0 ] ; METHOD_2 ( VAR_79 , 0 , VAR_80 , VAR_81 , VAR_82 , VAR_83 ) ; } METHOD_3 ( VAR_84 , & VAR_85 ) ; <S2SV_StartBug> if ( VAR_86 -> VAR_87 . VAR_88 && VAR_89 -> VAR_90 . VAR_91 ) { <S2SV_EndBug> <S2SV_StartBug> VAR_92 = ( METHOD_4 ( VAR_93 , VAR_94 -> VAR_95 [ VAR_96 ] ) + <S2SV_EndBug> <S2SV_StartBug> VAR_97 -> VAR_98 ) >> 1 ; <S2SV_EndBug> } else { VAR_99 = VAR_100 -> VAR_101 ; } <S2SV_StartBug> if ( VAR_102 -> VAR_103 . VAR_104 && VAR_105 < VAR_106 && <S2SV_EndBug> VAR_107 -> VAR_108 . VAR_109 ) { <S2SV_StartBug> TYPE_25 VAR_110 = 2 * ( METHOD_5 ( VAR_111 ) - METHOD_6 ( METHOD_7 ( VAR_112 ) , <S2SV_EndBug> METHOD_8 ( VAR_113 ) ) ) ; VAR_114 = METHOD_9 ( VAR_115 , VAR_116 ) ; } if ( VAR_117 -> VAR_118 . VAR_119 ) { TYPE_26 VAR_120 = VAR_121 [ VAR_122 ] ; <S2SV_StartBug> TYPE_27 VAR_123 = VAR_124 [ VAR_125 ] ; <S2SV_EndBug> TYPE_28 VAR_126 ; TYPE_29 VAR_127 = VAR_128 -> VAR_129 [ VAR_130 ] >> ( VAR_131 + VAR_132 + 4 ) ; if ( VAR_133 < 5 ) VAR_134 += 2 ; <S2SV_StartBug> for ( VAR_135 = VAR_136 ; VAR_137 <= VAR_138 && VAR_139 -> VAR_140 . VAR_141 ; ++ VAR_142 ) { <S2SV_EndBug> if ( ( VAR_143 -> VAR_144 [ VAR_145 ] >> 3 ) > VAR_146 -> VAR_147 [ VAR_148 ] ) { <S2SV_StartBug> VAR_149 -> VAR_150 [ VAR_151 ] . VAR_152 = 0 ; <S2SV_EndBug> VAR_153 -> VAR_154 = VAR_155 ; if ( VAR_156 ) { TYPE_30 VAR_157 ; <S2SV_StartBug> for ( VAR_158 = 0 ; VAR_159 < VAR_160 ; VAR_161 ++ ) <S2SV_EndBug> VAR_162 -> VAR_163 [ VAR_164 ] . VAR_165 [ 0 ] = VAR_166 [ VAR_167 ] ; } <S2SV_StartBug> return ; <S2SV_EndBug> } } } VAR_168 = VAR_169 [ VAR_170 -> VAR_171 [ VAR_172 ] ] ; VAR_173 . VAR_174 >>= 3 ; VAR_175 . VAR_176 >>= 3 ; <S2SV_StartBug> VAR_177 = ( VAR_178 -> VAR_179 . VAR_180 - 1 ) - VAR_181 ; <S2SV_EndBug> if ( VAR_182 -> VAR_183 . VAR_184 == VAR_185 ) { VAR_186 = METHOD_10 ( VAR_187 , & VAR_188 , VAR_189 , VAR_190 , 0 , & VAR_191 -> VAR_192 [ VAR_193 ] , 1 , & VAR_194 , & VAR_195 -> VAR_196 ) ; if ( VAR_197 < VAR_198 ) <S2SV_StartBug> VAR_199 = METHOD_11 ( VAR_200 , & VAR_201 -> VAR_202 , & VAR_203 , <S2SV_EndBug> <S2SV_StartBug> & VAR_204 -> VAR_205 [ VAR_206 ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( VAR_207 -> VAR_208 . VAR_209 == VAR_210 ) { <S2SV_EndBug> VAR_211 = METHOD_12 ( VAR_212 , & VAR_213 , VAR_214 , VAR_215 , 0 , & VAR_216 -> VAR_217 [ VAR_218 ] , 1 , & VAR_219 , & VAR_220 -> VAR_221 ) ; if ( VAR_222 < VAR_223 ) VAR_224 = METHOD_13 ( VAR_225 , & VAR_226 -> VAR_227 , & VAR_228 , & VAR_229 -> VAR_230 [ VAR_231 ] , 1 ) ; <S2SV_StartBug> } else if ( VAR_232 -> VAR_233 . VAR_234 == VAR_235 ) { <S2SV_EndBug> VAR_236 = METHOD_14 ( VAR_237 , & VAR_238 , VAR_239 , VAR_240 , 1 , & VAR_241 -> VAR_242 [ VAR_243 ] , 1 , & VAR_244 , & VAR_245 -> VAR_246 ) ; if ( VAR_247 < VAR_248 ) VAR_249 = METHOD_15 ( VAR_250 , & VAR_251 -> VAR_252 , & VAR_253 , & VAR_254 -> VAR_255 [ VAR_256 ] , 1 ) ; } else if ( VAR_257 -> VAR_258 . VAR_259 == VAR_260 ) { VAR_261 = METHOD_16 ( VAR_262 , & VAR_263 , VAR_264 , VAR_265 , 1 , & VAR_266 -> VAR_267 [ VAR_268 ] , 1 , & VAR_269 , & VAR_270 -> VAR_271 ) ; if ( VAR_272 < VAR_273 ) VAR_274 = METHOD_17 ( VAR_275 , & VAR_276 -> VAR_277 , & VAR_278 , & VAR_279 -> VAR_280 [ VAR_281 ] , 1 ) ; } else if ( VAR_282 -> VAR_283 . VAR_284 == VAR_285 ) { VAR_286 = METHOD_18 ( VAR_287 , & VAR_288 , VAR_289 , VAR_290 , 1 , & VAR_291 -> VAR_292 [ VAR_293 ] , 1 , & VAR_294 , & VAR_295 -> VAR_296 ) ; if ( VAR_297 < VAR_298 ) VAR_299 = METHOD_19 ( VAR_300 , & VAR_301 -> VAR_302 , & VAR_303 , & VAR_304 -> VAR_305 [ VAR_306 ] , 1 ) ; } else { VAR_307 = METHOD_20 ( VAR_308 , VAR_309 , & VAR_310 , VAR_311 , VAR_312 , VAR_313 , 1 , & VAR_314 -> VAR_315 [ VAR_316 ] , & VAR_317 , & VAR_318 -> VAR_319 ) ; } VAR_320 -> VAR_321 = VAR_322 ; VAR_323 -> VAR_324 = VAR_325 ; VAR_326 -> VAR_327 = VAR_328 ; VAR_329 -> VAR_330 = VAR_331 ; if ( VAR_332 < VAR_333 ) { TYPE_31 TYPE_32 ; VAR_334 -> METHOD_21 ( VAR_335 , & VAR_336 -> VAR_337 , & VAR_338 , VAR_339 -> VAR_340 , VAR_341 -> VAR_342 , & VAR_343 -> VAR_344 [ VAR_345 ] , VAR_346 -> VAR_347 . VAR_348 , VAR_349 -> VAR_350 . VAR_351 , VAR_352 -> VAR_353 , VAR_354 -> VAR_355 , <S2SV_StartBug> & TYPE_33 , & VAR_356 -> VAR_357 [ VAR_358 ] ) ; <S2SV_EndBug> } * VAR_359 = METHOD_22 ( & VAR_360 -> VAR_361 , & VAR_362 , VAR_363 -> VAR_364 , VAR_365 -> VAR_366 , VAR_367 ) ; <S2SV_StartBug> if ( VAR_368 -> VAR_369 . VAR_370 && VAR_371 -> VAR_372 . VAR_373 ) <S2SV_EndBug> <S2SV_StartBug> VAR_374 -> VAR_375 [ VAR_376 ] . VAR_377 = VAR_378 -> VAR_379 ; <S2SV_EndBug> if ( VAR_380 ) { TYPE_34 VAR_381 ; for ( VAR_382 = 0 ; VAR_383 < VAR_384 ; VAR_385 ++ ) VAR_386 -> VAR_387 [ VAR_388 ] . VAR_389 [ 0 ] = VAR_390 [ VAR_391 ] ; } }","<S2SV_ModStart> * VAR_374 , <S2SV_ModEnd> TYPE_4 VAR_345 , <S2SV_ModStart> -> VAR_10 ; const <S2SV_ModStart> { { 0 , 0 <S2SV_ModStart> VAR_333 ; TYPE_34 <S2SV_ModEnd> VAR_311 ; TYPE_34 <S2SV_ModStart> TYPE_23 VAR_362 = VAR_374 -> VAR_392 <S2SV_ModEnd> -> VAR_59 [ <S2SV_ModStart> VAR_374 -> VAR_330 ; TYPE_34 VAR_393 [ 5 ] <S2SV_ModStart> 0 ] = VAR_374 -> VAR_392 <S2SV_ModEnd> -> VAR_59 [ <S2SV_ModStart> 1 ] = VAR_374 -> VAR_392 <S2SV_ModEnd> -> VAR_59 [ <S2SV_ModStart> [ VAR_376 ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> VAR_369 . VAR_394 . VAR_88 && VAR_339 -> <S2SV_ModEnd> VAR_373 ) { <S2SV_ModStart> ( METHOD_4 ( <S2SV_ModEnd> VAR_374 -> VAR_95 <S2SV_ModStart> -> VAR_101 ) / 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> VAR_345 < VAR_111 <S2SV_ModEnd> ) { TYPE_34 <S2SV_ModStart> 2 * ( VAR_121 [ VAR_111 ] <S2SV_ModEnd> - METHOD_6 ( <S2SV_ModStart> - METHOD_6 ( VAR_124 [ VAR_345 ] , VAR_121 [ VAR_345 ] <S2SV_ModEnd> ) ) ; <S2SV_ModStart> [ VAR_345 ] <S2SV_ModEnd> ; TYPE_34 VAR_133 <S2SV_ModStart> += 2 ; if ( VAR_371 -> VAR_395 . VAR_396 != VAR_397 ) { TYPE_34 VAR_391 ; <S2SV_ModStart> <= VAR_138 && VAR_339 -> <S2SV_ModEnd> VAR_373 ; ++ <S2SV_ModStart> VAR_376 ] . VAR_176 = 0 ; VAR_374 -> VAR_375 [ VAR_376 ] . VAR_174 <S2SV_ModEnd> = 0 ; <S2SV_ModStart> < VAR_384 ; ++ VAR_391 <S2SV_ModEnd> ) VAR_386 -> <S2SV_ModStart> } return ; } <S2SV_ModStart> >>= 3 ; VAR_332 = METHOD_24 ( VAR_371 , VAR_374 , VAR_345 , & VAR_310 , VAR_311 , VAR_312 , METHOD_23 ( VAR_371 , VAR_393 ) , & VAR_362 , & VAR_378 -> VAR_361 , VAR_333 , 1 ) ; VAR_374 -> VAR_321 = VAR_322 ; VAR_374 -> VAR_324 = VAR_325 ; VAR_374 -> VAR_327 = VAR_328 ; VAR_374 -> VAR_330 = VAR_331 <S2SV_ModEnd> ; if ( <S2SV_ModStart> < VAR_333 ) { TYPE_34 TYPE_33 ; VAR_371 -> METHOD_21 <S2SV_ModEnd> ( VAR_374 , <S2SV_ModStart> & VAR_362 , VAR_339 -> VAR_340 , VAR_374 -> VAR_342 , <S2SV_ModStart> VAR_345 ] , <S2SV_ModEnd> VAR_371 -> VAR_369 <S2SV_ModStart> -> VAR_369 . VAR_394 . VAR_348 , <S2SV_ModEnd> VAR_371 -> VAR_369 <S2SV_ModStart> -> VAR_369 . VAR_394 . VAR_351 , METHOD_23 ( VAR_371 , VAR_393 ) , VAR_374 -> VAR_364 , VAR_374 -> VAR_366 , & TYPE_33 <S2SV_ModEnd> , & VAR_374 <S2SV_ModStart> [ VAR_376 ] , VAR_83 , 0 , 0 <S2SV_ModStart> VAR_369 . VAR_370 <S2SV_ModEnd> ) VAR_374 -> <S2SV_ModStart> [ VAR_376 ] <S2SV_ModEnd> = VAR_378 -> <S2SV_ModStart> = VAR_378 -> VAR_361 <S2SV_ModEnd> ; if (","CWE-119 static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> int bestsme = INT_MAX ; <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; } vp9_set_mv_search_range ( x , & ref_mv ) ; <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> } else { step_param = cpi -> mv_step_param ; } <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> cpi -> common . show_frame ) { <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> b_width_log2 ( bsize ) ) ) ; step_param = MAX ( step_param , boffset ) ; } if ( cpi -> sf . adaptive_motion_search ) { int bwl = b_width_log2_lookup [ bsize ] ; <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> int i ; int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; if ( tlevel < 5 ) step_param += 2 ; <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> tmp_mv -> as_int = INVALID_MV ; if ( scaled_ref_frame ) { int i ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } <S2SV_StartBug> return ; <S2SV_EndBug> } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full . col >>= 3 ; mvp_full . row >>= 3 ; <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> if ( cpi -> sf . search_method == FAST_DIAMOND ) { bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == SQUARE ) { bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == BIGDIA ) { bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else { bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } }","<S2SV_ModStart> * x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> -> e_mbd ; const <S2SV_ModStart> { { 0 , 0 <S2SV_ModStart> INT_MAX ; int <S2SV_ModEnd> step_param ; int <S2SV_ModStart> MV ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> x -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> 0 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> 1 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> [ ref ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> sf . mv . auto_mv_step_size && cm -> <S2SV_ModEnd> show_frame ) { <S2SV_ModStart> ( vp9_init_search_range ( <S2SV_ModEnd> x -> max_mv_context <S2SV_ModStart> -> mv_step_param ) / 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize < BLOCK_64X64 <S2SV_ModEnd> ) { int <S2SV_ModStart> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> - MIN ( <S2SV_ModStart> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) ; <S2SV_ModStart> [ bsize ] <S2SV_ModEnd> ; int tlevel <S2SV_ModStart> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> <= ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; ++ <S2SV_ModStart> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 ; <S2SV_ModStart> < MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd -> <S2SV_ModStart> } return ; } <S2SV_ModStart> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> ; if ( <S2SV_ModStart> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , <S2SV_ModStart> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart> bsize ] , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_force_stop , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> , & x <S2SV_ModStart> [ ref ] , NULL , 0 , 0 <S2SV_ModStart> sf . adaptive_motion_search <S2SV_ModEnd> ) x -> <S2SV_ModStart> [ ref ] <S2SV_ModEnd> = tmp_mv -> <S2SV_ModStart> = tmp_mv -> as_mv <S2SV_ModEnd> ; if ("
731,"CWE-190 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * * VAR_1 ) { <S2SV_StartBug> TYPE_2 VAR_2 = sizeof ( struct STRUCT_OR_UNION_1 ) ; <S2SV_EndBug> unsigned TYPE_3 VAR_3 = METHOD_1 ( VAR_4 ) - METHOD_2 ( VAR_5 ) ; TYPE_4 VAR_6 = 0 ; * VAR_7 = & METHOD_3 ( VAR_8 ) -> VAR_9 ; while ( VAR_10 <= VAR_11 ) { struct STRUCT_OR_UNION_2 * VAR_12 ; <S2SV_StartBug> switch ( * * VAR_13 ) { <S2SV_EndBug> case VAR_14 : break ; case VAR_15 : VAR_16 = 1 ; break ; case VAR_17 : if IS_ENABLED ( VAR_18 ) if ( METHOD_4 ( VAR_19 , VAR_20 , VAR_21 ) >= 0 ) break ; if ( VAR_22 ) return VAR_23 ; break ; default : return VAR_24 ; } if ( VAR_25 + sizeof ( struct STRUCT_OR_UNION_3 ) > VAR_26 ) return - VAR_27 ; VAR_28 = ( struct STRUCT_OR_UNION_4 * ) ( METHOD_5 ( VAR_29 ) + VAR_30 ) ; <S2SV_StartBug> VAR_31 += METHOD_6 ( VAR_32 ) ; <S2SV_EndBug> * VAR_33 = & VAR_34 -> VAR_35 ; } return - VAR_36 ; }",<S2SV_ModStart> VAR_35 ) { unsigned TYPE_4 <S2SV_ModEnd> VAR_31 = sizeof <S2SV_ModStart> * VAR_34 ; unsigned TYPE_4 VAR_37 ; <S2SV_ModStart> VAR_31 ) ; VAR_37 = METHOD_6 ( VAR_34 ) ; if ( VAR_37 + VAR_31 >= VAR_38 ) return - VAR_36 ; VAR_31 += VAR_37 <S2SV_ModEnd> ; * VAR_35,"CWE-190 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST :  if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ;   if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }",<S2SV_ModStart> nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> * exthdr ; unsigned int len ; <S2SV_ModStart> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> ; * nexthdr
732,"CWE-310 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , struct STRUCT_OR_UNION_1 * VAR_1 , struct STRUCT_OR_UNION_2 * VAR_2 ) { <S2SV_StartBug> METHOD_1 ( & VAR_3 -> VAR_4 , & VAR_5 -> VAR_6 , sizeof ( VAR_7 -> VAR_8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> METHOD_2 ( & VAR_9 -> VAR_10 , & VAR_11 -> VAR_12 , <S2SV_EndBug> sizeof ( VAR_13 -> VAR_14 ) ) ; <S2SV_StartBug> METHOD_3 ( & VAR_15 -> VAR_16 , METHOD_4 ( VAR_17 -> VAR_18 ) , <S2SV_EndBug> <S2SV_StartBug> VAR_19 ) ; <S2SV_EndBug> VAR_20 -> VAR_21 = VAR_22 -> VAR_23 ; VAR_24 -> VAR_25 = METHOD_5 ( & VAR_26 -> VAR_27 ) ; if ( METHOD_6 ( VAR_28 , VAR_29 , VAR_30 -> VAR_31 ) ) goto VAR_32 ; if ( VAR_33 -> VAR_34 & VAR_35 ) { struct STRUCT_OR_UNION_3 VAR_36 ; <S2SV_StartBug> METHOD_7 ( VAR_37 . VAR_38 , VAR_39 , ""%s"" , ""larval"" ) ; <S2SV_EndBug> if ( METHOD_8 ( VAR_40 , VAR_41 , sizeof ( struct STRUCT_OR_UNION_4 ) , & VAR_42 ) ) goto VAR_43 ; goto VAR_44 ; } if ( VAR_45 -> VAR_46 && VAR_47 -> VAR_48 -> METHOD_9 ) { if ( VAR_49 -> VAR_50 -> METHOD_10 ( VAR_51 , VAR_52 ) ) goto VAR_53 ; goto VAR_54 ; } switch ( VAR_55 -> VAR_56 & ( VAR_57 | VAR_58 ) ) { case VAR_59 : if ( METHOD_11 ( VAR_60 , VAR_61 ) ) goto VAR_62 ; break ; case VAR_63 : if ( METHOD_12 ( VAR_64 , VAR_65 ) ) goto VAR_66 ; break ; } VAR_67 : return 0 ; VAR_68 : return - VAR_69 ; }","<S2SV_ModStart> VAR_64 ) { METHOD_13 ( <S2SV_ModEnd> VAR_24 -> VAR_8 <S2SV_ModStart> -> VAR_8 , <S2SV_ModEnd> VAR_65 -> VAR_6 <S2SV_ModStart> ) ) ; METHOD_13 ( <S2SV_ModEnd> VAR_24 -> VAR_14 <S2SV_ModStart> -> VAR_14 , <S2SV_ModEnd> VAR_65 -> VAR_12 <S2SV_ModStart> ) ) ; METHOD_13 ( <S2SV_ModEnd> VAR_24 -> VAR_16 <S2SV_ModStart> VAR_18 ) , sizeof ( VAR_24 -> VAR_16 ) ) ; VAR_24 -> VAR_70 = 0 ; VAR_24 -> VAR_71 = 0 <S2SV_ModEnd> ; VAR_24 -> <S2SV_ModStart> STRUCT_OR_UNION_4 VAR_42 ; METHOD_13 <S2SV_ModEnd> ( VAR_42 . <S2SV_ModStart> . VAR_38 , ""larval"" , sizeof ( VAR_42 . VAR_38 ) <S2SV_ModEnd> ) ; if","CWE-310 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }","<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if"
733,"CWE-918 static TYPE_0 METHOD_0 ( TYPE_1 VAR_0 , struct STRUCT_OR_UNION_0 * VAR_1 , TYPE_2 VAR_2 , TYPE_3 * VAR_3 , TYPE_4 VAR_4 ) { TYPE_5 VAR_5 [ VAR_6 ] ; TYPE_6 VAR_7 [ VAR_8 ] ; VAR_9 * VAR_10 ; TYPE_7 VAR_11 ; TYPE_8 VAR_12 [ VAR_13 ] ; TYPE_9 VAR_14 = 0 ; struct STRUCT_OR_UNION_1 * VAR_15 ; if ( VAR_16 > VAR_17 - 1 ) { METHOD_1 ( VAR_18 , VAR_19 , ""Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long"" ) ; goto VAR_20 ; } VAR_21 = METHOD_2 ( VAR_22 -> VAR_23 , VAR_24 , VAR_25 , VAR_26 | VAR_27 , VAR_28 , VAR_29 ) ; if ( VAR_30 == - 1 ) { METHOD_3 ( VAR_31 , ""Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , VAR_32 ) ; return - 1 ; } VAR_33 [ VAR_34 ] = '\\0' ; VAR_35 -= VAR_36 ; <S2SV_StartBug> if ( ( VAR_37 = METHOD_4 ( VAR_38 , <S2SV_EndBug> 1500 , 0 , 1000 , VAR_39 ) ) == VAR_40 ) goto VAR_41 ; if ( METHOD_5 ( VAR_42 , sizeof ( struct STRUCT_OR_UNION_2 ) , VAR_43 , & VAR_44 , VAR_45 , VAR_46 , VAR_47 , VAR_48 ) == - 1 ) goto VAR_49 ; METHOD_6 ( ( struct STRUCT_OR_UNION_3 * ) VAR_50 , VAR_51 , VAR_52 , 0 , sizeof ( struct STRUCT_OR_UNION_4 ) ) ; VAR_53 = ( struct STRUCT_OR_UNION_5 * ) & VAR_54 [ VAR_55 ] ; if ( METHOD_7 ( VAR_56 , sizeof ( struct STRUCT_OR_UNION_6 ) , VAR_57 , & VAR_58 , VAR_59 , VAR_60 , VAR_61 , VAR_62 ) == - 1 ) goto VAR_63 ; METHOD_8 ( VAR_64 , 0 , sizeof ( struct STRUCT_OR_UNION_7 ) ) ; VAR_65 -> VAR_66 = METHOD_9 ( METHOD_10 ( VAR_67 ) ) ; VAR_68 -> VAR_69 = 0 ; METHOD_11 ( VAR_70 ) ; if ( METHOD_12 ( VAR_71 -> VAR_72 , VAR_73 , VAR_74 , VAR_75 , VAR_76 ) == - 1 ) { METHOD_13 ( VAR_77 , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , VAR_78 ) ; return - 1 ; } return 0 ; VAR_79 : if ( METHOD_14 ( VAR_80 -> VAR_81 , VAR_82 , VAR_83 , VAR_84 , VAR_85 ) == - 1 ) { METHOD_15 ( VAR_86 , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , VAR_87 ) ; return - 1 ; } if ( METHOD_16 ( VAR_88 -> VAR_89 , VAR_90 ) == - 1 ) { return - 1 ; } return 0 ; }","<S2SV_ModStart> ; if ( METHOD_17 ( VAR_38 ) ) { METHOD_1 ( VAR_84 , VAR_76 , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto VAR_79 ; } if (","CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long"" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }","<S2SV_ModStart> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto error ; } if ("
734,"CWE-77 TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 * VAR_1 , TYPE_2 VAR_2 , const TYPE_3 * VAR_3 ) { TYPE_4 * VAR_4 = METHOD_1 ( VAR_5 ) ; METHOD_2 ( VAR_6 , & VAR_7 ) ; <S2SV_StartBug> METHOD_3 ( VAR_8 , VAR_9 , VAR_10 ) ; <S2SV_EndBug> METHOD_4 ( & VAR_11 ) ; }","<S2SV_ModStart> VAR_9 , VAR_11 , VAR_12","CWE-77 void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }","<S2SV_ModStart> dlen , buf , false"
735,"CWE-264 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , <S2SV_StartBug> TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) <S2SV_EndBug> { struct STRUCT_OR_UNION_1 VAR_5 , VAR_6 ; TYPE_5 VAR_7 , VAR_8 ; unsigned VAR_9 = VAR_10 ; TYPE_6 VAR_11 = 0 ; TYPE_7 VAR_12 = ! ( VAR_13 & ~ 0x3 ) ; TYPE_8 VAR_14 ; TYPE_9 VAR_15 ; TYPE_10 VAR_16 ; TYPE_11 VAR_17 = 0 ; METHOD_1 ( & VAR_18 , 0 , sizeof VAR_19 ) ; if ( VAR_20 -> VAR_21 == VAR_22 ) { VAR_23 -> VAR_24 -> METHOD_2 ( VAR_25 , & VAR_26 , & VAR_27 , VAR_28 , VAR_29 ) ; METHOD_3 ( & VAR_30 , VAR_31 << 4 ) ; goto VAR_32 ; } else if ( VAR_33 <= VAR_34 && VAR_35 -> VAR_36 == VAR_37 ) { METHOD_4 ( & VAR_38 , VAR_39 << 4 ) ; METHOD_5 ( & VAR_40 , 0xffff ) ; VAR_41 . VAR_42 = 3 ; VAR_43 . VAR_44 = 1 ; VAR_45 . VAR_46 = 1 ; VAR_47 . VAR_48 = 3 ; goto VAR_49 ; } VAR_50 = VAR_51 & 3 ; if ( ( VAR_52 == VAR_53 || ( VAR_54 == VAR_55 && ( VAR_56 -> VAR_57 != VAR_58 || VAR_59 != VAR_60 ) ) || VAR_61 == VAR_62 ) && VAR_63 ) goto VAR_64 ; if ( VAR_65 == VAR_66 && ( VAR_67 & ( 1 << 2 ) ) ) goto VAR_68 ; if ( VAR_69 ) goto VAR_70 ; VAR_71 = METHOD_6 ( VAR_72 , VAR_73 , & VAR_74 , & VAR_75 ) ; if ( VAR_76 != VAR_77 ) return VAR_78 ; VAR_79 = VAR_80 & 0xfffc ; VAR_81 = VAR_82 ? VAR_83 : VAR_84 ; if ( VAR_85 <= VAR_86 && ! VAR_87 . VAR_88 ) goto VAR_89 ; if ( ! VAR_90 . VAR_91 ) { VAR_92 = ( VAR_93 == VAR_94 ) ? VAR_95 : VAR_96 ; goto VAR_97 ; } VAR_98 = VAR_99 . VAR_100 ; switch ( VAR_101 ) { case VAR_102 : if ( VAR_103 != VAR_104 || ( VAR_105 . VAR_106 & 0xa ) != 0x2 || VAR_107 != VAR_108 ) goto VAR_109 ; break ; case VAR_110 : if ( ! ( VAR_111 . VAR_112 & 8 ) ) goto VAR_113 ; if ( VAR_114 . VAR_115 & 4 ) { if ( VAR_116 > VAR_117 ) goto VAR_118 ; } else { if ( VAR_119 > VAR_120 || VAR_121 != VAR_122 ) goto VAR_123 ; } if ( VAR_124 . VAR_125 && VAR_126 . VAR_127 ) { TYPE_12 VAR_128 = 0 ; VAR_129 -> VAR_130 -> METHOD_7 ( VAR_131 , VAR_132 , & VAR_133 ) ; if ( VAR_134 & VAR_135 ) goto VAR_136 ; } VAR_137 = ( VAR_138 & 0xfffc ) | VAR_139 ; break ; case VAR_140 : if ( VAR_141 . VAR_142 || ( VAR_143 . VAR_144 != 1 && VAR_145 . VAR_146 != 9 ) ) goto VAR_147 ; VAR_148 = VAR_149 ; VAR_150 . VAR_151 |= 2 ; VAR_152 = VAR_153 -> VAR_154 -> METHOD_8 ( VAR_155 , VAR_156 , & VAR_157 , & VAR_158 , sizeof ( VAR_159 ) , & VAR_160 -> VAR_161 ) ; if ( VAR_162 != VAR_163 ) return VAR_164 ; break ; case VAR_165 : if ( VAR_166 . VAR_167 || VAR_168 . VAR_169 != 2 ) goto VAR_170 ; break ; default : if ( ( VAR_171 . VAR_172 & 0xa ) == 0x8 || ( ( ( VAR_173 . VAR_174 & 0xc ) != 0xc ) && ( VAR_175 > VAR_176 && VAR_177 > VAR_178 ) ) ) goto VAR_179 ; break ; } if ( VAR_180 . VAR_181 ) { VAR_182 . VAR_183 |= 1 ; VAR_184 = METHOD_9 ( VAR_185 , VAR_186 , & VAR_187 ) ; if ( VAR_188 != VAR_189 ) return VAR_190 ; } else if ( VAR_191 -> VAR_192 == VAR_193 ) { VAR_194 = VAR_195 -> VAR_196 -> METHOD_10 ( VAR_197 , VAR_198 + 8 , & VAR_199 , sizeof ( VAR_200 ) , & VAR_201 -> VAR_202 ) ; if ( VAR_203 != VAR_204 ) return VAR_205 ; } VAR_206 : VAR_207 -> VAR_208 -> METHOD_11 ( VAR_209 , VAR_210 , & VAR_211 , VAR_212 , VAR_213 ) ; <S2SV_StartBug> return VAR_214 ; <S2SV_EndBug> VAR_215 : return METHOD_12 ( VAR_216 , VAR_217 , VAR_218 , VAR_219 ) ; }","<S2SV_ModStart> , TYPE_7 VAR_82 , struct STRUCT_OR_UNION_1 * VAR_220 <S2SV_ModStart> VAR_213 ) ; if ( VAR_220 ) * VAR_220 = VAR_211 ;","CWE-264 static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; err_code = selector & 0xfffc ; err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR ; if ( seg <= VCPU_SREG_GS && ! seg_desc . s ) goto exception ; if ( ! seg_desc . p ) { err_vec = ( seg == VCPU_SREG_SS ) ? SS_VECTOR : NP_VECTOR ; goto exception ; } dpl = seg_desc . dpl ; switch ( seg ) { case VCPU_SREG_SS : if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) goto exception ; break ; case VCPU_SREG_CS : if ( ! ( seg_desc . type & 8 ) ) goto exception ; if ( seg_desc . type & 4 ) { if ( dpl > cpl ) goto exception ; } else { if ( rpl > cpl || dpl != cpl ) goto exception ; } if ( seg_desc . d && seg_desc . l ) { u64 efer = 0 ; ctxt -> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( efer & EFER_LMA ) goto exception ; } selector = ( selector & 0xfffc ) | cpl ; break ; case VCPU_SREG_TR : if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) goto exception ; old_desc = seg_desc ; seg_desc . type |= 2 ; ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , sizeof ( seg_desc ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; break ; case VCPU_SREG_LDTR : if ( seg_desc . s || seg_desc . type != 2 ) goto exception ; break ; default : if ( ( seg_desc . type & 0xa ) == 0x8 || ( ( ( seg_desc . type & 0xc ) != 0xc ) && ( rpl > dpl && cpl > dpl ) ) ) goto exception ; break ; } if ( seg_desc . s ) { seg_desc . type |= 1 ; ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } else if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) { ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , sizeof ( base3 ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } load : ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ; }","<S2SV_ModStart> , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> seg ) ; if ( desc ) * desc = seg_desc ;"
736,"CWE-200 static TYPE_0 METHOD_0 ( struct STRUCT_OR_UNION_0 * VAR_0 , TYPE_1 VAR_1 , unsigned TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <S2SV_StartBug> struct STRUCT_OR_UNION_1 VAR_4 ; <S2SV_EndBug> unsigned TYPE_4 VAR_5 ; union STRUCT_OR_UNION_2 * VAR_6 ; TYPE_5 VAR_7 ; <S2SV_StartBug> VAR_8 . VAR_9 = VAR_10 ; <S2SV_EndBug> VAR_11 . VAR_12 = VAR_13 ; VAR_14 . VAR_15 = VAR_16 ; METHOD_1 ( & VAR_17 -> VAR_18 , VAR_19 ) ; VAR_20 = & VAR_21 -> VAR_22 ; switch ( VAR_23 -> VAR_24 -> VAR_25 ) { case VAR_26 : <S2SV_StartBug> METHOD_2 ( METHOD_3 ( & VAR_27 -> VAR_28 , VAR_29 -> VAR_30 . VAR_31 ) , <S2SV_EndBug> & VAR_32 , sizeof ( VAR_33 ) ) ; break ; case VAR_34 : <S2SV_StartBug> METHOD_4 ( METHOD_5 ( & VAR_35 -> VAR_36 , VAR_37 -> VAR_38 . VAR_39 ) , <S2SV_EndBug> & VAR_40 , sizeof ( VAR_41 ) ) ; break ; case VAR_42 : <S2SV_StartBug> METHOD_6 ( METHOD_7 ( & VAR_43 -> VAR_44 , VAR_45 -> VAR_46 . VAR_47 ) , <S2SV_EndBug> & VAR_48 , sizeof ( VAR_49 ) ) ; break ; default : METHOD_8 ( ) ; <S2SV_StartBug> } <S2SV_EndBug> VAR_50 -> VAR_51 . VAR_52 ++ ; METHOD_9 ( & VAR_53 -> VAR_54 , VAR_55 ) ; METHOD_10 ( & VAR_56 -> VAR_57 , VAR_58 ) ; if ( VAR_59 ) METHOD_11 ( VAR_60 -> VAR_61 ) ; }",<S2SV_ModStart> { struct STRUCT_OR_UNION_1 * <S2SV_ModStart> TYPE_5 VAR_59 ; <S2SV_ModEnd> METHOD_1 ( & <S2SV_ModStart> case VAR_26 : VAR_49 = <S2SV_ModEnd> METHOD_7 ( & <S2SV_ModStart> VAR_30 . VAR_52 <S2SV_ModEnd> ) ; break <S2SV_ModStart> case VAR_34 : VAR_49 = <S2SV_ModEnd> METHOD_7 ( & <S2SV_ModStart> VAR_38 . VAR_52 <S2SV_ModEnd> ) ; break <S2SV_ModStart> case VAR_42 : VAR_49 = <S2SV_ModEnd> METHOD_7 ( & <S2SV_ModStart> . VAR_52 ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } VAR_49 -> VAR_10 = VAR_10 ; VAR_49 -> VAR_12 = VAR_13 ; VAR_49 -> VAR_15 = VAR_16 ;,"CWE-200 static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <S2SV_StartBug> } <S2SV_EndBug> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }",<S2SV_ModStart> { struct blkif_response * <S2SV_ModStart> int notify ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> native . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> x86_32 . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
737,"CWE-476 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 ) { const TYPE_4 * VAR_3 ; TYPE_5 VAR_4 , VAR_5 ; VAR_6 * VAR_7 ; if ( VAR_8 ) { TYPE_6 VAR_9 [ 1024 ] ; METHOD_1 ( VAR_10 , VAR_11 ) ; if ( ! VAR_12 ) { TYPE_7 * VAR_13 = METHOD_2 ( VAR_14 , '.' ) ; if ( VAR_15 ) VAR_16 [ 0 ] = 0 ; METHOD_3 ( VAR_17 , ""_sdp.txt"" ) ; } VAR_18 = METHOD_4 ( VAR_19 , ""wt"" ) ; if ( ! VAR_20 ) { METHOD_5 ( VAR_21 , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>dumping\\n"" , VAR_22 ) ; return ; } } else { VAR_23 = VAR_24 ; METHOD_6 ( VAR_25 , ""*<S2SV_blank>File<S2SV_blank>SDP<S2SV_blank>content<S2SV_blank>*\\n\\n"" ) ; } METHOD_7 ( VAR_26 , & VAR_27 , & VAR_28 ) ; <S2SV_StartBug> METHOD_8 ( VAR_29 , ""%s"" , VAR_30 ) ; <S2SV_EndBug> METHOD_9 ( VAR_31 , ""\\r\\n"" ) ; for ( VAR_32 = 0 ; VAR_33 < METHOD_10 ( VAR_34 ) ; VAR_35 ++ ) { if ( METHOD_11 ( VAR_36 , VAR_37 + 1 ) != VAR_38 ) continue ; METHOD_12 ( VAR_39 , VAR_40 + 1 , & VAR_41 , & VAR_42 ) ; METHOD_13 ( VAR_43 , ""%s"" , VAR_44 ) ; } METHOD_14 ( VAR_45 , ""\\n\\n"" ) ; if ( VAR_46 ) METHOD_15 ( VAR_47 ) ; }",<S2SV_ModStart> VAR_42 ) ; if ( VAR_44 && VAR_42 ),"CWE-476 void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , ""_sdp.txt"" ) ; } dump = gf_fopen ( szBuf , ""wt"" ) ; if ( ! dump ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>dumping\\n"" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , ""*<S2SV_blank>File<S2SV_blank>SDP<S2SV_blank>content<S2SV_blank>*\\n\\n"" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <S2SV_StartBug> fprintf ( dump , ""%s"" , sdp ) ; <S2SV_EndBug> fprintf ( dump , ""\\r\\n"" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , ""%s"" , sdp ) ; } fprintf ( dump , ""\\n\\n"" ) ; if ( inName ) gf_fclose ( dump ) ; }",<S2SV_ModStart> size ) ; if ( sdp && size )
738,"CWE-119 TYPE_0 METHOD_0 ( TYPE_1 * VAR_0 , TYPE_2 * VAR_1 , TYPE_3 VAR_2 , TYPE_4 * VAR_3 , TYPE_5 VAR_4 , TYPE_6 * * VAR_5 , TYPE_7 * * VAR_6 ) { TYPE_8 VAR_7 ; TYPE_9 VAR_8 [ sizeof ( VAR_9 ) + 65536 ] ; TYPE_10 VAR_10 ; TYPE_11 VAR_11 ; TYPE_12 * VAR_12 = VAR_13 ; TYPE_13 VAR_14 = { 0 } ; TYPE_14 * VAR_15 = VAR_16 , * VAR_17 , * VAR_18 = VAR_19 ; TYPE_15 * VAR_20 = VAR_21 ; VAR_22 = METHOD_1 ( VAR_23 ) ; if ( VAR_24 > sizeof ( VAR_25 ) + 65536 ) { VAR_26 = sizeof ( VAR_27 ) + 65536 ; if ( VAR_28 == METHOD_2 ( VAR_29 , - VAR_30 , VAR_31 ) ) { METHOD_3 ( VAR_32 ) ; if ( VAR_33 ) { METHOD_4 ( VAR_34 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_35 ) ; } return VAR_36 ; } } else { METHOD_5 ( VAR_37 , 0 , VAR_38 ) ; } if ( ! METHOD_6 ( VAR_39 , VAR_40 , VAR_41 ) ) { METHOD_7 ( VAR_42 ) ; if ( VAR_43 ) { METHOD_8 ( VAR_44 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>data<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_45 ) ; } return VAR_46 ; } while ( ( VAR_47 = ( TYPE_16 * ) METHOD_9 ( VAR_48 + 1 , 'P' , ( TYPE_17 ) ( VAR_49 - ( VAR_50 + 1 - VAR_51 ) ) ) ) != VAR_52 ) { if ( ( VAR_53 - VAR_54 ) + sizeof ( VAR_55 ) <= VAR_56 && ! METHOD_10 ( VAR_57 + 1 , ""K\\5\\6"" , 3 ) ) { METHOD_11 ( ( TYPE_18 * ) & VAR_58 , ( TYPE_19 * ) VAR_59 , sizeof ( VAR_60 ) ) ; if ( METHOD_12 ( VAR_61 . VAR_62 ) != 0 || METHOD_13 ( VAR_63 . VAR_64 ) != 0 ) { METHOD_14 ( VAR_65 ) ; if ( VAR_66 ) { METHOD_15 ( VAR_67 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>split<S2SV_blank>archives<S2SV_blank>spanning<S2SV_blank>multiple<S2SV_blank>zips<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>processed<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_68 ) ; } return VAR_69 ; } if ( METHOD_16 ( VAR_70 . VAR_71 ) != METHOD_17 ( VAR_72 . VAR_73 ) ) { if ( VAR_74 ) { METHOD_18 ( VAR_75 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>conflicting<S2SV_blank>file<S2SV_blank>count<S2SV_blank>in<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>record<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_76 ) ; } METHOD_19 ( VAR_77 ) ; return VAR_78 ; } VAR_79 = METHOD_20 ( 1 , sizeof ( TYPE_20 ) , METHOD_21 ( VAR_80 ) ) ; VAR_81 -> VAR_82 = METHOD_22 ( VAR_83 ) ; if ( METHOD_23 ( VAR_84 . VAR_85 ) ) { VAR_86 = VAR_87 + sizeof ( VAR_88 ) ; if ( METHOD_24 ( VAR_89 . VAR_90 ) != VAR_91 - ( VAR_92 - VAR_93 ) ) { if ( VAR_94 ) { METHOD_25 ( VAR_95 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>zip<S2SV_blank>file<S2SV_blank>comment<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_96 ) ; } METHOD_26 ( VAR_97 ) ; METHOD_27 ( VAR_98 , VAR_99 -> VAR_100 ) ; return VAR_101 ; } VAR_102 -> VAR_103 = METHOD_28 ( VAR_104 . VAR_105 ) ; if ( METHOD_29 ( & VAR_106 , & VAR_107 -> VAR_108 , METHOD_30 ( VAR_109 . VAR_110 ) ) == VAR_111 ) { VAR_112 -> VAR_113 = 0 ; METHOD_31 ( & VAR_114 -> VAR_115 , METHOD_32 ( VAR_116 , METHOD_33 ( VAR_117 . VAR_118 ) , VAR_119 -> VAR_120 ) ) ; } } else { METHOD_34 ( & VAR_121 -> VAR_122 ) ; } goto VAR_123 ; } } METHOD_35 ( VAR_124 ) ; if ( VAR_125 ) { METHOD_36 ( VAR_126 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_127 ) ; } return VAR_128 ; VAR_129 : VAR_130 -> VAR_131 = METHOD_37 ( VAR_132 , VAR_133 , VAR_134 -> VAR_135 ) ; TYPE_21 TYPE_22 TYPE_23 ( VAR_136 -> VAR_137 , VAR_138 ) ; VAR_139 -> VAR_140 = 1 ; VAR_141 -> VAR_142 = VAR_143 ; VAR_144 = METHOD_38 ( VAR_145 -> VAR_146 , '/' ) ; if ( VAR_147 ) { VAR_148 -> VAR_149 = METHOD_39 ( VAR_150 , '.' , ( VAR_151 -> VAR_152 + VAR_153 ) - VAR_154 ) ; if ( VAR_155 -> VAR_156 == VAR_157 ) { VAR_158 -> VAR_159 = METHOD_40 ( VAR_160 + 1 , '.' , ( VAR_161 -> VAR_162 + VAR_163 ) - VAR_164 - 1 ) ; } if ( VAR_165 -> VAR_166 ) { VAR_167 -> VAR_168 = ( VAR_169 -> VAR_170 + VAR_171 ) - VAR_172 -> VAR_173 ; } } METHOD_41 ( VAR_174 , METHOD_42 ( VAR_175 . VAR_176 ) , VAR_177 ) ; METHOD_43 ( & VAR_178 -> VAR_179 , METHOD_44 ( VAR_180 . VAR_181 ) , VAR_182 , VAR_183 , ( TYPE_24 ) VAR_184 -> VAR_185 ) ; METHOD_45 ( & VAR_186 -> VAR_187 , 5 , VAR_188 , VAR_189 , ( TYPE_25 ) VAR_190 -> VAR_191 ) ; METHOD_46 ( & VAR_192 -> VAR_193 , METHOD_47 ( VAR_194 . VAR_195 ) * 2 , VAR_196 , VAR_197 , ( TYPE_26 ) VAR_198 -> VAR_199 ) ; VAR_200 . VAR_201 = VAR_202 ; VAR_203 . VAR_204 = 1 ; VAR_205 . VAR_206 = VAR_207 ; VAR_208 . VAR_209 = VAR_210 -> VAR_211 ; METHOD_48 ( TYPE_27 , VAR_212 ) METHOD_49 ( & VAR_213 -> VAR_214 ) ; VAR_215 -> VAR_216 . VAR_217 . VAR_218 = 0 ; METHOD_50 ( & VAR_219 -> VAR_220 ) ; VAR_221 -> VAR_222 . VAR_223 . VAR_224 = 0 ; METHOD_51 ( & VAR_225 -> VAR_226 ) ; VAR_227 -> VAR_228 . VAR_229 . VAR_230 = 0 ; METHOD_52 ( VAR_231 ) ; METHOD_53 ( & VAR_232 -> VAR_233 ) ; if ( VAR_234 -> VAR_235 ) { METHOD_54 ( VAR_236 -> VAR_237 ) ; } if ( VAR_238 ) { METHOD_55 ( VAR_239 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , TYPE_28 , VAR_240 -> VAR_241 ) ; } METHOD_56 ( VAR_242 -> VAR_243 , VAR_244 -> VAR_245 ) ; if ( VAR_246 -> VAR_247 ) { METHOD_57 ( VAR_248 -> VAR_249 , VAR_250 -> VAR_251 ) ; } METHOD_58 ( VAR_252 , VAR_253 -> VAR_254 ) ; METHOD_59 ( VAR_255 ) ; return VAR_256 ; METHOD_60 ( TYPE_29 ) METHOD_61 ( & VAR_257 -> VAR_258 ) ; VAR_259 -> VAR_260 . VAR_261 . VAR_262 = 0 ; METHOD_62 ( & VAR_263 -> VAR_264 ) ; VAR_265 -> VAR_266 . VAR_267 . VAR_268 = 0 ; METHOD_63 ( & VAR_269 -> VAR_270 ) ; VAR_271 -> VAR_272 . VAR_273 . VAR_274 = 0 ; METHOD_64 ( VAR_275 ) ; METHOD_65 ( & VAR_276 -> VAR_277 ) ; if ( VAR_278 -> VAR_279 ) { METHOD_66 ( VAR_280 -> VAR_281 ) ; } if ( VAR_282 ) { METHOD_67 ( VAR_283 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , TYPE_30 , VAR_284 -> VAR_285 ) ; } METHOD_68 ( VAR_286 -> VAR_287 , VAR_288 -> VAR_289 ) ; if ( VAR_290 -> VAR_291 ) { METHOD_69 ( VAR_292 -> VAR_293 , VAR_294 -> VAR_295 ) ; } METHOD_70 ( VAR_296 , VAR_297 -> VAR_298 ) ; return VAR_299 ; for ( VAR_300 = 0 ; VAR_301 < METHOD_71 ( VAR_302 . VAR_303 ) ; ++ VAR_304 ) { TYPE_31 VAR_305 ; TYPE_32 VAR_306 = METHOD_72 ( VAR_307 ) ; if ( sizeof ( VAR_308 ) != METHOD_73 ( VAR_309 , ( TYPE_33 * ) & VAR_310 , sizeof ( VAR_311 ) ) ) { METHOD_74 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>truncated"" ) ; } if ( METHOD_75 ( ""PK\\1\\2"" , VAR_312 . VAR_313 , 4 ) ) { METHOD_76 ( ""corrupted<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>no<S2SV_blank>magic<S2SV_blank>signature"" ) ; } if ( VAR_314 . VAR_315 ) { VAR_316 . VAR_317 = VAR_318 ; } VAR_319 . VAR_320 = METHOD_77 ( VAR_321 . VAR_322 ) ; VAR_323 . VAR_324 = METHOD_78 ( VAR_325 . VAR_326 ) ; VAR_327 . VAR_328 = METHOD_79 ( VAR_329 . VAR_330 ) ; VAR_331 . VAR_332 = METHOD_80 ( VAR_333 . VAR_334 , VAR_335 . VAR_336 ) ; VAR_337 . VAR_338 = VAR_339 ; VAR_340 . VAR_341 = METHOD_81 ( VAR_342 . VAR_343 ) ; VAR_344 . VAR_345 = VAR_346 . VAR_347 = METHOD_82 ( VAR_348 . VAR_349 ) + sizeof ( TYPE_34 ) + METHOD_83 ( VAR_350 . VAR_351 ) + METHOD_84 ( VAR_352 . VAR_353 ) ; if ( METHOD_85 ( VAR_354 . VAR_355 ) & VAR_356 ) { METHOD_86 ( ""Cannot<S2SV_blank>process<S2SV_blank>encrypted<S2SV_blank>zip<S2SV_blank>files"" ) ; } if ( ! METHOD_87 ( VAR_357 . VAR_358 ) ) { METHOD_88 ( ""Cannot<S2SV_blank>process<S2SV_blank>zips<S2SV_blank>created<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>(zero-length<S2SV_blank>filename)"" ) ; } VAR_359 . VAR_360 = METHOD_89 ( VAR_361 . VAR_362 ) ; VAR_363 . VAR_364 = ( TYPE_35 * ) METHOD_90 ( VAR_365 . VAR_366 + 1 , VAR_367 . VAR_368 ) ; if ( VAR_369 . VAR_370 != METHOD_91 ( VAR_371 , VAR_372 . VAR_373 , VAR_374 . VAR_375 ) ) { METHOD_92 ( VAR_376 . VAR_377 , VAR_378 . VAR_379 ) ; METHOD_93 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>filename<S2SV_blank>from<S2SV_blank>central<S2SV_blank>directory,<S2SV_blank>truncated"" ) ; } VAR_380 . VAR_381 [ VAR_382 . VAR_383 ] = '\\0' ; if ( VAR_384 . VAR_385 [ VAR_386 . VAR_387 - 1 ] == '/' ) { VAR_388 . VAR_389 = 1 ; if ( VAR_390 . VAR_391 > 1 ) { VAR_392 . VAR_393 -- ; } VAR_394 . VAR_395 |= VAR_396 ; } else { VAR_397 . VAR_398 = 0 ; } if ( VAR_399 . VAR_400 == sizeof ( "".phar/signature.bin"" ) - 1 && ! METHOD_94 ( VAR_401 . VAR_402 , "".phar/signature.bin"" , sizeof ( "".phar/signature.bin"" ) - 1 ) ) { TYPE_36 VAR_403 ; TYPE_37 * VAR_404 ; TYPE_38 VAR_405 ; TYPE_39 * VAR_406 ; VAR_407 = METHOD_95 ( VAR_408 ) ; METHOD_96 ( VAR_409 . VAR_410 , VAR_411 . VAR_412 ) ; VAR_413 = METHOD_97 ( ) ; if ( ! VAR_414 ) { METHOD_98 ( ""couldn\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ; } METHOD_99 ( VAR_415 , 0 , VAR_416 ) ; METHOD_100 ( VAR_417 , VAR_418 , VAR_419 . VAR_420 , VAR_421 ) ; METHOD_101 ( VAR_422 , METHOD_102 ( VAR_423 . VAR_424 ) , VAR_425 ) ; METHOD_103 ( VAR_426 , VAR_427 , VAR_428 - METHOD_104 ( VAR_429 . VAR_430 ) , VAR_431 ) ; if ( VAR_432 ) { METHOD_105 ( VAR_433 , VAR_434 , METHOD_106 ( VAR_435 . VAR_436 ) ) ; } METHOD_107 ( VAR_437 , sizeof ( TYPE_40 ) + VAR_438 . VAR_439 + VAR_440 . VAR_441 + METHOD_108 ( VAR_442 . VAR_443 ) , VAR_444 ) ; VAR_445 = ( TYPE_41 * ) METHOD_109 ( VAR_446 . VAR_447 ) ; VAR_448 = METHOD_110 ( VAR_449 , VAR_450 , VAR_451 . VAR_452 ) ; <S2SV_StartBug> if ( VAR_453 != VAR_454 . VAR_455 ) { <S2SV_EndBug> METHOD_111 ( VAR_456 ) ; METHOD_112 ( VAR_457 ) ; METHOD_113 ( ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>read"" ) ; } VAR_458 -> VAR_459 = METHOD_114 ( VAR_460 ) ; if ( VAR_461 == METHOD_115 ( VAR_462 , METHOD_116 ( VAR_463 ) , VAR_464 -> VAR_465 , VAR_466 + 8 , VAR_467 . VAR_468 - 8 , VAR_469 , & VAR_470 -> VAR_471 , & VAR_472 -> VAR_473 , VAR_474 ) ) { METHOD_117 ( VAR_475 ) ; if ( VAR_476 ) { TYPE_42 * VAR_477 ; METHOD_118 ( VAR_478 ) ; METHOD_119 ( & VAR_479 , 4096 , ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified:<S2SV_blank>%s"" , * VAR_480 ) ; METHOD_120 ( * VAR_481 ) ; METHOD_121 ( VAR_482 , VAR_483 ) ; } else { METHOD_122 ( VAR_484 ) ; METHOD_123 ( ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified"" ) ; } } METHOD_124 ( VAR_485 ) ; METHOD_125 ( VAR_486 ) ; if ( VAR_487 != METHOD_126 ( VAR_488 . VAR_489 ) - 1 ) { METHOD_127 ( ""entries<S2SV_blank>exist<S2SV_blank>after<S2SV_blank>signature,<S2SV_blank>invalid<S2SV_blank>phar"" ) ; } continue ; } METHOD_128 ( VAR_490 , VAR_491 . VAR_492 , VAR_493 . VAR_494 ) ; if ( METHOD_129 ( VAR_495 . VAR_496 ) ) { TYPE_43 VAR_497 = METHOD_130 ( VAR_498 ) ; if ( VAR_499 == METHOD_131 ( VAR_500 , & VAR_501 , METHOD_132 ( VAR_502 . VAR_503 ) ) ) { METHOD_133 ( VAR_504 . VAR_505 , VAR_506 . VAR_507 ) ; METHOD_134 ( ""Unable<S2SV_blank>to<S2SV_blank>process<S2SV_blank>extra<S2SV_blank>field<S2SV_blank>header<S2SV_blank>for<S2SV_blank>file<S2SV_blank>in<S2SV_blank>central<S2SV_blank>directory"" ) ; } METHOD_135 ( VAR_508 , VAR_509 + METHOD_136 ( VAR_510 . VAR_511 ) , VAR_512 ) ; } switch ( METHOD_137 ( VAR_513 . VAR_514 ) ) { case VAR_515 : break ; case VAR_516 : VAR_517 . VAR_518 |= VAR_519 ; if ( ! METHOD_138 ( VAR_520 ) ) { METHOD_139 ( VAR_521 . VAR_522 , VAR_523 . VAR_524 ) ; METHOD_140 ( ""zlib<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required"" ) ; } break ; case VAR_525 : VAR_526 . VAR_527 |= VAR_528 ; if ( ! METHOD_141 ( VAR_529 ) ) { METHOD_142 ( VAR_530 . VAR_531 , VAR_532 . VAR_533 ) ; METHOD_143 ( ""bzip2<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required"" ) ; } break ; case 1 : METHOD_144 ( VAR_534 . VAR_535 , VAR_536 . VAR_537 ) ; METHOD_145 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Shrunk)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 2 : case 3 : case 4 : case 5 : METHOD_146 ( VAR_538 . VAR_539 , VAR_540 . VAR_541 ) ; METHOD_147 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Reduce)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 6 : METHOD_148 ( VAR_542 . VAR_543 , VAR_544 . VAR_545 ) ; METHOD_149 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Implode)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 7 : METHOD_150 ( VAR_546 . VAR_547 , VAR_548 . VAR_549 ) ; METHOD_151 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Tokenize)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 9 : METHOD_152 ( VAR_550 . VAR_551 , VAR_552 . VAR_553 ) ; METHOD_153 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Deflate64)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 10 : METHOD_154 ( VAR_554 . VAR_555 , VAR_556 . VAR_557 ) ; METHOD_155 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PKWare<S2SV_blank>Implode/old<S2SV_blank>IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 14 : METHOD_156 ( VAR_558 . VAR_559 , VAR_560 . VAR_561 ) ; METHOD_157 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(LZMA)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 18 : METHOD_158 ( VAR_562 . VAR_563 , VAR_564 . VAR_565 ) ; METHOD_159 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 19 : METHOD_160 ( VAR_566 . VAR_567 , VAR_568 . VAR_569 ) ; METHOD_161 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>LZ77)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 97 : METHOD_162 ( VAR_570 . VAR_571 , VAR_572 . VAR_573 ) ; METHOD_163 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(WavPack)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 98 : METHOD_164 ( VAR_574 . VAR_575 , VAR_576 . VAR_577 ) ; METHOD_165 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PPMd)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; default : METHOD_166 ( VAR_578 . VAR_579 , VAR_580 . VAR_581 ) ; METHOD_167 ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(unknown)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; } if ( METHOD_168 ( VAR_582 . VAR_583 ) ) { if ( METHOD_169 ( VAR_584 . VAR_585 ) != METHOD_170 ( VAR_586 , VAR_587 , METHOD_171 ( VAR_588 . VAR_589 ) ) ) { METHOD_172 ( VAR_590 . VAR_591 , VAR_592 . VAR_593 ) ; METHOD_173 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>file<S2SV_blank>comment,<S2SV_blank>truncated"" ) ; } VAR_594 = VAR_595 ; VAR_596 . VAR_597 = METHOD_174 ( VAR_598 . VAR_599 ) ; if ( METHOD_175 ( & VAR_600 , & ( VAR_601 . VAR_602 ) , METHOD_176 ( VAR_603 . VAR_604 ) ) == VAR_605 ) { VAR_606 . VAR_607 = 0 ; METHOD_177 ( & VAR_608 . VAR_609 , METHOD_178 ( VAR_610 , METHOD_179 ( VAR_611 . VAR_612 ) , VAR_613 . VAR_614 ) ) ; } } else { METHOD_180 ( & VAR_615 . VAR_616 ) ; } if ( ! VAR_617 && VAR_618 . VAR_619 == sizeof ( "".phar/alias.txt"" ) - 1 && ! METHOD_181 ( VAR_620 . VAR_621 , "".phar/alias.txt"" , sizeof ( "".phar/alias.txt"" ) - 1 ) ) { VAR_622 * VAR_623 ; TYPE_44 VAR_624 ; TYPE_45 VAR_625 ; VAR_626 = METHOD_182 ( VAR_627 ) ; METHOD_183 ( VAR_628 , METHOD_184 ( VAR_629 . VAR_630 ) , VAR_631 ) ; if ( sizeof ( VAR_632 ) != METHOD_185 ( VAR_633 , ( TYPE_46 * ) & VAR_634 , sizeof ( VAR_635 ) ) ) { METHOD_186 ( VAR_636 . VAR_637 , VAR_638 . VAR_639 ) ; METHOD_187 ( ""phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(cannot<S2SV_blank>read<S2SV_blank>local<S2SV_blank>file<S2SV_blank>header<S2SV_blank>for<S2SV_blank>alias)"" ) ; } if ( VAR_640 . VAR_641 != METHOD_188 ( VAR_642 . VAR_643 ) || VAR_644 . VAR_645 != METHOD_189 ( VAR_646 . VAR_647 ) || VAR_648 . VAR_649 != METHOD_190 ( VAR_650 . VAR_651 ) || VAR_652 . VAR_653 != METHOD_191 ( VAR_654 . VAR_655 ) ) { METHOD_192 ( VAR_656 . VAR_657 , VAR_658 . VAR_659 ) ; METHOD_193 ( ""phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(local<S2SV_blank>header<S2SV_blank>of<S2SV_blank>alias<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>central<S2SV_blank>directory)"" ) ; } VAR_660 . VAR_661 = VAR_662 . VAR_663 = sizeof ( VAR_664 ) + VAR_665 . VAR_666 + METHOD_194 ( VAR_667 . VAR_668 ) + METHOD_195 ( VAR_669 . VAR_670 ) ; METHOD_196 ( VAR_671 , VAR_672 . VAR_673 , VAR_674 ) ; VAR_675 -> VAR_676 = 0 ; VAR_677 -> VAR_678 = 0 ; METHOD_197 ( VAR_679 , VAR_680 . VAR_681 , VAR_682 ) ; VAR_683 -> VAR_684 = 0 ; VAR_685 -> VAR_686 = 0 ; VAR_687 -> VAR_688 = VAR_689 . VAR_690 ; if ( VAR_691 . VAR_692 & VAR_693 ) { VAR_694 = METHOD_198 ( ""zlib.inflate"" , VAR_695 , METHOD_199 ( VAR_696 ) ) ; if ( ! VAR_697 ) { METHOD_200 ( VAR_698 . VAR_699 , VAR_700 . VAR_701 ) ; METHOD_201 ( ""unable<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>alias,<S2SV_blank>zlib<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed"" ) ; } METHOD_202 ( & VAR_702 -> VAR_703 , VAR_704 ) ; { TYPE_47 * VAR_705 = METHOD_203 ( VAR_706 , VAR_707 . VAR_708 , 0 ) ; if ( VAR_709 ) { VAR_710 . VAR_711 = METHOD_204 ( VAR_712 ) ; VAR_713 = METHOD_205 ( METHOD_206 ( VAR_714 ) , METHOD_207 ( VAR_715 ) ) ; METHOD_208 ( VAR_716 ) ; } else { VAR_717 = VAR_718 ; VAR_719 . VAR_720 = 0 ; } } if ( ! VAR_721 . VAR_722 || ! VAR_723 ) { METHOD_209 ( VAR_724 . VAR_725 , VAR_726 . VAR_727 ) ; METHOD_210 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } METHOD_211 ( VAR_728 , 1 ) ; METHOD_212 ( VAR_729 , 1 ) ; } else if ( VAR_730 . VAR_731 & VAR_732 ) { VAR_733 = METHOD_213 ( ""bzip2.decompress"" , VAR_734 , METHOD_214 ( VAR_735 ) ) ; if ( ! VAR_736 ) { METHOD_215 ( VAR_737 . VAR_738 , VAR_739 . VAR_740 ) ; METHOD_216 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>bzip2<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed"" ) ; } METHOD_217 ( & VAR_741 -> VAR_742 , VAR_743 ) ; { TYPE_48 * VAR_744 = METHOD_218 ( VAR_745 , VAR_746 . VAR_747 , 0 ) ; if ( VAR_748 ) { VAR_749 . VAR_750 = METHOD_219 ( VAR_751 ) ; VAR_752 = METHOD_220 ( METHOD_221 ( VAR_753 ) , METHOD_222 ( VAR_754 ) ) ; METHOD_223 ( VAR_755 ) ; } else { VAR_756 = VAR_757 ; VAR_758 . VAR_759 = 0 ; } } if ( ! VAR_760 . VAR_761 || ! VAR_762 ) { METHOD_224 ( VAR_763 . VAR_764 , VAR_765 . VAR_766 ) ; METHOD_225 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } METHOD_226 ( VAR_767 , 1 ) ; METHOD_227 ( VAR_768 , 1 ) ; } else { { TYPE_49 * VAR_769 = METHOD_228 ( VAR_770 , VAR_771 . VAR_772 , 0 ) ; if ( VAR_773 ) { VAR_774 . VAR_775 = METHOD_229 ( VAR_776 ) ; VAR_777 = METHOD_230 ( METHOD_231 ( VAR_778 ) , METHOD_232 ( VAR_779 ) ) ; METHOD_233 ( VAR_780 ) ; } else { VAR_781 = VAR_782 ; VAR_783 . VAR_784 = 0 ; } } if ( ! VAR_785 . VAR_786 || ! VAR_787 ) { METHOD_234 ( VAR_788 . VAR_789 , VAR_790 . VAR_791 ) ; METHOD_235 ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } } METHOD_236 ( VAR_792 , VAR_793 , VAR_794 ) ; } METHOD_237 ( & VAR_795 ) ; METHOD_238 ( & VAR_796 -> VAR_797 , VAR_798 . VAR_799 , VAR_800 . VAR_801 , ( TYPE_50 * ) & VAR_802 , sizeof ( TYPE_51 ) ) ; } VAR_803 -> VAR_804 = VAR_805 ; if ( METHOD_239 ( & ( VAR_806 -> VAR_807 ) , "".phar/stub.php"" , sizeof ( "".phar/stub.php"" ) - 1 ) ) { VAR_808 -> VAR_809 = 0 ; } else { VAR_810 -> VAR_811 = 1 ; } METHOD_240 ( & ( METHOD_241 ( VAR_812 ) ) , VAR_813 -> VAR_814 , VAR_815 , VAR_816 ) ; if ( VAR_817 ) { TYPE_52 * VAR_818 ; if ( ! METHOD_242 ( VAR_819 , VAR_820 -> VAR_821 ) ) { if ( VAR_822 ) { METHOD_243 ( VAR_823 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>invalid<S2SV_blank>alias<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , VAR_824 , VAR_825 ) ; } METHOD_244 ( VAR_826 ) ; METHOD_245 ( & ( METHOD_246 ( VAR_827 ) ) , VAR_828 -> VAR_829 , VAR_830 ) ; return VAR_831 ; } VAR_832 -> VAR_833 = 0 ; if ( VAR_834 != ( VAR_835 = METHOD_247 ( & ( METHOD_248 ( VAR_836 ) ) , VAR_837 , VAR_838 -> VAR_839 ) ) ) { if ( VAR_840 != METHOD_249 ( VAR_841 , VAR_842 , VAR_843 -> VAR_844 ) ) { if ( VAR_845 ) { METHOD_250 ( VAR_846 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\""<S2SV_blank>with<S2SV_blank>implicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , VAR_847 ) ; } METHOD_251 ( VAR_848 ) ; METHOD_252 ( & ( METHOD_253 ( VAR_849 ) ) , VAR_850 -> VAR_851 , VAR_852 ) ; return VAR_853 ; } } VAR_854 -> VAR_855 = VAR_856 . VAR_857 ? METHOD_254 ( VAR_858 , VAR_859 -> VAR_860 , 1 ) : VAR_861 ; if ( VAR_862 . VAR_863 ) { METHOD_255 ( VAR_864 ) ; } METHOD_256 ( & ( METHOD_257 ( VAR_865 ) ) , VAR_866 , VAR_867 -> VAR_868 , VAR_869 ) ; } else { TYPE_53 * VAR_870 ; if ( VAR_871 ) { if ( VAR_872 != ( VAR_873 = METHOD_258 ( & ( METHOD_259 ( VAR_874 ) ) , VAR_875 , VAR_876 ) ) ) { if ( VAR_877 != METHOD_260 ( VAR_878 , VAR_879 , VAR_880 ) ) { if ( VAR_881 ) { METHOD_261 ( VAR_882 , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\""<S2SV_blank>with<S2SV_blank>explicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , VAR_883 ) ; } METHOD_262 ( & ( METHOD_263 ( VAR_884 ) ) , VAR_885 -> VAR_886 , VAR_887 ) ; return VAR_888 ; } } METHOD_264 ( & ( METHOD_265 ( VAR_889 ) ) , VAR_890 , VAR_891 -> VAR_892 , VAR_893 ) ; VAR_894 -> VAR_895 = METHOD_266 ( VAR_896 , VAR_897 , VAR_898 -> VAR_899 ) ; VAR_900 -> VAR_901 = VAR_902 ; } else { VAR_903 -> VAR_904 = METHOD_267 ( VAR_905 -> VAR_906 , VAR_907 , VAR_908 -> VAR_909 ) ; VAR_910 -> VAR_911 = VAR_912 ; } VAR_913 -> VAR_914 = 1 ; } if ( VAR_915 ) { * VAR_916 = VAR_917 ; } return VAR_918 ; }",<S2SV_ModStart> VAR_862 . VAR_786 || VAR_453 <= 8,"CWE-119 int phar_parse_zipfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , char * * error ) { phar_zip_dir_end locator ; char buf [ sizeof ( locator ) + 65536 ] ; zend_long size ; php_uint16 i ; phar_archive_data * mydata = NULL ; phar_entry_info entry = { 0 } ; char * p = buf , * ext , * actual_alias = NULL ; char * metadata = NULL ; size = php_stream_tell ( fp ) ; if ( size > sizeof ( locator ) + 65536 ) { size = sizeof ( locator ) + 65536 ; if ( FAILURE == php_stream_seek ( fp , - size , SEEK_END ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; } } else { php_stream_seek ( fp , 0 , SEEK_SET ) ; } if ( ! php_stream_read ( fp , buf , size ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>data<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; } while ( ( p = ( char * ) memchr ( p + 1 , 'P' , ( size_t ) ( size - ( p + 1 - buf ) ) ) ) != NULL ) { if ( ( p - buf ) + sizeof ( locator ) <= size && ! memcmp ( p + 1 , ""K\\5\\6"" , 3 ) ) { memcpy ( ( void * ) & locator , ( void * ) p , sizeof ( locator ) ) ; if ( PHAR_GET_16 ( locator . centraldisk ) != 0 || PHAR_GET_16 ( locator . disknumber ) != 0 ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>split<S2SV_blank>archives<S2SV_blank>spanning<S2SV_blank>multiple<S2SV_blank>zips<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>processed<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; } if ( PHAR_GET_16 ( locator . counthere ) != PHAR_GET_16 ( locator . count ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>conflicting<S2SV_blank>file<S2SV_blank>count<S2SV_blank>in<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>record<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } php_stream_close ( fp ) ; return FAILURE ; } mydata = pecalloc ( 1 , sizeof ( phar_archive_data ) , PHAR_G ( persist ) ) ; mydata -> is_persistent = PHAR_G ( persist ) ; if ( PHAR_GET_16 ( locator . comment_len ) ) { metadata = p + sizeof ( locator ) ; if ( PHAR_GET_16 ( locator . comment_len ) != size - ( metadata - buf ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>zip<S2SV_blank>file<S2SV_blank>comment<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } php_stream_close ( fp ) ; pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; } mydata -> metadata_len = PHAR_GET_16 ( locator . comment_len ) ; if ( phar_parse_metadata ( & metadata , & mydata -> metadata , PHAR_GET_16 ( locator . comment_len ) ) == FAILURE ) { mydata -> metadata_len = 0 ; ZVAL_NEW_STR ( & mydata -> metadata , zend_string_init ( metadata , PHAR_GET_16 ( locator . comment_len ) , mydata -> is_persistent ) ) ; } } else { ZVAL_UNDEF ( & mydata -> metadata ) ; } goto foundit ; } } php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; foundit : mydata -> fname = pestrndup ( fname , fname_len , mydata -> is_persistent ) ;  ifdef PHP_WIN32 phar_unixify_path_separators ( mydata -> fname , fname_len ) ;   mydata -> is_zip = 1 ; mydata -> fname_len = fname_len ; ext = strrchr ( mydata -> fname , '/' ) ; if ( ext ) { mydata -> ext = memchr ( ext , '.' , ( mydata -> fname + fname_len ) - ext ) ; if ( mydata -> ext == ext ) { mydata -> ext = memchr ( ext + 1 , '.' , ( mydata -> fname + fname_len ) - ext - 1 ) ; } if ( mydata -> ext ) { mydata -> ext_len = ( mydata -> fname + fname_len ) - mydata -> ext ; } } php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; zend_hash_init ( & mydata -> manifest , PHAR_GET_16 ( locator . count ) , zend_get_hash_value , destroy_phar_manifest_entry , ( zend_bool ) mydata -> is_persistent ) ; zend_hash_init ( & mydata -> mounted_dirs , 5 , zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; zend_hash_init ( & mydata -> virtual_dirs , PHAR_GET_16 ( locator . count ) * 2 , zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; entry . phar = mydata ; entry . is_zip = 1 ; entry . fp_type = PHAR_FP ; entry . is_persistent = mydata -> is_persistent ;   PHAR_ZIP_FAIL_FREE ( errmsg , save ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; efree ( save ) ; return FAILURE ;   PHAR_ZIP_FAIL ( errmsg ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; for ( i = 0 ; i < PHAR_GET_16 ( locator . count ) ; ++ i ) { phar_zip_central_dir_file zipentry ; zend_off_t beforeus = php_stream_tell ( fp ) ; if ( sizeof ( zipentry ) != php_stream_read ( fp , ( char * ) & zipentry , sizeof ( zipentry ) ) ) { PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>truncated"" ) ; } if ( memcmp ( ""PK\\1\\2"" , zipentry . signature , 4 ) ) { PHAR_ZIP_FAIL ( ""corrupted<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>no<S2SV_blank>magic<S2SV_blank>signature"" ) ; } if ( entry . is_persistent ) { entry . manifest_pos = i ; } entry . compressed_filesize = PHAR_GET_32 ( zipentry . compsize ) ; entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ; entry . crc32 = PHAR_GET_32 ( zipentry . crc32 ) ; entry . timestamp = phar_zip_d2u_time ( zipentry . timestamp , zipentry . datestamp ) ; entry . flags = PHAR_ENT_PERM_DEF_FILE ; entry . header_offset = PHAR_GET_32 ( zipentry . offset ) ; entry . offset = entry . offset_abs = PHAR_GET_32 ( zipentry . offset ) + sizeof ( phar_zip_file_header ) + PHAR_GET_16 ( zipentry . filename_len ) + PHAR_GET_16 ( zipentry . extra_len ) ; if ( PHAR_GET_16 ( zipentry . flags ) & PHAR_ZIP_FLAG_ENCRYPTED ) { PHAR_ZIP_FAIL ( ""Cannot<S2SV_blank>process<S2SV_blank>encrypted<S2SV_blank>zip<S2SV_blank>files"" ) ; } if ( ! PHAR_GET_16 ( zipentry . filename_len ) ) { PHAR_ZIP_FAIL ( ""Cannot<S2SV_blank>process<S2SV_blank>zips<S2SV_blank>created<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>(zero-length<S2SV_blank>filename)"" ) ; } entry . filename_len = PHAR_GET_16 ( zipentry . filename_len ) ; entry . filename = ( char * ) pemalloc ( entry . filename_len + 1 , entry . is_persistent ) ; if ( entry . filename_len != php_stream_read ( fp , entry . filename , entry . filename_len ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>filename<S2SV_blank>from<S2SV_blank>central<S2SV_blank>directory,<S2SV_blank>truncated"" ) ; } entry . filename [ entry . filename_len ] = '\\0' ; if ( entry . filename [ entry . filename_len - 1 ] == '/' ) { entry . is_dir = 1 ; if ( entry . filename_len > 1 ) { entry . filename_len -- ; } entry . flags |= PHAR_ENT_PERM_DEF_DIR ; } else { entry . is_dir = 0 ; } if ( entry . filename_len == sizeof ( "".phar/signature.bin"" ) - 1 && ! strncmp ( entry . filename , "".phar/signature.bin"" , sizeof ( "".phar/signature.bin"" ) - 1 ) ) { size_t read ; php_stream * sigfile ; zend_off_t now ; char * sig ; now = php_stream_tell ( fp ) ; pefree ( entry . filename , entry . is_persistent ) ; sigfile = php_stream_fopen_tmpfile ( ) ; if ( ! sigfile ) { PHAR_ZIP_FAIL ( ""couldn\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; php_stream_copy_to_stream_ex ( fp , sigfile , entry . header_offset , NULL ) ; php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; php_stream_copy_to_stream_ex ( fp , sigfile , beforeus - PHAR_GET_32 ( locator . cdir_offset ) , NULL ) ; if ( metadata ) { php_stream_write ( sigfile , metadata , PHAR_GET_16 ( locator . comment_len ) ) ; } php_stream_seek ( fp , sizeof ( phar_zip_file_header ) + entry . header_offset + entry . filename_len + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; sig = ( char * ) emalloc ( entry . uncompressed_filesize ) ; read = php_stream_read ( fp , sig , entry . uncompressed_filesize ) ; <S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> php_stream_close ( sigfile ) ; efree ( sig ) ; PHAR_ZIP_FAIL ( ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>read"" ) ; } mydata -> sig_flags = PHAR_GET_32 ( sig ) ; if ( FAILURE == phar_verify_signature ( sigfile , php_stream_tell ( sigfile ) , mydata -> sig_flags , sig + 8 , entry . uncompressed_filesize - 8 , fname , & mydata -> signature , & mydata -> sig_len , error ) ) { efree ( sig ) ; if ( error ) { char * save ; php_stream_close ( sigfile ) ; spprintf ( & save , 4096 , ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified:<S2SV_blank>%s"" , * error ) ; efree ( * error ) ; PHAR_ZIP_FAIL_FREE ( save , save ) ; } else { php_stream_close ( sigfile ) ; PHAR_ZIP_FAIL ( ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified"" ) ; } } php_stream_close ( sigfile ) ; efree ( sig ) ; if ( i != PHAR_GET_16 ( locator . count ) - 1 ) { PHAR_ZIP_FAIL ( ""entries<S2SV_blank>exist<S2SV_blank>after<S2SV_blank>signature,<S2SV_blank>invalid<S2SV_blank>phar"" ) ; } continue ; } phar_add_virtual_dirs ( mydata , entry . filename , entry . filename_len ) ; if ( PHAR_GET_16 ( zipentry . extra_len ) ) { zend_off_t loc = php_stream_tell ( fp ) ; if ( FAILURE == phar_zip_process_extra ( fp , & entry , PHAR_GET_16 ( zipentry . extra_len ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""Unable<S2SV_blank>to<S2SV_blank>process<S2SV_blank>extra<S2SV_blank>field<S2SV_blank>header<S2SV_blank>for<S2SV_blank>file<S2SV_blank>in<S2SV_blank>central<S2SV_blank>directory"" ) ; } php_stream_seek ( fp , loc + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; } switch ( PHAR_GET_16 ( zipentry . compressed ) ) { case PHAR_ZIP_COMP_NONE : break ; case PHAR_ZIP_COMP_DEFLATE : entry . flags |= PHAR_ENT_COMPRESSED_GZ ; if ( ! PHAR_G ( has_zlib ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""zlib<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required"" ) ; } break ; case PHAR_ZIP_COMP_BZIP2 : entry . flags |= PHAR_ENT_COMPRESSED_BZ2 ; if ( ! PHAR_G ( has_bz2 ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""bzip2<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required"" ) ; } break ; case 1 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Shrunk)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 2 : case 3 : case 4 : case 5 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Reduce)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 6 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Implode)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 7 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Tokenize)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 9 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Deflate64)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 10 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PKWare<S2SV_blank>Implode/old<S2SV_blank>IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 14 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(LZMA)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 18 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 19 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>LZ77)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 97 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(WavPack)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 98 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PPMd)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; default : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(unknown)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; } if ( PHAR_GET_16 ( zipentry . comment_len ) ) { if ( PHAR_GET_16 ( zipentry . comment_len ) != php_stream_read ( fp , buf , PHAR_GET_16 ( zipentry . comment_len ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>file<S2SV_blank>comment,<S2SV_blank>truncated"" ) ; } p = buf ; entry . metadata_len = PHAR_GET_16 ( zipentry . comment_len ) ; if ( phar_parse_metadata ( & p , & ( entry . metadata ) , PHAR_GET_16 ( zipentry . comment_len ) ) == FAILURE ) { entry . metadata_len = 0 ; ZVAL_NEW_STR ( & entry . metadata , zend_string_init ( buf , PHAR_GET_16 ( zipentry . comment_len ) , entry . is_persistent ) ) ; } } else { ZVAL_UNDEF ( & entry . metadata ) ; } if ( ! actual_alias && entry . filename_len == sizeof ( "".phar/alias.txt"" ) - 1 && ! strncmp ( entry . filename , "".phar/alias.txt"" , sizeof ( "".phar/alias.txt"" ) - 1 ) ) { php_stream_filter * filter ; zend_off_t saveloc ; phar_zip_file_header local ; saveloc = php_stream_tell ( fp ) ; php_stream_seek ( fp , PHAR_GET_32 ( zipentry . offset ) , SEEK_SET ) ; if ( sizeof ( local ) != php_stream_read ( fp , ( char * ) & local , sizeof ( local ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(cannot<S2SV_blank>read<S2SV_blank>local<S2SV_blank>file<S2SV_blank>header<S2SV_blank>for<S2SV_blank>alias)"" ) ; } if ( entry . filename_len != PHAR_GET_16 ( local . filename_len ) || entry . crc32 != PHAR_GET_32 ( local . crc32 ) || entry . uncompressed_filesize != PHAR_GET_32 ( local . uncompsize ) || entry . compressed_filesize != PHAR_GET_32 ( local . compsize ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(local<S2SV_blank>header<S2SV_blank>of<S2SV_blank>alias<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>central<S2SV_blank>directory)"" ) ; } entry . offset = entry . offset_abs = sizeof ( local ) + entry . header_offset + PHAR_GET_16 ( local . filename_len ) + PHAR_GET_16 ( local . extra_len ) ; php_stream_seek ( fp , entry . offset , SEEK_SET ) ; fp -> writepos = 0 ; fp -> readpos = 0 ; php_stream_seek ( fp , entry . offset , SEEK_SET ) ; fp -> writepos = 0 ; fp -> readpos = 0 ; mydata -> alias_len = entry . uncompressed_filesize ; if ( entry . flags & PHAR_ENT_COMPRESSED_GZ ) { filter = php_stream_filter_create ( ""zlib.inflate"" , NULL , php_stream_is_persistent ( fp ) ) ; if ( ! filter ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>alias,<S2SV_blank>zlib<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed"" ) ; } php_stream_filter_append ( & fp -> readfilters , filter ) ; { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } php_stream_filter_flush ( filter , 1 ) ; php_stream_filter_remove ( filter , 1 ) ; } else if ( entry . flags & PHAR_ENT_COMPRESSED_BZ2 ) { filter = php_stream_filter_create ( ""bzip2.decompress"" , NULL , php_stream_is_persistent ( fp ) ) ; if ( ! filter ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>bzip2<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed"" ) ; } php_stream_filter_append ( & fp -> readfilters , filter ) ; { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } php_stream_filter_flush ( filter , 1 ) ; php_stream_filter_remove ( filter , 1 ) ; } else { { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } } php_stream_seek ( fp , saveloc , SEEK_SET ) ; } phar_set_inode ( & entry ) ; zend_hash_str_add_mem ( & mydata -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) ) ; } mydata -> fp = fp ; if ( zend_hash_str_exists ( & ( mydata -> manifest ) , "".phar/stub.php"" , sizeof ( "".phar/stub.php"" ) - 1 ) ) { mydata -> is_data = 0 ; } else { mydata -> is_data = 1 ; } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len , mydata ) ; if ( actual_alias ) { phar_archive_data * fd_ptr ; if ( ! phar_validate_alias ( actual_alias , mydata -> alias_len ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>invalid<S2SV_blank>alias<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , actual_alias , fname ) ; } efree ( actual_alias ) ; zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } mydata -> is_temporary_alias = 0 ; if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len ) ) ) { if ( SUCCESS != phar_free_alias ( fd_ptr , actual_alias , mydata -> alias_len ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\""<S2SV_blank>with<S2SV_blank>implicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , fname ) ; } efree ( actual_alias ) ; zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } } mydata -> alias = entry . is_persistent ? pestrndup ( actual_alias , mydata -> alias_len , 1 ) : actual_alias ; if ( entry . is_persistent ) { efree ( actual_alias ) ; } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; } else { phar_archive_data * fd_ptr ; if ( alias_len ) { if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , alias , alias_len ) ) ) { if ( SUCCESS != phar_free_alias ( fd_ptr , alias , alias_len ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\""<S2SV_blank>with<S2SV_blank>explicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , fname ) ; } zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; mydata -> alias = pestrndup ( alias , alias_len , mydata -> is_persistent ) ; mydata -> alias_len = alias_len ; } else { mydata -> alias = pestrndup ( mydata -> fname , fname_len , mydata -> is_persistent ) ; mydata -> alias_len = fname_len ; } mydata -> is_temporary_alias = 1 ; } if ( pphar ) { * pphar = mydata ; } return SUCCESS ; }",<S2SV_ModStart> entry . uncompressed_filesize || read <= 8
